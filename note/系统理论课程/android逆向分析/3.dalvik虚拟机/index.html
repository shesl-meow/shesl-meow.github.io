<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Android Dalvik 虚拟机 - shesl's blog</title><meta name=Description content="佘崧林同学的碎碎念博客"><meta property="og:title" content="Android Dalvik 虚拟机"><meta property="og:description" content="虽然 Android 平台使用 Java 语言来开发应用程序，但 Android 程序却不是运行在标准 Java 虚拟机上，而是 Dalvik Virtual Machine（Dalvik 虚拟机）。 Dalvik 虚拟机的特点 与 Java 虚拟"><meta property="og:type" content="article"><meta property="og:url" content="http://shesl-meow.github.io/note/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/3.dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA/"><meta property="og:image" content="http://shesl-meow.github.io/avatar.png"><meta property="article:section" content="note"><meta property="article:published_time" content="2019-02-25T15:16:23+08:00"><meta property="article:modified_time" content="2019-02-25T15:16:23+08:00"><meta property="og:site_name" content="shesl's blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://shesl-meow.github.io/avatar.png"><meta name=twitter:title content="Android Dalvik 虚拟机"><meta name=twitter:description content="虽然 Android 平台使用 Java 语言来开发应用程序，但 Android 程序却不是运行在标准 Java 虚拟机上，而是 Dalvik Virtual Machine（Dalvik 虚拟机）。 Dalvik 虚拟机的特点 与 Java 虚拟"><meta name=application-name content="shesl's blog"><meta name=apple-mobile-web-app-title content="shesl's blog"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=http://shesl-meow.github.io/note/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/3.dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA/><link rel=prev href=http://shesl-meow.github.io/note/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/1.%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/><link rel=next href=http://shesl-meow.github.io/note/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/4.android%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/><link rel=stylesheet href=/css/style.min.1310433f6cdab9b292f4d93b71eeb4dcd4a0fc3770f6d90e2d21faa5387856c5.css integrity="sha256-ExBDP2zaubKS9Nk7ce603NSg/Ddw9tkOLSH6pTh4VsU="><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Android Dalvik 虚拟机","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/shesl-meow.github.io\/note\/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B\/android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90\/3.dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA\/"},"genre":"note","keywords":"","wordcount":5937,"url":"http:\/\/shesl-meow.github.io\/note\/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B\/android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90\/3.dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA\/","datePublished":"2019-02-25T15:16:23+08:00","dateModified":"2019-02-25T15:16:23+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"佘崧林"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="shesl's blog">shesl-meow</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>博客
</a><a class=menu-item href=/tags/>标签
</a><a class=menu-item href=/categories/>分类
</a><a class=menu-item href=/note/>笔记</a><div class=dropdown><a class="menu-item menu-more dropbtn" title href=javascript:void(0);>游戏</a><div class="menu-more-content dropdown-content"><a href=/games/2048/ title><i class='fa-solid fa-chess-board'></i> 2048</a></div></div><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="shesl's blog">shesl-meow</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/>博客
</a><a class=menu-item href=/tags/>标签
</a><a class=menu-item href=/categories/>分类
</a><a class=menu-item href=/note/>笔记</a><div class=dropdown><a class="menu-item menu-more dropbtn" title href=javascript:void(0);>游戏</a><div class="menu-more-content dropdown-content"><a href=/games/2048/ title><i class='fa-solid fa-chess-board'></i> 2048</a></div></div><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class="page single special"><h1 class="single-title animate__animated animate__pulse animate__faster">Android Dalvik 虚拟机</h1><div class=content id=content><p>虽然 Android 平台使用 Java 语言来开发应用程序，但 Android 程序却不是运行在标准 Java 虚拟机上，而是 Dalvik Virtual Machine（Dalvik 虚拟机）。</p><h2 id=dalvik-虚拟机的特点>Dalvik 虚拟机的特点</h2><h3 id=与-java-虚拟机的区别>与 Java 虚拟机的区别</h3><p>主要区别：</p><ol><li><p>Java 虚拟机运行的是 Java 字节码，Dalvik 虚拟机运行的是 Dalvik 字节码。</p><p>所有的 Dalvik 字节码由 Java 字节码转化而来，并且被打包到一个 DEX（Dalvik Executable）可执行文件中。Dalvik 虚拟机通过解释 DEX 文件来执行这些字节码。</p></li><li><p>Dalvik 可执行文件体积更小。</p><p>Android SDK 中有一个叫 <code>dx</code> 的工具负责将 Java 字节码转换为 Dalvik 字节码。</p></li><li><p>Java 虚拟机与 Dalvik 虚拟机架构不同。</p><p>Java 虚拟机基于栈结构。程序在运行时需要频繁地从栈上读取或写入数据。</p><p>Dalvik 虚拟机基于寄存器架构。数据的访问通过寄存器间直接传递。</p></li></ol><p>实例：</p><ol><li><p>编写 <code>Java</code> 程序如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// Hello.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Hello</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kt>int</span> <span class=nf>foo</span><span class=o>(</span><span class=kt>int</span> <span class=n>a</span><span class=o>,</span> <span class=kt>int</span> <span class=n>b</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>(</span><span class=n>a</span><span class=o>+</span><span class=n>b</span><span class=o>)</span> <span class=o>*</span> <span class=o>(</span><span class=n>a</span><span class=o>-</span><span class=n>b</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>argc</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=n>Hello</span> <span class=n>hello</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Hello</span><span class=o>();</span>
</span></span><span class=line><span class=cl>		<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>hello</span><span class=o>.</span><span class=na>foo</span><span class=o>(</span><span class=n>5</span><span class=o>,</span><span class=n>3</span><span class=o>));</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>执行以下命令生成 <code>.class</code> 文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ javac Hello.java
</span></span></code></pre></td></tr></table></div></div><p>执行以下命令生成 <code>.dex</code> 文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ dx --dex --output<span class=o>=</span>Hello.dex Hello.class
</span></span></code></pre></td></tr></table></div></div></li><li><p>使用 <code>javap</code> 反编译 <code>Hello.class</code> 查看 <code>foo()</code> 函数的 Java 字节码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ javap -c -classpath . Hello
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>  public int foo<span class=o>(</span>int, int<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    Code:
</span></span><span class=line><span class=cl>       0: iload_1
</span></span><span class=line><span class=cl>       1: iload_2
</span></span><span class=line><span class=cl>       2: iadd
</span></span><span class=line><span class=cl>       3: iload_1
</span></span><span class=line><span class=cl>       4: iload_2
</span></span><span class=line><span class=cl>       5: isub
</span></span><span class=line><span class=cl>       6: imul
</span></span><span class=line><span class=cl>       7: ireturn
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div><p>Java 虚拟机的指令集被称为零地址指令集，是指指令集的目标参数和源参数都是隐含的，它通过 Java 虚拟机中一个称作”求值栈“的数据结构传递。</p><p>完整的 Java 字节码指令列表可以参考维基百科：https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings</p></li><li><p>使用 <code>dexdump</code> 可以查看 Dalvik 字节码，执行以下命令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ dexdump -d Hello.dex
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>  Virtual methods   -
</span></span><span class=line><span class=cl>    <span class=c1>#0              : (in LHello;)</span>
</span></span><span class=line><span class=cl>      name          : <span class=s1>&#39;foo&#39;</span>
</span></span><span class=line><span class=cl>      <span class=nb>type</span>          : <span class=s1>&#39;(II)I&#39;</span>
</span></span><span class=line><span class=cl>      access        : 0x0001 <span class=o>(</span>PUBLIC<span class=o>)</span>
</span></span><span class=line><span class=cl>      code          -
</span></span><span class=line><span class=cl>      registers     : <span class=m>5</span>
</span></span><span class=line><span class=cl>      ins           : <span class=m>3</span>
</span></span><span class=line><span class=cl>      outs          : <span class=m>0</span>
</span></span><span class=line><span class=cl>      insns size    : <span class=m>6</span> 16-bit code units
</span></span><span class=line><span class=cl>000198:                                        <span class=p>|</span><span class=o>[</span>000198<span class=o>]</span> Hello.foo:<span class=o>(</span>II<span class=o>)</span>I
</span></span><span class=line><span class=cl>0001a8: <span class=m>9000</span> <span class=m>0304</span>                              <span class=p>|</span>0000: add-int v0, v3, v4
</span></span><span class=line><span class=cl>0001ac: <span class=m>9101</span> <span class=m>0304</span>                              <span class=p>|</span>0002: sub-int v1, v3, v4
</span></span><span class=line><span class=cl>0001b0: b210                                   <span class=p>|</span>0004: mul-int/2addr v0, v1
</span></span><span class=line><span class=cl>0001b2: 0f00                                   <span class=p>|</span>0005: <span class=k>return</span> v0
</span></span><span class=line><span class=cl>      catches       : <span class=o>(</span>none<span class=o>)</span>
</span></span><span class=line><span class=cl>      positions     :
</span></span><span class=line><span class=cl>        0x0000 <span class=nv>line</span><span class=o>=</span><span class=m>3</span>
</span></span><span class=line><span class=cl>      locals        :
</span></span><span class=line><span class=cl>        0x0000 - 0x0006 <span class=nv>reg</span><span class=o>=</span><span class=m>2</span> this LHello<span class=p>;</span>
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=dalvik-虚拟机是如何执行程序的>Dalvik 虚拟机是如何执行程序的</h3><p>Dalvik 虚拟机属于 Android 运行时环境，它与一些核心库共同承担 Android 应用程序的运行工作。</p><p>简述：</p><ol><li><p>Android 系统启动加载完内核之后，第一个执行的是 <code>init</code> 进程</p><p>它首先要做的是设备的初始化工作，然后读取 <code>inic.rc</code> 文件并启动系统中的重要外部程序 Zygote。</p></li><li><p>Zygote 进程是 Android 所有进程的孵化器进程</p><p>它启动后会首先初始化 Dalvik 虚拟机，然后启动 system_server 并进入 Zygote 模式，通过 socket 等待命令。</p></li><li><p>当执行一个 Android 应用程序时，system_server 进程通过 Binder IPC 方式发送命令给 Zygote，Zygote 收到命令后通过 fork 自身创建一个 Dalvik 虚拟机的实例来执行应用程序的入口函数。</p></li><li><p>当进程 fork 成功后，执行的工作就交给了 Dalvik 虚拟机。</p><p>Dalvik 虚拟机首先通过 <code>loadClassFromDex()</code> 函数完成类的装载工作，每个类被成功解析后都会拥有一个 <code>ClassObject</code> 类型的数据结构存储在运行时环境中，虚拟机使用 <code>gDvm.loadedClasses</code> 全局哈希表来存储与查询所有装载进来的类。</p></li><li><p>随后，字节码验证器使用 <code>dvmVerifyCodeFlow()</code> 函数对装入的代码进行校验。</p></li><li><p>接着虚拟机调用 <code>FindClass()</code> 函数查找并装载 main 方法类，随后调用 <code>dvmInterpret()</code> 函数初始化解释器并执行字节码流。</p></li></ol><h3 id=dalvik-虚拟机-jit即时编译>Dalvik 虚拟机 JIT（即时编译）</h3><p>主流的 JIT 包括两种字节码编译方式：</p><ul><li><code>method</code> 方式：以函数或方法为单位进行编译；</li><li><code>trace</code> 方式：以 trace 为单位进行编译。编译执行比较频繁的 ”热路径“ 代码。</li></ul><h2 id=dalvik-汇编语言基础>Dalvik 汇编语言基础</h2><h3 id=dalvik-指令格式>Dalvik 指令格式</h3><p>一段 Dalvik 汇编代码由一系列 Dalvik 指令组成，指令语法由指令的<strong>位描述</strong>与指令<strong>格式标识</strong>来决定。</p><p>位描述的约定如下：</p><ol><li>每 16 位的字采用空格分隔开来。</li><li>每个字母表示 4 位，每个字母按顺序从高字节开始，排列到低字节。</li><li>四位的内部可以用 ”|“ 来表示不同的内容。</li><li>顺序采用 <code>A~Z</code> 的单个大写字母表示一个 4 位操作码，op 表示一个 8 位操作码。</li><li>”$$\varnothing$$“ 来表示这个字段的所有位为 0。</li></ol><p>例子：”A|G|op BBBB F|E|D|C“</p><p>指令格式的约定如下：</p><ol><li>指令格式标识大多由三个字符组成，前两个是数字，最后一个是字母；</li><li>第一个数字是表示指令有多少个 16 位的字组成；</li><li>第二个数字是表示指令最多使用寄存器的个数。特殊标记 ”r“ 标识使用一定范围内的寄存器。</li><li>第三个字母表示类型码，表示指令用到的额外数据的类型；可能值如下表所示：</li></ol><table><thead><tr><th>助记符</th><th>位大小</th><th>说明</th></tr></thead><tbody><tr><td>b</td><td>8</td><td>8 位有符号立即数</td></tr><tr><td>c</td><td>16, 32</td><td>常量池索引</td></tr><tr><td>f</td><td>16</td><td>接口常量（仅对静态链接格式有效）</td></tr><tr><td>h</td><td>16</td><td>有符号立即数（32 位或 64 位数的高位值，低位为 0）</td></tr><tr><td>i</td><td>32</td><td>立即数，有符号整数或 32 位浮点数</td></tr><tr><td>l</td><td>64</td><td>立即数，有符号整数或 64 位双精度浮点数</td></tr><tr><td>m</td><td>16</td><td>方法常量（仅对静态链接格式有效）</td></tr><tr><td>n</td><td>4</td><td>4 位立即数</td></tr><tr><td>s</td><td>16</td><td>短整形立即数</td></tr><tr><td>t</td><td>8, 16, 32</td><td>跳转、分支</td></tr><tr><td>x</td><td>0</td><td>无额外数据</td></tr></tbody></table><p>最新的 Dalvik 字节码 Reference：https://source.android.com/devices/tech/dalvik/dalvik-bytecode</p><p>另外，Dalvik 对语法做了一些额外的说明：</p><ul><li><p>每个指令以命名的操作码开始，后面可选择使用一个或多个参数，并且参数之间用逗号分隔。</p></li><li><p>每条指令的参数从指令的第一部分开始，op 位于低 8 位，高 8 位可以是一个 8 位的参数，也可以是两个 4 位的参数，也可以为空；如果指令超过 16 位，则后面的部分依次作为参数。</p></li><li><p>命名寄存器的参数形式为“<code>vX</code>”，比如：<code>v0, v1</code>。选择“<code>v</code>”而不是更常用的“<code>r</code>”作为前缀，是因为这样可避免与可能会在其上实现 Dalvik 可执行格式的（非虚拟）架构（其寄存器使用“<code>r</code>”作为前缀）出现冲突。</p><p>（也就是说，我们可以直截了当地同时讨论虚拟和实际寄存器。）</p></li><li><p>表示字面量、常数的参数形式为“<code>#+X</code>”。有些格式表示高阶位仅为非零位的字面量；对于这种类型的字面量，在语法表示时会明确写出后面的 0，但是在按位表示时这些 0 会被省略。</p></li><li><p>表示相对指令地址偏移量的参数形式为“<code>+X</code>”。</p></li><li><p>表示字面量常量池索引的参数形式为“<code>kind@X</code>”，其中“<code>kind</code>”表示正在引用的常量池。每个使用此类格式的操作码明确地表示只允许使用一种常量；请查看操作码参考，找出对应关系。</p><p>常量池的种类包括“<code>string</code>”（字符串池索引）、“<code>type</code>”（类型池索引）、“<code>field</code>”（字段池索引） 、“<code>meth</code>” （方法池索引）和“<code>site</code>”（调用点索引）。</p></li></ul><h3 id=dex-文件反汇编工具>DEX 文件反汇编工具</h3><p>目前 DEX 可执行文件主流的反汇编工具有 BakSmali 和 Dedexer。</p><p>测试代码使用之前的 <code>Hello.java</code>，使用下面的命令编译生成 dex 文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ javac Hello.java
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ dx --dex --output<span class=o>=</span>Hello.dex Hello.class
</span></span></code></pre></td></tr></table></div></div><ol><li><p>使用 <code>baksmali.jar</code> 通过以下的命令反汇编 <code>Hello.dex</code>（<code>bakmali</code> 的使用方法与书本描述不一样，详细使用方法可以hi使用 <code>java -jar baksmali.jar help</code> 查看更加详细的使用方法）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ java -jar baksmali.jar dis -o baksmaliout Hello.dex
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ cat baksmaliout/Hello.smali
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl><span class=c1># virtual methods</span>
</span></span><span class=line><span class=cl>.method public foo<span class=o>(</span>II<span class=o>)</span>I
</span></span><span class=line><span class=cl>    .registers <span class=m>5</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    .prologue
</span></span><span class=line><span class=cl>    .line <span class=m>3</span>
</span></span><span class=line><span class=cl>    add-int v0, p1, p2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    sub-int v1, p1, p2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    mul-int/2addr v0, v1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> v0
</span></span><span class=line><span class=cl>.end method
</span></span></code></pre></td></tr></table></div></div><p>该命令成功执行后，会生成 <code>baksmali/Hello.smali</code> 文件。</p></li><li><p>使用 <code>ddx.jar</code> 通过以下的命令反汇编 <code>Hello.dex</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ java -jar ddx.jar -d ddxout Hello.dex
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ cat ddxout/Hello.ddx
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>.method public foo<span class=o>(</span>II<span class=o>)</span>I
</span></span><span class=line><span class=cl>	add-int	v0,v3,v4
</span></span><span class=line><span class=cl>	sub-int	v1,v3,v4
</span></span><span class=line><span class=cl>	mul-int/2addr	v0,v1
</span></span><span class=line><span class=cl>	<span class=k>return</span>	v0
</span></span><span class=line><span class=cl>.end method
</span></span></code></pre></td></tr></table></div></div><p>命令执行成功后，会生成 <code>ddxout/Hello.ddx</code> 文件。</p></li><li><p>两种反汇编代码的结构组织是一样的，在方法名、字段类型与代码指令序列上它们保持已知，具体表现在一些语法细节上：</p><ul><li>前者使用 <code>.registers</code> 指令指定函数用到的寄存器数目，后者则在 <code>.registers</code> 之前加了 <code>limit</code> 前缀；</li><li>前者使用 <code>p0</code> 做 <code>this</code> 引用，后者则使用 <code>v2</code> 做 <code>this</code> 引用；</li><li>前者使用 <code>.parameter</code> 指定参数，后者则使用 <code>parameter 数组</code> 指定参数；</li><li>前者使用 <code>.prologue</code> 做函数代码的起始位置，后者没有；</li><li>前者使用 p 命名法命名寄存器，后者使用 v 命名法命名寄存器。</li></ul></li></ol><h3 id=dalvik-寄存器>Dalvik 寄存器</h3><blockquote><p>ANDROID 源码可以在以下网址查看：https://android.googlesource.com</p><p>GITHUB 上有源码的镜像：https://github.com/aosp-mirror</p></blockquote><blockquote><p>Dalvik 源码可以使用以下的命令下载最新版本（官网总是 Timeout）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git clone --depth<span class=o>=</span><span class=m>1</span> https://github.com/aosp-mirror/platform_dalvik.git dalvik
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ <span class=nb>cd</span> dalvik
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git fetch --depth<span class=o>=</span><span class=m>1</span> origin gingerbread:gingerbread
</span></span><span class=line><span class=cl><span class=c1># 书本上的源码讲的是 gingerbread 这个分支的源码</span>
</span></span></code></pre></td></tr></table></div></div></blockquote><p>Dalvik 虚拟机基于寄存器架构，在设计之初采用了 ARM 架构（CPU 本身集成了多个寄存器）。</p><p>Dalvik 虚拟机如何虚拟地使用寄存器呢？</p><ol><li><p>每个函数在函数头声明其使用的寄存器数量，虚拟机执行到这个函数时，根据其寄存器的数目分配适当的栈空间，用来存放寄存器实际的值；</p></li><li><p>虚拟机通过处理字节码，对寄存器进行读写操作就是在写栈空间，Android SDK 中有一个名为 <code>dalvik.bytecode.Opcodes</code> 的接口，它定义了一份<a href=https://developer.android.com/reference/dalvik/bytecode/Opcodes target=_blank rel="noopener noreffer">完整的 Dalvik 字节码列表</a></p><p>处理这些字节码的函数为一个宏 <code>HANDLE_OPCODE()</code>，处理过程函数可以在 Android 源代码 <code>dalvik/vm/mterp/c</code> 中找到。</p></li></ol><p>下面以 <code>OP_MOVE.cpp</code> 举例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// vm/mterp/c/OP_MOVE.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>HANDLE_OPCODE</span><span class=p>(</span><span class=err>$</span><span class=n>opcode</span> <span class=cm>/*vA, vB*/</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>vdst</span> <span class=o>=</span> <span class=n>INST_A</span><span class=p>(</span><span class=n>inst</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>vsrc1</span> <span class=o>=</span> <span class=n>INST_B</span><span class=p>(</span><span class=n>inst</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ILOGV</span><span class=p>(</span><span class=s>&#34;|move%s v%d,v%d %s(v%d=0x%08x)&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>INST_INST</span><span class=p>(</span><span class=n>inst</span><span class=p>)</span> <span class=o>==</span> <span class=n>OP_MOVE</span><span class=p>)</span> <span class=o>?</span> <span class=s>&#34;&#34;</span> <span class=o>:</span> <span class=s>&#34;-object&#34;</span><span class=p>,</span> <span class=n>vdst</span><span class=p>,</span> <span class=n>vsrc1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>kSpacing</span><span class=p>,</span> <span class=n>vdst</span><span class=p>,</span> <span class=n>GET_REGISTER</span><span class=p>(</span><span class=n>vsrc1</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>SET_REGISTER</span><span class=p>(</span><span class=n>vdst</span><span class=p>,</span> <span class=n>GET_REGISTER</span><span class=p>(</span><span class=n>vsrc1</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>FINISH</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>OP_END</span>
</span></span></code></pre></td></tr></table></div></div><ol><li><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>vdst</span> <span class=o>=</span> <span class=n>INST_A</span><span class=p>(</span><span class=n>inst</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>vsrc1</span> <span class=o>=</span> <span class=n>INST_B</span><span class=p>(</span><span class=n>inst</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p><code>INST_A</code> 表示用来获取 <code>vA</code> 寄存器地址的宏，其中 <code>A</code> 表示寄存器的”名称“，可以是其他的字母或长度。在该文件的同目录下的 <code>headers.cpp</code> 文件 <code>300~304</code> 中，<code>INST_A</code> 与 <code>INST_B</code> 的声明如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * Extract the &#34;vA, vB&#34; 4-bit registers from the instruction word (_inst is u2).
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=cp>#define INST_A(_inst)       (((_inst) &gt;&gt; 8) &amp; 0x0f)
</span></span></span><span class=line><span class=cl><span class=cp>#define INST_B(_inst)       ((_inst) &gt;&gt; 12)
</span></span></span></code></pre></td></tr></table></div></div><p>也就是说，<code>vdst</code> 获取了 <code>_inst</code> 高 8 位的低 4 位的值；<code>vsrc1</code> 获取了 <code>_inst</code> 的最高 4 位。</p></li><li><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ILOGV</span><span class=p>(</span><span class=s>&#34;|move%s v%d,v%d %s(v%d=0x%08x)&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=n>INST_INST</span><span class=p>(</span><span class=n>inst</span><span class=p>)</span> <span class=o>==</span> <span class=n>OP_MOVE</span><span class=p>)</span> <span class=o>?</span> <span class=s>&#34;&#34;</span> <span class=o>:</span> <span class=s>&#34;-object&#34;</span><span class=p>,</span> <span class=n>vdst</span><span class=p>,</span> <span class=n>vsrc1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>kSpacing</span><span class=p>,</span> <span class=n>vdst</span><span class=p>,</span> <span class=n>GET_REGISTER</span><span class=p>(</span><span class=n>vsrc1</span><span class=p>));</span>
</span></span></code></pre></td></tr></table></div></div><p>用来输出调试信息。</p></li><li><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>SET_REGISTER</span><span class=p>(</span><span class=n>vdst</span><span class=p>,</span> <span class=n>GET_REGISTER</span><span class=p>(</span><span class=n>vsrc1</span><span class=p>));</span>
</span></span></code></pre></td></tr></table></div></div><p><code>SET_REGISTER</code> 用来设置寄存器的值，<code>GET_REGISTER</code> 用来获取寄存器的值（操作的寄存器可以是其它的大小与类型，比如 <code>WIDE</code> 类型相关的宏函数则是 <code>GET_REGISTER_WIDE</code>）。在 <code>headers.cpp</code> 文件，声明如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp># define GET_REGISTER(_idx) \
</span></span></span><span class=line><span class=cl><span class=cp>    ( (_idx) &lt; curMethod-&gt;registersSize ? \
</span></span></span><span class=line><span class=cl><span class=cp>        (fp[(_idx)]) : (assert(!&#34;bad reg&#34;),1969) )
</span></span></span><span class=line><span class=cl><span class=cp># define SET_REGISTER(_idx, _val) \
</span></span></span><span class=line><span class=cl><span class=cp>    ( (_idx) &lt; curMethod-&gt;registersSize ? \
</span></span></span><span class=line><span class=cl><span class=cp>        (fp[(_idx)] = (u4)(_val)) : (assert(!&#34;bad reg&#34;),1969) )
</span></span></span></code></pre></td></tr></table></div></div><p><code>fp</code> 为 ARM 栈帧寄存器，在虚拟机运行到某个函数时指向函数的局部变量区，其中就维护着一份寄存器值的列表。</p></li></ol><h3 id=v-命名法与-p-命名法><code>v</code> 命名法与 <code>p</code> 命名法</h3><p>假设一个函数有 M 个寄存器和 N 个参数，则寄存器命名法如下表所示：</p><table><thead><tr><th>v 命名法</th><th>p 命名法</th><th>寄存器含义</th></tr></thead><tbody><tr><td>v0</td><td>v0</td><td>第 1 个局部变量寄存器</td></tr><tr><td>v1</td><td>v1</td><td>第 2 个局部变量寄存器</td></tr><tr><td>&mldr;</td><td>&mldr;</td><td>。。。</td></tr><tr><td>v{M-N}</td><td>p1</td><td>第 1 个参数寄存器</td></tr><tr><td>&mldr;</td><td>&mldr;</td><td>。。。</td></tr><tr><td>v{M-1}</td><td>p{N-1}</td><td>第 N 个寄存器</td></tr></tbody></table><h3 id=类型方法与字段表示方法>类型、方法与字段表示方法</h3><ol><li><p>类型。</p><p>Dalvik 字节码只有两种类型，基本类型和引用类型。Dalvik 使用这两种类型来表示 Java 语言的全部类型，除了对象和数组是引用对象类型之外，其他的 Java 类型全都是基本类型。全部的类型列表如下：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=../dalvik-type-descript.png data-srcset="../dalvik-type-descript.png, ../dalvik-type-descript.png 1.5x, ../dalvik-type-descript.png 2x" data-sizes=auto alt=../dalvik-type-descript.png title=dalvik-type-descript></p><ul><li>对于 32 位的类型来说，一个寄存器就可以存放该类型的值；而像 J、D 这样等 64 位的类型则是用两个响铃的寄存器来存储的，比如 v0 和 v1。</li><li>L 类型可以表示 Java 中的任何类，这些类在 Java 代码中以 <code>package.name.ObjectName</code> 方式引用，在 Dalvik 汇编代码中，以 <code>Lpackage/name/ObjectName;</code> 形式表示（注意最后有个<strong>分号</strong>）</li><li>[ 类型表示所有基本类型的数组，[ 后面紧跟基本类型描述符，比如 <code>[I</code> 表示一个整型一位数组、<code>[[I</code> 表示 <code>int[][]</code>。</li><li>[ 和 L 同时使用就可以表示对象数组。</li></ul></li><li><p>方法。</p><p>Dalvik 使用方法名、类型参数与返回值来详细描述一个方法。方法格式例子如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-smali data-lang=smali><span class=line><span class=cl><span class=kt>L</span>package/name/<span class=nc>Objectname</span>;<span class=p>-&gt;</span><span class=nf>MethodName</span><span class=p>(</span><span class=kt>III</span><span class=p>)</span><span class=kt>Z</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ol><li><p><code>Lpackage/name/Objectname;</code> 表示一个类型；</p></li><li><p><code>MethodName</code> 表示方法名；</p></li><li><p><code>III</code> 表示方法的参数，在此位三个整形参数；</p></li><li><p><code>Z</code> 表示方法的返回类型，<code>Z</code> 为 boolean 类型。</p><p><code>BakSmali</code> 生成的方法代码以 <code>.method</code> 指令开始，以 <code>.end method</code> 指令结束，根据生成的方法类型不同，在方法指令开始前会用 ”#“ 加以解释。如：<code># virtual methods</code> 表示这是一个虚方法。</p></li></ol></li><li><p>字段。方法格式例子如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-smali data-lang=smali><span class=line><span class=cl><span class=err>Lpackage/name/ObjectName</span><span class=p>-&gt;</span><span class=nv>FieldName</span><span class=p>:</span><span class=kt>L</span>java/lang/<span class=nc>Strng</span>;<span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>字段由类型（<code>Lpackage/name/ObjectName;</code>）、字段名（<code>FieldName</code>）与字段类型（<code>Ljava/lang/String;</code>）组成。其中后两者用 <code>:</code> 隔开。</p><p><code>BakSmali</code> 生成的方法代码以 <code>.field</code> 指令开头，根据生成的方法类型不同，在方法指令开始前会用 &ldquo;#&rdquo; 加以解释。比如：<code># instance field</code> 表示这是一个实例字段。</p></li></ol><h2 id=dalvik-指令集>Dalvik 指令集</h2><h3 id=指令特点>指令特点</h3><p>Dalvik 指令在调用格式上模仿了 C 语言的调用约定。Dalvik 指令的语法与助记符有以下特点：</p><ul><li><p>参数采用从目标（destination）到源（source）的方式；</p></li><li><p>根据字节码的大小与类型不同，一些字节码添加了名称后缀以消除歧义：</p><ul><li><p>32 位没有后缀；</p></li><li><p>64 位常规类型的字节码添加 <code>-wide</code> 后缀；</p></li><li><p>特殊类型的字节码根据具体类型添加后缀。</p><p>可能值为： <code>-boolean</code>、<code>-byte</code>、<code>-char</code>、<code>-short</code>、<code>-int</code>、<code>-long</code>、<code>-float</code>、<code>-double</code>、<code>-object</code>、<code>-string</code>、<code>-class</code>、<code>-void</code>。</p></li></ul></li><li><p>根据字节码的布局与选项不同，一些字节码添加了字节码后缀以消除歧义。这些后缀通过在字节码主名称后添加 <code>/</code> 来分隔。</p></li><li><p>在指令集的描述中，宽度值中的每个字母表示宽度为 4 位。</p></li></ul><p>比如这样一个指令：<code>move-wide/from16 vAA vBBBB</code></p><ul><li><code>move</code> 表示基础字节码（base opcode）：标识这是基本操作；</li><li><code>wide</code> 为名称后缀（name suffix）：标识数据宽度是 64；</li><li><code>from16</code> 为字节码后缀（opcode suffix）：标识操作源是一个 16 位的寄存器引用常量；</li><li><code>vAA</code> 为目的寄存器，始终在源之前，表示 8 位，取值范围是 <code>v0~v255</code>；</li><li><code>vBBBB</code> 为源寄存器，表示 16 位，取值范围是 <code>v0~v65535</code>。</li></ul><p>注意：</p><p><strong>Dalvik 虚拟机中的每个虚拟机都是 32 位的</strong>，描述指令中说的位数表示下标取值范围。</p><h3 id=指令>指令</h3><ol><li><p><strong>空指令</strong>：助记符为 <code>nop</code>，它的值为 <code>00</code>，无实际用途。</p></li><li><p><strong>数据操作指令</strong>：数据操作指令为 <code>move</code>。指令原型为 <code>move destination source</code>，会根据字节码的大小与类型不同，后面会跟上不同的后缀。</p></li><li><p><strong>返回指令</strong>：函数结尾运行的最后一条指令。它的基础字节码为 <code>return</code>，共有以下四条指令：</p><ol><li><code>return-void</code> 表示函数从一个 <code>void</code> 方法返回；</li><li><code>return vAA</code> 表示函数返回一个 32 位非对象类型的值；</li><li><code>return-wide vAA</code> 表示函数返回一个 64 位费对象类型的值；</li><li><code>return-object vAA</code> 表示函数返回一个对象类型的值；</li></ol></li><li><p><strong>数据定义指令</strong>：用来定义程序中用到的常量、字符串、类等数据。它的基础字节码为 <code>const</code>。</p><p>比如：<code>const-wide/16 vAA, #+BBBB</code> 表示将 16 位的数字扩展为 64 位后赋值给寄存器 <code>vAA</code>。</p></li><li><p><strong>锁指令</strong>：Dalvik 中有两条锁指令：<code>monitor-enter vAA</code> 为指定的对象获取锁，<code>monitor-exit vAA</code> 释放指定对象的锁。</p></li><li><p><strong>实例操作指令</strong>：与实例操作相关的操作包括类型转换、检查与新建等。</p><ul><li><code>check-cast vAA, type@BBBB</code>：将 <code>vAA</code> 寄存器中的对象转换为指定的类型，如果失败会抛出 <code>ClassCastException</code> 异常。</li><li><code>instance-of vA, vB, type@CCCC</code>：判断 <code>vB</code> 寄存器中的对象是否可以转换为指定的类型，如果可以则将寄存器 <code>vA</code> 赋值为 1，否则赋值为 0。</li><li><code>new-instance vAA, type@BBBB</code>：构造一个指定类型对象的新实例，并将对象引用赋值给 <code>vAA</code> 寄存器，类型符 type 指定的类型不能是数组类型。</li></ul></li><li><p><strong>数组操作指令</strong>：包括获取数组长度、新建数组、数组赋值、数组元素取值与赋值等操作。</p></li><li><p><strong>异常指令</strong>：Dalvik 中用 <code>throw vAA</code> 指令来抛出 <code>vAA</code> 寄存器中的异常。</p></li><li><p><strong>跳转指令</strong>：Dalvik 指令集中有三种跳转指令：无条件跳转（<code>goto</code>）、分支跳转（<code>switch</code>）与条件跳转（<code>if</code>）</p></li><li><p><strong>比较指令</strong>：它的格式为 <code>cmpkind vAA, vBB, vCC</code>，其中 <code>vBB</code> 与 <code>vCC</code> 是两个待比较的寄存器对，<code>vAA</code> 是存放比较结果的寄存器。</p></li><li><p><strong>字段操作指令</strong>：字段操作指令用来对对象实例的字段进行读写操作。字段的类型可以是 Java 中有效的数据类型。</p><p>对普通字段和静态字段有两种指令集：<code>iinstanceop vA,vB, field@CCCC</code> 与 <code>sstaticop vAA, field@BBBB</code>；</p><p>普通字段指令的前缀为 <code>i</code>，比如普通字段读操作 <code>iget</code>，写操作 <code>iput</code>；</p><p>静态字段指令前缀为 <code>s</code>，比如静态字段读操作 <code>sget</code>，写操作 <code>sput</code>。</p></li><li><p><strong>方法调用指令</strong>：负责调用类实例的方法，它的基础指令为 <code>invoke</code>，方法调用指令有 <code>invoke-kind {vC, vD, vE, vF, vG}, meth@BBBB</code> 与 <code>invoke-kind/range {vCCCC ... vNNNN}, meth@BBBB</code> 两类。两类指令在作用上并无不同，只是后者使用了 range 来指定寄存器的范围。</p></li><li><p><strong>数据转换指令</strong>：用于将一种类型的数值转换为另一种类型。它的格式为 <code>unop vA, vB</code>。<code>vB</code> 中存放着需要转换的数据，转换后的结果保存在 <code>vA</code> 中。</p></li><li><p><strong>数据运算指令</strong>：包括算术运算（加、减、乘、除、模、移位等）与逻辑运算（与、或、非、异或等）</p></li></ol></div><div id=comments><div id=valine class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://valine.js.org/>Valine</a>.</noscript></div></div></div></main><footer class=footer><div class=footer-container><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2022 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://shesl-meow.github.io target=_blank>佘崧林</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=/lib/valine/valine.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/copy-tex.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/valine@1.4.18/dist/Valine.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.8127f0ca4cabc7246f3620f3ef3bf9b1db02805dfe03d6d4c57bc74bc0bf6eea.js integrity="sha256-gSfwykyrxyRvNiDz7zv5sdsCgF3+A9bUxXvHS8C/buo="></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.825fab54c26891370cbd3df4cdff5c9de31af8bb84474e6774573463d8708ae7.js integrity="sha256-gl+rVMJokTcMvT30zf9cneMa+LuER05ndFc0Y9hwiuc="></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.1/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/copy-tex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{valine:{appId:"zDVJohJIQbD6f3W267xtaYRC-gzGzoHsz",appKey:"ewsfU9ocNOeuvt0MzONe6yKx",avatar:"mp",el:"#valine",emojiCDN:"https://cdn.jsdelivr.net/npm/emoji-datasource-google@14.0.0/img/google/64/",emojiMaps:{100:"1f4af.png",alien:"1f47d.png",anger:"1f4a2.png",angry:"1f620.png",anguished:"1f627.png",astonished:"1f632.png",black_heart:"1f5a4.png",blue_heart:"1f499.png",blush:"1f60a.png",bomb:"1f4a3.png",boom:"1f4a5.png",broken_heart:"1f494.png",brown_heart:"1f90e.png",clown_face:"1f921.png",cold_face:"1f976.png",cold_sweat:"1f630.png",confounded:"1f616.png",confused:"1f615.png",cry:"1f622.png",crying_cat_face:"1f63f.png",cupid:"1f498.png",dash:"1f4a8.png",disappointed:"1f61e.png",disappointed_relieved:"1f625.png",dizzy:"1f4ab.png",dizzy_face:"1f635.png",drooling_face:"1f924.png",exploding_head:"1f92f.png",expressionless:"1f611.png",face_vomiting:"1f92e.png",face_with_cowboy_hat:"1f920.png",face_with_hand_over_mouth:"1f92d.png",face_with_head_bandage:"1f915.png",face_with_monocle:"1f9d0.png",face_with_raised_eyebrow:"1f928.png",face_with_rolling_eyes:"1f644.png",face_with_symbols_on_mouth:"1f92c.png",face_with_thermometer:"1f912.png",fearful:"1f628.png",flushed:"1f633.png",frowning:"1f626.png",ghost:"1f47b.png",gift_heart:"1f49d.png",green_heart:"1f49a.png",grimacing:"1f62c.png",grin:"1f601.png",grinning:"1f600.png",hankey:"1f4a9.png",hear_no_evil:"1f649.png",heart:"2764-fe0f.png",heart_decoration:"1f49f.png",heart_eyes:"1f60d.png",heart_eyes_cat:"1f63b.png",heartbeat:"1f493.png",heartpulse:"1f497.png",heavy_heart_exclamation_mark_ornament:"2763-fe0f.png",hole:"1f573-fe0f.png",hot_face:"1f975.png",hugging_face:"1f917.png",hushed:"1f62f.png",imp:"1f47f.png",innocent:"1f607.png",japanese_goblin:"1f47a.png",japanese_ogre:"1f479.png",joy:"1f602.png",joy_cat:"1f639.png",kiss:"1f48b.png",kissing:"1f617.png",kissing_cat:"1f63d.png",kissing_closed_eyes:"1f61a.png",kissing_heart:"1f618.png",kissing_smiling_eyes:"1f619.png",laughing:"1f606.png",left_speech_bubble:"1f5e8-fe0f.png",love_letter:"1f48c.png",lying_face:"1f925.png",mask:"1f637.png",money_mouth_face:"1f911.png",nauseated_face:"1f922.png",nerd_face:"1f913.png",neutral_face:"1f610.png",no_mouth:"1f636.png",open_mouth:"1f62e.png",orange_heart:"1f9e1.png",partying_face:"1f973.png",pensive:"1f614.png",persevere:"1f623.png",pleading_face:"1f97a.png",pouting_cat:"1f63e.png",purple_heart:"1f49c.png",rage:"1f621.png",relaxed:"263a-fe0f.png",relieved:"1f60c.png",revolving_hearts:"1f49e.png",right_anger_bubble:"1f5ef-fe0f.png",robot_face:"1f916.png",rolling_on_the_floor_laughing:"1f923.png",scream:"1f631.png",scream_cat:"1f640.png",see_no_evil:"1f648.png",shushing_face:"1f92b.png",skull:"1f480.png",skull_and_crossbones:"2620-fe0f.png",sleeping:"1f634.png",sleepy:"1f62a.png",slightly_frowning_face:"1f641.png",slightly_smiling_face:"1f642.png",smile:"1f604.png",smile_cat:"1f638.png",smiley:"1f603.png",smiley_cat:"1f63a.png",smiling_face_with_3_hearts:"1f970.png",smiling_imp:"1f608.png",smirk:"1f60f.png",smirk_cat:"1f63c.png",sneezing_face:"1f927.png",sob:"1f62d.png",space_invader:"1f47e.png",sparkling_heart:"1f496.png",speak_no_evil:"1f64a.png",speech_balloon:"1f4ac.png","star-struck":"1f929.png",stuck_out_tongue:"1f61b.png",stuck_out_tongue_closed_eyes:"1f61d.png",stuck_out_tongue_winking_eye:"1f61c.png",sunglasses:"1f60e.png",sweat:"1f613.png",sweat_drops:"1f4a6.png",sweat_smile:"1f605.png",thinking_face:"1f914.png",thought_balloon:"1f4ad.png",tired_face:"1f62b.png",triumph:"1f624.png",two_hearts:"1f495.png",unamused:"1f612.png",upside_down_face:"1f643.png",weary:"1f629.png",white_frowning_face:"2639-fe0f.png",white_heart:"1f90d.png",wink:"1f609.png",woozy_face:"1f974.png",worried:"1f61f.png",yawning_face:"1f971.png",yellow_heart:"1f49b.png",yum:"1f60b.png",zany_face:"1f92a.png",zipper_mouth_face:"1f910.png",zzz:"1f4a4.png"},enableQQ:!1,highlight:!0,lang:"zh-CN",pageSize:10,placeholder:"你的评论 ...",recordIP:!0,serverURLs:"https://zdvjohji.lc-cn-n1-shared.com",visitor:!0}},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:30}}</script><script type=text/javascript src=/js/theme.min.b0df51c2c57145081cc73960e9aa780e6f5f56d06cf4ef0f96da8ce1619d1e12.js integrity="sha256-sN9RwsVxRQgcxzlg6ap4Dm9fVtBs9O8PltqM4WGdHhI="></script></body></html>