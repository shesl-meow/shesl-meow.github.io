<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>数据结构 - 分类 - shesl's blog</title><link>http://shesl-meow.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><description>数据结构 - 分类 - shesl's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>shesl-meow@qq.com (佘崧林)</managingEditor><webMaster>shesl-meow@qq.com (佘崧林)</webMaster><lastBuildDate>Sat, 19 Jan 2019 13:37:04 +0800</lastBuildDate><atom:link href="http://shesl-meow.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="self" type="application/rss+xml"/><item><title>REVIEW</title><link>http://shesl-meow.github.io/note/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/review/</link><pubDate>Sat, 19 Jan 2019 13:37:04 +0800</pubDate><author>佘崧林</author><guid>http://shesl-meow.github.io/note/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/review/</guid><description>1. 基本知识 维基百科上列出了下面的时间复杂度种类： 名称 运行时间（$${\displaystyle T(n)}$$） 算法举例 常数时间 $${\displaystyle O(1)}$$ 判断一个二</description></item><item><title>搜索树</title><link>http://shesl-meow.github.io/note/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/searchtree/</link><pubDate>Sat, 19 Jan 2019 13:37:04 +0800</pubDate><author>佘崧林</author><guid>http://shesl-meow.github.io/note/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/searchtree/</guid><description>二叉搜索树 BST 满足以下特性的二叉树是棵二叉搜索树（Binary Search Tree）： 每个元素有一个关键字，并且任意两个元素的关键字都不同；因此所有关键</description></item><item><title>优先级队列</title><link>http://shesl-meow.github.io/note/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/priorityqueue/</link><pubDate>Sat, 19 Jan 2019 13:37:04 +0800</pubDate><author>佘崧林</author><guid>http://shesl-meow.github.io/note/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/priorityqueue/</guid><description>ADT 抽象数据类型 1 2 3 4 5 6 7 8 9 10 11 12 ADT maxPriorityQueue { DATA: element ele_queue[]; METHOD: empty(): return true if ele_queue is empty. size(): return size of ele_queue. top(): return the element with max priority. pop(): delete the element with max priority. push(x): push element &amp;#34;x&amp;#34;. } 堆 概念：大根堆，小根堆。 左</description></item><item><title>字典</title><link>http://shesl-meow.github.io/note/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dictionary/</link><pubDate>Sat, 19 Jan 2019 13:37:04 +0800</pubDate><author>佘崧林</author><guid>http://shesl-meow.github.io/note/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dictionary/</guid><description>ADT 抽象数据类型 1 2 3 4 5 6 7 8 9 10 11 12 ADT dictionary { DATA: data_pair key_value[]; METHOD: empty(): return true if key_value is empty. size(): return size of key_value. find(k): return pointer in key_value whose key is k. insert(p): insert data_pair p into key_value. erase(k): erase data_pair from key_value where its key is k. } 线性表表示 两</description></item><item><title>B-Tree</title><link>http://shesl-meow.github.io/note/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/b-tree/</link><pubDate>Mon, 24 Dec 2018 15:08:53 +0800</pubDate><author>佘崧林</author><guid>http://shesl-meow.github.io/note/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/b-tree/</guid><description>学习链接： https://www.geeksforgeeks.org/b-tree-set-1-introduction-2/ https://www.geeksforgeeks.org/b-tree-set-1-insert-2/ Introduction Defination: B-Tree is a self-balancing search tree. In most of the other self-balancing search trees (like AVL and Red-Black Trees), it is assumed that everything is in main memory. Usage: Disk access time is very high compared to main memory access time. The main idea of using B-Trees is to reduce the number of disk accesses. Analysis: Most of the tree operations</description></item><item><title>Chapter 10--Binary Trees</title><link>http://shesl-meow.github.io/note/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/bintree/</link><pubDate>Mon, 24 Dec 2018 15:08:53 +0800</pubDate><author>佘崧林</author><guid>http://shesl-meow.github.io/note/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/bintree/</guid><description>Binary Trees Definitions Binary Tree: A binary tree is either empty, or it consists of a node called the root together with two binary trees called the left subtree and the right subtree of the root. Empty Tree: The first case, the base case that involves no recursion, is that of an empty binary tree. The empty tree will usually be the base case for recursive algorithms and will determine</description></item></channel></rss>