<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LeetCode on shesl-meow's note site</title><link>http://shesl-meow.github.io/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/leetcode/</link><description>Recent content in LeetCode on shesl-meow's note site</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="http://shesl-meow.github.io/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>http://shesl-meow.github.io/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/leetcode/boyermoore/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/leetcode/boyermoore/</guid><description>Boyer–Moore majority vote algorithm # 多数投票算法：Boyer-Moore 是为了解决这样一个问题的算法：
用来寻找一组数据中占多数的元素的算法，时间复杂度 O(n)，空间复杂度 O(1)； Golang 代码实现：
func majorityElement(nums []int) int { iter, most := 0, 0 for _,num := range nums { if iter == 0 { most, iter = num, iter+1 } else if most == num { iter += 1 } else { iter -= 1 } } count, sz := 0, len(nums) for _,num := range nums { if num == most { count += 1 } if count * 2 &amp;gt; sz { return most } } return -1 }</description></item></channel></rss>