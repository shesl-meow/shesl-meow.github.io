<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>functional on shesl-meow's note site</title><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/functional/</link><description>Recent content in functional on shesl-meow's note site</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/functional/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/functional/1.basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/functional/1.basic/</guid><description>函数式编程入门 # 纯函数 # 什么是纯函数？
纯函数：相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。 为什么要追求纯函数？
可缓存性（Cacheable）：JavaScript 中应用最广泛的库为 memoizee； 可移植性（Portable）：可移植性可以意味着把函数序列化。与之相对的是面向对象语言，移植一个对象通常需要将整个庞大的体系迁移，这也是 JavaScript 拥有强大的组件化生态的原因。 自文档化（Self-Documenting）：不需要过多的 Context 来描述函数执行前、执行后的效果； 可测试性（Testable）：Quickcheck，一个为函数式环境量身定制的测试工具。 引用透明性（Referential Transparency）：如果一个函数调用可以完全用它的返回值代替，那么称这个函数时引用透明的。 柯里化 (Curry) # Curry 的概念：
只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。 柯里化函数的简单实现：
var curry = fn =&amp;gt; function $curry(...args) { return (args.length &amp;lt; fn.length) ? $curry.bind(null, ...args) : fn.call(null, ...args); } 函数组合 (Compose) # 以下的操作称作为两个函数 f、g 的组合（相当于数学中的复合函数）：
var compose = (f,g) =&amp;gt; ( (x) =&amp;gt; f(g(x)) ); JavaScript 中有一个为了函数式编程设计的库就聚合了 compose、curry 等函数：ramda</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/functional/2.container/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/functional/2.container/</guid><description>容器 # 通过一些基础的函数式编程操作，我们得以更优雅地进行编程，但是之前使用的纯函数编程方法却并不能解决所有的问题。比如：控制流、异常处理、异步操作、状态变化等。这些问题都可以用本节抽象的概念解决。
Container # 通过如下方式定义的对象称为一个简单的容器：
class Container { constructor(x) { this.$value = x; } static of (x) { return new this.constructor(x); } } 其中 static 函数 of 仅仅是为了方便代码更加函数化而定义，不影响理论探究的函数。
具体的，容器的操作应该遵循以下的约定：
Container 是一个有且仅有一个属性的对象，我们后面将抽象地将它命名为 $value； $value 不能被约束为任何特定的类型，否则我们的使用场景将相当有限； $value 一旦进入容器，它将一只被设置在容器内。我们可以但不应当通过 .$value 这种访问属性的方式访问他。 Functor (Identity) # Functor 是一类特殊的 Container，我们后续讨论的容器都是基于 Functor 的。它的简单实现：
class Functor extends Container { map(f) { return Functor.of( f(this.$value) ); } } 所以 Functor 是：一种实现了 map 方法的容器。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/functional/3.monad/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/functional/3.monad/</guid><description>Monad # Pointy Functor Factory # 在前面有关 Functor 的论述中使用了 of 函数，实际上这个函数并不是用来替换 new 这个操作符的：
Pointed Functor：一种实现了 of 方法的 Functor。 of 方法在很多地方以不同的名称出现，但是它们都是相同的意思，比如 pure, point, unit 或 return。
JavaScript 语言中有许多类型功能的库：folktale、ramda 或 fantasy-land。
What&amp;rsquo;s Monad? # 先看一个通过 Container 方法从 Json 中获取给定字段的例子：
const safeProp: string =&amp;gt; object =&amp;gt; Mabey&amp;lt;any&amp;gt; = curry((x, obj) =&amp;gt; Maybe.of(obj[x])); const safeHead: object =&amp;gt; Maybe&amp;lt;any&amp;gt; = safeProp(0); const firstAddressStreet: object =&amp;gt; Maybe&amp;lt;Maybe&amp;lt;Maybe&amp;lt;any&amp;gt;&amp;gt;&amp;gt; = compose( map(map(safeProp(&amp;#39;street&amp;#39;))), map(safeHead), safeProp(&amp;#39;addresses&amp;#39;), ); firstAddressStreet({ addresses: [{ street: { name: &amp;#39;Mulburry&amp;#39;, number: 8402 }, postcode: &amp;#39;WC2N&amp;#39; }], }); 可以看到在处理真实场景时，map 会像上面的情况一样出现多层嵌套的情况。我们可以用 join 函数解决上面的问题：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/functional/4.applicative/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/functional/4.applicative/</guid><description>Applicative # Brief Introduction # Applicative 指的是这样的一个性质：functor 之间可以相互 apply。
看下面这样一个例子：
Container.of(2).chain(two =&amp;gt; Container.of(3).map(add(two))); 上面是一个用 Monad 实现 2+3 的例子，可以看到我们需要构造 Container.of(3) 然后构造一个加法函数，最后构造一个 Container.of(2) 进行应用。
我们发现 Container.of(3)/Container.of(2) 具有先后的构造关系，这是没有必要的，如果我们能同时构造两个 Functor 并且其中一个应用到另一个上，那么我们就完美解决了这个问题，这个性质就叫做 Applicative。
ap # 在 applicative 这个概念里的核心函数是 ap。它的实现如下：
// 类型签名 type apSig&amp;lt;Farg, Fret&amp;gt; = (Container&amp;lt;Farg&amp;gt;, Container&amp;lt;Farg =&amp;gt; Fret&amp;gt;) =&amp;gt; Container&amp;lt;Fret&amp;gt;; // 函数实现 Container.prototype.ap = function (otherContainer) { return otherContainer.map(this.$value); } ap 函数的实现即 Applicative Functor 的定义：
实现了 ap 函数的 Pointed Functor 即为 Applicative Functor； 可以用 ap 优化上面的例子：</description></item></channel></rss>