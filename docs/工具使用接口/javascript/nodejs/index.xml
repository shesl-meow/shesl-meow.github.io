<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>nodejs on shesl-meow's note site</title><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/</link><description>Recent content in nodejs on shesl-meow's note site</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/1.%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/1.%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90/</guid><description>参考：
https://www.runoob.com/nodejs/nodejs-http-server.html 第一个程序 # HelloWorld # 在 Mac 上直接使用下面的命令即可安装：
brew install node HelloWorld 程序，可以检测安装状态：
console.log(&amp;#34;Hello World&amp;#34;); 简单的 WEB 服务器 # 在我们创建 Node.js 第一个 &amp;ldquo;Hello, World!&amp;rdquo; 应用前，让我们先了解下 Node.js 应用是由哪几部分组成的：
**引入 required 模块：**我们可以使用 require 指令来载入 Node.js 模块。 **创建服务器：**服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。 **接收请求与响应请求：**服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。 代码如下：
var http = require(&amp;#39;http&amp;#39;); http.createServer(function (request, response) { // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/10.%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/10.%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B1%BB/</guid><description>函数与类 # prototype # 简单地说，JavaScript 是基于原型的语言。
当我们调用一个对象的属性时，如果对象没有该属性，JavaScript 解释器就会从对象的原型对象上去找该属性，如果原型上也没有该属性，那就去找原型的原型，直到最后返回 null 为止，null没有原型。这种属性查找的方式被称为原型链（prototype chain）。
new # 当 js 语言执行 new 操作时具体时执行的什么操作呢？
创建一个空对象 u = {}
绑定原型，u.__proto__ = User.prototype 或 Objet.setPrototypeOf(u, User.prototype)；
调用 User() 函数，并把空对象 u 当做 this 传入，即 User.call(u)；
如果 User() 函数执行完自己 return 一个 object 类型，那么返回此变量，否则返回 this。
PS：如果构造函数返回基本类型值，则不影响，还是返回 this
箭头函数与普通函数 # 区别：
箭头函数不会创建自己的 this：它会从自己的作用域链上继承一个 this； 箭头函数的 this 永远不变：它的 this 在被定义时就已经确定了（call/apply/bind 都无法改变箭头函数的指向）； 箭头函数不能作为构造函数使用（本质是因为 this 无法改变）； 箭头函数没有自己的 argument，没有 prototype； 箭头函数不能使用 yeild 关键字；</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/2.npm%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/2.npm%E4%BB%8B%E7%BB%8D/</guid><description>参考：
https://www.runoob.com/nodejs/nodejs-npm.html NPM # 介绍 # NPM 是随同 node.js 一起安装的包管理工具，能解决 node.js 代码部署上的很多问题。
常见的使用场景有以下几种：
允许用户从 NPM 服务器下载，别人编写的第三方包到本地使用。 允许用户从 NPM 服务器下载并安装，别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序，上传到 NPM 服务器供别人使用。 通过查看版本信息，检测是否安装：
npm -v 如果你安装的是旧版本的 npm，可以很容易得通过 npm 命令来升级，命令如下：
sudo npm install npm -g 命令行使用方式 # 本地安装 # 以 express 为例，安装方式为：
npm install express 这种安装方式：
将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。 可以通过 require() 来引入本地安装的包。 全局安装 # 以 express 为例，安装方式为：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/3.repl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/3.repl/</guid><description>Node.js REPL # 介绍 # Node.js REPL (Read Eval Print Loop: 交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。
Node 自带了交互式解释器，可以执行以下任务：
读取 Read：读取用户输入，解析输入了Javascript 数据结构并存储在内存中。 执行 Eval：执行输入的数据结构 打印 Print：输出结果 循环 Loop：循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。 Node 的交互式解释器可以很好的调试 Javascript 代码。
学习 REPL # 我们可以输入以下命令来启动 Node 的终端：
node 这个终端内的运行效果跟 chrome 中的 console 中差异不大。
除了数值计算、函数、逻辑控制这些其他语言都具备的功能之外，以下特性值得学习：
下划线(_)变量：你可以使用下划线 _ 获取上一个表达式的运算结果： ctrl + c：退出当前终端。 ctrl + c 按下两次 / ctrl + d：退出 Node REPL。 :arrow_up:/:arrow_down:：查看输入的历史命令 tab 键：列出当前命令 .</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/4.%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/4.%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</guid><description>回调函数 # 介绍 # Node.js 异步编程的直接体现就是回调。
异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。
回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。
回调函数一般作为函数的最后一个参数出现：
function foo1(name, age, callback) { } function foo2(value, callback1, callback2) { } 阻塞代码（同步）实例 # 创建一个文件 test.txt ，内容如下：
laji shesl&amp;#39;s test case 创建 mainsync.js 文件, 代码如下：
var fs = require(&amp;#34;fs&amp;#34;); var data = fs.readFileSync(&amp;#39;test.txt&amp;#39;); console.log(data.toString()); console.log(&amp;#34;done!&amp;#34;); 以上代码执行结果如下：
$ node mainsync.js laji shesl&amp;#39;s test case Done!! 非阻塞代码（异步）实例 # 创建一个文件 testasync.txt ，内容如下：
laji shesl&amp;#39;s test case 创建 mainasync.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/5.%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/5.%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</guid><description>参考：
https://www.runoob.com/nodejs/nodejs-event-loop.html
https://zhuanlan.zhihu.com/p/37427130
事件循环 # 简介 # Node.js 是单进程单线程应用程序，那么它是如何实现异步调用的呢？
它维护了六个 FIFO 队列，分别表示不同的功能的函数：
┌───────────────────────────┐ ┌─&amp;gt;│ timers │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ pending callbacks │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ idle, prepare │ │ └─────────────┬─────────────┘ ┌───────────────┐ │ ┌─────────────┴─────────────┐ │ incoming: │ │ │ poll │&amp;lt;─────┤ connections, │ │ └─────────────┬─────────────┘ │ data, etc. │ │ ┌─────────────┴─────────────┐ └───────────────┘ │ │ check │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ └──┤ close callbacks │ └───────────────────────────┘ 然后它的单线程只执行一个 while 循环，一直跑这六个的头部任务，直到队列为空或者执行时间到达上限。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/6.eventemitter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/6.eventemitter/</guid><description>参考：
https://www.runoob.com/nodejs/nodejs-event.html EventEmitter # Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。
Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。
所有这些产生事件的对象都是 events.EventEmitter 的实例。
它被定义在 events，这个模块中：
var events = require(&amp;#39;events&amp;#39;); 这个模块只定义了一个对象 events.EventEmitter，它的核心就是事件触发与事件监听器功能的封装：
var eventEmitter = new events.EventEmitter(); 下面一个简单的例子阐述事件的监听和出发过程：
//event.js 文件 var events = require(&amp;#39;events&amp;#39;); var emitter = new events.EventEmitter(); emitter.on(&amp;#39;someEvent&amp;#39;, function(arg1, arg2) { console.log(&amp;#39;listener1&amp;#39;, arg1, arg2); }); emitter.on(&amp;#39;someEvent&amp;#39;, function(arg1, arg2) { console.log(&amp;#39;listener2&amp;#39;, arg1, arg2); }); emitter.emit(&amp;#39;someEvent&amp;#39;, &amp;#39;strArg1&amp;#39;, &amp;#39;strArg2&amp;#39;); $ node events.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/7.buffer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/7.buffer/</guid><description>参考：
https://www.runoob.com/nodejs/nodejs-buffer.html Buffer # 概述 # JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。因此在 Node.js 中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。
下面介绍一些常见的用法。完整的请参考官方文档。
编码与解码 # 将字符串转化为二进制数据的过程叫编码：
const buf = Buffer.from(&amp;#39;runoob&amp;#39;, &amp;#39;ascii&amp;#39;); 将二进制数据转化为字符串的过程叫解码：
console.log(buf.toString(&amp;#39;hex&amp;#39;)); // 输出 72756e6f6f62 Node.js 目前支持的字符编码包括：
ascii：仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。 utf8：多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。 utf16le/ucs2：2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。 base64：Base64 编码。 latin1/binary：一种把 Buffer 编码成一字节编码的字符串的方式。 hex：将每个字节编码为两个十六进制字符。 创建 Buffer 类 # Buffer 提供了以下 API 来创建 Buffer 类：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/8.stream/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/8.stream/</guid><description>Stream # 概述 # Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对 http 服务器发起请求的 request 对象就是一个 Stream，还有 stdout（标准输出）也是一个 Stream。
Node.js，Stream 有四种流类型：
Readable：可读操作。 Writable：可写操作。 Duplex：可读可写操作. Transform：操作被写入数据，然后读出结果。 所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：
data：当有数据可读时触发。 end：没有更多的数据可读时触发。 error：在接收和写入过程中发生错误时触发。 finish：所有数据已被写入到底层系统时触发。 从流中读取数据 # 读取的基本方法是：通过监听 data 事件，数据会在回调函数的参数中回传。
一个示例程序如下：
var fs = require(&amp;#34;fs&amp;#34;); var data = &amp;#39;&amp;#39;; var readerStream = fs.createReadStream(&amp;#39;test.txt&amp;#39;); readerStream.setEncoding(&amp;#39;UTF8&amp;#39;); // 处理流事件 --&amp;gt; data, end, and error readerStream.on(&amp;#39;data&amp;#39;, chunk =&amp;gt; { data += chunk; }); readerStream.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/9.%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/9.%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/</guid><description>模块系统 # 概述 # 为了让 Node.js 的文件可以相互调用，Node.js 提供了一个简单的模块系统。
模块是 Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是 JavaScript 代码、JSON 或者编译过的C/C++ 扩展。
创建模块 # 创建一个模块非常简单，举个例子。
创建一个叫 hello 的模块，只需要创建 hello.js 文件，代码如下：
exports.world = () =&amp;gt; { console.log(&amp;#39;Hello World&amp;#39;); } 这样，其他文件包含这个文件时，就可以访问到 world 这个函数了。
如果我们希望直接封装一个对象，可以直接给 module.exports 这个变量赋值。比如：
function Hello() { var name; this.setName = thyName =&amp;gt; { name = thyName; }; }; module.exports = Hello; js 模块的编译在编译的过程中，Node 对获取的 javascript 文件内容进行了头尾包装，将文件内容包装在一个 function 中：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/nodemodules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/nodemodules/</guid><description>参考：
https://www.zhihu.com/question/62791509 https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1 Commonjs vs ES Modules # What’s CJS? What’s ESM? # 在 Node 模块的早期，所有的 Node Module 都是用 Common.js 编写的。我们可以从 named export 与 default export 两种方式简单地了解它的使用规则：
named export： // @filename: util.cjs module.exports.sum = (x, y) =&amp;gt; x + y; // @filename: main.cjs const {sum} = require(&amp;#39;./util.cjs&amp;#39;); default export： // @filename: util.cjs module.exports = (x, y) =&amp;gt; x + y; // @filename: main.</description></item></channel></rss>