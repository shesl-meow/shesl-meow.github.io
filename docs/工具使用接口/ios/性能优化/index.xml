<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>性能优化 on shesl-meow's note site</title><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link><description>Recent content in 性能优化 on shesl-meow's note site</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/cpugpu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/cpugpu/</guid><description>参考：
https://juejin.im/post/5ace078cf265da23994ee493#heading-2 https://www.zhihu.com/question/29163054 https://www.jianshu.com/p/f62e81b72bba CPU &amp;amp; GPU # 图形学概念 # 光栅化（Rasterize / Rasteriztion）：
就是把矢量图形转化成像素点儿的过程。 着色器（Shader），通常着色器分两种：
顶点着色器（vertex shader）：这个是告诉电脑如何打线稿的——如何处理顶点、法线等的数据的小程序。 片面着色器（fragment shader）：这个是告诉电脑如何上色的——如何处理光、阴影、遮挡、环境等等对物体表面的影响，最终生成一副图像的小程序。 二者功能 # CPU 的职能：
加载资源，对象创建，对象调整，对象销毁，布局计算，Autolayout，文本计算，文本渲染； 图片的解码， 图像的绘制（Core Graphics）都是在CPU上面进行的。 GPU 的特点：
GPU 是一个专门为图形高并发计算而量身定做的处理单元，比 CPU 使用更少的电来完成工作并且 GPU 的浮点计算能力要超出 CPU 很多。 GPU 的渲染性能要比 CPU 高效很多，同时对系统的负载和消耗也更低一些，所以在开发中，我们应该尽量让 CPU 负责主线程的 UI 调动，把图形显示相关的工作交给 GPU 来处理，当涉及到光栅化等一些工作时，CPU也会参与进来，这点在后面再详细描述。 GPU 的指责：
接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合（合成）并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。 离屏渲染 # GPU 屏幕渲染有以下两种方式：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</guid><description>参考：
https://github.com/ming1016/study/wiki/iOS性能优化 https://juejin.im/post/5ace078cf265da23994ee493#heading-7 优化方案 # UITableView # 缓存池存储 cell，复用 cell：
在 cellForRowAtIndexPath: 回调的时候只创建实例，快速返回 cell，不绑定数据。 在 willDisplayCell: forRowAtIndexPath: 的时候通过 dequeueReusableCellWithIdentifier: 方法取缓存的 cell，通过 initWithStyle:reuseIdentifier: 绑定数据（赋值）。 缓存高度：
在 tableView 滑动时，会不断调用 heightForRowAtIndexPath:，当 cell 高度需要自适应时，每次回调都要计算高度，会导致 UI 卡顿。为了避免重复无意义的计算，需要缓存高度。 通过 Dictionary 或 NSCache 的方式进行缓存； 开源项目：FDTemplateLayoutCell 视图层级优化 # 不要动态创建视图：
在内存可控的前提下，缓存 subview；善用hidden。 减少视图层级：
减少 subview 的数量，使用layer 中的 drawrect 绘制，这样可以利用 GPU 离屏渲染； 少用 clearColor，maskToBounds，阴影效果等，可以避免 GPU 离屏渲染； 图片优化：</description></item></channel></rss>