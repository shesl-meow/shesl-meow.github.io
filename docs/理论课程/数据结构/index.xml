<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>数据结构 on shesl-meow's note site</title><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><description>Recent content in 数据结构 on shesl-meow's note site</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/b-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/b-tree/</guid><description>学习链接：
https://www.geeksforgeeks.org/b-tree-set-1-introduction-2/ https://www.geeksforgeeks.org/b-tree-set-1-insert-2/ B-Tree # Introduction # Defination:
B-Tree is a self-balancing search tree. In most of the other self-balancing search trees (like AVL and Red-Black Trees), it is assumed that everything is in main memory.
Usage:
Disk access time is very high compared to main memory access time. The main idea of using B-Trees is to reduce the number of disk accesses.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/bintree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/bintree/</guid><description>Chapter 10&amp;ndash;Binary Trees # Binary Trees # Definitions # Binary Tree:
A binary tree is either empty, or it consists of a node called the root together with two binary trees called the left subtree and the right subtree of the root.
Empty Tree: The first case, the base case that involves no recursion, is that of an empty binary tree. The empty tree will usually be the base case for recursive algorithms and will determine when the algorithm stops.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dictionary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dictionary/</guid><description>字典 # ADT 抽象数据类型 # ADT dictionary
{
DATA:
data_pair key_value[];
METHOD:
empty(): return true if key_value is empty.
size(): return size of key_value.
find(k): return pointer in key_value whose key is k.
insert(p): insert data_pair p into key_value.
erase(k): erase data_pair from key_value where its key is k.
}
线性表表示 # 两个类 sortedArrayList 和 sortedChain 分别存储键和值。
跳表表示 # 跳跃表（skiplist）是一种随机化的数据， 由 William Pugh 在论文《Skip lists: a probabilistic alternative to balanced trees》中提出， 跳跃表以有序的方式在层次化的链表中保存元素， 效率和平衡树媲美 —— 查找、删除、添加等操作都可以在对数期望时间下完成， 并且比起平衡树来说， 跳跃表的实现要简单直观得多。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/priorityqueue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/priorityqueue/</guid><description>优先级队列 # ADT 抽象数据类型 # ADT maxPriorityQueue
{
DATA:
element ele_queue[];
METHOD:
empty(): return true if ele_queue is empty.
size(): return size of ele_queue.
top(): return the element with max priority.
pop(): delete the element with max priority.
push(x): push element &amp;quot;x&amp;quot;.
}
堆 # 概念：大根堆，小根堆。
左高树 # 概念：
外部结点（external node）：加入在树中所有空子树的结点。
内部结点（internal node）：原本就存在的结点。
扩充二叉树（extended binary tree）：增加了外部节点的二叉树。
令 s(x) 是从结点 x 到其子树的外部节点的所有路径中最短的一条，则：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/review/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/review/</guid><description>REVIEW # 1. 基本知识 # 维基百科上列出了下面的时间复杂度种类：
名称 运行时间（$${\displaystyle T(n)}$$） 算法举例 常数时间 $${\displaystyle O(1)}$$ 判断一个二进制数的奇偶 反阿克曼时间 $${\displaystyle O(\alpha (n))}$$ 并查集的单个操作的平摊时间 迭代对数时间 $${\displaystyle O(\log ^{*}n)}$$ 分布式圆环着色问题 对数对数时间 $${\displaystyle O(\log \log n)}$$ 有界优先队列的单个操作 对数时间 $${\displaystyle O(\log n)}$$ 二分搜索 幂对数时间 $${\displaystyle (\log n)^{O(1)}}$$ （小于1次）幂时间 $${\displaystyle O(n^{c})}$$，其中$${\displaystyle 0&amp;lt;c&amp;lt;1}$$ K-d 树的搜索操作 线性时间 $${\displaystyle O(n)}$$ 无序数组的搜索 线性迭代对数时间 $${\displaystyle O(n\log ^{*}n)}$$ 莱姆德·赛德尔的三角分割多边形算法 线性对数时间 $${\displaystyle O(n\log n)}$$ 最快的比较排序 二次时间 $${\displaystyle O(n^{2})}$$ 冒泡排序、插入排序 三次时间 $${\displaystyle O(n^{3})}$$ 矩阵乘法的基本实现，计算部分相关性 多项式时间 $${\displaystyle 2^{O(\log n)}=n^{O(1)}}$$ 线性规划中的卡马卡算法，AKS 质数测试 准多项式时间 $${\displaystyle 2^{(\log n)^{O(1)}}}$$ 关于有向斯坦纳树问题最著名的$${\displaystyle O(\log ^{2}n)}!</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/searchtree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/searchtree/</guid><description>搜索树 # 二叉搜索树 BST # 满足以下特性的二叉树是棵二叉搜索树（Binary Search Tree）：
每个元素有一个关键字，并且任意两个元素的关键字都不同；因此所有关键字都是唯一的； 在根节点的左子树中，元素的关键字（如果有的话）都小于根节点的关键字； 在根节点的右子树中，元素的关键字（如果有的话）都大于根节点的关键字； 根节点的左右子树也都是二叉搜索树。 AVL 搜索树 # AVL 树是 Adelson-Velskii 和 Landis 在 1962 年提出的：
AVL 搜索树是一棵二叉搜索树 左右子树的高分别为 $$h_L, h_R$$，则 AVL 搜索树有：$$|h_L - h_R| \le 1$$ AVL 搜索树根节点的左子树和右子树也是 AVL 搜索树。 红黑树 # 红黑树：
红黑树是一个带有颜色的二叉查找树，所有结点均是红色或黑色； 根是黑色； 所有叶子都是黑色（叶子结点是外部结点）； 每个红色结点必须有两个黑色结点； 从任一节点到其每个叶子的简单路径都包含相同数量的黑色结点。 B-树 # 根据 Knuth 的定义，一个 m 阶的B树是一个有以下属性的树：
每个节点最多有 m 个子节点； 每个非叶子节点（除根节点）最少有 $$\displaystyle [\frac{m}{2}] $$ 个子节点； 如果根节点不是叶子节点，那么它至少有两个子节点； 有 k 个子节点的非叶子节点拥有 k − 1 个键； 所有的叶子节点都在同一层。</description></item></channel></rss>