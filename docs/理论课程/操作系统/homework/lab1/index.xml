<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>lab1 on shesl-meow's note site</title><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/</link><description>Recent content in lab1 on shesl-meow's note site</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe1/</guid><description>exe1 # make # make命令执行需要一个makefile文件，以告诉make命令需要如何去编译和链接程序。
如果工程没有被编译过，所有的c文件都要编译并被链接。 如果某几个c文件被修改，那么只编译被修改的c文件，并链接目标程序。 如果工程的头文件被修改了，那么需要编译引用了这几个头文件的c文件，并链接目标程序 target... : prerequisites... command ... ... target也就是一个目标文件，可以是object file,也可以是执行文件。还可以是一个label。prerequisites就是要生成target所需要的文件或是目标。command就是make需要执行的命令。target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。如果prerequisites中有一个以上的文件比target文件要新，那么command所定义的命令就会被执行。
问题 1 # 操作系统镜像文件ucore.img是如何一步一步生成的?(需要比较详细地解释Makefile中每 一条相关命令和命令参数的含义,以及说明命令导致的结果)
ucore.img # makefile中生成ucore.img的代码为：
UCOREIMG := $(call totarget,ucore.img) $(UCOREIMG): $(kernel) $(bootblock) $(V)dd if=/dev/zero of=$@ count=10000 $(V)dd if=$(bootblock) of=$@ conv=notrunc $(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc $(call create_target,ucore.img) 将ucore.img传入totarget表达式调用call函数结果赋值给变量UCOREIMG，UCOREIMG作为target，其依赖于两个文件，一个是kernel，一个是bootblock。接下来给出make需要执行的命令。首先从/dev/zero中读了10000*512块的空字节，生成空文件，接着将bootlock中的内容拷贝到目标文件，然后从输文件的512字节后继续写入kernel的内容。makefile的第六行V := @将@赋值给变量V，所以$(V)代指@,表示命令不回显。conv=notrunc代表不截断输出文件，count=n’ 代表从输入文件中拷贝n个大小为ibs byte的块，ibs默认为512字节。seek=n代表在拷贝前输出文件时跳过n 个‘obs’-byte的块。obs默认为512字节。所以seek=1代表跳过输出文件的512个字节。
kenel：
kernel = $(call totarget,kernel) $(kernel): tools/kernel.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe2/</guid><description>exe2 # 使用 qemu 执行并调试 lab1 中的软件。
为了更加简易地对 gdb 进行调试，我们应该安装 peda。但是我发现这个内核调试的版本并不能显示颜色，很多乱码，所以并没有什么卵用。
STEP-1 # 从 CPU 加电后执行的第一条指令开始，单步跟踪 BIOS 的执行
可以在 Makefile 的第 219-222 行看到 make 列举的命令中，有一个叫做 debug 的命令：
debug: $(UCOREIMG) $(V)$(QEMU) -S -s -parallel stdio -hda $&amp;lt; -serial null &amp;amp; $(V)sleep 2 $(V)$(TERMINAL) -e &amp;#34;gdb -q -tui -x tools/gdbinit&amp;#34; 这三行命令分别执行：
使用 qemu 运行 32 位程序的虚拟机，这个变量值在 Makefile 的 27 行进行赋值，在我的 Ubuntu 中这个变量的最终赋值是 qemu-system-i386。要查看上面各个命令的含义使用 manual 即可：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe3/</guid><description>exe3 # 问题1 # 为何开启 A20,以及如何开启 A20
为了与早期的pc机兼容，物理地址线20(实模式)置于低位不能使用。所以超过1MB的地址，默认就会返回到地址0。寻址空间只有1MB。
开启A20：
seta20.1: inb $0x64, %al # Wait for not busy(8042 input buffer empty). testb $0x2, %al jnz seta20.1 movb $0xd1, %al # 0xd1 -&amp;gt; port 0x64 outb %al, $0x64 # 0xd1 means: write data to 8042&amp;#39;s P2 port 从0x64端口读入一个字节的数据到al中，如果a1第二位不为0，则跳转到seta20.1接着执行检查a1的第二位是不是0。将0xd1写入到al中，再将al中的数据写入到端口0x64中。
seta20.2: inb $0x64, %al # Wait for not busy(8042 input buffer empty). testb $0x2, %al jnz seta20.2 movb $0xdf, %al # 0xdf -&amp;gt; port 0x60 outb %al, $0x60 # 0xdf = 11011111, means set P2&amp;#39;s A20 bit(the 1 bit) to 1 从0x64端口读入一个字节的数据到al中，如果a1第二位不为0，则跳转到seta20.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe4/</guid><description>exe4 # 分析 bootloader 加载 ELF 格式的 OS 的过程
bootmian.c # 让我们简单地翻译一下这个文件的注释：
磁盘内存布局：
这个程序是一个启动加载器 (bootloader)，它应该在磁盘的第一个扇区上； 紧接着的第二个扇区存储着内核的镜像，它必须是一个 ELF 格式的文件。 启动的流程：
当 CPU 启动时，它首先将 BIOS 加载进内存中，然后执行它； 然后 BIOS 会初始化中断周期，然后取出启动程序的第一个选区然后跳转到它； 如果启动加载器存储在第一个扇区，控制权就转移到了这个文件中的代码（具体是在 bootasm.S 这个文件中调用的 bootmain() 这个函数）； 当这个文件中的函数执行完毕之后，内核会被读入，控制权会被转移给内核。 问题一 # Boot loader 如何读取硬盘扇区的？
我们看文件中函数 readsect 的注释，就知道用来读取硬盘扇区的是这个函数，我们来逐行解释这个函数：
/* readsect - read a single sector at @secno into @dst */ static void readsect(void *dst, uint32_t secno) { // wait for disk to be ready waitdisk(); outb(0x1F2, 1); // count = 1 outb(0x1F3, secno &amp;amp; 0xFF); outb(0x1F4, (secno &amp;gt;&amp;gt; 8) &amp;amp; 0xFF); outb(0x1F5, (secno &amp;gt;&amp;gt; 16) &amp;amp; 0xFF); outb(0x1F6, ((secno &amp;gt;&amp;gt; 24) &amp;amp; 0xF) | 0xE0); outb(0x1F7, 0x20); // cmd 0x20 - read sectors // wait for disk to be ready waitdisk(); // read a sector insl(0x1F0, dst, SECTSIZE / 4); } 看文件前的注释可知，函数两个参数的含义：dst 是目标句柄，secno 是扇区标示； 根据参考资料，后面的几行是通过 24-bit LBA 的方式读取磁盘（下面进行详细解析）； 后面的 insl 函数则是读取四个字节到 dst 这个句柄中； 那么 outb 那几行的具体原理是什么呢，首先我们在 Linux manual 上找到了函数原型：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe5/</guid><description>exe5 # 程序思路：函数kern/debug/kdebug.c::print_stackframe的注释写的很清楚了，先调用read_ebp(),read_eip()读出 ebp 和 eip 的指并打印出来。然后输出四个参数的值，由 ebp 开始向上找两位所保存的值是第一个参数，以此类推。然后找到下一个函数栈的 eip 和 ebp,下一个函数的 eip 就是压入栈的返回地址，也就是当前 ebp 向上找一位所保存的值，下一个函数的 ebp 就是当前 ebp 保存的地址所指向的地方。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe6/</guid><description>exe6 # 写在前面： # 阅读源码时，发现了一个之前没有遇到过的 c 语言语法：
struct struct_name { unsigned field1: 16; unsigned field2: 16; }; 这个结构声明表示声明了一个名为 struct_name，同时有 field1、field2 这两个 16 位字段的结构。（同时发现 64 位计算器的结构大小一定是 4 个字节的整数倍，不足则向上 padding）
问题一 # 中断描述表（保护模式下的中断向量表）中，一个表项占多少个字节？其中哪几位代表中断处理代码的入口？
中断描述表定义在 kern/trap/trap.c 这个文件中：
/* * * Interrupt descriptor table: * * Must be built at run time because shifted function addresses can&amp;#39;t * be represented in relocation records. * */ static struct gatedesc idt[256] = {{0}}; 其中 gatedesc 这个结构定义在 kern/mm/mmu.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/personal_summary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/personal_summary/</guid><description>@石博：
遇到的首要问题就是读不懂 linux 命令与汇编，感谢 bing.com，为什么不感谢 google 呢，因为我翻不了墙啊，服务器太贵了租不起。然后就是读出来的 ebp 和 eip 值我当成了指针，直接当指针使用了，报错很清晰，改完程序就ok了，完结撒花。 @佘崧林：
熟悉了解了操作系统的底层中断机制 石博牛逼</description></item></channel></rss>