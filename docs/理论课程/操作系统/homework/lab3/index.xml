<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>lab3 on shesl-meow's note site</title><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab3/</link><description>Recent content in lab3 on shesl-meow's note site</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab3/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab3/exe0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab3/exe0/</guid><description>exe0 # 同 lab2：
导出 change：
$ git diff 7ca90137c09c54f5afa9b87a35a68d9f65ecef52 HEAD labcodes/lab2/ | sed &amp;#39;s/lab2/lab3/g&amp;#39; &amp;gt; lab3/exe0.patch 进行 merge：
$ git apply lab3/exe0.patch</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab3/exe1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab3/exe1/</guid><description>如果ucore的缺页服务例程在执行过程中访问内存,出现了页访问异常,请问硬件要做哪 些事情?
将产生页访问异常的线性地址存入 cr2 寄存器中 并且给出 错误码 error_code 说明是页访问异常的具体原因
error_code : the error code recorded in trapframe-&amp;gt;tf_err which is setted by x86 hardware
将其 存入 trapframe 中 tf_err 等到中断服务例程 调用页访问异常处理函数do_pgfault() 时 再判断 具体原因 若不在某个VMA的地址范围内 或 不满足正确的读写权限 则是非法访问 若在此范围 且 权限也正确 则 认为是 合法访问 只是没有建立虚实对应关系 应分配一页 并修改页表 完成 虚拟地址到 物理地址的映射 刷新 TLB.重新执行引发页访问异常的 那条指令.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab3/exe2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab3/exe2/</guid><description>exe2 # 代码 # _fifo_map_swappable # FIFA 算法需要将最近使用过的页链接在链表的头部。
看注释，这个函数是要将刚刚使用过的 page 放在链表的第二个元素。程序已经将链表和元素都选取出来了：
list_entry_t *head=(list_entry_t*) mm-&amp;gt;sm_priv; list_entry_t *entry=&amp;amp;(page-&amp;gt;pra_page_link); 因此我们只需要调用 list_entry_t 中的方法即可：
list_add(head, entry); _fifo_swap_out_victim # FIFA 算法需要将最长时间未使用过的页从链表的尾部去除。
看注释我们需要做的事情是删除尾部，并且用 ptr_page 这个参数指向被替换的页：
static int _fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick) { list_entry_t *head=(list_entry_t*) mm-&amp;gt;sm_priv; assert(head != NULL &amp;amp;&amp;amp; in_tick==0); list_entry_t *tail = head-&amp;gt;prev; // Select the victim assert(tail != head); // this isn&amp;#39;t a one-element-list *ptr_page = le2page(tail, pra_page_link); // (2) assign the value of *ptr_page to the addr of this page list_del(tail); // (1) unlink the earliest arrival page in front of pra_list_head qeueue assert(*ptr_page !</description></item></channel></rss>