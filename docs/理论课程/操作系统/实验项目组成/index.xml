<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>实验项目组成 on shesl-meow's note site</title><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E7%BB%84%E6%88%90/</link><description>Recent content in 实验项目组成 on shesl-meow's note site</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E7%BB%84%E6%88%90/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E7%BB%84%E6%88%90/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E7%BB%84%E6%88%90/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8/</guid><description>中断与异常 # 简述 # 中断引入的目的：
CPU 需要与外设进行交流。 因为 CPU 与外设存在显著的速度差异，如果使用轮询的方式则太浪费 CPU 资源了。 引入中断机制解决了上面两个问题，但是导致操作系统的理解更加困难。 在操作系统中，有三种特殊的中断事件：
由 CPU 外部设备引起的外部事件，简称中断 (interrupt) 比如：IO 中断、时钟中断、控制台中断。 因为它的产生与 CPU 的执行无关，我们也称它为异步中断。 把在 CPU 执行指令期间检测到不正常或非法的条件所引起的内部事件称作异常 (exception) 比如：除零错误、地址访问越界。 这类 CPU 内部事件导致的称谓同步中断，也称哪部中断 在程序中使用请求系统服务而引发，称作陷入中断 (trap interrupt)、也称软中断、系统调用。 处理中断的的流程大致如下：
CPU 收到中断 (8259A) 或者异常的事件时，它会暂定执行当前的程序或任务； CPU 通过 IDT（Interrupt Descriptor Table，存储着中断向量与中断服务例程的对应关系）查询处理中断的例程，IDT 是中断处理的核心结构； 执行例程完成后跳回被打断的程序。 中断描述符表 IDT # IDT 中的中断描述符可以分为三种：
Task Gate、Interrupt Gate、Trap Gate 下面是这三种中断描述符的结构：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E7%BB%84%E6%88%90/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%88%86%E6%AE%B5%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E7%BB%84%E6%88%90/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%88%86%E6%AE%B5%E6%A8%A1%E5%BC%8F/</guid><description>保护模式与分段模式 # 简介 # 为什么要有保护模式？
Intel 80386 只有在保护模式下，才可以提供更好的保护机制和更大的寻址空间； 没有保护机制，任何应用软件都可以任意地访问所有计算机资源； 许多操作系统功能（比如分页）都是建立在保护模式上设计的； 实模式 # bootloader 在 BIOS 之后开始运行时，PC 处于 16 位实模式运行状态。
它主要有以下特点：
实模式下，上层软件可以访问的物理内存空间不超过 1MB；
实模式将整个物理内存看成分段的区域，每一个指针都是指向实际的物理内存。
通过修改 A20 地址线可以完成从实模式到保护模式的切换。
保护模式 # 概念 # GDT 与 LDT：
保护模式下，有两个段表：GDT（Global Descriptor Table）和 LDT（Local Descriptor Table） 段描述符：GDT 表的内容；
为了兼容各个不同版本的 CPU，它的形式比较复杂； 它最重要的字段是 segment base 与 segment limit； 也称之为段，此处的段与 ELF 源程序中的 .</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E7%BB%84%E6%88%90/%E5%88%86%E9%A1%B5%E6%8A%80%E6%9C%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E7%BB%84%E6%88%90/%E5%88%86%E9%A1%B5%E6%8A%80%E6%9C%AF/</guid><description>参考：
https://stackoverflow.com/questions/29945171/difference-between-page-table-and-page-directory 分页技术 # 设计 # 下面一张图可以展示分页技术的层级设计过程：
概念 # 页 (Page)：
在进程的逻辑地址中，一段连续地址的集合。 页的大小一般提供三种规格：4K、2M、4M Frame：
在内存的物理地址中，一段连续地址的集合。 一个 Page 与一个对应的 Frame 对应，Frame 的大小与 Page 也是相同的。 页表 (Page Table) 与页目录 (Page Directory)：
页表：是一个有 1024 个 32-bit 元素的列表，每一个元素都指向一个真实的物理地址；
如果页表大小为 4K，我们只能表示 1024 * 4K = 2^22，22-bit 的逻辑地址。而我们需要 4G = 32-bit 的逻辑地址。因此如果只有一个页表，我们无法表示整个逻辑地址空间。
页目录：因为页表无法映射所有逻辑地址而产生的二级目录，它也是一个有 1024 个 32-bit 元素的列表，每一个元素都指向一个页表的地址；
页表和页目录项一起工作，我们即可以映射整个 4G = 32-bit 的逻辑地址。</description></item></channel></rss>