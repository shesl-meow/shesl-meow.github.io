<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux源码阅读 on shesl-meow's note site</title><link>http://shesl-meow.github.io/docs/%E9%A1%B9%E7%9B%AE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link><description>Recent content in Linux源码阅读 on shesl-meow's note site</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="http://shesl-meow.github.io/docs/%E9%A1%B9%E7%9B%AE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>http://shesl-meow.github.io/docs/%E9%A1%B9%E7%9B%AE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/elfformat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E9%A1%B9%E7%9B%AE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/elfformat/</guid><description>参考：
https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/ ELF Format # ELF is the abbreviation for Executable and Linkable Format and defines the structure for binaries, libraries, and core files.
The formal specification allows the operating system to interpreter its underlying machine instructions correctly. ELF files are typically the output of a compiler or linker and are a binary format. With the right tools, such file can be analyzed and better understood.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E9%A1%B9%E7%9B%AE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/elfsections/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E9%A1%B9%E7%9B%AE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/elfsections/</guid><description>参考：
https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/
https://lief.quarkslab.com/doc/stable/tutorials/05_elf_infect_plt_got.html
http://blog.k3170makan.com/2018/10/introduction-to-elf-format-part-v.html
http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html
https://stackoverflow.com/questions/34966097/what-functions-does-gcc-add-to-the-linux-elf
Elf Sections # 常见节 # 我们分析以下几个比较重要的节头：
.text：该段包含的是可执行代码，该段中的数据只可读不可写，该段中的数据只加载一次。 .data：已被初始化的数据，可读可写。 .rodata：已被初始化的数据，只可读不可写。 .bss：未初始化数据，可读可写。 链接相关 # 动态链接过程 # 此处详解以下动态链接过程中最重要的部分，libc 函数的链接过程。libc 中的函数，若使用动态链接，则关键的两个表项时 .got 表与 .plt 表，这种绑定方式又称为延迟绑定。
比如我们在某一个函数中进行了 puts 系统调用，在调用之前表结构大致如下：
.text sections .plt table .got table +--------------+ +---------------+ +------------------+ | [my_func] | | [puts@plt] | | [puts@got] | | | | | | | | jmp 0x400480 ----&amp;gt;| jmp 0x601028 ---&amp;gt;| 0x601028:0x400486--+ | | | | | | | | .</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E9%A1%B9%E7%9B%AE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/glibcheap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E9%A1%B9%E7%9B%AE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/glibcheap/</guid><description>参考：长亭科技堆的概念
堆基础 # 堆的一些特点：
堆是可以根据运行时的需要进行动态分配和释放的内存，大小可变； 堆的实现重点关注内存块的组织和管理方式（尤其时空闲的内存块）： 如何提高分配和释放的时间效率； 如何降低碎片化，提高空间利用率； 常见堆的实现：
dlmalloc：通用分配器； ptmalloc2：glibc 函数，基于 dlmalloc，支持多线程； jemalloc：FreeBSD、FireFox、Android；内存占用更高，但是在多核多线程下的表现也最为优异。 tcmalloc：Google Chrome、Golang；针对多核情况有所优化，性能有所提高，但是内存占用稍高，大内存分配容易出现 CPU 飙升。 libumem：Solaris； Windows 10：segment heap。 相关资料：
https://www.cyningsun.com/07-07-2018/memory-allocator-contrasts.html#%E7%B3%BB%E7%BB%9F%E5%90%91%E7%9C%8Bptmalloc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86 glibc heap # 相关结构 # 下面介绍管理 glic 堆的各种数据结构：
arena # arena 指的是内存区域本身，并非一个结构：
主线程的堆由 sbrk 创建，称为 main arena； 其他线程的堆由 mmap 创建，称为 per thread arena； arena 的数量受 CPU 核数的限制：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E9%A1%B9%E7%9B%AE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/glibctcache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E9%A1%B9%E7%9B%AE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/glibctcache/</guid><description>参考资料：
http://p4nda.top/2018/03/20/tcache/ https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/ Tcache # 介绍 # tcache，全称是 thread local caching，是 libc 2.26 版本中新增加的内存管理机制，属于一种用于加速 malloc 分配的缓存机制。
它由 64 个链表组成，处理逻辑位于 malloc 函数和 free 函数中，优先级较高，会先于全部的 bin 来处理，当缓存链表装满时，分配方式就与之前版本的 malloc 相同。
源码分析 # tcache_entry &amp;amp;&amp;amp; tcache_perthread_struct # 在 tcache 中新增了两个数据结构，它们的定义源码如下：
/* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache. */ typedef struct tcache_entry { struct tcache_entry *next; /* This field exists to detect double frees.</description></item></channel></rss>