<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>算法竞赛入门经典 on shesl-meow's note site</title><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/</link><description>Recent content in 算法竞赛入门经典 on shesl-meow's note site</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/1.%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/1.%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE/</guid><description>基础题目 # 数学相关 # Cantor 数表：将 Georg Cantor 用于证明有理数是可穷举的数表，拟合为一个列表（第一项是 1/1，第二项是 1/2，接着是 2/1、3/1、2/2、1/3&amp;hellip;）。
求 Cantor 数表的第 n 项。
第 i 条线上有 i 个数。
果园里的树：树排列成矩阵，它们的 x/y 坐标均是 1-99 的整数。输入若干个三角形，依次统计每个三角形内部和边界上总共有多少棵树。
三角形的有向面积：$$\begin{pmatrix} x_0 &amp;amp; y_0 &amp;amp; 1 \ x_1 &amp;amp; y_1 &amp;amp; 1 \ x_2 &amp;amp; y_2 &amp;amp; 1 \end{pmatrix}$$
多少块土地：你有一块椭圆形的地，在边界上选取 n 个点，两两连接得到 $$\displaystyle \frac{n(n-1)}{2}$$ 条线段，它们最多能把土地分成多少个部分。
欧拉公式：V - E + F = 2；
图相关 # 岛屿问题</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/2.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%9D%E6%AD%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/2.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%9D%E6%AD%A5/</guid><description>动态规划初步 # 问题：数字三角形 # 有一个由非负整数组成的三角形，第一行只有一个数字，出了最下面一行之外的每一个数字的左下方和右下方都有一个数字。
如果从第一行开始，每次可以向左下或右下走一格，怎样的走法能使路径节点和最大。
如果我们把每个格子按照行列编号，然后定义 d(i, j) 为从格子 (i, j) 出发时能得到的最大和，于是原问题即求解 d(1, 1)，可以得到状态转移方程：
$d(i, j) = a(i, j) + max(d(i+1, j), d(i+1, j+1))$ 最优子结构（optimal substructure）：全局最优解包含局部最优解，如果局部不是最优的，那么全局肯定不是最优的。
除了动态规划之外，这个问题还可以使用记忆化 (memoization) 的思想。
DAG 上的动态规划 # 最长路径问题 # 嵌套矩形：有 n 个长宽分别为 $(a_i, b_i)$ 的矩形，如果对于两个矩形 X(a, b), Y(c, d)，如果 a&amp;lt;c, b&amp;lt;d 或者 a&amp;lt;d, b&amp;lt;c，那么我们称 X 可以被 Y 嵌套。
给定任意多的矩形，求最长的嵌套序列，使得序列中的每个矩形都能嵌套在后一个中。
这个问题中的“嵌套”就是一个典型的二元关系，可以 DAG 来建模。
在这样一个嵌套关系的 DAG 中，如果设 d(i) 表示从节点 i 出发的最长路长度，边的集合设为 E，那么可以得到有状态转移方程：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/3.%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/3.%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%96%B9%E6%B3%95/</guid><description>数学概念与方法 # 数论初步 # 最大公因数算法 # 辗转相除法，或欧几里得算法（Euclid Algorithm）：
int gcd(int a, int b) { return (b == 0) ? a : gcd(b, a%b); } 值得一提的是，通过 gcd 可以计算出 lcm：
int lcm(int a, int b) { return a / gcd(a, b) * b; } 有一个细节是先除后乘可以避免整数溢出；
素数定理 # Eratosthenes 筛法：
int m = sqrt(n + 0.5); int c = 0; memset(vis, 0, sizeof(vis)); for (int i = 2; i &amp;lt;= m; i++) if (!</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/4.%E5%9B%BE%E8%AE%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%AE%97%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/4.%E5%9B%BE%E8%AE%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%AE%97%E6%B3%95/</guid><description>图论模型与算法 # 图的表示方法 # 本书中的图通过空间复杂度 $O(|V| + 3 * |E|)$ 表示（无向图的边需要通过两条有向边表示）：
first：长度为 $|V|$ 的数组，每个元素 x 表示从 x 出发的第一条边； u、v：长度为 $|E|$ 的数组，分别存储着边关联的两个节点； next：长度为 $|E|$ 的数组，边的邻接链表的下一条边； 树 # 无根树转化为有根树 # 转化代码：
void dfs(int u, int fa) { int d = G[u].size(); for (int i = 0; i &amp;lt; d; i++) { int v = G[u][i]; if (v != fa) dfs(v, p[v] = u); } } 表达式树 # 二叉树是表达式处理的常用工具，其中每个非叶子节点都表示一个运算符，它的左子树是这个运算符的第一个运算数，右子树则是这个运算符的第二个运算数。</description></item></channel></rss>