<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>5.应用层 on shesl-meow's note site</title><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/</link><description>Recent content in 5.应用层 on shesl-meow's note site</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/ftp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/ftp/</guid><description>学习网址：
https://www.cnblogs.com/luoxn28/p/5585458.html https://en.wikipedia.org/wiki/File_Transfer_Protocol 文件传输协议 FTP # 文件传输协议有基于 TCP 的FTP和基于UDP 的简单文件传输协议 TFTP，它们都是文件共享协议中的一大类，即复制整个文件，其特点是：若要存取一个文件，就必须先获得一个本地的文件副本。如果要修改文件，只能对文件的副本进行修改，然后再将修改后的文件传回到原节点。
基本工作原理 # FTP 使用客户端-服务器模型，一个 FTP 服务器进程可以为多个客户提供服务。
FTP 有两大组成部分：
一个主进程，负责接受新的请求，其工作步骤如下： 打开众所周知的 21 端口，使客户进行可以连接上； 等待客户进程发送连接请求； 启动从属进程处理客户进程发送的连接请求，从属进程处理完请求后结束，从属进程在运行期间可能根据需要可创建其他一些子进程； 回到等待状态，继续接受其他客户进程发起的请求，主进程与从属进程的处理是并发进行的。 若干个从属进程，负责处理单个请求。 FTP 控制连接在整个会话期间都保持打开，只用来发送连接/传送请求。当客户进程向服务器发送连接请求时，寻找连接服务器进程的熟知端口 21，同时还要告诉服务器进程自己的另一个端口号码，用于建立数据传送连接。接着，服务器进程用自己传送数据的熟知端口 20 与客户进程所提供的端口号码建立数据传送连接，FTP使用了2个不同的端口号，所以数据连接和控制连接不会混乱。
Communication and data transfer # Working Mode # FTP may run in active or passive mode, which determines how the data connection is established:
In active mode, the client starts listening for incoming data connections from the server on port M.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/ntp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/ntp/</guid><description>学习地址：
https://www.tecmint.com/synchronize-time-with-ntp-in-linux/ NTP # Protocol # The Network Time Protocol (NTP) is a protocol used to synchronize computer system clock automatically over a networks. The machine can have the system clock use Coordinated Universal Time (UTC) rather than local time.
ntpdate # The most common method to sync system time over a network in Linux desktops or servers is by executing the ntpdate command which can set your system time from an NTP time server.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/smtp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/smtp/</guid><description>学习地址：
https://blog.csdn.net/kerry0071/article/details/28604267 http://coolnull.com/3055.html SMTP 协议 # 简介 # SMTP 称为简单邮件传输协议（Simple Mail Transfer Protocal），目标是向用户提供高效、可靠的邮件传输。它的一个重要特点是它能够在传送中接力传送邮件，即邮件可以通过不同网络上的主机接力式传送。
通常它工作在两种情况下：
邮件从客户机传输到服务器； 从某一个服务器传输到另一个服务器。 SMTP 是一个请求/响应协议，它监听 25 号端口，用于接收用户的 Mail 请求，并与远端 Mail 服务器建立 SMTP 连接。
工作机制 # 发送 SMTP 在接收到用户的邮件请求后，判断此邮件是否为本地邮件，若是直接投送到用户的邮箱，否则向 DNS 查询远端邮件服务器的 MX 记录，并建立与远端接收 SMTP 之间的一个双向传送通道，此后 SMTP 命令由发送 SMTP 发出，由接收 SMTP 接收，而应答则反方向传送。一旦传送通道建立，SMTP 发送者发送 MAIL 命令指明邮件发送者。
如果 SMTP 接收者可以接收邮件则返回 OK 应答。SMTP 发送者再发出 RCPT 命令确认邮件是否接收到。如果 SMTP 接收者接收，则返回 OK 应答；如果不能接收到，则发出拒绝接收应答（但不中止整个邮件操作），双方将如此反复多次。当接收者收到全部邮件后会接收到特别的序列，入伏哦接收者成功处理了邮件，则返回 OK 应答。
连接和发送过程 # 建立 TCP 连接。 客户端发送 HELO 命令以标识发件人自己的身份。 客户端发送 MAIL 命令，服务器端以 OK 作为响应，表示准备接收。 客户端发送 RCPT 命令以标识该邮件的计划接收人，可以有多个 RECPT 行，服务器端则表示是否愿意为接收人接收邮件。 客户端发送 DATA 命令，发送邮件，最后以只含有 .</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/socket/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/socket/</guid><description>学习网址：
https://www.geeksforgeeks.org/socket-programming-cc/ Socket Programming # 什么是 socket 编程？
Socket programming is a way of connecting two nodes on a network to communicate with each other. One socket(node) listens on a particular port at an IP, while other socket reaches out to the other to form a connection. Server forms the listener socket while client reaches out to the server.
服务端 # 示例代码 # // Server side C/C++ program to demonstrate Socket programming #include &amp;lt;unistd.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/uwsgi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/uwsgi/</guid><description>在搭建 NKCTF 网站的时候学习到的有关 UWSGI 的知识
WSGI协议 # 几个概念：
WSGI：Web Server Gateway Interface。WSGI 不是服务器，python 模块，框架，API 或者任何软件，只是一种规范，描述 web server 如何与 web application 通信的规范。 WSGI server 负责从客户端接收请求，将 request 转发给 application，将 application 返回的 response 返回给客户端； WSGI application 接收由 server 转发的 request，处理请求，并将处理结果返回给 server。application 中可以包括多个栈式的中间件(middlewares)，这些中间件需要同时实现 server 与 application，因此可以在 WSGI 服务器与 WSGI 应用之间起调节作用：对服务器来说，中间件扮演应用程序，对应用程序来说，中间件扮演服务器。 **uwsgi：**与 WSGI 一样是一种通信协议，是 uWSGI 服务器的独占协议，用于定义传输信息的类型，每一个 uwsgi packet 前 4byte 为传输信息类型的描述，与WSGI协议是两种东西，据说该协议是 fcgi 协议的10倍快。（快速通用网关接口 → Fast Common Gateway Interface／FastCGI）是一种让交互程序与Web服务器通信的协议） **uWSGI：**是一个 web 服务器，实现了 WSGI 协议、uwsgi 协议、http 协议等。 WSGI协议的实现 # 以 Django 为例，分析一下 WSGI 协议的具体实现过程：</description></item></channel></rss>