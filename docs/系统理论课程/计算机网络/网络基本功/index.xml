<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>网络基本功 on shesl-meow's note site</title><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/</link><description>Recent content in 网络基本功 on shesl-meow's note site</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/1.%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/1.%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/</guid><description>学习网址：https://www.kancloud.cn/wizardforcel/network-basic/135483
网络传输 # 传输流程 # 下图显示了一个网络服务器向客户端传送数据的完整过程：
传送的数据是网络服务器的HTML页面。
应用层协议 HTTP 报文头添加到 HTML 数据之前生成报文。报文头信息包括：服务器所使用的HTTP版本，以及表明它包含发给网络客户端信息的状态编码。
HTTP 应用层协议将 HTML 格式的网页数据发送给传输层。TCP 传输层用于管理网络服务器和客户端之间的 TCP 会话。
IP 信息添加到 TCP 信息之前。IP 指定适当的源和目的 IP 地址。这些信息就构成了 IP 报文。
以太网协议添加到IP报文的两端之后，就形成了数据链路帧。上述帧发送至通向网络客户端的路径上的最近一个路由器。路由器移除以太网信息，观察IP报文，判定最佳路径，将报文插入一个新的帧，并发送至目标路径上下一个相邻路由器。每一个路由器在转发之前都移除并添加新的数据链路层信息。
数据通过互联网络传输，互联网络包含媒介和中间设备。
客户端接收到包含数据的数据链路帧，处理各层协议头，之后以添加时相反的顺序移除协议头。首先处理并移除以太网信息 → 之后是 IP 协议信息 → 接下来 TCP 信息 → 最后是 HTTP 信息。
之后，将网页信息传递给客户端网页浏览器软件。
传输概念 # 数据封装 # 消息要在网络中传输，必须对它进行编码，以特定的格式进行封装，同时需要适当地封装以足够的控制和地址信息，以使它能够从发送方移动到接收方。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/2.%E4%BA%A4%E6%8D%A2%E6%9C%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/2.%E4%BA%A4%E6%8D%A2%E6%9C%BA/</guid><description>学习网址：https://www.kancloud.cn/wizardforcel/network-basic/135484
交换机 # 帧转发技术
交换概念 # 交换指基于以下两条准则做出决定的设备：
进入（ingress）端口 目的地址 交换机通过以太网帧中的源 MAC 地址与目的 MAC 地址，从源设备接收到帧并快速发往目的地址。
术语 ingress 用于描述帧通过特定端口进入设备，egress 用于描述帧通过特定端口离开设备。
LAN（Local Area Network，局域网）交换机维护一张表，通过这张表决定如何转发数据流。LAN 交换机唯一智能部分是利用这张表基于消息的进入端口和目的地址来转发。
一个 LAN 交换机中只有一张定义了地址和端口的主交换表；因此，无论进入端口如何，同一目的地址的消息永远从同一出口离开。
MAC 地址表动态更新 # 一个交换机要知道使用哪一个端口进行传送帧，首先必须知道各个端口有哪些设备。
交换机使用 MAC 表的方式完成，它建立起一张 MAC 地址表，内容可寻址寄存表（CAM）。交换机将连接到它的端口的设备的 MAC 地址记录到 MAC 表中，然后利用表中信息将帧发送至输出端口设备，该端口已指定给该设备。
交换机操作模式的一句简单的话是：交换机学习“源地址”，基于“目的地址”转发。以下步骤描述了更新 MAC 地址表的方法：
交换机在 port1 接收到来自 PC1 的帧。 交换机检查源 MAC 地址并与 MAC 地址表相比较： 如果地址不在表中，则将交换机在 MAC 地址表中将 PC 1 的源 MAC 地址关联到进入端口（port 1） 如果地址已经存在该表中，则交换机重置老化计时器。通常一个表项会保持 5 分钟。 交换机记录源地址信息后，检查目的地址：如果目的 MAC 地址不在表项中或如果它是一个广播 MAC 地址，则交换机把该帧泛洪（flood）至除了进入端口以外的所有端口。（如果在表项中则可以直接正常通信） 目标设备（PC 3）返回目的地址为 PC 1 的单播帧。 交换机地址表中输入 PC 3 的源 MAC 地址以及进入的端口号。 交换机现在可以在源 PC 1 和目标设备 PC 3 之间传送帧而无需泛洪。 交换机的转发方式 # 存储转发交换 Store-and-Forward # 运行在存储转发模式下的交换机在发送信息前要把整帧数据读入内存并检查其正确性。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/3.vlan%E4%B8%8Etrunk/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/3.vlan%E4%B8%8Etrunk/</guid><description>学习地址：
https://community.emc.com/message/834012#834012 VLAN # 概念 # 虚拟局域网（VLAN）是一组逻辑上的设备和用户，这些设备和用户并不受物理位置的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样，由此得名虚拟局域网。
VLAN 是一种比较新的技术，工作在 OSI 参考模型的第 2 层和第 3 层，一个 VLAN 就是一个广播域，VLAN 之间的通信是通过第3层的路由器来完成的。
部署结构 # 下图显示了一个常规的部署，左边这张图节点连接到交换机，交换机连接到路由器。所有的节点都位于同一 IP 网络，因为他们都连接到路由器同一接口。
另一种常用的拓扑结构是两个交换机被一个路由器分离开来：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/4.%E8%B7%AF%E7%94%B1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/4.%E8%B7%AF%E7%94%B1/</guid><description>学习地址：
https://community.emc.com/message/835157#835157 路由器 # 以太网交换机工作在第二层即数据链路层，用于在同一网络内部转发以太网帧。
但是，当源和目的IP地址位于不同网络时，以太网帧必须发送给路由器。路由器负责在不同网络间传输报文，通过路由表来决定最佳转发路径。当主机将报文发送至不同IP地址时，由于主机无法直接与本地网络以外的设备通信，报文被转发至默认网关。默认网关就是数据流从本地网络路由至远端设备的目的地。它通常用来连接本地网与公共网。
报文的转发过程 # 路由器在一个接口接收报文并将它从另一个接口转发出去。路由器主要执行以下三个步骤：
将第二层的帧头和帧尾移除，解析出第三层报文。 检查 IP 报文的目的 IP 地址，在路由表中查找最佳路由。 如果路由器找到一条最佳路径，则将三层报文封装到新的二层帧中，并将帧转发到输出端口。 如下图所示：
过程详解 # 发送报文 # PC 1 发送报文给PC 2 时：
首先必须确定目的 IPv4 地址是否位于同一网络。 PC 1 通过将自己的 IPv4 地址与子网掩码做与操作，来判断 PC 1 所属的网段。 接下来，PC 1 对目的 IPv4 地址与 PC 1 的子网掩码做同样的与操作。 如果目的网络地址与PC 1网段相同，则PC 1不使用默认网关，而是在 ARP 缓存中查找目的 IPv4 地址的设备MAC地址。如果MAC地址不在缓存中，则 PC 1 产生一个 ARP 请求来获取地址并将报文发给目的地址。 如果目的网络地址位于另一网络，则PC 1将报文转发至默认网关。 要确定默认网关的 MAC 地址，PC 1 在它的 ARP 表中查找默认网关的 IPv4 地址以及相应的 MAC 地址。 如果 ARP 表中没有默认网关的对应表项，则 PC 1 发送 ARP 请求。路由器 R1 回复 ARP 响应。之后 PC 1 将报文转发至默认网关的 MAC 地址，即路由器 R1 的 Fa0/0 接口。 路由器转发 # R1 从 PC 1 接收到以太网帧后执行以下步骤：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/8.tcp%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/8.tcp%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</guid><description>学习网址：
https://www.kancloud.cn/wizardforcel/network-basic/135490 TCP 滑动窗口 # 介绍 # 将 TCP 与 UDP 这样的简单传输协议区分开来的根据是它们传输数据的质量。主要考虑的是以下两个关键功能：
可靠性：保证数据确实到达目的地。如果未到达，能够发现并重传。 数据流控：管理数据的发送速率，以使接收设备不致于过载。 要完成这些任务，整个协议操作是围绕滑动窗口确认机制来进行的。因此，理解了滑动窗口，也就是理解了TCP。
面向流的滑动窗口确认机制 # TCP将独立的字节数据当作流来处理。一次发送一个字节并接收一次确认显然是不可行的。即使重叠传输（即不等待确认就发送下一个数据），速度也还是会非常缓慢。
TCP 消息确认机制如下图所示，首先，每一条消息都有一个识别编号，每一条消息都能够被独立地确认，因此同一时刻可以发送多条信息。设备 B 定期发送给 A 一条发送限制参数，制约设备 A 一次能发送的消息最大数量。设备 B 可以对该参数进行调整，以控制设备 A 的数据流。
为了提高速度，TCP 并没有按照字节单个发送而是将数据流划分为片段。片段内所有字节都是一起发送和接收的，因此也是一起确认的。确认机制没有采用 message ID 字段，而是使用的片段内最后一个字节的 sequence number。因此一次可以处理不同的字节数，这一数量即为片段内的 sequence number。
发送方和接收方必须就它们将要为数据流中的字节指定的 sequence number 达成一致。这一过程称为同步，在TCP连接建立时完成。
我们可以将 TCP buffer 中的数据分为以下的四类，并把他们看作一个时间轴，如下图所示：
已发送已确认：数据流中最早的字节已经发送并得到确认。这些数据是站在发送设备的角度来看的。 已发送但尚未确认：已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。 未发送而接收方已Ready：设备尚未将数据发出，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。 未发送而接收方Not Ready：由于接收方 not ready，还不允许将这部分数据发出。 实际上，收发双方各自维护一套独立的变量，来监控发送和接收的数据流落在哪一类。
发送窗口与可用窗口 # 概念 # 整个过程关键的操作在于接收方允许发送方一次能容纳的未确认的字节数。这称为发送窗口，有时也称为窗口。该窗口决定了发送方允许传送的字节数，也是 2 类和 3 类的字节数之和。</description></item></channel></rss>