<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Objective-C&amp;SDK on shesl-meow's note site</title><link>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/</link><description>Recent content in Objective-C&amp;SDK on shesl-meow's note site</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/1.%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/1.%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid><description>基本语法 # 基本类型 # 布尔型 # 布尔型主要有两种使用方式：
BOOL v1 = YES; // 常用的布尔型使用方式，两个取值分别是 YES, NO bool v2 = false; // 两个取值分别是 true, false 上面的两种方式不是等价的，前者是通过下面的方式实现的：
#if (TARGET_OS_IPHONE &amp;amp;&amp;amp; __LP64__) || TARGET_OS_WATCH #define OBJC_BOOL_IS_BOOL 1 typedef bool BOOL; #else #define OBJC_BOOL_IS_CHAR 1 typedef unsigned char BOOL; #endif 整数型 # 除了 C 中实现的整数和无符号整数，OC 同样也实现了两个整数类型：
NSInteger v1 = 8; NSUInteger v2 = 9; // 无符号和有符号都是：32 位类型为 int, 64 位类型为 long 同样也可以看看他们的实现方式：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/10.%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E5%85%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/10.%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E5%85%B8/</guid><description>参考：https://github.com/ming1016/study/wiki/iOS基础集合类
数组与字典 # NSArray/NSMutableArray # 基本使用 # 定义、初始化一个 NSArray，可以用以下的方式：
// NSArray: @[] NSArray *instructors = @[ @&amp;#34;Joe&amp;#34;, @&amp;#34;Tim&amp;#34;, @&amp;#34;Jim&amp;#34;, @&amp;#34;Tom&amp;#34;, @&amp;#34;Mark&amp;#34; ]; // NSArray: arrayWithObjects/initWithObjects NSArray *instructors = [NSArray arrayWithObjects:@&amp;#34;Joe&amp;#34;, @&amp;#34;Tim&amp;#34;, @&amp;#34;Jim&amp;#34;, @&amp;#34;Tom&amp;#34;, @&amp;#34;Mark&amp;#34;, nil]; NSArray *instructors = [[NSArray alloc] initWithObjects:@&amp;#34;Joe&amp;#34;, @&amp;#34;Tim&amp;#34;, @&amp;#34;Jim&amp;#34;, @&amp;#34;Tom&amp;#34;, @&amp;#34;Mark&amp;#34;, nil]; 定义、初始化一个 NSMutableArray，可以用以下的方式：
// NSMutableArray: copy from NSArray NSArray *instructors = @[ @&amp;#34;Joe&amp;#34;, @&amp;#34;Tim&amp;#34;, @&amp;#34;Jim&amp;#34;, @&amp;#34;Tom&amp;#34;, @&amp;#34;Mark&amp;#34; ]; NSMutableArray *mInstructors = [instructors mutableCopy]; // NSMutableArray: array with array NSMutableArray *mInstructors = [NSMutableArray arrayWithArray:@[ @&amp;#34;Joe&amp;#34;, @&amp;#34;Tim&amp;#34;, @&amp;#34;Jim&amp;#34;, @&amp;#34;Tom&amp;#34;, @&amp;#34;Mark&amp;#34; ] ]; // NSMutableArray: 下面三种初始化空Array的方式是等价的，建议的方法是第一种 NSMutableArray *mEmpty = [[NSMutableArray alloc] init]; NSMutableArray *mEmpty = [NSMutableArray new]; NSMutableArray *mEmpty = [NSMutableArray array]; 另外还有常用的函数 removeObject: / removeObject:atIndex: / insertObject: / insertObject:atIndex: / replaceObjectAtIndex:withObject: 等，不举例了。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/11.runloop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/11.runloop/</guid><description> 参考：
https://stackoverflow.com/questions/7222449/nsdefaultrunloopmode-vs-nsrunloopcommonmodes https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runloop.html https://blog.ibireme.com/2015/05/18/runloop/ 官方文档：
https://developer.apple.com/documentation/foundation/nsrunloop?language=objc</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/2.%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/2.%E7%B1%BB/</guid><description>类 # 概述 # Objective-C 主要有以下三种文件类型：
扩展名 内容类型 .h 头文件。头文件包含类，类型，函数和常数的声明。 .m 源代码文件。这是典型的源代码文件扩展名，可以包含 Objective-C 和 C 代码。 .mm 源代码文件。带有这种扩展名的源代码文件，还可以包含 C++ 代码。
仅在你的 Objective-C 代码中确实需要使用 C++ 类或者特性的时候才用这种扩展名。 新建类文件，在 xcode 中使用快捷键 command + N。可见它创建了一下的两个文件：
// Person.h #import &amp;lt;Foundation/Foundation.h&amp;gt; NS_ASSUME_NONNULL_BEGIN @interface Person : NSObject @end NS_ASSUME_NONNULL_END // Person.m #import &amp;#34;Person.h&amp;#34; @implementation Person @end 下面由这两个文件，展开介绍一下 OC 的内容：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/3.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/3.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid><description>内存管理 # 概述 # 三种主要的内存管理方式：
显示内存释放：C 中的 free、C++ 中的 delete； 基于引用计数：C++ 中的智能指针（smart pointer），Objective-C 中使用的方式； 垃圾回收机制：Java、JavaScript、C#； OS X (macOS) 过去支持垃圾回收，现在已经废除了。iOS 则一直不支持垃圾回收。
引用计数 # iOS 支持 MRC (Mannul Reference Counting) 手动引用计数与 ARC (Automatic Reference Counting) 自动引用计数两种管理机制。
MRC # 手动引用计数主要有以下的几个相关的操作：
生成（分配一个对象，并且引用计数置为 1）：alloc、cpoy、new； 持有（将一个对象的引用计数自增 1）：retain； 释放（将一个对象的引用计数自减 1）：release、autorelease； 废弃（释放一个对象，引用计数降为 0 应该废弃）：dealloc； 显示（显示一个对象的引用计数）：retainCount。 为什么要引入 autorelease？
在初始化一个对象的时候自动指明，如果对象的引用计数降为 0，则自动释放这个对象。
比如在未使用 autorelease 的时候一个代码可能是这么写的：
- (People *)createPeople { People *people = [[People alloc] init]; people.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/4.%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/4.%E5%9D%97/</guid><description>块 # 概念 # 什么是 Blocks？
Blocks 是对 C 语言的扩展，也就是带有局部变量的匿名函数； 它的好处是是使得 Objective-C 可以像 JavaScript 一样进行函数式编程； Blocks 的一些特点：
块可接受参数，也可返回值。 块可以分配在栈或堆上，也可以是全局的，分配在栈上的块可拷贝到堆里。 和标准的 Objective-C 对象一样，具备引用计数了。 定义块 # 定义一个块对象基础的语法是：
^{ // Block implementation here };  很显然这是一个匿名函数，就像 JavaScript 一样，也可以像下面一样直接执行：
^{ // Block implementation here }(); 但是通常我们定义一个 Blocks 时，通常是需要一个名字的：
void (^someBlock)() = ^{ // Block implementation here }; 这样定义的块可以通过像 C 中的语法一样调用：someBlock()
常见问题 # 块的强大之处是：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/5.%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/5.%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</guid><description>通信方式 # Delegate # delegate 是委托模式，委托模式是将一件属于委托者做的事情，交给另外一个被委托者来处理。
一个标准的委托由以下的部分组成：
@protocol FeederDelegate &amp;lt;NSObject&amp;gt; - (void)feed; @end @interface People : NSObject&amp;lt;FeederDelegate&amp;gt; @end @interface Dog : NSObject @property(nonatomic, weak) id&amp;lt;FeederDelegate&amp;gt; delegate; @end 也就是说，People 是一个必须要满足 Feeder 这个协议的模型，那么它必须实现一个 feed 函数。在 Dog 这个对象创建的时候可以将其 delegate 成员：
- (People *)createPeople { People *people = [[People alloc] init]; Dog *dog = [[Dog alloc] init]; dog.delegate = people; // 赋值 delegate 属性 people.dog = dog; return people; } 比如我们需要捕获对于一个按钮相应的动作事件，我们可以通过下面的两步完成：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/6.%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/6.%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid><description>多线程 # iOS 线程概述 # 主线程：
iOS App 运行后，默认会开启 1 条线程，称为“主线程”或“UI线程” 主线程处理 UI 事件（比如点、滑动、拖拽等等）和显示、刷新 UI 界面 iOS 的线程相关技术主要有以下四种：
技术方案 特点 语言 线程生命周期 pthread 一套通用的多线程 API
适用于 Unix/Linux/Windows 系统
跨平台、可移植、使用难度大 C 程序员管理 NSThread 使用面向对象编程
简单易用，可以直接操作线程对象 Objective-C 程序员管理 GCD 旨在替代前面两种的线程技术
充分利用设备的多核特性 C 自动管理 NSOperation 基于 GCD，加入一些简单实用的功能
内容更加面向对象 Objective-C 自动管理 多线程的优缺点：
优点是很显然的：能适当提升程序的执行效率；能适当提升资源利用率（CPU、内存等） 缺点： 创建线程是有开销的，比如 iOS 的开销主要有（内核数据结构大约 1KB，栈空间，创建时间 90ms） 如果开启大量的线程，会降低程序的性能、增加 CPU 在线程调度上的开销、程序设计更加复杂。 NSThread # 什么是 NSThread？</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/7.%E7%AE%80%E5%8D%95ui/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/7.%E7%AE%80%E5%8D%95ui/</guid><description>简单 UI # iOS App # 官方文档：
https://developer.apple.com/documentation/uikit/app_and_environment/managing_your_app_s_life_cycle 一个参考了一个有趣的博客：
https://medium.com/@theiOSzone/briefly-about-the-ios-application-lifecycle-92f0c830b754 一个 iOS 的声明周期中会有以下的五种状态，下图列举官网中对这五种状态之间切换的示例：
这些声明周期的转换中也有一些相关的 HOOK 函数，那下图这个流程中的编号举例子：
这个变换流程中，有两个声明周期函数：
willFinishLaunchingWithOptions：如果你的程序启动成功的话，这个是整个应用第一次执行的代码； didFinishLaunchingWithOptions：在屏幕上即将显示任何画面之前执行的函数； 在程序进入 Active 状态之后，会执行：applicationDidBecomeActive；
applicationWillResignActive：当用户点击了 Home 键或者启动了其他应用程序之后，会执行这个函数；与此同时，系统还会发出一个信号 UIApplicationWillResignActiveNotification。
applicationDidEnterBackground：在上面的一个流程之后，程序会从 Inactive 状态进入 Background 状态，同时触发这个 hook 函数；
applicationWIllEnterForeground：如果应用程序在被操作系统杀死之前，再次被打开进入 Foregound，则会触发这个 hook 函数；
Backgound -&amp;gt; Suspended；
Suspended -&amp;gt; Backgound；
如果应用进入后台后 5s 不执行任何计算任务，操作系统则会把它置为暂停状态；相反则会回到后台状态。那是这两个状态之间的切换对程序员是透明的，也就是说无法 HOOK 到这两个状态的切换。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/8.%E5%A4%8D%E6%9D%82ui/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/8.%E5%A4%8D%E6%9D%82ui/</guid><description>参考：
https://developer.apple.com/documentation/uikit/view_controllers?language=objc https://medium.com/@felicity.johnson.mail/pushing-popping-dismissing-viewcontrollers-a30e98731df5 复杂 UI &amp;amp;&amp;amp; 多视图 # MVC 设计模式 # MVC 是一种设计模式。我们创建的对象根据其职责来划分，它要么属于 M:Model，要么属于 V:View，要么属于C:Controller，下面我们分别简要介绍一下 Model、View、ViewController。
Model # Model 一般是我们对真实世界中一些事物的抽象，来定义的一些数据对象，它包含我们所需要的数据以及对这些数据的操作。
Model 一般是负责定义及存储数据，是与用户界面上用于显示的各个视觉元素是无关的。
View # 接下来是 View，在 iOS 中，View 一般是 UIKit 中 UIView 及其子类的一些实例，是用户可以看得见的对象。比如说 UIView，是用于界面元素展示的类的基类，以及 UIButton、UILabel、UISlider、UITextField 等等。
ViewController # Objective-C 一般是 ViewController 一般是 UIViewController 及其子类的实例，系统提供给我们的比较常用的 ViewController 有以下的这些：
UIViewController：用来展示多个视图控制器； UITabBarController：在 UIViewController 的特性之上，加入可以在这些控制器之间进行切换； UINavigationController：在 UIViewController 的特性之上，在视图控制器间进行导航控制； UITableViewController：展示一个单列的表的视图控制器； UICollectionViewController：以及展示集合视图的； UIAlertViewController：展示弹框消息。 在项目中，ViewController 可以通过持有的方式直接与 View 与 Model 进行通信。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/9.%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AD%98%E5%82%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/9.%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AD%98%E5%82%A8/</guid><description>网络 # 基础知识 # 两种数据交换格式：XML、JSON（JavaScript Object Notation） 调试器： https://www.httpdebugger.com/tools/ViewHttpHeaders.aspx https://www.xiongdianpku.com/api/bytedance/image/list https://www.charlesproxy.com/ 处理 HTTP/HTTPS 请求 # NSURLSession # 什么是 NSURLSession？
本身是一个类，同时也代指一套用于处理 HTTP/HTTPS 请求的类。 关于类 NSURLSession：
负责管理发送和接收 HTTP 请求； 通过获取单例或传入 NSURLSessionConfiguration 创建实例； 可以通过 Block 或 delegate 接收回调； 主要有以下三种方法创建获取一个 session：
+ (NSURLSession *)sharedSession; // 使用全局的 Cache、Cookie、证书，获取一个共享的会话。 + (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration; // 通过传入一个 NSURLSessioinConfiguration（用于设置相关的参数）配置来创建相关会话。 + (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(id &amp;lt;NSURLSessionDelegate&amp;gt;)delegate delegateQueue:(NSOperationQueue *)queue; // 根据 NSURLSessionConfiguration、NSURLSessionDelegate、NSOperationQueue 三个参数创建会话。 NSURLSessionConfiguration # 上面创建方法中已经提及了这个类，它有三种类型的配置：</description></item></channel></rss>