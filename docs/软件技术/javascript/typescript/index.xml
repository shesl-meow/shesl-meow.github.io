<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>typescript on shesl-meow's note site</title><link>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/typescript/</link><description>Recent content in typescript on shesl-meow's note site</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/typescript/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/typescript/stackoverflow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/typescript/stackoverflow/</guid><description>Stack Overflow # 来自 StackOverflow 上的大神教程。
如何得到一个类派生出的所有子类型：https://stackoverflow.com/questions/42414045/how-to-get-child-classes-which-implement-a-certain-base-class-using-reflection-i
export default function hierarchyTracked(target: new (...args: any[]) =&amp;gt; object) { for (const proto of walkPrototypeChain(target)) { if (!Object.hasOwnProperty.call(proto, &amp;#39;extendedBy&amp;#39;)) { const extendedBy: typeof Function.extendedBy = []; Object.defineProperty(proto, &amp;#39;extendedBy&amp;#39;, { get: () =&amp;gt; extendedBy }); } // ! is used to suppress a strictNullChecks error on optional. // This is OK since we know it is now defined.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/typescript/trick/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/typescript/trick/</guid><description>Trick # 定义 getter setter，在类方法前使用关键字 get/set；
https://www.typescriptlang.org/docs/handbook/classes.html#accessors 使用 @ 符号，引用 Decorator：
https://www.typescriptlang.org/docs/handbook/decorators.html#property-decorators 使用模版字符串：
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/typescript/%E5%85%B6%E4%BB%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/typescript/%E5%85%B6%E4%BB%96/</guid><description>Mixin # Mixin 本身是一种设计模式，它指不通过继承而是通过混入，将一个类的方法添加到另一个类中。这通常用于解决多继承的问题（一个子类不能同时继承两个基类）。
TypeScript 官方文档给出了一个 mixin 的方法：https://www.typescriptlang.org/docs/handbook/mixins.html：
// Each mixin is a traditional ES class class Jumpable { jump() {} } class Duckable { duck() {} } // Including the base class Sprite { x = 0; y = 0; } // Then you create an interface which merges // the expected mixins with the same name as your base interface Sprite extends Jumpable, Duckable {} // Apply the mixins into the base class via // the JS at runtime applyMixins(Sprite, [Jumpable, Duckable]); let player = new Sprite(); player.</description></item></channel></rss>