<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Redis on shesl-meow's note site</title><link>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/database/redis/</link><description>Recent content in Redis on shesl-meow's note site</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/database/redis/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/database/redis/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/database/redis/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/</guid><description>第一部分：数据结构与对象 # 因为阅读的书已经较为过时，新的数据结构没有完全讲完，比如：
zipmap、quicklist、stream 字符串 (Simple Dynamic String) # Redis 没有使用 C 语言中的 \0 结尾的方式表示一个字符串，而是自己构建了一个结构 SDS 作为基本字符串类型。这一结构的定义和实现分别在源码的 src/sds.h、src/sds.c 这两个文件中。
结构 # 以最长 256 字节长度串的结构 sdshdr8 为例：
struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; 由上面的源码可以看出 SDS 结构的核心是：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/database/redis/2.%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/database/redis/2.%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/</guid><description>mixin # 概念 # Mixin 这个概念本身是一种设计模式，它指一个类不通过继承的方式获得另一个类的所有方法与属性，它通常可以用于解决在不能实现多继承的语言（TypeScript 就是这样一个只支持单继承的语言）中实现多继承。
TypeScript #</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/database/redis/%E9%94%81%E5%AE%9E%E7%8E%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/database/redis/%E9%94%81%E5%AE%9E%E7%8E%B0/</guid><description>参考：
https://www.jianshu.com/p/81b0f1bd1328 Redis 实现锁机制 # 第一种锁命令 INCR # 这种加锁的思路是， key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作进行加一。
然后其它用户在执行 INCR 操作进行加一时，如果返回的数大于 1 ，说明这个锁正在被使用当中。
1、 客户端A请求服务器获取key的值为1表示获取了锁 2、 客户端B也去请求服务器获取key的值为2表示获取锁失败 3、 客户端A执行代码完成，删除锁 4、 客户端B在等待一段时间后在去请求的时候获取key的值为1表示获取锁成功 5、 客户端B执行代码完成，删除锁 $redis-&amp;gt;incr($key); $redis-&amp;gt;expire($key, $ttl); //设置生成时间为1秒 第二种锁 SETNX # 这种加锁的思路是，如果 key 不存在，将 key 设置为 value。
如果 key 已存在，则 SETNX 不做任何动作
1、 客户端A请求服务器设置key的值，如果设置成功就表示加锁成功 2、 客户端B也去请求服务器设置key的值，如果返回失败，那么就代表加锁失败 3、 客户端A执行代码完成，删除锁 4、 客户端B在等待一段时间后在去请求设置key的值，设置成功 5、 客户端B执行代码完成，删除锁 $redis-&amp;gt;setNX($key, $value); $redis-&amp;gt;expire($key, $ttl); 第三种锁 SET # 上面两种方法都有一个问题，会发现，都需要设置 key 过期。那么为什么要设置key过期呢？如果请求执行因为某些原因意外退出了，导致创建了锁但是没有删除锁，那么这个锁将一直存在，以至于以后缓存再也得不到更新。</description></item></channel></rss>